{"mappings":"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","sources":["<anon>","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/app/init.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/app/init.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/app/ResizePlugin.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/app/ResizePlugin.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/app/TickerPlugin.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/app/TickerPlugin.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/ticker/const.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/ticker/const.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/ticker/Ticker.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/ticker/Ticker.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/ticker/TickerListener.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/ticker/TickerListener.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/spritesheet/init.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/spritesheet/init.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/spritesheet/spritesheetAsset.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/assets/loader/parsers/LoaderParser.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/assets/resolver/Resolver.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/assets/resolver/Resolver.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/utils/path.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/utils/path.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/assets/utils/convertToList.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/assets/utils/convertToList.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/assets/utils/createStringVariations.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/assets/utils/isSingleItem.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/assets/utils/copySearchParams.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/spritesheet/Spritesheet.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/init.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/init.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/mask/alpha/AlphaMask.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/mask/utils/addMaskBounds.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/mask/utils/addMaskLocalBounds.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/mask/color/ColorMask.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/mask/stencil/StencilMask.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/ImageSource.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/VideoSource.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/utils/browser/detectVideoAlphaMode.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/shared/texture/utils/textureFrom.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/assets/cache/Cache.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/assets/cache/Cache.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/graphics/init.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/graphics/init.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/graphics/shared/GraphicsContextSystem.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/graphics/shared/utils/buildContextBatches.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/buildUvs.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/transformVertices.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/graphics/shared/BatchableGraphics.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildCircle.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildLine.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/graphics/shared/const.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/graphics/shared/const.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/graphics/shared/utils/getOrientationOfPoints.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildPolygon.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/graphics/shared/utils/triangulateWithHoles.ts","node_modules/.pnpm/earcut@2.2.4/node_modules/earcut/src/earcut.js","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildRectangle.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildTriangle.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/graphics/shared/GraphicsPipe.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/mesh/init.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/mesh/init.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/mesh/shared/MeshPipe.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/mesh/shared/BatchableMesh.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text/init.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text/init.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text/canvas/CanvasTextPipe.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text/canvas/CanvasTextSystem.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/utils/canvas/getCanvasBoundingBox.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text/utils/getPo2TextureFromSource.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text/canvas/CanvasTextMetrics.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text/canvas/utils/fontStringFromTextStyle.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text/canvas/utils/getCanvasFillStyle.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/graphics/shared/fill/FillGradient.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/graphics/shared/fill/FillPattern.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text-bitmap/init.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text-bitmap/init.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text-bitmap/asset/loadBitmapFont.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text-bitmap/asset/loadBitmapFont.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text-bitmap/BitmapFont.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text-bitmap/BitmapFont.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text-bitmap/AbstractBitmapFont.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text-bitmap/BitmapFontManager.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text/TextStyle.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text/TextStyle.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/graphics/shared/GraphicsContext.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/graphics/shared/path/GraphicsPath.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGToGraphicsPath.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/graphics/shared/svg/SVGToGraphicsPath.ts","node_modules/.pnpm/parse-svg-path@0.1.2/node_modules/parse-svg-path/index.js","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/graphics/shared/path/ShapePath.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/maths/shapes/Circle.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/maths/shapes/Circle.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/maths/shapes/Ellipse.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/maths/shapes/Polygon.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/maths/shapes/Polygon.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/maths/misc/squaredDistanceToLineSegment.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/maths/shapes/RoundedRectangle.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildAdaptiveBezier.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildArc.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildArcTo.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildArcToSvg.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/graphics/shared/path/roundShape.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/graphics/shared/svg/SVGParser.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/graphics/shared/utils/convertFillInputToFillStyle.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text/utils/generateTextStyleKey.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text-bitmap/DynamicBitmapFont.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text-bitmap/utils/resolveCharacters.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text-bitmap/utils/getBitmapTextLayout.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontTextParser.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text-bitmap/asset/bitmapFontTextParser.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text-bitmap/asset/bitmapFontXMLStringParser.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLParser.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text-bitmap/asset/bitmapFontXMLParser.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text-bitmap/BitmapTextPipe.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/graphics/shared/Graphics.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text/sdfShader/SdfShader.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/localUniformMSDFBit.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/mSDFBit.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text-html/init.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text-html/init.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text-html/HTMLTextPipe.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text-html/HTMLTextSystem.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/utils/browser/isSafari.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/utils/browser/isSafari.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text-html/HTMLTextRenderData.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text-html/HtmlTextStyle.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text-html/HtmlTextStyle.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text-html/utils/textStyleToCSS.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text-html/utils/textStyleToCSS.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text-html/utils/extractFontFamilies.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text-html/utils/getFontCss.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text-html/utils/loadFontCSS.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text-html/utils/loadFontAsBase64.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text-html/utils/getSVGUrl.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text-html/utils/getTemporaryCanvasFromImage.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text-html/utils/loadSVGImage.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/text-html/utils/measureHtmlText.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/sprite-tiling/init.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/sprite-tiling/TilingSpritePipe.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/mesh/shared/MeshGeometry.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/sprite-tiling/shader/TilingSpriteShader.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/sprite-tiling/shader/tilingBit.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/sprite-tiling/utils/QuadGeometry.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/sprite-tiling/utils/setPositions.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/sprite-tiling/utils/setUvs.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/sprite-tiling/utils/applyMatrix.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/sprite-nine-slice/init.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceSpritePipe.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceGeometry.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/mesh-plane/PlaneGeometry.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/filters/init.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/filters/init.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/filters/FilterPipe.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/filters/FilterPipe.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/filters/FilterSystem.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/filters/FilterSystem.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/container/bounds/getFastGlobalBounds.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/container/bounds/getFastGlobalBounds.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/container/bounds/getRenderableBounds.ts"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequire4692\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"3AoPf\", function(module, exports) {\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $c9r7l = parcelRequire(\"c9r7l\");\n\nvar $6jyhb = parcelRequire(\"6jyhb\");\n\"use strict\";\n(0, $eVz1R.extensions).add((0, $c9r7l.ResizePlugin));\n(0, $eVz1R.extensions).add((0, $6jyhb.TickerPlugin));\n\n});\nparcelRegister(\"c9r7l\", function(module, exports) {\n\n$parcel$export(module.exports, \"ResizePlugin\", () => $c2e7faafdc49eb51$export$6453cd852defe94a);\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\"use strict\";\nclass $c2e7faafdc49eb51$export$6453cd852defe94a {\n    /**\n   * Initialize the plugin with scope of application instance\n   * @static\n   * @private\n   * @param {object} [options] - See application options\n   */ static init(options) {\n        Object.defineProperty(this, \"resizeTo\", /**\n       * The HTML element or window to automatically resize the\n       * renderer's view element to match width and height.\n       * @member {Window|HTMLElement}\n       * @name resizeTo\n       * @memberof app.Application#\n       */ {\n            set (dom) {\n                globalThis.removeEventListener(\"resize\", this.queueResize);\n                this._resizeTo = dom;\n                if (dom) {\n                    globalThis.addEventListener(\"resize\", this.queueResize);\n                    this.resize();\n                }\n            },\n            get () {\n                return this._resizeTo;\n            }\n        });\n        this.queueResize = ()=>{\n            if (!this._resizeTo) return;\n            this._cancelResize();\n            this._resizeId = requestAnimationFrame(()=>this.resize());\n        };\n        this._cancelResize = ()=>{\n            if (this._resizeId) {\n                cancelAnimationFrame(this._resizeId);\n                this._resizeId = null;\n            }\n        };\n        this.resize = ()=>{\n            if (!this._resizeTo) return;\n            this._cancelResize();\n            let width;\n            let height;\n            if (this._resizeTo === globalThis.window) {\n                width = globalThis.innerWidth;\n                height = globalThis.innerHeight;\n            } else {\n                const { clientWidth: clientWidth, clientHeight: clientHeight } = this._resizeTo;\n                width = clientWidth;\n                height = clientHeight;\n            }\n            this.renderer.resize(width, height);\n            this.render();\n        };\n        this._resizeId = null;\n        this._resizeTo = null;\n        this.resizeTo = options.resizeTo || null;\n    }\n    /**\n   * Clean up the ticker, scoped to application\n   * @static\n   * @private\n   */ static destroy() {\n        globalThis.removeEventListener(\"resize\", this.queueResize);\n        this._cancelResize();\n        this._cancelResize = null;\n        this.queueResize = null;\n        this.resizeTo = null;\n        this.resize = null;\n    }\n}\n/** @ignore */ $c2e7faafdc49eb51$export$6453cd852defe94a.extension = (0, $eVz1R.ExtensionType).Application;\n\n});\n\nparcelRegister(\"6jyhb\", function(module, exports) {\n\n$parcel$export(module.exports, \"TickerPlugin\", () => $eef91818de7f56f7$export$50c361ceb4e2f4f0);\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $gu9S0 = parcelRequire(\"gu9S0\");\n\nvar $1WaK0 = parcelRequire(\"1WaK0\");\n\"use strict\";\nclass $eef91818de7f56f7$export$50c361ceb4e2f4f0 {\n    /**\n   * Initialize the plugin with scope of application instance\n   * @static\n   * @private\n   * @param {object} [options] - See application options\n   */ static init(options) {\n        options = Object.assign({\n            autoStart: true,\n            sharedTicker: false\n        }, options);\n        Object.defineProperty(this, \"ticker\", {\n            set (ticker) {\n                if (this._ticker) this._ticker.remove(this.render, this);\n                this._ticker = ticker;\n                if (ticker) ticker.add(this.render, this, (0, $gu9S0.UPDATE_PRIORITY).LOW);\n            },\n            get () {\n                return this._ticker;\n            }\n        });\n        this.stop = ()=>{\n            this._ticker.stop();\n        };\n        this.start = ()=>{\n            this._ticker.start();\n        };\n        this._ticker = null;\n        this.ticker = options.sharedTicker ? (0, $1WaK0.Ticker).shared : new (0, $1WaK0.Ticker)();\n        if (options.autoStart) this.start();\n    }\n    /**\n   * Clean up the ticker, scoped to application.\n   * @static\n   * @private\n   */ static destroy() {\n        if (this._ticker) {\n            const oldTicker = this._ticker;\n            this.ticker = null;\n            oldTicker.destroy();\n        }\n    }\n}\n/** @ignore */ $eef91818de7f56f7$export$50c361ceb4e2f4f0.extension = (0, $eVz1R.ExtensionType).Application;\n\n});\nparcelRegister(\"gu9S0\", function(module, exports) {\n\n$parcel$export(module.exports, \"UPDATE_PRIORITY\", () => $d5fcb0cfb12f95a2$export$688aaf132ba9b379);\n\"use strict\";\nvar $d5fcb0cfb12f95a2$export$688aaf132ba9b379 = /* @__PURE__ */ ((UPDATE_PRIORITY2)=>{\n    UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"INTERACTION\"] = 50] = \"INTERACTION\";\n    UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"HIGH\"] = 25] = \"HIGH\";\n    UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"NORMAL\"] = 0] = \"NORMAL\";\n    UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"LOW\"] = -25] = \"LOW\";\n    UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"UTILITY\"] = -50] = \"UTILITY\";\n    return UPDATE_PRIORITY2;\n})($d5fcb0cfb12f95a2$export$688aaf132ba9b379 || {});\n\n});\n\nparcelRegister(\"1WaK0\", function(module, exports) {\n\n$parcel$export(module.exports, \"Ticker\", () => $ec35c199f341d964$export$39c54bcc89dcee11);\n\nvar $gu9S0 = parcelRequire(\"gu9S0\");\n\nvar $aUStc = parcelRequire(\"aUStc\");\n\"use strict\";\nconst $ec35c199f341d964$var$_Ticker = class _Ticker {\n    constructor(){\n        /**\n     * Whether or not this ticker should invoke the method\n     * {@link ticker.Ticker#start|start} automatically when a listener is added.\n     */ this.autoStart = false;\n        /**\n     * Scalar time value from last frame to this frame.\n     * This value is capped by setting {@link ticker.Ticker#minFPS|minFPS}\n     * and is scaled with {@link ticker.Ticker#speed|speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     */ this.deltaTime = 1;\n        /**\n     * The last time {@link ticker.Ticker#update|update} was invoked.\n     * This value is also reset internally outside of invoking\n     * update, but only when a new animation frame is requested.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 s.\n     */ this.lastTime = -1;\n        /**\n     * Factor of current {@link ticker.Ticker#deltaTime|deltaTime}.\n     * @example\n     * // Scales ticker.deltaTime to what would be\n     * // the equivalent of approximately 120 FPS\n     * ticker.speed = 2;\n     */ this.speed = 1;\n        /**\n     * Whether or not this ticker has been started.\n     * `true` if {@link ticker.Ticker#start|start} has been called.\n     * `false` if {@link ticker.Ticker#stop|Stop} has been called.\n     * While `false`, this value may change to `true` in the\n     * event of {@link ticker.Ticker#autoStart|autoStart} being `true`\n     * and a listener is added.\n     */ this.started = false;\n        /** Internal current frame request ID */ this._requestId = null;\n        /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the maximum allowed milliseconds between updates.\n     */ this._maxElapsedMS = 100;\n        /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the minimum allowed milliseconds between updates.\n     */ this._minElapsedMS = 0;\n        /** If enabled, deleting is disabled.*/ this._protected = false;\n        /** The last time keyframe was executed. Maintains a relatively fixed interval with the previous value. */ this._lastFrame = -1;\n        this._head = new (0, $aUStc.TickerListener)(null, null, Infinity);\n        this.deltaMS = 1 / _Ticker.targetFPMS;\n        this.elapsedMS = 1 / _Ticker.targetFPMS;\n        this._tick = (time)=>{\n            this._requestId = null;\n            if (this.started) {\n                this.update(time);\n                if (this.started && this._requestId === null && this._head.next) this._requestId = requestAnimationFrame(this._tick);\n            }\n        };\n    }\n    /**\n   * Conditionally requests a new animation frame.\n   * If a frame has not already been requested, and if the internal\n   * emitter has listeners, a new frame is requested.\n   * @private\n   */ _requestIfNeeded() {\n        if (this._requestId === null && this._head.next) {\n            this.lastTime = performance.now();\n            this._lastFrame = this.lastTime;\n            this._requestId = requestAnimationFrame(this._tick);\n        }\n    }\n    /**\n   * Conditionally cancels a pending animation frame.\n   * @private\n   */ _cancelIfNeeded() {\n        if (this._requestId !== null) {\n            cancelAnimationFrame(this._requestId);\n            this._requestId = null;\n        }\n    }\n    /**\n   * Conditionally requests a new animation frame.\n   * If the ticker has been started it checks if a frame has not already\n   * been requested, and if the internal emitter has listeners. If these\n   * conditions are met, a new frame is requested. If the ticker has not\n   * been started, but autoStart is `true`, then the ticker starts now,\n   * and continues with the previous conditions to request a new frame.\n   * @private\n   */ _startIfPossible() {\n        if (this.started) this._requestIfNeeded();\n        else if (this.autoStart) this.start();\n    }\n    /**\n   * Register a handler for tick events. Calls continuously unless\n   * it is removed or the ticker is stopped.\n   * @param fn - The listener function to be added for updates\n   * @param context - The listener context\n   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */ add(fn, context, priority = (0, $gu9S0.UPDATE_PRIORITY).NORMAL) {\n        return this._addListener(new (0, $aUStc.TickerListener)(fn, context, priority));\n    }\n    /**\n   * Add a handler for the tick event which is only execute once.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */ addOnce(fn, context, priority = (0, $gu9S0.UPDATE_PRIORITY).NORMAL) {\n        return this._addListener(new (0, $aUStc.TickerListener)(fn, context, priority, true));\n    }\n    /**\n   * Internally adds the event handler so that it can be sorted by priority.\n   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n   * before the rendering.\n   * @private\n   * @param listener - Current listener being added.\n   * @returns This instance of a ticker\n   */ _addListener(listener) {\n        let current = this._head.next;\n        let previous = this._head;\n        if (!current) listener.connect(previous);\n        else {\n            while(current){\n                if (listener.priority > current.priority) {\n                    listener.connect(previous);\n                    break;\n                }\n                previous = current;\n                current = current.next;\n            }\n            if (!listener.previous) listener.connect(previous);\n        }\n        this._startIfPossible();\n        return this;\n    }\n    /**\n   * Removes any handlers matching the function and context parameters.\n   * If no handlers are left after removing, then it cancels the animation frame.\n   * @param fn - The listener function to be removed\n   * @param context - The listener context to be removed\n   * @returns This instance of a ticker\n   */ remove(fn, context) {\n        let listener = this._head.next;\n        while(listener)if (listener.match(fn, context)) listener = listener.destroy();\n        else listener = listener.next;\n        if (!this._head.next) this._cancelIfNeeded();\n        return this;\n    }\n    /**\n   * The number of listeners on this ticker, calculated by walking through linked list\n   * @readonly\n   * @member {number}\n   */ get count() {\n        if (!this._head) return 0;\n        let count = 0;\n        let current = this._head;\n        while(current = current.next)count++;\n        return count;\n    }\n    /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */ start() {\n        if (!this.started) {\n            this.started = true;\n            this._requestIfNeeded();\n        }\n    }\n    /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */ stop() {\n        if (this.started) {\n            this.started = false;\n            this._cancelIfNeeded();\n        }\n    }\n    /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */ destroy() {\n        if (!this._protected) {\n            this.stop();\n            let listener = this._head.next;\n            while(listener)listener = listener.destroy(true);\n            this._head.destroy();\n            this._head = null;\n        }\n    }\n    /**\n   * Triggers an update. An update entails setting the\n   * current {@link ticker.Ticker#elapsedMS|elapsedMS},\n   * the current {@link ticker.Ticker#deltaTime|deltaTime},\n   * invoking all listeners with current deltaTime,\n   * and then finally setting {@link ticker.Ticker#lastTime|lastTime}\n   * with the value of currentTime that was provided.\n   * This method will be called automatically by animation\n   * frame callbacks if the ticker instance has been started\n   * and listeners are added.\n   * @param {number} [currentTime=performance.now()] - the current time of execution\n   */ update(currentTime = performance.now()) {\n        let elapsedMS;\n        if (currentTime > this.lastTime) {\n            elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n            if (elapsedMS > this._maxElapsedMS) elapsedMS = this._maxElapsedMS;\n            elapsedMS *= this.speed;\n            if (this._minElapsedMS) {\n                const delta = currentTime - this._lastFrame | 0;\n                if (delta < this._minElapsedMS) return;\n                this._lastFrame = currentTime - delta % this._minElapsedMS;\n            }\n            this.deltaMS = elapsedMS;\n            this.deltaTime = this.deltaMS * _Ticker.targetFPMS;\n            const head = this._head;\n            let listener = head.next;\n            while(listener)listener = listener.emit(this);\n            if (!head.next) this._cancelIfNeeded();\n        } else this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n        this.lastTime = currentTime;\n    }\n    /**\n   * The frames per second at which this ticker is running.\n   * The default is approximately 60 in most modern browsers.\n   * **Note:** This does not factor in the value of\n   * {@link ticker.Ticker#speed|speed}, which is specific\n   * to scaling {@link ticker.Ticker#deltaTime|deltaTime}.\n   * @member {number}\n   * @readonly\n   */ get FPS() {\n        return 1e3 / this.elapsedMS;\n    }\n    /**\n   * Manages the maximum amount of milliseconds allowed to\n   * elapse between invoking {@link ticker.Ticker#update|update}.\n   * This value is used to cap {@link ticker.Ticker#deltaTime|deltaTime},\n   * but does not effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n   * When setting this property it is clamped to a value between\n   * `0` and `Ticker.targetFPMS * 1000`.\n   * @member {number}\n   * @default 10\n   */ get minFPS() {\n        return 1e3 / this._maxElapsedMS;\n    }\n    set minFPS(fps) {\n        const minFPS = Math.min(this.maxFPS, fps);\n        const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);\n        this._maxElapsedMS = 1 / minFPMS;\n    }\n    /**\n   * Manages the minimum amount of milliseconds required to\n   * elapse between invoking {@link ticker.Ticker#update|update}.\n   * This will effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n   * Otherwise it will be at least `minFPS`\n   * @member {number}\n   * @default 0\n   */ get maxFPS() {\n        if (this._minElapsedMS) return Math.round(1e3 / this._minElapsedMS);\n        return 0;\n    }\n    set maxFPS(fps) {\n        if (fps === 0) this._minElapsedMS = 0;\n        else {\n            const maxFPS = Math.max(this.minFPS, fps);\n            this._minElapsedMS = 1 / (maxFPS / 1e3);\n        }\n    }\n    /**\n   * The shared ticker instance used by {@link AnimatedSprite} and by\n   * {@link VideoResource} to update animation frames / video textures.\n   *\n   * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.\n   *\n   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n   * @example\n   * import { Ticker } from 'pixi.js';\n   *\n   * const ticker = Ticker.shared;\n   * // Set this to prevent starting this ticker when listeners are added.\n   * // By default this is true only for the Ticker.shared instance.\n   * ticker.autoStart = false;\n   *\n   * // FYI, call this to ensure the ticker is stopped. It should be stopped\n   * // if you have not attempted to render anything yet.\n   * ticker.stop();\n   *\n   * // Call this when you are ready for a running shared ticker.\n   * ticker.start();\n   * @example\n   * import { autoDetectRenderer, Container } from 'pixi.js';\n   *\n   * // You may use the shared ticker to render...\n   * const renderer = autoDetectRenderer();\n   * const stage = new Container();\n   * document.body.appendChild(renderer.view);\n   * ticker.add((time) => renderer.render(stage));\n   *\n   * // Or you can just update it manually.\n   * ticker.autoStart = false;\n   * ticker.stop();\n   * const animate = (time) => {\n   *     ticker.update(time);\n   *     renderer.render(stage);\n   *     requestAnimationFrame(animate);\n   * };\n   * animate(performance.now());\n   * @member {ticker.Ticker}\n   * @readonly\n   * @static\n   */ static get shared() {\n        if (!_Ticker._shared) {\n            const shared = _Ticker._shared = new _Ticker();\n            shared.autoStart = true;\n            shared._protected = true;\n        }\n        return _Ticker._shared;\n    }\n    /**\n   * The system ticker instance used by {@link BasePrepare} for core timing\n   * functionality that shouldn't usually need to be paused, unlike the `shared`\n   * ticker which drives visual animations and rendering which may want to be paused.\n   *\n   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n   * @member {ticker.Ticker}\n   * @readonly\n   * @static\n   */ static get system() {\n        if (!_Ticker._system) {\n            const system = _Ticker._system = new _Ticker();\n            system.autoStart = true;\n            system._protected = true;\n        }\n        return _Ticker._system;\n    }\n};\n/**\n * Target frames per millisecond.\n * @static\n */ $ec35c199f341d964$var$_Ticker.targetFPMS = 0.06;\nlet $ec35c199f341d964$export$39c54bcc89dcee11 = $ec35c199f341d964$var$_Ticker;\n\n});\nparcelRegister(\"aUStc\", function(module, exports) {\n\n$parcel$export(module.exports, \"TickerListener\", () => $d4f3b3eea778246a$export$579021a5759a260f);\n\"use strict\";\nclass $d4f3b3eea778246a$export$579021a5759a260f {\n    /**\n   * Constructor\n   * @private\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param priority - The priority for emitting\n   * @param once - If the handler should fire once\n   */ constructor(fn, context = null, priority = 0, once = false){\n        /** The next item in chain. */ this.next = null;\n        /** The previous item in chain. */ this.previous = null;\n        /** `true` if this listener has been destroyed already. */ this._destroyed = false;\n        this._fn = fn;\n        this._context = context;\n        this.priority = priority;\n        this._once = once;\n    }\n    /**\n   * Simple compare function to figure out if a function and context match.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @returns `true` if the listener match the arguments\n   */ match(fn, context = null) {\n        return this._fn === fn && this._context === context;\n    }\n    /**\n   * Emit by calling the current function.\n   * @param ticker - The ticker emitting.\n   * @returns Next ticker\n   */ emit(ticker) {\n        if (this._fn) {\n            if (this._context) this._fn.call(this._context, ticker);\n            else this._fn(ticker);\n        }\n        const redirect = this.next;\n        if (this._once) this.destroy(true);\n        if (this._destroyed) this.next = null;\n        return redirect;\n    }\n    /**\n   * Connect to the list.\n   * @param previous - Input node, previous listener\n   */ connect(previous) {\n        this.previous = previous;\n        if (previous.next) previous.next.previous = this;\n        this.next = previous.next;\n        previous.next = this;\n    }\n    /**\n   * Destroy and don't use after this.\n   * @param hard - `true` to remove the `next` reference, this\n   *        is considered a hard destroy. Soft destroy maintains the next reference.\n   * @returns The listener to redirect while emitting or removing.\n   */ destroy(hard = false) {\n        this._destroyed = true;\n        this._fn = null;\n        this._context = null;\n        if (this.previous) this.previous.next = this.next;\n        if (this.next) this.next.previous = this.previous;\n        const redirect = this.next;\n        this.next = hard ? null : redirect;\n        this.previous = null;\n        return redirect;\n    }\n}\n\n});\n\n\n\n\nparcelRegister(\"ipkVP\", function(module, exports) {\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $bHBRz = parcelRequire(\"bHBRz\");\n\"use strict\";\n(0, $eVz1R.extensions).add((0, $bHBRz.spritesheetAsset));\n\n});\nparcelRegister(\"bHBRz\", function(module, exports) {\n\n$parcel$export(module.exports, \"spritesheetAsset\", () => $d2e9ea45ca6bce6f$export$46dcda4f1cdd80fe);\n\nvar $kuLtH = parcelRequire(\"kuLtH\");\n\nvar $Lmcdo = parcelRequire(\"Lmcdo\");\n\nvar $kY7V1 = parcelRequire(\"kY7V1\");\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $5h88T = parcelRequire(\"5h88T\");\n\nvar $kaDu9 = parcelRequire(\"kaDu9\");\n\nvar $2v83S = parcelRequire(\"2v83S\");\n\"use strict\";\nconst $d2e9ea45ca6bce6f$var$validImages = [\n    \"jpg\",\n    \"png\",\n    \"jpeg\",\n    \"avif\",\n    \"webp\",\n    \"basis\",\n    \"etc2\",\n    \"bc7\",\n    \"bc6h\",\n    \"bc5\",\n    \"bc4\",\n    \"bc3\",\n    \"bc2\",\n    \"bc1\",\n    \"eac\",\n    \"astc\"\n];\nfunction $d2e9ea45ca6bce6f$var$getCacheableAssets(keys, asset, ignoreMultiPack) {\n    const out = {};\n    keys.forEach((key)=>{\n        out[key] = asset;\n    });\n    Object.keys(asset.textures).forEach((key)=>{\n        out[key] = asset.textures[key];\n    });\n    if (!ignoreMultiPack) {\n        const basePath = (0, $kaDu9.path).dirname(keys[0]);\n        asset.linkedSheets.forEach((item, i)=>{\n            const out2 = $d2e9ea45ca6bce6f$var$getCacheableAssets([\n                `${basePath}/${asset.data.meta.related_multi_packs[i]}`\n            ], item, true);\n            Object.assign(out, out2);\n        });\n    }\n    return out;\n}\nconst $d2e9ea45ca6bce6f$export$46dcda4f1cdd80fe = {\n    extension: (0, $eVz1R.ExtensionType).Asset,\n    /** Handle the caching of the related Spritesheet Textures */ cache: {\n        test: (asset)=>asset instanceof (0, $2v83S.Spritesheet),\n        getCacheableAssets: (keys, asset)=>$d2e9ea45ca6bce6f$var$getCacheableAssets(keys, asset, false)\n    },\n    /** Resolve the resolution of the asset. */ resolver: {\n        test: (value)=>{\n            const tempURL = value.split(\"?\")[0];\n            const split = tempURL.split(\".\");\n            const extension = split.pop();\n            const format = split.pop();\n            return extension === \"json\" && $d2e9ea45ca6bce6f$var$validImages.includes(format);\n        },\n        parse: (value)=>{\n            const split = value.split(\".\");\n            return {\n                resolution: parseFloat((0, $Lmcdo.Resolver).RETINA_PREFIX.exec(value)?.[1] ?? \"1\"),\n                format: split[split.length - 2],\n                src: value\n            };\n        }\n    },\n    /**\n   * Loader plugin that parses sprite sheets!\n   * once the JSON has been loaded this checks to see if the JSON is spritesheet data.\n   * If it is, we load the spritesheets image and parse the data into Spritesheet\n   * All textures in the sprite sheet are then added to the cache\n   */ loader: {\n        name: \"spritesheetLoader\",\n        extension: {\n            type: (0, $eVz1R.ExtensionType).LoadParser,\n            priority: (0, $kuLtH.LoaderParserPriority).Normal\n        },\n        async testParse (asset, options) {\n            return (0, $kaDu9.path).extname(options.src).toLowerCase() === \".json\" && !!asset.frames;\n        },\n        async parse (asset, options, loader) {\n            const { texture: imageTexture, imageFilename: // if user need to use preloaded texture\n            imageFilename } = options?.data ?? {};\n            let basePath = (0, $kaDu9.path).dirname(options.src);\n            if (basePath && basePath.lastIndexOf(\"/\") !== basePath.length - 1) basePath += \"/\";\n            let texture;\n            if (imageTexture instanceof (0, $5h88T.Texture)) texture = imageTexture;\n            else {\n                const imagePath = (0, $kY7V1.copySearchParams)(basePath + (imageFilename ?? asset.meta.image), options.src);\n                const assets = await loader.load([\n                    imagePath\n                ]);\n                texture = assets[imagePath];\n            }\n            const spritesheet = new (0, $2v83S.Spritesheet)(texture.source, asset);\n            await spritesheet.parse();\n            const multiPacks = asset?.meta?.related_multi_packs;\n            if (Array.isArray(multiPacks)) {\n                const promises = [];\n                for (const item of multiPacks){\n                    if (typeof item !== \"string\") continue;\n                    let itemUrl = basePath + item;\n                    if (options.data?.ignoreMultiPack) continue;\n                    itemUrl = (0, $kY7V1.copySearchParams)(itemUrl, options.src);\n                    promises.push(loader.load({\n                        src: itemUrl,\n                        data: {\n                            ignoreMultiPack: true\n                        }\n                    }));\n                }\n                const res = await Promise.all(promises);\n                spritesheet.linkedSheets = res;\n                res.forEach((item)=>{\n                    item.linkedSheets = [\n                        spritesheet\n                    ].concat(spritesheet.linkedSheets.filter((sp)=>sp !== item));\n                });\n            }\n            return spritesheet;\n        },\n        async unload (spritesheet, _resolvedAsset, loader) {\n            await loader.unload(spritesheet.textureSource._sourceOrigin);\n            spritesheet.destroy(false);\n        }\n    }\n};\n\n});\nparcelRegister(\"kuLtH\", function(module, exports) {\n\n$parcel$export(module.exports, \"LoaderParserPriority\", () => $0734c567d6f21224$export$820ed6348c4f2750);\n\"use strict\";\nvar $0734c567d6f21224$export$820ed6348c4f2750 = /* @__PURE__ */ ((LoaderParserPriority2)=>{\n    LoaderParserPriority2[LoaderParserPriority2[\"Low\"] = 0] = \"Low\";\n    LoaderParserPriority2[LoaderParserPriority2[\"Normal\"] = 1] = \"Normal\";\n    LoaderParserPriority2[LoaderParserPriority2[\"High\"] = 2] = \"High\";\n    return LoaderParserPriority2;\n})($0734c567d6f21224$export$820ed6348c4f2750 || {});\n\n});\n\nparcelRegister(\"Lmcdo\", function(module, exports) {\n\n$parcel$export(module.exports, \"Resolver\", () => $ffe5eb4b246313bd$export$8b4c839865b08288);\n\nvar $8CF4q = parcelRequire(\"8CF4q\");\n\nvar $kaDu9 = parcelRequire(\"kaDu9\");\n\nvar $lbclP = parcelRequire(\"lbclP\");\n\nvar $ahHFV = parcelRequire(\"ahHFV\");\n\nvar $6BHki = parcelRequire(\"6BHki\");\n\"use strict\";\nclass $ffe5eb4b246313bd$export$8b4c839865b08288 {\n    constructor(){\n        this._defaultBundleIdentifierOptions = {\n            connector: \"-\",\n            createBundleAssetId: (bundleId, assetId)=>`${bundleId}${this._bundleIdConnector}${assetId}`,\n            extractAssetIdFromBundle: (bundleId, assetBundleId)=>assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, \"\")\n        };\n        /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */ this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n        /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */ this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;\n        /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */ this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n        this._assetMap = {};\n        this._preferredOrder = [];\n        this._parsers = [];\n        this._resolverHash = {};\n        this._bundles = {};\n    }\n    /**\n   * Override how the resolver deals with generating bundle ids.\n   * must be called before any bundles are added\n   * @param bundleIdentifier - the bundle identifier options\n   */ setBundleIdentifier(bundleIdentifier) {\n        this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n        this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n        this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n        if (this._extractAssetIdFromBundle(\"foo\", this._createBundleAssetId(\"foo\", \"bar\")) !== \"bar\") throw new Error(\"[Resolver] GenerateBundleAssetId are not working correctly\");\n    }\n    /**\n   * Let the resolver know which assets you prefer to use when resolving assets.\n   * Multiple prefer user defined rules can be added.\n   * @example\n   * resolver.prefer({\n   *     // first look for something with the correct format, and then then correct resolution\n   *     priority: ['format', 'resolution'],\n   *     params:{\n   *         format:'webp', // prefer webp images\n   *         resolution: 2, // prefer a resolution of 2\n   *     }\n   * })\n   * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n   * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n   * @param preferOrders - the prefer options\n   */ prefer(...preferOrders) {\n        preferOrders.forEach((prefer)=>{\n            this._preferredOrder.push(prefer);\n            if (!prefer.priority) prefer.priority = Object.keys(prefer.params);\n        });\n        this._resolverHash = {};\n    }\n    /**\n   * Set the base path to prepend to all urls when resolving\n   * @example\n   * resolver.basePath = 'https://home.com/';\n   * resolver.add('foo', 'bar.ong');\n   * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n   * @param basePath - the base path to use\n   */ set basePath(basePath) {\n        this._basePath = basePath;\n    }\n    get basePath() {\n        return this._basePath;\n    }\n    /**\n   * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n   * default value for browsers is `window.location.origin`\n   * @example\n   * // Application hosted on https://home.com/some-path/index.html\n   * resolver.basePath = 'https://home.com/some-path/';\n   * resolver.rootPath = 'https://home.com/';\n   * resolver.add('foo', '/bar.png');\n   * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n   * @param rootPath - the root path to use\n   */ set rootPath(rootPath) {\n        this._rootPath = rootPath;\n    }\n    get rootPath() {\n        return this._rootPath;\n    }\n    /**\n   * All the active URL parsers that help the parser to extract information and create\n   * an asset object-based on parsing the URL itself.\n   *\n   * Can be added using the extensions API\n   * @example\n   * resolver.add('foo', [\n   *     {\n   *         resolution: 2,\n   *         format: 'png',\n   *         src: 'image@2x.png',\n   *     },\n   *     {\n   *         resolution:1,\n   *         format:'png',\n   *         src: 'image.png',\n   *     },\n   * ]);\n   *\n   * // With a url parser the information such as resolution and file format could extracted from the url itself:\n   * extensions.add({\n   *     extension: ExtensionType.ResolveParser,\n   *     test: loadTextures.test, // test if url ends in an image\n   *     parse: (value: string) =>\n   *     ({\n   *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n   *         format: value.split('.').pop(),\n   *         src: value,\n   *     }),\n   * });\n   *\n   * // Now resolution and format can be extracted from the url\n   * resolver.add('foo', [\n   *     'image@2x.png',\n   *     'image.png',\n   * ]);\n   */ get parsers() {\n        return this._parsers;\n    }\n    /** Used for testing, this resets the resolver to its initial state */ reset() {\n        this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n        this._assetMap = {};\n        this._preferredOrder = [];\n        this._resolverHash = {};\n        this._rootPath = null;\n        this._basePath = null;\n        this._manifest = null;\n        this._bundles = {};\n        this._defaultSearchParams = null;\n    }\n    /**\n   * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n   * @param searchParams - the default url parameters to append when resolving urls\n   */ setDefaultSearchParams(searchParams) {\n        if (typeof searchParams === \"string\") this._defaultSearchParams = searchParams;\n        else {\n            const queryValues = searchParams;\n            this._defaultSearchParams = Object.keys(queryValues).map((key)=>`${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join(\"&\");\n        }\n    }\n    /**\n   * Returns the aliases for a given asset\n   * @param asset - the asset to get the aliases for\n   */ getAlias(asset) {\n        const { alias: alias, src: src } = asset;\n        const aliasesToUse = (0, $lbclP.convertToList)(alias || src, (value)=>{\n            if (typeof value === \"string\") return value;\n            if (Array.isArray(value)) return value.map((v)=>v?.src ?? v);\n            if (value?.src) return value.src;\n            return value;\n        }, true);\n        return aliasesToUse;\n    }\n    /**\n   * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n   * generally a manifest would be built using a tool.\n   * @param manifest - the manifest to add to the resolver\n   */ addManifest(manifest) {\n        if (this._manifest) (0, $8CF4q.warn)(\"[Resolver] Manifest already exists, this will be overwritten\");\n        this._manifest = manifest;\n        manifest.bundles.forEach((bundle)=>{\n            this.addBundle(bundle.name, bundle.assets);\n        });\n    }\n    /**\n   * This adds a bundle of assets in one go so that you can resolve them as a group.\n   * For example you could add a bundle for each screen in you pixi app\n   * @example\n   * resolver.addBundle('animals', [\n   *  { alias: 'bunny', src: 'bunny.png' },\n   *  { alias: 'chicken', src: 'chicken.png' },\n   *  { alias: 'thumper', src: 'thumper.png' },\n   * ]);\n   * // or\n   * resolver.addBundle('animals', {\n   *     bunny: 'bunny.png',\n   *     chicken: 'chicken.png',\n   *     thumper: 'thumper.png',\n   * });\n   *\n   * const resolvedAssets = await resolver.resolveBundle('animals');\n   * @param bundleId - The id of the bundle to add\n   * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n   */ addBundle(bundleId, assets) {\n        const assetNames = [];\n        let convertedAssets = assets;\n        if (!Array.isArray(assets)) convertedAssets = Object.entries(assets).map(([alias, src])=>{\n            if (typeof src === \"string\" || Array.isArray(src)) return {\n                alias: alias,\n                src: src\n            };\n            return {\n                alias: alias,\n                ...src\n            };\n        });\n        convertedAssets.forEach((asset)=>{\n            const srcs = asset.src;\n            const aliases = asset.alias;\n            let ids;\n            if (typeof aliases === \"string\") {\n                const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n                assetNames.push(bundleAssetId);\n                ids = [\n                    aliases,\n                    bundleAssetId\n                ];\n            } else {\n                const bundleIds = aliases.map((name)=>this._createBundleAssetId(bundleId, name));\n                assetNames.push(...bundleIds);\n                ids = [\n                    ...aliases,\n                    ...bundleIds\n                ];\n            }\n            this.add({\n                ...asset,\n                alias: ids,\n                src: srcs\n            });\n        });\n        this._bundles[bundleId] = assetNames;\n    }\n    /**\n   * Tells the resolver what keys are associated with witch asset.\n   * The most important thing the resolver does\n   * @example\n   * // Single key, single asset:\n   * resolver.add({alias: 'foo', src: 'bar.png');\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   *\n   * // Multiple keys, single asset:\n   * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   * resolver.resolveUrl('boo') // => 'bar.png'\n   *\n   * // Multiple keys, multiple assets:\n   * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   *\n   * // Add custom data attached to the resolver\n   * Resolver.add({\n   *     alias: 'bunnyBooBooSmooth',\n   *     src: 'bunny{png,webp}',\n   *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n   * });\n   *\n   * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n   * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver\n   */ add(aliases) {\n        const assets = [];\n        if (Array.isArray(aliases)) assets.push(...aliases);\n        else assets.push(aliases);\n        let keyCheck;\n        keyCheck = (key)=>{\n            if (this.hasKey(key)) (0, $8CF4q.warn)(`[Resolver] already has key: ${key} overwriting`);\n        };\n        const assetArray = (0, $lbclP.convertToList)(assets);\n        assetArray.forEach((asset)=>{\n            const { src: src } = asset;\n            let { data: data, format: format, loadParser: loadParser } = asset;\n            const srcsToUse = (0, $lbclP.convertToList)(src).map((src2)=>{\n                if (typeof src2 === \"string\") return (0, $ahHFV.createStringVariations)(src2);\n                return Array.isArray(src2) ? src2 : [\n                    src2\n                ];\n            });\n            const aliasesToUse = this.getAlias(asset);\n            Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n            const resolvedAssets = [];\n            srcsToUse.forEach((srcs)=>{\n                srcs.forEach((src2)=>{\n                    let formattedAsset = {};\n                    if (typeof src2 !== \"object\") {\n                        formattedAsset.src = src2;\n                        for(let i = 0; i < this._parsers.length; i++){\n                            const parser = this._parsers[i];\n                            if (parser.test(src2)) {\n                                formattedAsset = parser.parse(src2);\n                                break;\n                            }\n                        }\n                    } else {\n                        data = src2.data ?? data;\n                        format = src2.format ?? format;\n                        loadParser = src2.loadParser ?? loadParser;\n                        formattedAsset = {\n                            ...formattedAsset,\n                            ...src2\n                        };\n                    }\n                    if (!aliasesToUse) throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);\n                    formattedAsset = this._buildResolvedAsset(formattedAsset, {\n                        aliases: aliasesToUse,\n                        data: data,\n                        format: format,\n                        loadParser: loadParser\n                    });\n                    resolvedAssets.push(formattedAsset);\n                });\n            });\n            aliasesToUse.forEach((alias)=>{\n                this._assetMap[alias] = resolvedAssets;\n            });\n        });\n    }\n    // TODO: this needs an overload like load did in Assets\n    /**\n   * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n   * a given bundleId or bundleIds.\n   * @example\n   * // Manifest Example\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: 'load-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'background',\n   *                     src: 'sunset.png',\n   *                 },\n   *                 {\n   *                     alias: 'bar',\n   *                     src: 'load-bar.{png,webp}',\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: 'game-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'character',\n   *                     src: 'robot.png',\n   *                 },\n   *                 {\n   *                     alias: 'enemy',\n   *                     src: 'bad-guy.png',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * resolver.setManifest(manifest);\n   * const resolved = resolver.resolveBundle('load-screen');\n   * @param bundleIds - The bundle ids to resolve\n   * @returns All the bundles assets or a hash of assets for each bundle specified\n   */ resolveBundle(bundleIds) {\n        const singleAsset = (0, $6BHki.isSingleItem)(bundleIds);\n        bundleIds = (0, $lbclP.convertToList)(bundleIds);\n        const out = {};\n        bundleIds.forEach((bundleId)=>{\n            const assetNames = this._bundles[bundleId];\n            if (assetNames) {\n                const results = this.resolve(assetNames);\n                const assets = {};\n                for(const key in results){\n                    const asset = results[key];\n                    assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n                }\n                out[bundleId] = assets;\n            }\n        });\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n    /**\n   * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n   * @param key - The key or keys to resolve\n   * @returns - The URLs associated with the key(s)\n   */ resolveUrl(key) {\n        const result = this.resolve(key);\n        if (typeof key !== \"string\") {\n            const out = {};\n            for(const i in result)out[i] = result[i].src;\n            return out;\n        }\n        return result.src;\n    }\n    resolve(keys) {\n        const singleAsset = (0, $6BHki.isSingleItem)(keys);\n        keys = (0, $lbclP.convertToList)(keys);\n        const result = {};\n        keys.forEach((key)=>{\n            if (!this._resolverHash[key]) {\n                if (this._assetMap[key]) {\n                    let assets = this._assetMap[key];\n                    const preferredOrder = this._getPreferredOrder(assets);\n                    preferredOrder?.priority.forEach((priorityKey)=>{\n                        preferredOrder.params[priorityKey].forEach((value)=>{\n                            const filteredAssets = assets.filter((asset)=>{\n                                if (asset[priorityKey]) return asset[priorityKey] === value;\n                                return false;\n                            });\n                            if (filteredAssets.length) assets = filteredAssets;\n                        });\n                    });\n                    this._resolverHash[key] = assets[0];\n                } else this._resolverHash[key] = this._buildResolvedAsset({\n                    alias: [\n                        key\n                    ],\n                    src: key\n                }, {});\n            }\n            result[key] = this._resolverHash[key];\n        });\n        return singleAsset ? result[keys[0]] : result;\n    }\n    /**\n   * Checks if an asset with a given key exists in the resolver\n   * @param key - The key of the asset\n   */ hasKey(key) {\n        return !!this._assetMap[key];\n    }\n    /**\n   * Checks if a bundle with the given key exists in the resolver\n   * @param key - The key of the bundle\n   */ hasBundle(key) {\n        return !!this._bundles[key];\n    }\n    /**\n   * Internal function for figuring out what prefer criteria an asset should use.\n   * @param assets\n   */ _getPreferredOrder(assets) {\n        for(let i = 0; i < assets.length; i++){\n            const asset = assets[0];\n            const preferred = this._preferredOrder.find((preference)=>preference.params.format.includes(asset.format));\n            if (preferred) return preferred;\n        }\n        return this._preferredOrder[0];\n    }\n    /**\n   * Appends the default url parameters to the url\n   * @param url - The url to append the default parameters to\n   * @returns - The url with the default parameters appended\n   */ _appendDefaultSearchParams(url) {\n        if (!this._defaultSearchParams) return url;\n        const paramConnector = /\\?/.test(url) ? \"&\" : \"?\";\n        return `${url}${paramConnector}${this._defaultSearchParams}`;\n    }\n    _buildResolvedAsset(formattedAsset, data) {\n        const { aliases: aliases, data: assetData, loadParser: loadParser, format: format } = data;\n        if (this._basePath || this._rootPath) formattedAsset.src = (0, $kaDu9.path).toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n        formattedAsset.alias = aliases ?? formattedAsset.alias ?? [\n            formattedAsset.src\n        ];\n        formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n        formattedAsset.data = {\n            ...assetData || {},\n            ...formattedAsset.data\n        };\n        formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;\n        formattedAsset.format = format ?? formattedAsset.format ?? $ffe5eb4b246313bd$export$4bb0ea38086a2ed5(formattedAsset.src);\n        return formattedAsset;\n    }\n}\n/**\n * The prefix that denotes a URL is for a retina asset.\n * @static\n * @name RETINA_PREFIX\n * @type {RegExp}\n * @default /@([0-9\\.]+)x/\n * @example `@2x`\n */ $ffe5eb4b246313bd$export$8b4c839865b08288.RETINA_PREFIX = /@([0-9\\.]+)x/;\nfunction $ffe5eb4b246313bd$export$4bb0ea38086a2ed5(url) {\n    return url.split(\".\").pop().split(\"?\").shift().split(\"#\").shift();\n}\n\n});\nparcelRegister(\"kaDu9\", function(module, exports) {\n\n$parcel$export(module.exports, \"path\", () => $71fdf52ee267c3d5$export$bb654e07daaf8c3a);\n\nvar $5m2Qn = parcelRequire(\"5m2Qn\");\n\"use strict\";\nfunction $71fdf52ee267c3d5$var$assertPath(path2) {\n    if (typeof path2 !== \"string\") throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);\n}\nfunction $71fdf52ee267c3d5$var$removeUrlParams(url) {\n    const re = url.split(\"?\")[0];\n    return re.split(\"#\")[0];\n}\nfunction $71fdf52ee267c3d5$var$escapeRegExp(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction $71fdf52ee267c3d5$var$replaceAll(str, find, replace) {\n    return str.replace(new RegExp($71fdf52ee267c3d5$var$escapeRegExp(find), \"g\"), replace);\n}\nfunction $71fdf52ee267c3d5$var$normalizeStringPosix(path2, allowAboveRoot) {\n    let res = \"\";\n    let lastSegmentLength = 0;\n    let lastSlash = -1;\n    let dots = 0;\n    let code = -1;\n    for(let i = 0; i <= path2.length; ++i){\n        if (i < path2.length) code = path2.charCodeAt(i);\n        else if (code === 47) break;\n        else code = 47;\n        if (code === 47) {\n            if (lastSlash === i - 1 || dots === 1) ;\n            else if (lastSlash !== i - 1 && dots === 2) {\n                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {\n                    if (res.length > 2) {\n                        const lastSlashIndex = res.lastIndexOf(\"/\");\n                        if (lastSlashIndex !== res.length - 1) {\n                            if (lastSlashIndex === -1) {\n                                res = \"\";\n                                lastSegmentLength = 0;\n                            } else {\n                                res = res.slice(0, lastSlashIndex);\n                                lastSegmentLength = res.length - 1 - res.lastIndexOf(\"/\");\n                            }\n                            lastSlash = i;\n                            dots = 0;\n                            continue;\n                        }\n                    } else if (res.length === 2 || res.length === 1) {\n                        res = \"\";\n                        lastSegmentLength = 0;\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                }\n                if (allowAboveRoot) {\n                    if (res.length > 0) res += \"/..\";\n                    else res = \"..\";\n                    lastSegmentLength = 2;\n                }\n            } else {\n                if (res.length > 0) res += `/${path2.slice(lastSlash + 1, i)}`;\n                else res = path2.slice(lastSlash + 1, i);\n                lastSegmentLength = i - lastSlash - 1;\n            }\n            lastSlash = i;\n            dots = 0;\n        } else if (code === 46 && dots !== -1) ++dots;\n        else dots = -1;\n    }\n    return res;\n}\nconst $71fdf52ee267c3d5$export$bb654e07daaf8c3a = {\n    /**\n   * Converts a path to posix format.\n   * @param path - The path to convert to posix\n   */ toPosix (path2) {\n        return $71fdf52ee267c3d5$var$replaceAll(path2, \"\\\\\", \"/\");\n    },\n    /**\n   * Checks if the path is a URL e.g. http://, https://\n   * @param path - The path to check\n   */ isUrl (path2) {\n        return /^https?:/.test(this.toPosix(path2));\n    },\n    /**\n   * Checks if the path is a data URL\n   * @param path - The path to check\n   */ isDataUrl (path2) {\n        return /^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i.test(path2);\n    },\n    /**\n   * Checks if the path is a blob URL\n   * @param path - The path to check\n   */ isBlobUrl (path2) {\n        return path2.startsWith(\"blob:\");\n    },\n    /**\n   * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n   * This will return true for windows file paths\n   * @param path - The path to check\n   */ hasProtocol (path2) {\n        return /^[^/:]+:/.test(this.toPosix(path2));\n    },\n    /**\n   * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n   * @param path - The path to get the protocol from\n   */ getProtocol (path2) {\n        $71fdf52ee267c3d5$var$assertPath(path2);\n        path2 = this.toPosix(path2);\n        const matchFile = /^file:\\/\\/\\//.exec(path2);\n        if (matchFile) return matchFile[0];\n        const matchProtocol = /^[^/:]+:\\/{0,2}/.exec(path2);\n        if (matchProtocol) return matchProtocol[0];\n        return \"\";\n    },\n    /**\n   * Converts URL to an absolute path.\n   * When loading from a Web Worker, we must use absolute paths.\n   * If the URL is already absolute we return it as is\n   * If it's not, we convert it\n   * @param url - The URL to test\n   * @param customBaseUrl - The base URL to use\n   * @param customRootUrl - The root URL to use\n   */ toAbsolute (url, customBaseUrl, customRootUrl) {\n        $71fdf52ee267c3d5$var$assertPath(url);\n        if (this.isDataUrl(url) || this.isBlobUrl(url)) return url;\n        const baseUrl = $71fdf52ee267c3d5$var$removeUrlParams(this.toPosix(customBaseUrl ?? (0, $5m2Qn.DOMAdapter).get().getBaseUrl()));\n        const rootUrl = $71fdf52ee267c3d5$var$removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));\n        url = this.toPosix(url);\n        if (url.startsWith(\"/\")) return $71fdf52ee267c3d5$export$bb654e07daaf8c3a.join(rootUrl, url.slice(1));\n        const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);\n        return absolutePath;\n    },\n    /**\n   * Normalizes the given path, resolving '..' and '.' segments\n   * @param path - The path to normalize\n   */ normalize (path2) {\n        $71fdf52ee267c3d5$var$assertPath(path2);\n        if (path2.length === 0) return \".\";\n        if (this.isDataUrl(path2) || this.isBlobUrl(path2)) return path2;\n        path2 = this.toPosix(path2);\n        let protocol = \"\";\n        const isAbsolute = path2.startsWith(\"/\");\n        if (this.hasProtocol(path2)) {\n            protocol = this.rootname(path2);\n            path2 = path2.slice(protocol.length);\n        }\n        const trailingSeparator = path2.endsWith(\"/\");\n        path2 = $71fdf52ee267c3d5$var$normalizeStringPosix(path2, false);\n        if (path2.length > 0 && trailingSeparator) path2 += \"/\";\n        if (isAbsolute) return `/${path2}`;\n        return protocol + path2;\n    },\n    /**\n   * Determines if path is an absolute path.\n   * Absolute paths can be urls, data urls, or paths on disk\n   * @param path - The path to test\n   */ isAbsolute (path2) {\n        $71fdf52ee267c3d5$var$assertPath(path2);\n        path2 = this.toPosix(path2);\n        if (this.hasProtocol(path2)) return true;\n        return path2.startsWith(\"/\");\n    },\n    /**\n   * Joins all given path segments together using the platform-specific separator as a delimiter,\n   * then normalizes the resulting path\n   * @param segments - The segments of the path to join\n   */ join (...segments) {\n        if (segments.length === 0) return \".\";\n        let joined;\n        for(let i = 0; i < segments.length; ++i){\n            const arg = segments[i];\n            $71fdf52ee267c3d5$var$assertPath(arg);\n            if (arg.length > 0) {\n                if (joined === void 0) joined = arg;\n                else {\n                    const prevArg = segments[i - 1] ?? \"\";\n                    if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase())) joined += `/../${arg}`;\n                    else joined += `/${arg}`;\n                }\n            }\n        }\n        if (joined === void 0) return \".\";\n        return this.normalize(joined);\n    },\n    /**\n   * Returns the directory name of a path\n   * @param path - The path to parse\n   */ dirname (path2) {\n        $71fdf52ee267c3d5$var$assertPath(path2);\n        if (path2.length === 0) return \".\";\n        path2 = this.toPosix(path2);\n        let code = path2.charCodeAt(0);\n        const hasRoot = code === 47;\n        let end = -1;\n        let matchedSlash = true;\n        const proto = this.getProtocol(path2);\n        const origpath = path2;\n        path2 = path2.slice(proto.length);\n        for(let i = path2.length - 1; i >= 1; --i){\n            code = path2.charCodeAt(i);\n            if (code === 47) {\n                if (!matchedSlash) {\n                    end = i;\n                    break;\n                }\n            } else matchedSlash = false;\n        }\n        if (end === -1) return hasRoot ? \"/\" : this.isUrl(origpath) ? proto + path2 : proto;\n        if (hasRoot && end === 1) return \"//\";\n        return proto + path2.slice(0, end);\n    },\n    /**\n   * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n   * @param path - The path to parse\n   */ rootname (path2) {\n        $71fdf52ee267c3d5$var$assertPath(path2);\n        path2 = this.toPosix(path2);\n        let root = \"\";\n        if (path2.startsWith(\"/\")) root = \"/\";\n        else root = this.getProtocol(path2);\n        if (this.isUrl(path2)) {\n            const index = path2.indexOf(\"/\", root.length);\n            if (index !== -1) root = path2.slice(0, index);\n            else root = path2;\n            if (!root.endsWith(\"/\")) root += \"/\";\n        }\n        return root;\n    },\n    /**\n   * Returns the last portion of a path\n   * @param path - The path to test\n   * @param ext - Optional extension to remove\n   */ basename (path2, ext) {\n        $71fdf52ee267c3d5$var$assertPath(path2);\n        if (ext) $71fdf52ee267c3d5$var$assertPath(ext);\n        path2 = $71fdf52ee267c3d5$var$removeUrlParams(this.toPosix(path2));\n        let start = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i;\n        if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {\n            if (ext.length === path2.length && ext === path2) return \"\";\n            let extIdx = ext.length - 1;\n            let firstNonSlashEnd = -1;\n            for(i = path2.length - 1; i >= 0; --i){\n                const code = path2.charCodeAt(i);\n                if (code === 47) {\n                    if (!matchedSlash) {\n                        start = i + 1;\n                        break;\n                    }\n                } else {\n                    if (firstNonSlashEnd === -1) {\n                        matchedSlash = false;\n                        firstNonSlashEnd = i + 1;\n                    }\n                    if (extIdx >= 0) {\n                        if (code === ext.charCodeAt(extIdx)) {\n                            if (--extIdx === -1) end = i;\n                        } else {\n                            extIdx = -1;\n                            end = firstNonSlashEnd;\n                        }\n                    }\n                }\n            }\n            if (start === end) end = firstNonSlashEnd;\n            else if (end === -1) end = path2.length;\n            return path2.slice(start, end);\n        }\n        for(i = path2.length - 1; i >= 0; --i){\n            if (path2.charCodeAt(i) === 47) {\n                if (!matchedSlash) {\n                    start = i + 1;\n                    break;\n                }\n            } else if (end === -1) {\n                matchedSlash = false;\n                end = i + 1;\n            }\n        }\n        if (end === -1) return \"\";\n        return path2.slice(start, end);\n    },\n    /**\n   * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n   * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n   * the first character of the basename of path, an empty string is returned.\n   * @param path - The path to parse\n   */ extname (path2) {\n        $71fdf52ee267c3d5$var$assertPath(path2);\n        path2 = $71fdf52ee267c3d5$var$removeUrlParams(this.toPosix(path2));\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let preDotState = 0;\n        for(let i = path2.length - 1; i >= 0; --i){\n            const code = path2.charCodeAt(i);\n            if (code === 47) {\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46) {\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            } else if (startDot !== -1) preDotState = -1;\n        }\n        if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) return \"\";\n        return path2.slice(startDot, end);\n    },\n    /**\n   * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n   * @param path - The path to parse\n   */ parse (path2) {\n        $71fdf52ee267c3d5$var$assertPath(path2);\n        const ret = {\n            root: \"\",\n            dir: \"\",\n            base: \"\",\n            ext: \"\",\n            name: \"\"\n        };\n        if (path2.length === 0) return ret;\n        path2 = $71fdf52ee267c3d5$var$removeUrlParams(this.toPosix(path2));\n        let code = path2.charCodeAt(0);\n        const isAbsolute = this.isAbsolute(path2);\n        let start;\n        const protocol = \"\";\n        ret.root = this.rootname(path2);\n        if (isAbsolute || this.hasProtocol(path2)) start = 1;\n        else start = 0;\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i = path2.length - 1;\n        let preDotState = 0;\n        for(; i >= start; --i){\n            code = path2.charCodeAt(i);\n            if (code === 47) {\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46) {\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            } else if (startDot !== -1) preDotState = -1;\n        }\n        if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n            if (end !== -1) {\n                if (startPart === 0 && isAbsolute) ret.base = ret.name = path2.slice(1, end);\n                else ret.base = ret.name = path2.slice(startPart, end);\n            }\n        } else {\n            if (startPart === 0 && isAbsolute) {\n                ret.name = path2.slice(1, startDot);\n                ret.base = path2.slice(1, end);\n            } else {\n                ret.name = path2.slice(startPart, startDot);\n                ret.base = path2.slice(startPart, end);\n            }\n            ret.ext = path2.slice(startDot, end);\n        }\n        ret.dir = this.dirname(path2);\n        if (protocol) ret.dir = protocol + ret.dir;\n        return ret;\n    },\n    sep: \"/\",\n    delimiter: \":\",\n    joinExtensions: [\n        \".html\"\n    ]\n};\n\n});\n\nparcelRegister(\"lbclP\", function(module, exports) {\n\n$parcel$export(module.exports, \"convertToList\", () => $e2bf4ca911ccb6c4$export$b01be8e180bf3d9b);\n\"use strict\";\nconst $e2bf4ca911ccb6c4$export$b01be8e180bf3d9b = (input, transform, forceTransform = false)=>{\n    if (!Array.isArray(input)) input = [\n        input\n    ];\n    if (!transform) return input;\n    return input.map((item)=>{\n        if (typeof item === \"string\" || forceTransform) return transform(item);\n        return item;\n    });\n};\n\n});\n\nparcelRegister(\"ahHFV\", function(module, exports) {\n\n$parcel$export(module.exports, \"createStringVariations\", () => $640f472f529f8d2c$export$738117acc6638004);\n\"use strict\";\nfunction $640f472f529f8d2c$var$processX(base, ids, depth, result, tags) {\n    const id = ids[depth];\n    for(let i = 0; i < id.length; i++){\n        const value = id[i];\n        if (depth < ids.length - 1) $640f472f529f8d2c$var$processX(base.replace(result[depth], value), ids, depth + 1, result, tags);\n        else tags.push(base.replace(result[depth], value));\n    }\n}\nfunction $640f472f529f8d2c$export$738117acc6638004(string) {\n    const regex = /\\{(.*?)\\}/g;\n    const result = string.match(regex);\n    const tags = [];\n    if (result) {\n        const ids = [];\n        result.forEach((vars)=>{\n            const split = vars.substring(1, vars.length - 1).split(\",\");\n            ids.push(split);\n        });\n        $640f472f529f8d2c$var$processX(string, ids, 0, result, tags);\n    } else tags.push(string);\n    return tags;\n}\n\n});\n\nparcelRegister(\"6BHki\", function(module, exports) {\n\n$parcel$export(module.exports, \"isSingleItem\", () => $2eda5fd8d2343e44$export$16a80d27953452d4);\n\"use strict\";\nconst $2eda5fd8d2343e44$export$16a80d27953452d4 = (item)=>!Array.isArray(item);\n\n});\n\n\nparcelRegister(\"kY7V1\", function(module, exports) {\n\n$parcel$export(module.exports, \"copySearchParams\", () => $d4712b2ff08e6328$export$f57b97ef8be10dda);\n\"use strict\";\nconst $d4712b2ff08e6328$export$f57b97ef8be10dda = (targetUrl, sourceUrl)=>{\n    const searchParams = sourceUrl.split(\"?\")[1];\n    if (searchParams) targetUrl += `?${searchParams}`;\n    return targetUrl;\n};\n\n});\n\nparcelRegister(\"2v83S\", function(module, exports) {\n\n$parcel$export(module.exports, \"Spritesheet\", () => $9bc8b71d4eda66ae$export$674d2eb4debbef0c);\n\nvar $soqVu = parcelRequire(\"soqVu\");\n\nvar $5h88T = parcelRequire(\"5h88T\");\n\"use strict\";\nconst $9bc8b71d4eda66ae$var$_Spritesheet = class _Spritesheet {\n    /**\n   * @param texture - Reference to the source BaseTexture object.\n   * @param {object} data - Spritesheet image data.\n   */ constructor(texture, data){\n        /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */ this.linkedSheets = [];\n        this._texture = texture instanceof (0, $5h88T.Texture) ? texture : null;\n        this.textureSource = texture.source;\n        this.textures = {};\n        this.animations = {};\n        this.data = data;\n        const metaResolution = parseFloat(data.meta.scale);\n        if (metaResolution) {\n            this.resolution = metaResolution;\n            texture.source.resolution = this.resolution;\n        } else this.resolution = texture.source._resolution;\n        this._frames = this.data.frames;\n        this._frameKeys = Object.keys(this._frames);\n        this._batchIndex = 0;\n        this._callback = null;\n    }\n    /**\n   * Parser spritesheet from loaded data. This is done asynchronously\n   * to prevent creating too many Texture within a single process.\n   */ parse() {\n        return new Promise((resolve)=>{\n            this._callback = resolve;\n            this._batchIndex = 0;\n            if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {\n                this._processFrames(0);\n                this._processAnimations();\n                this._parseComplete();\n            } else this._nextBatch();\n        });\n    }\n    /**\n   * Process a batch of frames\n   * @param initialFrameIndex - The index of frame to start.\n   */ _processFrames(initialFrameIndex) {\n        let frameIndex = initialFrameIndex;\n        const maxFrames = _Spritesheet.BATCH_SIZE;\n        while(frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length){\n            const i = this._frameKeys[frameIndex];\n            const data = this._frames[i];\n            const rect = data.frame;\n            if (rect) {\n                let frame = null;\n                let trim = null;\n                const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;\n                const orig = new (0, $soqVu.Rectangle)(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);\n                if (data.rotated) frame = new (0, $soqVu.Rectangle)(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);\n                else frame = new (0, $soqVu.Rectangle)(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);\n                if (data.trimmed !== false && data.spriteSourceSize) trim = new (0, $soqVu.Rectangle)(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);\n                this.textures[i] = new (0, $5h88T.Texture)({\n                    source: this.textureSource,\n                    frame: frame,\n                    orig: orig,\n                    trim: trim,\n                    rotate: data.rotated ? 2 : 0,\n                    defaultAnchor: data.anchor,\n                    defaultBorders: data.borders,\n                    label: i.toString()\n                });\n            }\n            frameIndex++;\n        }\n    }\n    /** Parse animations config. */ _processAnimations() {\n        const animations = this.data.animations || {};\n        for(const animName in animations){\n            this.animations[animName] = [];\n            for(let i = 0; i < animations[animName].length; i++){\n                const frameName = animations[animName][i];\n                this.animations[animName].push(this.textures[frameName]);\n            }\n        }\n    }\n    /** The parse has completed. */ _parseComplete() {\n        const callback = this._callback;\n        this._callback = null;\n        this._batchIndex = 0;\n        callback.call(this, this.textures);\n    }\n    /** Begin the next batch of textures. */ _nextBatch() {\n        this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);\n        this._batchIndex++;\n        setTimeout(()=>{\n            if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) this._nextBatch();\n            else {\n                this._processAnimations();\n                this._parseComplete();\n            }\n        }, 0);\n    }\n    /**\n   * Destroy Spritesheet and don't use after this.\n   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n   */ destroy(destroyBase = false) {\n        for(const i in this.textures)this.textures[i].destroy();\n        this._frames = null;\n        this._frameKeys = null;\n        this.data = null;\n        this.textures = null;\n        if (destroyBase) {\n            this._texture?.destroy();\n            this.textureSource.destroy();\n        }\n        this._texture = null;\n        this.textureSource = null;\n        this.linkedSheets = [];\n    }\n};\n/** The maximum number of Textures to build per process. */ $9bc8b71d4eda66ae$var$_Spritesheet.BATCH_SIZE = 1e3;\nlet $9bc8b71d4eda66ae$export$674d2eb4debbef0c = $9bc8b71d4eda66ae$var$_Spritesheet;\n\n});\n\n\n\nparcelRegister(\"28YnR\", function(module, exports) {\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $jgXaH = parcelRequire(\"jgXaH\");\n\nvar $vwyRu = parcelRequire(\"vwyRu\");\n\nvar $lcq2f = parcelRequire(\"lcq2f\");\n\nvar $i8D1k = parcelRequire(\"i8D1k\");\n\nvar $2rfX3 = parcelRequire(\"2rfX3\");\n\nvar $4XrO5 = parcelRequire(\"4XrO5\");\n\nvar $c9SSH = parcelRequire(\"c9SSH\");\nparcelRequire(\"i4n4u\");\n\n\"use strict\";\n(0, $eVz1R.extensions).add((0, $jgXaH.AlphaMask), (0, $vwyRu.ColorMask), (0, $lcq2f.StencilMask), (0, $c9SSH.VideoSource), (0, $4XrO5.ImageSource), (0, $2rfX3.CanvasSource), (0, $i8D1k.BufferImageSource));\n\n});\nparcelRegister(\"jgXaH\", function(module, exports) {\n\n$parcel$export(module.exports, \"AlphaMask\", () => $00f658052eacd8e9$export$3c32667be409917c);\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $9Qy7u = parcelRequire(\"9Qy7u\");\n\nvar $kARrF = parcelRequire(\"kARrF\");\n\nvar $kBq1a = parcelRequire(\"kBq1a\");\n\"use strict\";\nclass $00f658052eacd8e9$export$3c32667be409917c {\n    constructor(options){\n        this.priority = 0;\n        this.pipe = \"alphaMask\";\n        if (options?.mask) this.init(options.mask);\n    }\n    init(mask) {\n        this.mask = mask;\n        this.renderMaskToTexture = !(mask instanceof (0, $9Qy7u.Sprite));\n        this.mask.renderable = this.renderMaskToTexture;\n        this.mask.includeInBuild = !this.renderMaskToTexture;\n        this.mask.measurable = false;\n    }\n    reset() {\n        this.mask.measurable = true;\n        this.mask = null;\n    }\n    addBounds(bounds, skipUpdateTransform) {\n        (0, $kARrF.addMaskBounds)(this.mask, bounds, skipUpdateTransform);\n    }\n    addLocalBounds(bounds, localRoot) {\n        (0, $kBq1a.addMaskLocalBounds)(this.mask, bounds, localRoot);\n    }\n    containsPoint(point, hitTestFn) {\n        const mask = this.mask;\n        return hitTestFn(mask, point);\n    }\n    destroy() {\n        this.reset();\n    }\n    static test(mask) {\n        return mask instanceof (0, $9Qy7u.Sprite);\n    }\n}\n$00f658052eacd8e9$export$3c32667be409917c.extension = (0, $eVz1R.ExtensionType).MaskEffect;\n\n});\nparcelRegister(\"kARrF\", function(module, exports) {\n\n$parcel$export(module.exports, \"addMaskBounds\", () => $7b87da68c49fb137$export$12af48852c6ac574);\n\nvar $ggeMF = parcelRequire(\"ggeMF\");\n\nvar $dXx4G = parcelRequire(\"dXx4G\");\n\"use strict\";\nconst $7b87da68c49fb137$var$tempBounds = new (0, $ggeMF.Bounds)();\nfunction $7b87da68c49fb137$export$12af48852c6ac574(mask, bounds, skipUpdateTransform) {\n    const boundsToMask = $7b87da68c49fb137$var$tempBounds;\n    mask.measurable = true;\n    (0, $dXx4G.getGlobalBounds)(mask, skipUpdateTransform, boundsToMask);\n    bounds.addBoundsMask(boundsToMask);\n    mask.measurable = false;\n}\n\n});\n\nparcelRegister(\"kBq1a\", function(module, exports) {\n\n$parcel$export(module.exports, \"addMaskLocalBounds\", () => $3fc9498bf56d1000$export$7416ac774b1f1a33);\n\nvar $5pskN = parcelRequire(\"5pskN\");\n\nvar $96ND8 = parcelRequire(\"96ND8\");\n\nvar $8CF4q = parcelRequire(\"8CF4q\");\n\"use strict\";\nfunction $3fc9498bf56d1000$export$7416ac774b1f1a33(mask, bounds, localRoot) {\n    const boundsToMask = (0, $96ND8.boundsPool).get();\n    mask.measurable = true;\n    const tempMatrix = (0, $96ND8.matrixPool).get().identity();\n    const relativeMask = $3fc9498bf56d1000$export$1536bde1a0bf3cb9(mask, localRoot, tempMatrix);\n    (0, $5pskN.getLocalBounds)(mask, boundsToMask, relativeMask);\n    mask.measurable = false;\n    bounds.addBoundsMask(boundsToMask);\n    (0, $96ND8.matrixPool).return(tempMatrix);\n    (0, $96ND8.boundsPool).return(boundsToMask);\n}\nfunction $3fc9498bf56d1000$export$1536bde1a0bf3cb9(target, root, matrix) {\n    if (!target) {\n        (0, $8CF4q.warn)(\"Mask bounds, renderable is not inside the root container\");\n        return matrix;\n    }\n    if (target !== root) {\n        $3fc9498bf56d1000$export$1536bde1a0bf3cb9(target.parent, root, matrix);\n        target.updateLocalTransform();\n        matrix.append(target.localTransform);\n    }\n    return matrix;\n}\n\n});\n\n\nparcelRegister(\"vwyRu\", function(module, exports) {\n\n$parcel$export(module.exports, \"ColorMask\", () => $9d623112a0b61944$export$1e2a2c76374c2542);\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\"use strict\";\nclass $9d623112a0b61944$export$1e2a2c76374c2542 {\n    constructor(options){\n        this.priority = 0;\n        this.pipe = \"colorMask\";\n        if (options?.mask) this.init(options.mask);\n    }\n    init(mask) {\n        this.mask = mask;\n    }\n    destroy() {}\n    static test(mask) {\n        return typeof mask === \"number\";\n    }\n}\n$9d623112a0b61944$export$1e2a2c76374c2542.extension = (0, $eVz1R.ExtensionType).MaskEffect;\n\n});\n\nparcelRegister(\"lcq2f\", function(module, exports) {\n\n$parcel$export(module.exports, \"StencilMask\", () => $f004bf9ee6cb5cde$export$abd85894695764cb);\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $lR3Ev = parcelRequire(\"lR3Ev\");\n\nvar $kARrF = parcelRequire(\"kARrF\");\n\nvar $kBq1a = parcelRequire(\"kBq1a\");\n\"use strict\";\nclass $f004bf9ee6cb5cde$export$abd85894695764cb {\n    constructor(options){\n        this.priority = 0;\n        this.pipe = \"stencilMask\";\n        if (options?.mask) this.init(options.mask);\n    }\n    init(mask) {\n        this.mask = mask;\n        this.mask.includeInBuild = false;\n        this.mask.measurable = false;\n    }\n    reset() {\n        this.mask.measurable = true;\n        this.mask.includeInBuild = true;\n        this.mask = null;\n    }\n    addBounds(bounds, skipUpdateTransform) {\n        (0, $kARrF.addMaskBounds)(this.mask, bounds, skipUpdateTransform);\n    }\n    addLocalBounds(bounds, localRoot) {\n        (0, $kBq1a.addMaskLocalBounds)(this.mask, bounds, localRoot);\n    }\n    containsPoint(point, hitTestFn) {\n        const mask = this.mask;\n        return hitTestFn(mask, point);\n    }\n    destroy() {\n        this.reset();\n    }\n    static test(mask) {\n        return mask instanceof (0, $lR3Ev.Container);\n    }\n}\n$f004bf9ee6cb5cde$export$abd85894695764cb.extension = (0, $eVz1R.ExtensionType).MaskEffect;\n\n});\n\nparcelRegister(\"4XrO5\", function(module, exports) {\n\n$parcel$export(module.exports, \"ImageSource\", () => $0a4120f708973e3a$export$280e9a68c3ffd919);\n\nvar $5m2Qn = parcelRequire(\"5m2Qn\");\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $8CF4q = parcelRequire(\"8CF4q\");\n\nvar $9Ur0D = parcelRequire(\"9Ur0D\");\n\"use strict\";\nclass $0a4120f708973e3a$export$280e9a68c3ffd919 extends (0, $9Ur0D.TextureSource) {\n    constructor(options){\n        if (options.resource && globalThis.HTMLImageElement && options.resource instanceof HTMLImageElement) {\n            const canvas = (0, $5m2Qn.DOMAdapter).get().createCanvas(options.resource.width, options.resource.height);\n            const context = canvas.getContext(\"2d\");\n            context.drawImage(options.resource, 0, 0);\n            options.resource = canvas;\n            (0, $8CF4q.warn)(\"ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.\");\n        }\n        super(options);\n        this.uploadMethodId = \"image\";\n        this.autoGarbageCollect = true;\n    }\n    static test(resource) {\n        return globalThis.HTMLImageElement && resource instanceof HTMLImageElement || typeof ImageBitmap !== \"undefined\" && resource instanceof ImageBitmap;\n    }\n}\n$0a4120f708973e3a$export$280e9a68c3ffd919.extension = (0, $eVz1R.ExtensionType).TextureSource;\n\n});\n\nparcelRegister(\"c9SSH\", function(module, exports) {\n\n$parcel$export(module.exports, \"VideoSource\", () => $c255db0163bf6e8b$export$f3a17123d80000c5);\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $1WaK0 = parcelRequire(\"1WaK0\");\n\nvar $aG1Od = parcelRequire(\"aG1Od\");\n\nvar $9Ur0D = parcelRequire(\"9Ur0D\");\n\"use strict\";\nconst $c255db0163bf6e8b$var$_VideoSource = class _VideoSource extends (0, $9Ur0D.TextureSource) {\n    constructor(options){\n        super(options);\n        // Public\n        /** Whether or not the video is ready to play. */ this.isReady = false;\n        /** The upload method for this texture. */ this.uploadMethodId = \"video\";\n        options = {\n            ..._VideoSource.defaultOptions,\n            ...options\n        };\n        this._autoUpdate = true;\n        this._isConnectedToTicker = false;\n        this._updateFPS = options.updateFPS || 0;\n        this._msToNextUpdate = 0;\n        this.autoPlay = options.autoPlay !== false;\n        this.alphaMode = options.alphaMode ?? \"premultiply-alpha-on-upload\";\n        this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);\n        this._videoFrameRequestCallbackHandle = null;\n        this._load = null;\n        this._resolve = null;\n        this._reject = null;\n        this._onCanPlay = this._onCanPlay.bind(this);\n        this._onCanPlayThrough = this._onCanPlayThrough.bind(this);\n        this._onError = this._onError.bind(this);\n        this._onPlayStart = this._onPlayStart.bind(this);\n        this._onPlayStop = this._onPlayStop.bind(this);\n        this._onSeeked = this._onSeeked.bind(this);\n        if (options.autoLoad !== false) this.load();\n    }\n    /** Update the video frame if the source is not destroyed and meets certain conditions. */ updateFrame() {\n        if (this.destroyed) return;\n        if (this._updateFPS) {\n            const elapsedMS = (0, $1WaK0.Ticker).shared.elapsedMS * this.resource.playbackRate;\n            this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n        }\n        if (!this._updateFPS || this._msToNextUpdate <= 0) this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;\n        if (this.isValid) this.update();\n    }\n    /** Callback to update the video frame and potentially request the next frame update. */ _videoFrameRequestCallback() {\n        this.updateFrame();\n        if (this.destroyed) this._videoFrameRequestCallbackHandle = null;\n        else this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(this._videoFrameRequestCallback);\n    }\n    /**\n   * Checks if the resource has valid dimensions.\n   * @returns {boolean} True if width and height are set, otherwise false.\n   */ get isValid() {\n        return !!this.resource.videoWidth && !!this.resource.videoHeight;\n    }\n    /**\n   * Start preloading the video resource.\n   * @returns {Promise<this>} Handle the validate event\n   */ async load() {\n        if (this._load) return this._load;\n        const source = this.resource;\n        const options = this.options;\n        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) source.complete = true;\n        source.addEventListener(\"play\", this._onPlayStart);\n        source.addEventListener(\"pause\", this._onPlayStop);\n        source.addEventListener(\"seeked\", this._onSeeked);\n        if (!this._isSourceReady()) {\n            if (!options.preload) source.addEventListener(\"canplay\", this._onCanPlay);\n            source.addEventListener(\"canplaythrough\", this._onCanPlayThrough);\n            source.addEventListener(\"error\", this._onError, true);\n        } else this._mediaReady();\n        this.alphaMode = await (0, $aG1Od.detectVideoAlphaMode)();\n        this._load = new Promise((resolve, reject)=>{\n            if (this.isValid) resolve(this);\n            else {\n                this._resolve = resolve;\n                this._reject = reject;\n                if (options.preloadTimeoutMs !== void 0) this._preloadTimeout = setTimeout(()=>{\n                    this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));\n                });\n                source.load();\n            }\n        });\n        return this._load;\n    }\n    /**\n   * Handle video error events.\n   * @param event - The error event\n   */ _onError(event) {\n        this.resource.removeEventListener(\"error\", this._onError, true);\n        this.emit(\"error\", event);\n        if (this._reject) {\n            this._reject(event);\n            this._reject = null;\n            this._resolve = null;\n        }\n    }\n    /**\n   * Checks if the underlying source is playing.\n   * @returns True if playing.\n   */ _isSourcePlaying() {\n        const source = this.resource;\n        return !source.paused && !source.ended;\n    }\n    /**\n   * Checks if the underlying source is ready for playing.\n   * @returns True if ready.\n   */ _isSourceReady() {\n        const source = this.resource;\n        return source.readyState > 2;\n    }\n    /** Runs the update loop when the video is ready to play. */ _onPlayStart() {\n        if (!this.isValid) this._mediaReady();\n        this._configureAutoUpdate();\n    }\n    /** Stops the update loop when a pause event is triggered. */ _onPlayStop() {\n        this._configureAutoUpdate();\n    }\n    /** Handles behavior when the video completes seeking to the current playback position. */ _onSeeked() {\n        if (this._autoUpdate && !this._isSourcePlaying()) {\n            this._msToNextUpdate = 0;\n            this.updateFrame();\n            this._msToNextUpdate = 0;\n        }\n    }\n    _onCanPlay() {\n        const source = this.resource;\n        source.removeEventListener(\"canplay\", this._onCanPlay);\n        this._mediaReady();\n    }\n    _onCanPlayThrough() {\n        const source = this.resource;\n        source.removeEventListener(\"canplaythrough\", this._onCanPlay);\n        if (this._preloadTimeout) {\n            clearTimeout(this._preloadTimeout);\n            this._preloadTimeout = void 0;\n        }\n        this._mediaReady();\n    }\n    /** Fired when the video is loaded and ready to play. */ _mediaReady() {\n        const source = this.resource;\n        if (this.isValid) {\n            this.isReady = true;\n            this.resize(source.videoWidth, source.videoHeight);\n        }\n        this._msToNextUpdate = 0;\n        this.updateFrame();\n        this._msToNextUpdate = 0;\n        if (this._resolve) {\n            this._resolve(this);\n            this._resolve = null;\n            this._reject = null;\n        }\n        if (this._isSourcePlaying()) this._onPlayStart();\n        else if (this.autoPlay) this.resource.play();\n    }\n    /** Cleans up resources and event listeners associated with this texture. */ destroy() {\n        this._configureAutoUpdate();\n        const source = this.resource;\n        if (source) {\n            source.removeEventListener(\"play\", this._onPlayStart);\n            source.removeEventListener(\"pause\", this._onPlayStop);\n            source.removeEventListener(\"seeked\", this._onSeeked);\n            source.removeEventListener(\"canplay\", this._onCanPlay);\n            source.removeEventListener(\"canplaythrough\", this._onCanPlayThrough);\n            source.removeEventListener(\"error\", this._onError, true);\n            source.pause();\n            source.src = \"\";\n            source.load();\n        }\n        super.destroy();\n    }\n    /** Should the base texture automatically update itself, set to true by default. */ get autoUpdate() {\n        return this._autoUpdate;\n    }\n    set autoUpdate(value) {\n        if (value !== this._autoUpdate) {\n            this._autoUpdate = value;\n            this._configureAutoUpdate();\n        }\n    }\n    /**\n   * How many times a second to update the texture from the video.\n   * Leave at 0 to update at every render.\n   * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n   */ get updateFPS() {\n        return this._updateFPS;\n    }\n    set updateFPS(value) {\n        if (value !== this._updateFPS) {\n            this._updateFPS = value;\n            this._configureAutoUpdate();\n        }\n    }\n    /**\n   * Configures the updating mechanism based on the current state and settings.\n   *\n   * This method decides between using the browser's native video frame callback or a custom ticker\n   * for updating the video frame. It ensures optimal performance and responsiveness\n   * based on the video's state, playback status, and the desired frames-per-second setting.\n   *\n   * - If `_autoUpdate` is enabled and the video source is playing:\n   *   - It will prefer the native video frame callback if available and no specific FPS is set.\n   *   - Otherwise, it will use a custom ticker for manual updates.\n   * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.\n   */ _configureAutoUpdate() {\n        if (this._autoUpdate && this._isSourcePlaying()) {\n            if (!this._updateFPS && this.source.requestVideoFrameCallback) {\n                if (this._isConnectedToTicker) {\n                    (0, $1WaK0.Ticker).shared.remove(this.updateFrame, this);\n                    this._isConnectedToTicker = false;\n                    this._msToNextUpdate = 0;\n                }\n                if (this._videoFrameRequestCallbackHandle === null) this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(this._videoFrameRequestCallback);\n            } else {\n                if (this._videoFrameRequestCallbackHandle !== null) {\n                    this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n                    this._videoFrameRequestCallbackHandle = null;\n                }\n                if (!this._isConnectedToTicker) {\n                    (0, $1WaK0.Ticker).shared.add(this.updateFrame, this);\n                    this._isConnectedToTicker = true;\n                    this._msToNextUpdate = 0;\n                }\n            }\n        } else {\n            if (this._videoFrameRequestCallbackHandle !== null) {\n                this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n                this._videoFrameRequestCallbackHandle = null;\n            }\n            if (this._isConnectedToTicker) {\n                (0, $1WaK0.Ticker).shared.remove(this.updateFrame, this);\n                this._isConnectedToTicker = false;\n                this._msToNextUpdate = 0;\n            }\n        }\n    }\n    static test(resource) {\n        return globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement || globalThis.VideoFrame && resource instanceof VideoFrame;\n    }\n};\n$c255db0163bf6e8b$var$_VideoSource.extension = (0, $eVz1R.ExtensionType).TextureSource;\n/** The default options for video sources. */ $c255db0163bf6e8b$var$_VideoSource.defaultOptions = {\n    ...(0, $9Ur0D.TextureSource).defaultOptions,\n    /** If true, the video will start loading immediately. */ autoLoad: true,\n    /** If true, the video will start playing as soon as it is loaded. */ autoPlay: true,\n    /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */ updateFPS: 0,\n    /** If true, the video will be loaded with the `crossorigin` attribute. */ crossorigin: true,\n    /** If true, the video will loop when it ends. */ loop: false,\n    /** If true, the video will be muted. */ muted: true,\n    /** If true, the video will play inline. */ playsinline: true,\n    /** If true, the video will be preloaded. */ preload: false\n};\n/**\n * Map of video MIME types that can't be directly derived from file extensions.\n * @readonly\n */ $c255db0163bf6e8b$var$_VideoSource.MIME_TYPES = {\n    ogv: \"video/ogg\",\n    mov: \"video/quicktime\",\n    m4v: \"video/mp4\"\n};\nlet $c255db0163bf6e8b$export$f3a17123d80000c5 = $c255db0163bf6e8b$var$_VideoSource;\n\n});\nparcelRegister(\"aG1Od\", function(module, exports) {\n\n$parcel$export(module.exports, \"detectVideoAlphaMode\", () => $6b8bedec82fcc4ee$export$8df68d58aae31877);\n\"use strict\";\nlet $6b8bedec82fcc4ee$var$promise;\nasync function $6b8bedec82fcc4ee$export$8df68d58aae31877() {\n    $6b8bedec82fcc4ee$var$promise ?? ($6b8bedec82fcc4ee$var$promise = (async ()=>{\n        const canvas = document.createElement(\"canvas\");\n        const gl = canvas.getContext(\"webgl\");\n        if (!gl) return \"premultiply-alpha-on-upload\";\n        const video = await new Promise((resolve)=>{\n            const video2 = document.createElement(\"video\");\n            video2.onloadeddata = ()=>resolve(video2);\n            video2.onerror = ()=>resolve(null);\n            video2.autoplay = false;\n            video2.crossOrigin = \"anonymous\";\n            video2.preload = \"auto\";\n            video2.src = \"data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=\";\n            video2.load();\n        });\n        if (!video) return \"premultiply-alpha-on-upload\";\n        const texture = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        const framebuffer = gl.createFramebuffer();\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n        gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);\n        const pixel = new Uint8Array(4);\n        gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n        gl.deleteFramebuffer(framebuffer);\n        gl.deleteTexture(texture);\n        gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n        return pixel[0] <= pixel[3] ? \"premultiplied-alpha\" : \"premultiply-alpha-on-upload\";\n    })());\n    return $6b8bedec82fcc4ee$var$promise;\n}\n\n});\n\n\nparcelRegister(\"i4n4u\", function(module, exports) {\n\nvar $gYSnF = parcelRequire(\"gYSnF\");\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $9Ur0D = parcelRequire(\"9Ur0D\");\n\nvar $5h88T = parcelRequire(\"5h88T\");\n\"use strict\";\nconst $917f49679f7aef27$var$sources = [];\n(0, $eVz1R.extensions).handleByList((0, $eVz1R.ExtensionType).TextureSource, $917f49679f7aef27$var$sources);\nfunction $917f49679f7aef27$export$688bcf31fbf7eb15(options = {}) {\n    const hasResource = options && options.resource;\n    const res = hasResource ? options.resource : options;\n    const opts = hasResource ? options : {\n        resource: options\n    };\n    for(let i = 0; i < $917f49679f7aef27$var$sources.length; i++){\n        const Source = $917f49679f7aef27$var$sources[i];\n        if (Source.test(res)) return new Source(opts);\n    }\n    throw new Error(`Could not find a source type for resource: ${opts.resource}`);\n}\nfunction $917f49679f7aef27$export$3b748ed6327ec85b(options = {}, skipCache = false) {\n    const hasResource = options && options.resource;\n    const resource = hasResource ? options.resource : options;\n    const opts = hasResource ? options : {\n        resource: options\n    };\n    if (!skipCache && (0, $gYSnF.Cache).has(resource)) return (0, $gYSnF.Cache).get(resource);\n    const texture = new (0, $5h88T.Texture)({\n        source: $917f49679f7aef27$export$688bcf31fbf7eb15(opts)\n    });\n    texture.on(\"destroy\", ()=>{\n        if ((0, $gYSnF.Cache).has(resource)) (0, $gYSnF.Cache).remove(resource);\n    });\n    if (!skipCache) (0, $gYSnF.Cache).set(resource, texture);\n    return texture;\n}\nfunction $917f49679f7aef27$export$4266177d9730bb1(id, skipCache = false) {\n    if (typeof id === \"string\") return (0, $gYSnF.Cache).get(id);\n    else if (id instanceof (0, $9Ur0D.TextureSource)) return new (0, $5h88T.Texture)({\n        source: id\n    });\n    return $917f49679f7aef27$export$3b748ed6327ec85b(id, skipCache);\n}\n(0, $5h88T.Texture).from = $917f49679f7aef27$export$4266177d9730bb1;\n\n});\nparcelRegister(\"gYSnF\", function(module, exports) {\n\n$parcel$export(module.exports, \"Cache\", () => $d254af94afe44123$export$94affb487e701bf2);\n\nvar $8CF4q = parcelRequire(\"8CF4q\");\n\nvar $lbclP = parcelRequire(\"lbclP\");\n\"use strict\";\nclass $d254af94afe44123$var$CacheClass {\n    constructor(){\n        this._parsers = [];\n        this._cache = /* @__PURE__ */ new Map();\n        this._cacheMap = /* @__PURE__ */ new Map();\n    }\n    /** Clear all entries. */ reset() {\n        this._cacheMap.clear();\n        this._cache.clear();\n    }\n    /**\n   * Check if the key exists\n   * @param key - The key to check\n   */ has(key) {\n        return this._cache.has(key);\n    }\n    /**\n   * Fetch entry by key\n   * @param key - The key of the entry to get\n   */ get(key) {\n        const result = this._cache.get(key);\n        if (!result) (0, $8CF4q.warn)(`[Assets] Asset id ${key} was not found in the Cache`);\n        return result;\n    }\n    /**\n   * Set a value by key or keys name\n   * @param key - The key or keys to set\n   * @param value - The value to store in the cache or from which cacheable assets will be derived.\n   */ set(key, value) {\n        const keys = (0, $lbclP.convertToList)(key);\n        let cacheableAssets;\n        for(let i = 0; i < this.parsers.length; i++){\n            const parser = this.parsers[i];\n            if (parser.test(value)) {\n                cacheableAssets = parser.getCacheableAssets(keys, value);\n                break;\n            }\n        }\n        const cacheableMap = new Map(Object.entries(cacheableAssets || {}));\n        if (!cacheableAssets) keys.forEach((key2)=>{\n            cacheableMap.set(key2, value);\n        });\n        const cacheKeys = [\n            ...cacheableMap.keys()\n        ];\n        const cachedAssets = {\n            cacheKeys: cacheKeys,\n            keys: keys\n        };\n        keys.forEach((key2)=>{\n            this._cacheMap.set(key2, cachedAssets);\n        });\n        cacheKeys.forEach((key2)=>{\n            const val = cacheableAssets ? cacheableAssets[key2] : value;\n            if (this._cache.has(key2) && this._cache.get(key2) !== val) (0, $8CF4q.warn)(\"[Cache] already has key:\", key2);\n            this._cache.set(key2, cacheableMap.get(key2));\n        });\n    }\n    /**\n   * Remove entry by key\n   *\n   * This function will also remove any associated alias from the cache also.\n   * @param key - The key of the entry to remove\n   */ remove(key) {\n        if (!this._cacheMap.has(key)) {\n            (0, $8CF4q.warn)(`[Assets] Asset id ${key} was not found in the Cache`);\n            return;\n        }\n        const cacheMap = this._cacheMap.get(key);\n        const cacheKeys = cacheMap.cacheKeys;\n        cacheKeys.forEach((key2)=>{\n            this._cache.delete(key2);\n        });\n        cacheMap.keys.forEach((key2)=>{\n            this._cacheMap.delete(key2);\n        });\n    }\n    /** All loader parsers registered */ get parsers() {\n        return this._parsers;\n    }\n}\nconst $d254af94afe44123$export$94affb487e701bf2 = new $d254af94afe44123$var$CacheClass();\n\n});\n\n\n\nparcelRegister(\"aX86R\", function(module, exports) {\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $bBCDe = parcelRequire(\"bBCDe\");\n\nvar $g4d6y = parcelRequire(\"g4d6y\");\n\"use strict\";\n(0, $eVz1R.extensions).add((0, $g4d6y.GraphicsPipe));\n(0, $eVz1R.extensions).add((0, $bBCDe.GraphicsContextSystem));\n\n});\nparcelRegister(\"bBCDe\", function(module, exports) {\n\n$parcel$export(module.exports, \"GraphicsContextSystem\", () => $5cda66bda9bb03b4$export$f2f3ca33e4c65172);\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $h1qkv = parcelRequire(\"h1qkv\");\n\nvar $9q6W4 = parcelRequire(\"9q6W4\");\n\nvar $gC5Pa = parcelRequire(\"gC5Pa\");\n\nvar $vdXhX = parcelRequire(\"vdXhX\");\n\nvar $e98Fy = parcelRequire(\"e98Fy\");\n\nvar $03aVk = parcelRequire(\"03aVk\");\n\"use strict\";\nclass $5cda66bda9bb03b4$export$e3e348c254036d55 {\n    constructor(){\n        this.batches = [];\n        this.geometryData = {\n            vertices: [],\n            uvs: [],\n            indices: []\n        };\n    }\n}\nclass $5cda66bda9bb03b4$export$9b6a6c5b37fc8f49 {\n    constructor(){\n        this.geometry = new (0, $h1qkv.BatchGeometry)();\n        this.instructions = new (0, $vdXhX.InstructionSet)();\n    }\n    init() {\n        this.instructions.reset();\n    }\n}\nconst $5cda66bda9bb03b4$var$_GraphicsContextSystem = class _GraphicsContextSystem {\n    constructor(){\n        // the root context batches, used to either make a batch or geometry\n        // all graphics use this as a base\n        this._activeBatchers = [];\n        this._gpuContextHash = {};\n        // used for non-batchable graphics\n        this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null);\n        this._needsContextNeedsRebuild = [];\n    }\n    /**\n   * Runner init called, update the default options\n   * @ignore\n   */ init(options) {\n        _GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness ?? _GraphicsContextSystem.defaultOptions.bezierSmoothness;\n    }\n    prerender() {\n        this._returnActiveBatchers();\n    }\n    getContextRenderData(context) {\n        return this._graphicsDataContextHash[context.uid] || this._initContextRenderData(context);\n    }\n    // Context management functions\n    updateGpuContext(context) {\n        let gpuContext = this._gpuContextHash[context.uid] || this._initContext(context);\n        if (context.dirty) {\n            if (gpuContext) this._cleanGraphicsContextData(context);\n            else gpuContext = this._initContext(context);\n            (0, $03aVk.buildContextBatches)(context, gpuContext);\n            const batchMode = context.batchMode;\n            if (context.customShader || batchMode === \"no-batch\") gpuContext.isBatchable = false;\n            else if (batchMode === \"auto\") gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;\n            context.dirty = false;\n        }\n        return gpuContext;\n    }\n    getGpuContext(context) {\n        return this._gpuContextHash[context.uid] || this._initContext(context);\n    }\n    _returnActiveBatchers() {\n        for(let i = 0; i < this._activeBatchers.length; i++)(0, $e98Fy.BigPool).return(this._activeBatchers[i]);\n        this._activeBatchers.length = 0;\n    }\n    _initContextRenderData(context) {\n        const graphicsData = (0, $e98Fy.BigPool).get($5cda66bda9bb03b4$export$9b6a6c5b37fc8f49);\n        const { batches: batches, geometryData: geometryData } = this._gpuContextHash[context.uid];\n        const vertexSize = geometryData.vertices.length;\n        const indexSize = geometryData.indices.length;\n        for(let i = 0; i < batches.length; i++)batches[i].applyTransform = false;\n        const batcher = (0, $e98Fy.BigPool).get((0, $gC5Pa.Batcher));\n        this._activeBatchers.push(batcher);\n        batcher.ensureAttributeBuffer(vertexSize);\n        batcher.ensureIndexBuffer(indexSize);\n        batcher.begin();\n        for(let i = 0; i < batches.length; i++){\n            const batch = batches[i];\n            batcher.add(batch);\n        }\n        batcher.finish(graphicsData.instructions);\n        const geometry = graphicsData.geometry;\n        geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);\n        geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);\n        const drawBatches = batcher.batches;\n        for(let i = 0; i < drawBatches.length; i++){\n            const batch = drawBatches[i];\n            batch.bindGroup = (0, $9q6W4.getTextureBatchBindGroup)(batch.textures.textures, batch.textures.count);\n        }\n        this._graphicsDataContextHash[context.uid] = graphicsData;\n        return graphicsData;\n    }\n    _initContext(context) {\n        const gpuContext = new $5cda66bda9bb03b4$export$e3e348c254036d55();\n        this._gpuContextHash[context.uid] = gpuContext;\n        context.on(\"update\", this.onGraphicsContextUpdate, this);\n        context.on(\"destroy\", this.onGraphicsContextDestroy, this);\n        return this._gpuContextHash[context.uid];\n    }\n    onGraphicsContextUpdate(context) {\n        this._needsContextNeedsRebuild.push(context);\n    }\n    onGraphicsContextDestroy(context) {\n        this._cleanGraphicsContextData(context);\n        context.off(\"update\", this.onGraphicsContextUpdate, this);\n        context.off(\"destroy\", this.onGraphicsContextDestroy, this);\n        this._gpuContextHash[context.uid] = null;\n    }\n    _cleanGraphicsContextData(context) {\n        const gpuContext = this._gpuContextHash[context.uid];\n        if (!gpuContext.isBatchable) {\n            if (this._graphicsDataContextHash[context.uid]) {\n                (0, $e98Fy.BigPool).return(this.getContextRenderData(context));\n                this._graphicsDataContextHash[context.uid] = null;\n            }\n        }\n        if (gpuContext.batches) gpuContext.batches.forEach((batch)=>{\n            (0, $e98Fy.BigPool).return(batch);\n        });\n    }\n    destroy() {\n        for (const context of this._needsContextNeedsRebuild)if (this._gpuContextHash[context.uid]) this.onGraphicsContextDestroy(context);\n        this._needsContextNeedsRebuild.length = 0;\n    }\n};\n/** @ignore */ $5cda66bda9bb03b4$var$_GraphicsContextSystem.extension = {\n    type: [\n        (0, $eVz1R.ExtensionType).WebGLSystem,\n        (0, $eVz1R.ExtensionType).WebGPUSystem,\n        (0, $eVz1R.ExtensionType).CanvasSystem\n    ],\n    name: \"graphicsContext\"\n};\n/** The default options for the GraphicsContextSystem. */ $5cda66bda9bb03b4$var$_GraphicsContextSystem.defaultOptions = {\n    /**\n   * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n   * @default 0.5\n   */ bezierSmoothness: 0.5\n};\nlet $5cda66bda9bb03b4$export$f2f3ca33e4c65172 = $5cda66bda9bb03b4$var$_GraphicsContextSystem;\n\n});\nparcelRegister(\"03aVk\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildContextBatches\", () => $d3159e79409670b7$export$e3c00f31a053d231);\n\nvar $soqVu = parcelRequire(\"soqVu\");\n\nvar $cvBir = parcelRequire(\"cvBir\");\n\nvar $5Mobi = parcelRequire(\"5Mobi\");\n\nvar $5h88T = parcelRequire(\"5h88T\");\n\nvar $e98Fy = parcelRequire(\"e98Fy\");\n\nvar $7bQyz = parcelRequire(\"7bQyz\");\n\nvar $lkR0B = parcelRequire(\"lkR0B\");\n\nvar $dspZV = parcelRequire(\"dspZV\");\n\nvar $6AePw = parcelRequire(\"6AePw\");\n\nvar $3P3MX = parcelRequire(\"3P3MX\");\n\nvar $5gUNA = parcelRequire(\"5gUNA\");\n\nvar $7KshX = parcelRequire(\"7KshX\");\n\"use strict\";\nconst $d3159e79409670b7$var$buildMap = {\n    rectangle: (0, $3P3MX.buildRectangle),\n    polygon: (0, $6AePw.buildPolygon),\n    triangle: (0, $5gUNA.buildTriangle),\n    circle: (0, $lkR0B.buildCircle),\n    ellipse: (0, $lkR0B.buildCircle),\n    roundedRectangle: (0, $lkR0B.buildCircle)\n};\nconst $d3159e79409670b7$var$tempRect = new (0, $soqVu.Rectangle)();\nfunction $d3159e79409670b7$export$e3c00f31a053d231(context, gpuContext) {\n    const { geometryData: geometryData, batches: batches } = gpuContext;\n    batches.length = 0;\n    geometryData.indices.length = 0;\n    geometryData.vertices.length = 0;\n    geometryData.uvs.length = 0;\n    for(let i = 0; i < context.instructions.length; i++){\n        const instruction = context.instructions[i];\n        if (instruction.action === \"texture\") $d3159e79409670b7$var$addTextureToGeometryData(instruction.data, batches, geometryData);\n        else if (instruction.action === \"fill\" || instruction.action === \"stroke\") {\n            const isStroke = instruction.action === \"stroke\";\n            const shapePath = instruction.data.path.shapePath;\n            const style = instruction.data.style;\n            const hole = instruction.data.hole;\n            if (isStroke && hole) $d3159e79409670b7$var$addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);\n            $d3159e79409670b7$var$addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);\n        }\n    }\n}\nfunction $d3159e79409670b7$var$addTextureToGeometryData(data, batches, geometryData) {\n    const { vertices: vertices, uvs: uvs, indices: indices } = geometryData;\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n    const points = [];\n    const build = $d3159e79409670b7$var$buildMap.rectangle;\n    const rect = $d3159e79409670b7$var$tempRect;\n    const texture = data.image;\n    rect.x = data.dx;\n    rect.y = data.dy;\n    rect.width = data.dw;\n    rect.height = data.dh;\n    const matrix = data.transform;\n    build.build(rect, points);\n    if (matrix) (0, $5Mobi.transformVertices)(points, matrix);\n    build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n    const textureUvs = texture.uvs;\n    uvs.push(textureUvs.x0, textureUvs.y0, textureUvs.x1, textureUvs.y1, textureUvs.x3, textureUvs.y3, textureUvs.x2, textureUvs.y2);\n    const graphicsBatch = (0, $e98Fy.BigPool).get((0, $7bQyz.BatchableGraphics));\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n    graphicsBatch.vertexOffset = vertOffset;\n    graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;\n    graphicsBatch.color = data.style;\n    graphicsBatch.alpha = data.alpha;\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n    batches.push(graphicsBatch);\n}\nfunction $d3159e79409670b7$var$addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData) {\n    const { vertices: vertices, uvs: uvs, indices: indices } = geometryData;\n    const lastIndex = shapePath.shapePrimitives.length - 1;\n    shapePath.shapePrimitives.forEach(({ shape: shape, transform: matrix }, i)=>{\n        const indexOffset = indices.length;\n        const vertOffset = vertices.length / 2;\n        const points = [];\n        const build = $d3159e79409670b7$var$buildMap[shape.type];\n        build.build(shape, points);\n        if (matrix) (0, $5Mobi.transformVertices)(points, matrix);\n        if (!isStroke) {\n            if (hole && lastIndex === i) {\n                if (lastIndex !== 0) console.warn(\"[Pixi Graphics] only the last shape have be cut out\");\n                const holeIndices = [];\n                const otherPoints = points.slice();\n                const holeArrays = $d3159e79409670b7$var$getHoleArrays(hole.shapePath);\n                holeArrays.forEach((holePoints)=>{\n                    holeIndices.push(otherPoints.length / 2);\n                    otherPoints.push(...holePoints);\n                });\n                (0, $7KshX.triangulateWithHoles)(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n            } else build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n        } else {\n            const close = shape.closePath ?? true;\n            const lineStyle = style;\n            (0, $dspZV.buildLine)(points, lineStyle, false, close, vertices, 2, vertOffset, indices, indexOffset);\n        }\n        const uvsOffset = uvs.length / 2;\n        const texture = style.texture;\n        if (texture !== (0, $5h88T.Texture).WHITE) {\n            const textureMatrix = style.matrix;\n            if (matrix) textureMatrix.append(matrix.clone().invert());\n            (0, $cvBir.buildUvs)(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);\n        } else (0, $cvBir.buildSimpleUvs)(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);\n        const graphicsBatch = (0, $e98Fy.BigPool).get((0, $7bQyz.BatchableGraphics));\n        graphicsBatch.indexOffset = indexOffset;\n        graphicsBatch.indexSize = indices.length - indexOffset;\n        graphicsBatch.vertexOffset = vertOffset;\n        graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;\n        graphicsBatch.color = style.color;\n        graphicsBatch.alpha = style.alpha;\n        graphicsBatch.texture = texture;\n        graphicsBatch.geometryData = geometryData;\n        batches.push(graphicsBatch);\n    });\n}\nfunction $d3159e79409670b7$var$getHoleArrays(shape) {\n    if (!shape) return [];\n    const holePrimitives = shape.shapePrimitives;\n    const holeArrays = [];\n    for(let k = 0; k < holePrimitives.length; k++){\n        const holePrimitive = holePrimitives[k].shape;\n        const holePoints = [];\n        const holeBuilder = $d3159e79409670b7$var$buildMap[holePrimitive.type];\n        holeBuilder.build(holePrimitive, holePoints);\n        holeArrays.push(holePoints);\n    }\n    return holeArrays;\n}\n\n});\nparcelRegister(\"cvBir\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildUvs\", () => $eadc1079aec88a51$export$2027711a0ff70dc2);\n$parcel$export(module.exports, \"buildSimpleUvs\", () => $eadc1079aec88a51$export$580e3d8462b9fe52);\n\"use strict\";\nfunction $eadc1079aec88a51$export$2027711a0ff70dc2(vertices, verticesStride, verticesOffset, uvs, uvsOffset, uvsStride, size, matrix = null) {\n    let index = 0;\n    verticesOffset *= verticesStride;\n    uvsOffset *= uvsStride;\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    while(index < size){\n        const x = vertices[verticesOffset];\n        const y = vertices[verticesOffset + 1];\n        uvs[uvsOffset] = a * x + c * y + tx;\n        uvs[uvsOffset + 1] = b * x + d * y + ty;\n        uvsOffset += uvsStride;\n        verticesOffset += verticesStride;\n        index++;\n    }\n}\nfunction $eadc1079aec88a51$export$580e3d8462b9fe52(uvs, uvsOffset, uvsStride, size) {\n    let index = 0;\n    uvsOffset *= uvsStride;\n    while(index < size){\n        uvs[uvsOffset] = 0;\n        uvs[uvsOffset + 1] = 0;\n        uvsOffset += uvsStride;\n        index++;\n    }\n}\n\n});\n\nparcelRegister(\"5Mobi\", function(module, exports) {\n\n$parcel$export(module.exports, \"transformVertices\", () => $8e0648d3b196e6db$export$cbe36b8a8d6e3d3);\n\"use strict\";\nfunction $8e0648d3b196e6db$export$cbe36b8a8d6e3d3(vertices, m, offset, stride, size) {\n    const a = m.a;\n    const b = m.b;\n    const c = m.c;\n    const d = m.d;\n    const tx = m.tx;\n    const ty = m.ty;\n    offset = offset || 0;\n    stride = stride || 2;\n    size = size || vertices.length / stride - offset;\n    let index = offset * stride;\n    for(let i = 0; i < size; i++){\n        const x = vertices[index];\n        const y = vertices[index + 1];\n        vertices[index] = a * x + c * y + tx;\n        vertices[index + 1] = b * x + d * y + ty;\n        index += stride;\n    }\n}\n\n});\n\nparcelRegister(\"7bQyz\", function(module, exports) {\n\n$parcel$export(module.exports, \"BatchableGraphics\", () => $fe2f0279269cf065$export$91d2a08bbf21546b);\n\nvar $bLQN7 = parcelRequire(\"bLQN7\");\n\"use strict\";\nclass $fe2f0279269cf065$export$91d2a08bbf21546b {\n    constructor(){\n        this.batcher = null;\n        this.batch = null;\n        this.applyTransform = true;\n        this.roundPixels = 0;\n    }\n    get blendMode() {\n        if (this.applyTransform) return this.renderable.groupBlendMode;\n        return \"normal\";\n    }\n    packIndex(indexBuffer, index, indicesOffset) {\n        const indices = this.geometryData.indices;\n        for(let i = 0; i < this.indexSize; i++)indexBuffer[index++] = indices[i + this.indexOffset] + indicesOffset - this.vertexOffset;\n    }\n    packAttributes(float32View, uint32View, index, textureId) {\n        const geometry = this.geometryData;\n        const graphics = this.renderable;\n        const positions = geometry.vertices;\n        const uvs = geometry.uvs;\n        const offset = this.vertexOffset * 2;\n        const vertSize = (this.vertexOffset + this.vertexSize) * 2;\n        const rgb = this.color;\n        const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;\n        if (this.applyTransform) {\n            const argb = (0, $bLQN7.mixColors)(bgr, graphics.groupColor) + (this.alpha * graphics.groupAlpha * 255 << 24);\n            const wt = graphics.groupTransform;\n            const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;\n            const a = wt.a;\n            const b = wt.b;\n            const c = wt.c;\n            const d = wt.d;\n            const tx = wt.tx;\n            const ty = wt.ty;\n            for(let i = offset; i < vertSize; i += 2){\n                const x = positions[i];\n                const y = positions[i + 1];\n                float32View[index] = a * x + c * y + tx;\n                float32View[index + 1] = b * x + d * y + ty;\n                float32View[index + 2] = uvs[i];\n                float32View[index + 3] = uvs[i + 1];\n                uint32View[index + 4] = argb;\n                uint32View[index + 5] = textureIdAndRound;\n                index += 6;\n            }\n        } else {\n            const argb = bgr + (this.alpha * 255 << 24);\n            for(let i = offset; i < vertSize; i += 2){\n                float32View[index] = positions[i];\n                float32View[index + 1] = positions[i + 1];\n                float32View[index + 2] = uvs[i];\n                float32View[index + 3] = uvs[i + 1];\n                uint32View[index + 4] = argb;\n                uint32View[index + 5] = textureId << 16;\n                index += 6;\n            }\n        }\n    }\n    // TODO rename to vertexSize\n    get vertSize() {\n        return this.vertexSize;\n    }\n    copyTo(gpuBuffer) {\n        gpuBuffer.indexOffset = this.indexOffset;\n        gpuBuffer.indexSize = this.indexSize;\n        gpuBuffer.vertexOffset = this.vertexOffset;\n        gpuBuffer.vertexSize = this.vertexSize;\n        gpuBuffer.color = this.color;\n        gpuBuffer.alpha = this.alpha;\n        gpuBuffer.texture = this.texture;\n        gpuBuffer.geometryData = this.geometryData;\n    }\n    reset() {\n        this.applyTransform = true;\n    }\n}\n\n});\n\nparcelRegister(\"lkR0B\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildCircle\", () => $08464aef58e30e75$export$a3541b2d8ecbfcf2);\n\"use strict\";\nconst $08464aef58e30e75$export$a3541b2d8ecbfcf2 = {\n    build (shape, points) {\n        let x;\n        let y;\n        let dx;\n        let dy;\n        let rx;\n        let ry;\n        if (shape.type === \"circle\") {\n            const circle = shape;\n            x = circle.x;\n            y = circle.y;\n            rx = ry = circle.radius;\n            dx = dy = 0;\n        } else if (shape.type === \"ellipse\") {\n            const ellipse = shape;\n            x = ellipse.x;\n            y = ellipse.y;\n            rx = ellipse.halfWidth;\n            ry = ellipse.halfHeight;\n            dx = dy = 0;\n        } else {\n            const roundedRect = shape;\n            const halfWidth = roundedRect.width / 2;\n            const halfHeight = roundedRect.height / 2;\n            x = roundedRect.x + halfWidth;\n            y = roundedRect.y + halfHeight;\n            rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n            dx = halfWidth - rx;\n            dy = halfHeight - ry;\n        }\n        if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) return points;\n        const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n        const m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);\n        if (m === 0) return points;\n        if (n === 0) {\n            points[0] = points[6] = x + dx;\n            points[1] = points[3] = y + dy;\n            points[2] = points[4] = x - dx;\n            points[5] = points[7] = y - dy;\n            return points;\n        }\n        let j1 = 0;\n        let j2 = n * 4 + (dx ? 2 : 0) + 2;\n        let j3 = j2;\n        let j4 = m;\n        let x0 = dx + rx;\n        let y0 = dy;\n        let x1 = x + x0;\n        let x2 = x - x0;\n        let y1 = y + y0;\n        points[j1++] = x1;\n        points[j1++] = y1;\n        points[--j2] = y1;\n        points[--j2] = x2;\n        if (dy) {\n            const y22 = y - y0;\n            points[j3++] = x2;\n            points[j3++] = y22;\n            points[--j4] = y22;\n            points[--j4] = x1;\n        }\n        for(let i = 1; i < n; i++){\n            const a = Math.PI / 2 * (i / n);\n            const x02 = dx + Math.cos(a) * rx;\n            const y02 = dy + Math.sin(a) * ry;\n            const x12 = x + x02;\n            const x22 = x - x02;\n            const y12 = y + y02;\n            const y22 = y - y02;\n            points[j1++] = x12;\n            points[j1++] = y12;\n            points[--j2] = y12;\n            points[--j2] = x22;\n            points[j3++] = x22;\n            points[j3++] = y22;\n            points[--j4] = y22;\n            points[--j4] = x12;\n        }\n        x0 = dx;\n        y0 = dy + ry;\n        x1 = x + x0;\n        x2 = x - x0;\n        y1 = y + y0;\n        const y2 = y - y0;\n        points[j1++] = x1;\n        points[j1++] = y1;\n        points[--j4] = y2;\n        points[--j4] = x1;\n        if (dx) {\n            points[j1++] = x2;\n            points[j1++] = y1;\n            points[--j4] = y2;\n            points[--j4] = x2;\n        }\n        return points;\n    },\n    triangulate (points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n        if (points.length === 0) return;\n        let centerX = 0;\n        let centerY = 0;\n        for(let i = 0; i < points.length; i += 2){\n            centerX += points[i];\n            centerY += points[i + 1];\n        }\n        centerX /= points.length / 2;\n        centerY /= points.length / 2;\n        let count = verticesOffset;\n        vertices[count * verticesStride] = centerX;\n        vertices[count * verticesStride + 1] = centerY;\n        const centerIndex = count++;\n        for(let i = 0; i < points.length; i += 2){\n            vertices[count * verticesStride] = points[i];\n            vertices[count * verticesStride + 1] = points[i + 1];\n            if (i > 0) {\n                indices[indicesOffset++] = count;\n                indices[indicesOffset++] = centerIndex;\n                indices[indicesOffset++] = count - 1;\n            }\n            count++;\n        }\n        indices[indicesOffset++] = centerIndex + 1;\n        indices[indicesOffset++] = centerIndex;\n        indices[indicesOffset++] = count - 1;\n    }\n};\n\n});\n\nparcelRegister(\"dspZV\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildLine\", () => $f4ab86a5c05caa8e$export$45986ccf08e93b0b);\n\nvar $2NXni = parcelRequire(\"2NXni\");\n\nvar $3LOun = parcelRequire(\"3LOun\");\n\nvar $4G5QW = parcelRequire(\"4G5QW\");\n\"use strict\";\nfunction $f4ab86a5c05caa8e$var$square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {\n    const ix = x - nx * innerWeight;\n    const iy = y - ny * innerWeight;\n    const ox = x + nx * outerWeight;\n    const oy = y + ny * outerWeight;\n    let exx;\n    let eyy;\n    if (clockwise) {\n        exx = ny;\n        eyy = -nx;\n    } else {\n        exx = -ny;\n        eyy = nx;\n    }\n    const eix = ix + exx;\n    const eiy = iy + eyy;\n    const eox = ox + exx;\n    const eoy = oy + eyy;\n    verts.push(eix, eiy);\n    verts.push(eox, eoy);\n    return 2;\n}\nfunction $f4ab86a5c05caa8e$var$round(cx, cy, sx, sy, ex, ey, verts, clockwise) {\n    const cx2p0x = sx - cx;\n    const cy2p0y = sy - cy;\n    let angle0 = Math.atan2(cx2p0x, cy2p0y);\n    let angle1 = Math.atan2(ex - cx, ey - cy);\n    if (clockwise && angle0 < angle1) angle0 += Math.PI * 2;\n    else if (!clockwise && angle0 > angle1) angle1 += Math.PI * 2;\n    let startAngle = angle0;\n    const angleDiff = angle1 - angle0;\n    const absAngleDiff = Math.abs(angleDiff);\n    const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);\n    const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;\n    const angleInc = angleDiff / segCount;\n    startAngle += angleInc;\n    if (clockwise) {\n        verts.push(cx, cy);\n        verts.push(sx, sy);\n        for(let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc){\n            verts.push(cx, cy);\n            verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);\n        }\n        verts.push(cx, cy);\n        verts.push(ex, ey);\n    } else {\n        verts.push(sx, sy);\n        verts.push(cx, cy);\n        for(let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc){\n            verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);\n            verts.push(cx, cy);\n        }\n        verts.push(ex, ey);\n        verts.push(cx, cy);\n    }\n    return segCount * 2;\n}\nfunction $f4ab86a5c05caa8e$export$45986ccf08e93b0b(points, lineStyle, flipAlignment, closed, vertices, _verticesStride, _verticesOffset, indices, _indicesOffset) {\n    const eps = (0, $3LOun.closePointEps);\n    if (points.length === 0) return;\n    const style = lineStyle;\n    let alignment = style.alignment;\n    if (lineStyle.alignment !== 0.5) {\n        let orientation = (0, $4G5QW.getOrientationOfPoints)(points);\n        if (flipAlignment) orientation *= -1;\n        alignment = (alignment - 0.5) * orientation + 0.5;\n    }\n    const firstPoint = new (0, $2NXni.Point)(points[0], points[1]);\n    const lastPoint = new (0, $2NXni.Point)(points[points.length - 2], points[points.length - 1]);\n    const closedShape = closed;\n    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;\n    if (closedShape) {\n        points = points.slice();\n        if (closedPath) {\n            points.pop();\n            points.pop();\n            lastPoint.set(points[points.length - 2], points[points.length - 1]);\n        }\n        const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n        const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n    const verts = vertices;\n    const length = points.length / 2;\n    let indexCount = points.length;\n    const indexStart = verts.length / 2;\n    const width = style.width / 2;\n    const widthSquared = width * width;\n    const miterLimitSquared = style.miterLimit * style.miterLimit;\n    let x0 = points[0];\n    let y0 = points[1];\n    let x1 = points[2];\n    let y1 = points[3];\n    let x2 = 0;\n    let y2 = 0;\n    let perpX = -(y0 - y1);\n    let perpY = x0 - x1;\n    let perp1x = 0;\n    let perp1y = 0;\n    let dist = Math.sqrt(perpX * perpX + perpY * perpY);\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n    const ratio = alignment;\n    const innerWeight = (1 - ratio) * 2;\n    const outerWeight = ratio * 2;\n    if (!closedShape) {\n        if (style.cap === \"round\") indexCount += $f4ab86a5c05caa8e$var$round(x0 - perpX * (innerWeight - outerWeight) * 0.5, y0 - perpY * (innerWeight - outerWeight) * 0.5, x0 - perpX * innerWeight, y0 - perpY * innerWeight, x0 + perpX * outerWeight, y0 + perpY * outerWeight, verts, true) + 2;\n        else if (style.cap === \"square\") indexCount += $f4ab86a5c05caa8e$var$square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);\n    }\n    verts.push(x0 - perpX * innerWeight, y0 - perpY * innerWeight);\n    verts.push(x0 + perpX * outerWeight, y0 + perpY * outerWeight);\n    for(let i = 1; i < length - 1; ++i){\n        x0 = points[(i - 1) * 2];\n        y0 = points[(i - 1) * 2 + 1];\n        x1 = points[i * 2];\n        y1 = points[i * 2 + 1];\n        x2 = points[(i + 1) * 2];\n        y2 = points[(i + 1) * 2 + 1];\n        perpX = -(y0 - y1);\n        perpY = x0 - x1;\n        dist = Math.sqrt(perpX * perpX + perpY * perpY);\n        perpX /= dist;\n        perpY /= dist;\n        perpX *= width;\n        perpY *= width;\n        perp1x = -(y1 - y2);\n        perp1y = x1 - x2;\n        dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);\n        perp1x /= dist;\n        perp1y /= dist;\n        perp1x *= width;\n        perp1y *= width;\n        const dx0 = x1 - x0;\n        const dy0 = y0 - y1;\n        const dx1 = x1 - x2;\n        const dy1 = y2 - y1;\n        const dot = dx0 * dx1 + dy0 * dy1;\n        const cross = dy0 * dx1 - dy1 * dx0;\n        const clockwise = cross < 0;\n        if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {\n            verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n            verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n            if (dot >= 0) {\n                if (style.join === \"round\") indexCount += $f4ab86a5c05caa8e$var$round(x1, y1, x1 - perpX * innerWeight, y1 - perpY * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;\n                else indexCount += 2;\n                verts.push(x1 - perp1x * outerWeight, y1 - perp1y * outerWeight);\n                verts.push(x1 + perp1x * innerWeight, y1 + perp1y * innerWeight);\n            }\n            continue;\n        }\n        const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);\n        const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);\n        const px = (dx0 * c2 - dx1 * c1) / cross;\n        const py = (dy1 * c1 - dy0 * c2) / cross;\n        const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);\n        const imx = x1 + (px - x1) * innerWeight;\n        const imy = y1 + (py - y1) * innerWeight;\n        const omx = x1 - (px - x1) * outerWeight;\n        const omy = y1 - (py - y1) * outerWeight;\n        const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);\n        const insideWeight = clockwise ? innerWeight : outerWeight;\n        const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;\n        const insideMiterOk = pDist <= smallerInsideDiagonalSq;\n        if (insideMiterOk) {\n            if (style.join === \"bevel\" || pDist / widthSquared > miterLimitSquared) {\n                if (clockwise) {\n                    verts.push(imx, imy);\n                    verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n                    verts.push(imx, imy);\n                    verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n                } else {\n                    verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n                    verts.push(omx, omy);\n                    verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n                    verts.push(omx, omy);\n                }\n                indexCount += 2;\n            } else if (style.join === \"round\") {\n                if (clockwise) {\n                    verts.push(imx, imy);\n                    verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n                    indexCount += $f4ab86a5c05caa8e$var$round(x1, y1, x1 + perpX * outerWeight, y1 + perpY * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;\n                    verts.push(imx, imy);\n                    verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n                } else {\n                    verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n                    verts.push(omx, omy);\n                    indexCount += $f4ab86a5c05caa8e$var$round(x1, y1, x1 - perpX * innerWeight, y1 - perpY * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;\n                    verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n                    verts.push(omx, omy);\n                }\n            } else {\n                verts.push(imx, imy);\n                verts.push(omx, omy);\n            }\n        } else {\n            verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n            verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n            if (style.join === \"round\") {\n                if (clockwise) indexCount += $f4ab86a5c05caa8e$var$round(x1, y1, x1 + perpX * outerWeight, y1 + perpY * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;\n                else indexCount += $f4ab86a5c05caa8e$var$round(x1, y1, x1 - perpX * innerWeight, y1 - perpY * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;\n            } else if (style.join === \"miter\" && pDist / widthSquared <= miterLimitSquared) {\n                if (clockwise) {\n                    verts.push(omx, omy);\n                    verts.push(omx, omy);\n                } else {\n                    verts.push(imx, imy);\n                    verts.push(imx, imy);\n                }\n                indexCount += 2;\n            }\n            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n            indexCount += 2;\n        }\n    }\n    x0 = points[(length - 2) * 2];\n    y0 = points[(length - 2) * 2 + 1];\n    x1 = points[(length - 1) * 2];\n    y1 = points[(length - 1) * 2 + 1];\n    perpX = -(y0 - y1);\n    perpY = x0 - x1;\n    dist = Math.sqrt(perpX * perpX + perpY * perpY);\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n    verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n    verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n    if (!closedShape) {\n        if (style.cap === \"round\") indexCount += $f4ab86a5c05caa8e$var$round(x1 - perpX * (innerWeight - outerWeight) * 0.5, y1 - perpY * (innerWeight - outerWeight) * 0.5, x1 - perpX * innerWeight, y1 - perpY * innerWeight, x1 + perpX * outerWeight, y1 + perpY * outerWeight, verts, false) + 2;\n        else if (style.cap === \"square\") indexCount += $f4ab86a5c05caa8e$var$square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);\n    }\n    const eps2 = (0, $3LOun.curveEps) * (0, $3LOun.curveEps);\n    for(let i = indexStart; i < indexCount + indexStart - 2; ++i){\n        x0 = verts[i * 2];\n        y0 = verts[i * 2 + 1];\n        x1 = verts[(i + 1) * 2];\n        y1 = verts[(i + 1) * 2 + 1];\n        x2 = verts[(i + 2) * 2];\n        y2 = verts[(i + 2) * 2 + 1];\n        if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) continue;\n        indices.push(i, i + 1, i + 2);\n    }\n}\n\n});\nparcelRegister(\"3LOun\", function(module, exports) {\n\n$parcel$export(module.exports, \"closePointEps\", () => $14339eff216787b9$export$7159a7c43f12984);\n$parcel$export(module.exports, \"curveEps\", () => $14339eff216787b9$export$51a946149243709);\n\"use strict\";\nconst $14339eff216787b9$export$7159a7c43f12984 = 1e-4;\nconst $14339eff216787b9$export$51a946149243709 = 1e-4;\n\n});\n\nparcelRegister(\"4G5QW\", function(module, exports) {\n\n$parcel$export(module.exports, \"getOrientationOfPoints\", () => $954666132023b6df$export$38856eae80d480e1);\n\"use strict\";\nfunction $954666132023b6df$export$38856eae80d480e1(points) {\n    const m = points.length;\n    if (m < 6) return 1;\n    let area = 0;\n    for(let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2){\n        const x2 = points[i];\n        const y2 = points[i + 1];\n        area += (x2 - x1) * (y2 + y1);\n        x1 = x2;\n        y1 = y2;\n    }\n    if (area < 0) return -1;\n    return 1;\n}\n\n});\n\n\nparcelRegister(\"6AePw\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildPolygon\", () => $5ca58799171465f2$export$4c2d12f7b210f357);\n\nvar $7KshX = parcelRequire(\"7KshX\");\n\"use strict\";\nconst $5ca58799171465f2$var$emptyArray = [];\nconst $5ca58799171465f2$export$4c2d12f7b210f357 = {\n    build (shape, points) {\n        for(let i = 0; i < shape.points.length; i++)points[i] = shape.points[i];\n        return points;\n    },\n    triangulate (points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n        (0, $7KshX.triangulateWithHoles)(points, $5ca58799171465f2$var$emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);\n    }\n};\n\n});\nparcelRegister(\"7KshX\", function(module, exports) {\n\n$parcel$export(module.exports, \"triangulateWithHoles\", () => $83f5c12aa1c2b92a$export$5a241bf9c2c3d94b);\n\nvar $eH7tg = parcelRequire(\"eH7tg\");\n\"use strict\";\nfunction $83f5c12aa1c2b92a$export$5a241bf9c2c3d94b(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    const triangles = (0, (/*@__PURE__*/$parcel$interopDefault($eH7tg)))(points, holes, 2);\n    if (!triangles) return;\n    for(let i = 0; i < triangles.length; i += 3){\n        indices[indicesOffset++] = triangles[i] + verticesOffset;\n        indices[indicesOffset++] = triangles[i + 1] + verticesOffset;\n        indices[indicesOffset++] = triangles[i + 2] + verticesOffset;\n    }\n    let index = verticesOffset * verticesStride;\n    for(let i = 0; i < points.length; i += 2){\n        vertices[index] = points[i];\n        vertices[index + 1] = points[i + 1];\n        index += verticesStride;\n    }\n}\n\n});\nparcelRegister(\"eH7tg\", function(module, exports) {\n\"use strict\";\nmodule.exports = $ab2ae071cd7be4a4$var$earcut;\nmodule.exports.default = $ab2ae071cd7be4a4$var$earcut;\nfunction $ab2ae071cd7be4a4$var$earcut(data, holeIndices, dim) {\n    dim = dim || 2;\n    var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = $ab2ae071cd7be4a4$var$linkedList(data, 0, outerLen, dim, true), triangles = [];\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n    var minX, minY, maxX, maxY, x, y, invSize;\n    if (hasHoles) outerNode = $ab2ae071cd7be4a4$var$eliminateHoles(data, holeIndices, outerNode, dim);\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n        for(var i = dim; i < outerLen; i += dim){\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n    $ab2ae071cd7be4a4$var$earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n    return triangles;\n}\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction $ab2ae071cd7be4a4$var$linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n    if (clockwise === $ab2ae071cd7be4a4$var$signedArea(data, start, end, dim) > 0) for(i = start; i < end; i += dim)last = $ab2ae071cd7be4a4$var$insertNode(i, data[i], data[i + 1], last);\n    else for(i = end - dim; i >= start; i -= dim)last = $ab2ae071cd7be4a4$var$insertNode(i, data[i], data[i + 1], last);\n    if (last && $ab2ae071cd7be4a4$var$equals(last, last.next)) {\n        $ab2ae071cd7be4a4$var$removeNode(last);\n        last = last.next;\n    }\n    return last;\n}\n// eliminate colinear or duplicate points\nfunction $ab2ae071cd7be4a4$var$filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n    var p = start, again;\n    do {\n        again = false;\n        if (!p.steiner && ($ab2ae071cd7be4a4$var$equals(p, p.next) || $ab2ae071cd7be4a4$var$area(p.prev, p, p.next) === 0)) {\n            $ab2ae071cd7be4a4$var$removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n        } else p = p.next;\n    }while (again || p !== end);\n    return end;\n}\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction $ab2ae071cd7be4a4$var$earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) $ab2ae071cd7be4a4$var$indexCurve(ear, minX, minY, invSize);\n    var stop = ear, prev, next;\n    // iterate through ears, slicing them one by one\n    while(ear.prev !== ear.next){\n        prev = ear.prev;\n        next = ear.next;\n        if (invSize ? $ab2ae071cd7be4a4$var$isEarHashed(ear, minX, minY, invSize) : $ab2ae071cd7be4a4$var$isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim | 0);\n            triangles.push(ear.i / dim | 0);\n            triangles.push(next.i / dim | 0);\n            $ab2ae071cd7be4a4$var$removeNode(ear);\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n            continue;\n        }\n        ear = next;\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) $ab2ae071cd7be4a4$var$earcutLinked($ab2ae071cd7be4a4$var$filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n            else if (pass === 1) {\n                ear = $ab2ae071cd7be4a4$var$cureLocalIntersections($ab2ae071cd7be4a4$var$filterPoints(ear), triangles, dim);\n                $ab2ae071cd7be4a4$var$earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) $ab2ae071cd7be4a4$var$splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            break;\n        }\n    }\n}\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction $ab2ae071cd7be4a4$var$isEar(ear) {\n    var a = ear.prev, b = ear, c = ear.next;\n    if ($ab2ae071cd7be4a4$var$area(a, b, c) >= 0) return false; // reflex, can't be an ear\n    // now make sure we don't have other points inside the potential ear\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;\n    var p = c.next;\n    while(p !== a){\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && $ab2ae071cd7be4a4$var$pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && $ab2ae071cd7be4a4$var$area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n    return true;\n}\nfunction $ab2ae071cd7be4a4$var$isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev, b = ear, c = ear.next;\n    if ($ab2ae071cd7be4a4$var$area(a, b, c) >= 0) return false; // reflex, can't be an ear\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;\n    // z-order range for the current triangle bbox;\n    var minZ = $ab2ae071cd7be4a4$var$zOrder(x0, y0, minX, minY, invSize), maxZ = $ab2ae071cd7be4a4$var$zOrder(x1, y1, minX, minY, invSize);\n    var p = ear.prevZ, n = ear.nextZ;\n    // look for points inside the triangle in both directions\n    while(p && p.z >= minZ && n && n.z <= maxZ){\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && $ab2ae071cd7be4a4$var$pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && $ab2ae071cd7be4a4$var$area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && $ab2ae071cd7be4a4$var$pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && $ab2ae071cd7be4a4$var$area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n    // look for remaining points in decreasing z-order\n    while(p && p.z >= minZ){\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && $ab2ae071cd7be4a4$var$pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && $ab2ae071cd7be4a4$var$area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n    // look for remaining points in increasing z-order\n    while(n && n.z <= maxZ){\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && $ab2ae071cd7be4a4$var$pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && $ab2ae071cd7be4a4$var$area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n    return true;\n}\n// go through all polygon nodes and cure small local self-intersections\nfunction $ab2ae071cd7be4a4$var$cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev, b = p.next.next;\n        if (!$ab2ae071cd7be4a4$var$equals(a, b) && $ab2ae071cd7be4a4$var$intersects(a, p, p.next, b) && $ab2ae071cd7be4a4$var$locallyInside(a, b) && $ab2ae071cd7be4a4$var$locallyInside(b, a)) {\n            triangles.push(a.i / dim | 0);\n            triangles.push(p.i / dim | 0);\n            triangles.push(b.i / dim | 0);\n            // remove two nodes involved\n            $ab2ae071cd7be4a4$var$removeNode(p);\n            $ab2ae071cd7be4a4$var$removeNode(p.next);\n            p = start = b;\n        }\n        p = p.next;\n    }while (p !== start);\n    return $ab2ae071cd7be4a4$var$filterPoints(p);\n}\n// try splitting polygon into two and triangulate them independently\nfunction $ab2ae071cd7be4a4$var$splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while(b !== a.prev){\n            if (a.i !== b.i && $ab2ae071cd7be4a4$var$isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = $ab2ae071cd7be4a4$var$splitPolygon(a, b);\n                // filter colinear points around the cuts\n                a = $ab2ae071cd7be4a4$var$filterPoints(a, a.next);\n                c = $ab2ae071cd7be4a4$var$filterPoints(c, c.next);\n                // run earcut on each half\n                $ab2ae071cd7be4a4$var$earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                $ab2ae071cd7be4a4$var$earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    }while (a !== start);\n}\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction $ab2ae071cd7be4a4$var$eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [], i, len, start, end, list;\n    for(i = 0, len = holeIndices.length; i < len; i++){\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = $ab2ae071cd7be4a4$var$linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push($ab2ae071cd7be4a4$var$getLeftmost(list));\n    }\n    queue.sort($ab2ae071cd7be4a4$var$compareX);\n    // process holes from left to right\n    for(i = 0; i < queue.length; i++)outerNode = $ab2ae071cd7be4a4$var$eliminateHole(queue[i], outerNode);\n    return outerNode;\n}\nfunction $ab2ae071cd7be4a4$var$compareX(a, b) {\n    return a.x - b.x;\n}\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction $ab2ae071cd7be4a4$var$eliminateHole(hole, outerNode) {\n    var bridge = $ab2ae071cd7be4a4$var$findHoleBridge(hole, outerNode);\n    if (!bridge) return outerNode;\n    var bridgeReverse = $ab2ae071cd7be4a4$var$splitPolygon(bridge, hole);\n    // filter collinear points around the cuts\n    $ab2ae071cd7be4a4$var$filterPoints(bridgeReverse, bridgeReverse.next);\n    return $ab2ae071cd7be4a4$var$filterPoints(bridge, bridge.next);\n}\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction $ab2ae071cd7be4a4$var$findHoleBridge(hole, outerNode) {\n    var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    }while (p !== outerNode);\n    if (!m) return null;\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n    var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;\n    p = m;\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x && $ab2ae071cd7be4a4$var$pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n            if ($ab2ae071cd7be4a4$var$locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && $ab2ae071cd7be4a4$var$sectorContainsSector(m, p)))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n        p = p.next;\n    }while (p !== stop);\n    return m;\n}\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction $ab2ae071cd7be4a4$var$sectorContainsSector(m, p) {\n    return $ab2ae071cd7be4a4$var$area(m.prev, m, p.prev) < 0 && $ab2ae071cd7be4a4$var$area(p.next, m, m.next) < 0;\n}\n// interlink polygon nodes in z-order\nfunction $ab2ae071cd7be4a4$var$indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === 0) p.z = $ab2ae071cd7be4a4$var$zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    }while (p !== start);\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n    $ab2ae071cd7be4a4$var$sortLinked(p);\n}\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction $ab2ae071cd7be4a4$var$sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n        while(p){\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for(i = 0; i < inSize; i++){\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n            while(pSize > 0 || qSize > 0 && q){\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n                if (tail) tail.nextZ = e;\n                else list = e;\n                e.prevZ = tail;\n                tail = e;\n            }\n            p = q;\n        }\n        tail.nextZ = null;\n        inSize *= 2;\n    }while (numMerges > 1);\n    return list;\n}\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction $ab2ae071cd7be4a4$var$zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n    x = (x | x << 8) & 0x00FF00FF;\n    x = (x | x << 4) & 0x0F0F0F0F;\n    x = (x | x << 2) & 0x33333333;\n    x = (x | x << 1) & 0x55555555;\n    y = (y | y << 8) & 0x00FF00FF;\n    y = (y | y << 4) & 0x0F0F0F0F;\n    y = (y | y << 2) & 0x33333333;\n    y = (y | y << 1) & 0x55555555;\n    return x | y << 1;\n}\n// find the leftmost node of a polygon ring\nfunction $ab2ae071cd7be4a4$var$getLeftmost(start) {\n    var p = start, leftmost = start;\n    do {\n        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;\n        p = p.next;\n    }while (p !== start);\n    return leftmost;\n}\n// check if a point lies within a convex triangle\nfunction $ab2ae071cd7be4a4$var$pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction $ab2ae071cd7be4a4$var$isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !$ab2ae071cd7be4a4$var$intersectsPolygon(a, b) && // dones't intersect other edges\n    ($ab2ae071cd7be4a4$var$locallyInside(a, b) && $ab2ae071cd7be4a4$var$locallyInside(b, a) && $ab2ae071cd7be4a4$var$middleInside(a, b) && // locally visible\n    ($ab2ae071cd7be4a4$var$area(a.prev, a, b.prev) || $ab2ae071cd7be4a4$var$area(a, b.prev, b)) || // does not create opposite-facing sectors\n    $ab2ae071cd7be4a4$var$equals(a, b) && $ab2ae071cd7be4a4$var$area(a.prev, a, a.next) > 0 && $ab2ae071cd7be4a4$var$area(b.prev, b, b.next) > 0); // special zero-length case\n}\n// signed area of a triangle\nfunction $ab2ae071cd7be4a4$var$area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n// check if two points are equal\nfunction $ab2ae071cd7be4a4$var$equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n// check if two segments intersect\nfunction $ab2ae071cd7be4a4$var$intersects(p1, q1, p2, q2) {\n    var o1 = $ab2ae071cd7be4a4$var$sign($ab2ae071cd7be4a4$var$area(p1, q1, p2));\n    var o2 = $ab2ae071cd7be4a4$var$sign($ab2ae071cd7be4a4$var$area(p1, q1, q2));\n    var o3 = $ab2ae071cd7be4a4$var$sign($ab2ae071cd7be4a4$var$area(p2, q2, p1));\n    var o4 = $ab2ae071cd7be4a4$var$sign($ab2ae071cd7be4a4$var$area(p2, q2, q1));\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n    if (o1 === 0 && $ab2ae071cd7be4a4$var$onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && $ab2ae071cd7be4a4$var$onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && $ab2ae071cd7be4a4$var$onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && $ab2ae071cd7be4a4$var$onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n    return false;\n}\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction $ab2ae071cd7be4a4$var$onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\nfunction $ab2ae071cd7be4a4$var$sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n// check if a polygon diagonal intersects any polygon segments\nfunction $ab2ae071cd7be4a4$var$intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && $ab2ae071cd7be4a4$var$intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    }while (p !== a);\n    return false;\n}\n// check if a polygon diagonal is locally inside the polygon\nfunction $ab2ae071cd7be4a4$var$locallyInside(a, b) {\n    return $ab2ae071cd7be4a4$var$area(a.prev, a, a.next) < 0 ? $ab2ae071cd7be4a4$var$area(a, b, a.next) >= 0 && $ab2ae071cd7be4a4$var$area(a, a.prev, b) >= 0 : $ab2ae071cd7be4a4$var$area(a, b, a.prev) < 0 || $ab2ae071cd7be4a4$var$area(a, a.next, b) < 0;\n}\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction $ab2ae071cd7be4a4$var$middleInside(a, b) {\n    var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;\n    do {\n        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;\n        p = p.next;\n    }while (p !== a);\n    return inside;\n}\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction $ab2ae071cd7be4a4$var$splitPolygon(a, b) {\n    var a2 = new $ab2ae071cd7be4a4$var$Node(a.i, a.x, a.y), b2 = new $ab2ae071cd7be4a4$var$Node(b.i, b.x, b.y), an = a.next, bp = b.prev;\n    a.next = b;\n    b.prev = a;\n    a2.next = an;\n    an.prev = a2;\n    b2.next = a2;\n    a2.prev = b2;\n    bp.next = b2;\n    b2.prev = bp;\n    return b2;\n}\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction $ab2ae071cd7be4a4$var$insertNode(i, x, y, last) {\n    var p = new $ab2ae071cd7be4a4$var$Node(i, x, y);\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\nfunction $ab2ae071cd7be4a4$var$removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\nfunction $ab2ae071cd7be4a4$var$Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n    // z-order curve value\n    this.z = 0;\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\n$ab2ae071cd7be4a4$var$earcut.deviation = function(data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n    var polygonArea = Math.abs($ab2ae071cd7be4a4$var$signedArea(data, 0, outerLen, dim));\n    if (hasHoles) for(var i = 0, len = holeIndices.length; i < len; i++){\n        var start = holeIndices[i] * dim;\n        var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        polygonArea -= Math.abs($ab2ae071cd7be4a4$var$signedArea(data, start, end, dim));\n    }\n    var trianglesArea = 0;\n    for(i = 0; i < triangles.length; i += 3){\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n    return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\nfunction $ab2ae071cd7be4a4$var$signedArea(data, start, end, dim) {\n    var sum = 0;\n    for(var i = start, j = end - dim; i < end; i += dim){\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\n$ab2ae071cd7be4a4$var$earcut.flatten = function(data) {\n    var dim = data[0][0].length, result = {\n        vertices: [],\n        holes: [],\n        dimensions: dim\n    }, holeIndex = 0;\n    for(var i = 0; i < data.length; i++){\n        for(var j = 0; j < data[i].length; j++)for(var d = 0; d < dim; d++)result.vertices.push(data[i][j][d]);\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n\n});\n\n\n\nparcelRegister(\"3P3MX\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildRectangle\", () => $a068e7e6351473f8$export$cbe813d11f2192b2);\n\"use strict\";\nconst $a068e7e6351473f8$export$cbe813d11f2192b2 = {\n    build (shape, points) {\n        const rectData = shape;\n        const x = rectData.x;\n        const y = rectData.y;\n        const width = rectData.width;\n        const height = rectData.height;\n        if (!(width >= 0 && height >= 0)) return points;\n        points[0] = x;\n        points[1] = y;\n        points[2] = x + width;\n        points[3] = y;\n        points[4] = x + width;\n        points[5] = y + height;\n        points[6] = x;\n        points[7] = y + height;\n        return points;\n    },\n    triangulate (points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n        let count = 0;\n        verticesOffset *= verticesStride;\n        vertices[verticesOffset + count] = points[0];\n        vertices[verticesOffset + count + 1] = points[1];\n        count += verticesStride;\n        vertices[verticesOffset + count] = points[2];\n        vertices[verticesOffset + count + 1] = points[3];\n        count += verticesStride;\n        vertices[verticesOffset + count] = points[6];\n        vertices[verticesOffset + count + 1] = points[7];\n        count += verticesStride;\n        vertices[verticesOffset + count] = points[4];\n        vertices[verticesOffset + count + 1] = points[5];\n        count += verticesStride;\n        const verticesIndex = verticesOffset / verticesStride;\n        indices[indicesOffset++] = verticesIndex;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 2;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 3;\n        indices[indicesOffset++] = verticesIndex + 2;\n    }\n};\n\n});\n\nparcelRegister(\"5gUNA\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildTriangle\", () => $e325eef422fafe85$export$8eb75cb9f614d270);\n\"use strict\";\nconst $e325eef422fafe85$export$8eb75cb9f614d270 = {\n    build (shape, points) {\n        points[0] = shape.x;\n        points[1] = shape.y;\n        points[2] = shape.x2;\n        points[3] = shape.y2;\n        points[4] = shape.x3;\n        points[5] = shape.y3;\n        return points;\n    },\n    triangulate (points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n        let count = 0;\n        verticesOffset *= verticesStride;\n        vertices[verticesOffset + count] = points[0];\n        vertices[verticesOffset + count + 1] = points[1];\n        count += verticesStride;\n        vertices[verticesOffset + count] = points[2];\n        vertices[verticesOffset + count + 1] = points[3];\n        count += verticesStride;\n        vertices[verticesOffset + count] = points[4];\n        vertices[verticesOffset + count + 1] = points[5];\n        const verticesIndex = verticesOffset / verticesStride;\n        indices[indicesOffset++] = verticesIndex;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 2;\n    }\n};\n\n});\n\n\n\nparcelRegister(\"g4d6y\", function(module, exports) {\n\n$parcel$export(module.exports, \"GraphicsPipe\", () => $0aab1cc3669c9573$export$56171ef5563dc803);\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $4rJn2 = parcelRequire(\"4rJn2\");\n\nvar $e98Fy = parcelRequire(\"e98Fy\");\n\nvar $1A6sa = parcelRequire(\"1A6sa\");\n\nvar $7bQyz = parcelRequire(\"7bQyz\");\n\"use strict\";\nclass $0aab1cc3669c9573$export$56171ef5563dc803 {\n    constructor(renderer, adaptor){\n        this.state = (0, $4rJn2.State).for2d();\n        // batchable graphics list, used to render batches\n        this._graphicsBatchesHash = /* @__PURE__ */ Object.create(null);\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n        this._adaptor.init();\n    }\n    validateRenderable(graphics) {\n        const context = graphics.context;\n        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n        if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) return true;\n        return false;\n    }\n    addRenderable(graphics, instructionSet) {\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n        if (graphics._didGraphicsUpdate) {\n            graphics._didGraphicsUpdate = false;\n            this._rebuild(graphics);\n        }\n        if (gpuContext.isBatchable) this._addToBatcher(graphics, instructionSet);\n        else {\n            this.renderer.renderPipes.batch.break(instructionSet);\n            instructionSet.add(graphics);\n        }\n    }\n    updateRenderable(graphics) {\n        const batches = this._graphicsBatchesHash[graphics.uid];\n        if (batches) for(let i = 0; i < batches.length; i++){\n            const batch = batches[i];\n            batch.batcher.updateElement(batch);\n        }\n    }\n    destroyRenderable(graphics) {\n        if (this._graphicsBatchesHash[graphics.uid]) this._removeBatchForRenderable(graphics.uid);\n    }\n    execute(graphics) {\n        if (!graphics.isRenderable) return;\n        const renderer = this.renderer;\n        const context = graphics.context;\n        const contextSystem = renderer.graphicsContext;\n        if (!contextSystem.getGpuContext(context).batches.length) return;\n        const shader = context.customShader || this._adaptor.shader;\n        this.state.blendMode = graphics.groupBlendMode;\n        const localUniforms = shader.resources.localUniforms.uniforms;\n        localUniforms.uTransformMatrix = graphics.groupTransform;\n        localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n        (0, $1A6sa.color32BitToUniform)(graphics.groupColorAlpha, localUniforms.uColor, 0);\n        this._adaptor.execute(this, graphics);\n    }\n    _rebuild(graphics) {\n        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n        if (wasBatched) this._removeBatchForRenderable(graphics.uid);\n        if (gpuContext.isBatchable) this._initBatchesForRenderable(graphics);\n        graphics.batched = gpuContext.isBatchable;\n    }\n    _addToBatcher(graphics, instructionSet) {\n        const batchPipe = this.renderer.renderPipes.batch;\n        const batches = this._getBatchesForRenderable(graphics);\n        for(let i = 0; i < batches.length; i++){\n            const batch = batches[i];\n            batchPipe.addToBatch(batch, instructionSet);\n        }\n    }\n    _getBatchesForRenderable(graphics) {\n        return this._graphicsBatchesHash[graphics.uid] || this._initBatchesForRenderable(graphics);\n    }\n    _initBatchesForRenderable(graphics) {\n        const context = graphics.context;\n        const gpuContext = this.renderer.graphicsContext.getGpuContext(context);\n        const roundPixels = this.renderer._roundPixels | graphics._roundPixels;\n        const batches = gpuContext.batches.map((batch)=>{\n            const batchClone = (0, $e98Fy.BigPool).get((0, $7bQyz.BatchableGraphics));\n            batch.copyTo(batchClone);\n            batchClone.renderable = graphics;\n            batchClone.roundPixels = roundPixels;\n            return batchClone;\n        });\n        this._graphicsBatchesHash[graphics.uid] = batches;\n        graphics.on(\"destroyed\", ()=>{\n            this.destroyRenderable(graphics);\n        });\n        return batches;\n    }\n    _removeBatchForRenderable(graphicsUid) {\n        this._graphicsBatchesHash[graphicsUid].forEach((batch)=>{\n            (0, $e98Fy.BigPool).return(batch);\n        });\n        this._graphicsBatchesHash[graphicsUid] = null;\n    }\n    destroy() {\n        this.renderer = null;\n        this._adaptor.destroy();\n        this._adaptor = null;\n        this.state = null;\n        for(const i in this._graphicsBatchesHash)this._removeBatchForRenderable(i);\n        this._graphicsBatchesHash = null;\n    }\n}\n/** @ignore */ $0aab1cc3669c9573$export$56171ef5563dc803.extension = {\n    type: [\n        (0, $eVz1R.ExtensionType).WebGLPipes,\n        (0, $eVz1R.ExtensionType).WebGPUPipes,\n        (0, $eVz1R.ExtensionType).CanvasPipes\n    ],\n    name: \"graphics\"\n};\n\n});\n\n\nparcelRegister(\"7FXt7\", function(module, exports) {\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $kpjyU = parcelRequire(\"kpjyU\");\n\"use strict\";\n(0, $eVz1R.extensions).add((0, $kpjyU.MeshPipe));\n\n});\nparcelRegister(\"kpjyU\", function(module, exports) {\n\n$parcel$export(module.exports, \"MeshPipe\", () => $c2a32bb93b0457d5$export$ec121977b4273ffd);\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $dNaJE = parcelRequire(\"dNaJE\");\n\nvar $86NKO = parcelRequire(\"86NKO\");\n\nvar $lJEsO = parcelRequire(\"lJEsO\");\n\nvar $e98Fy = parcelRequire(\"e98Fy\");\n\nvar $1A6sa = parcelRequire(\"1A6sa\");\n\nvar $bq09x = parcelRequire(\"bq09x\");\n\"use strict\";\nclass $c2a32bb93b0457d5$export$ec121977b4273ffd {\n    constructor(renderer, adaptor){\n        this.localUniforms = new (0, $lJEsO.UniformGroup)({\n            uTransformMatrix: {\n                value: new (0, $dNaJE.Matrix)(),\n                type: \"mat3x3<f32>\"\n            },\n            uColor: {\n                value: new Float32Array([\n                    1,\n                    1,\n                    1,\n                    1\n                ]),\n                type: \"vec4<f32>\"\n            },\n            uRound: {\n                value: 0,\n                type: \"f32\"\n            }\n        });\n        this.localUniformsBindGroup = new (0, $86NKO.BindGroup)({\n            0: this.localUniforms\n        });\n        this._meshDataHash = /* @__PURE__ */ Object.create(null);\n        this._gpuBatchableMeshHash = /* @__PURE__ */ Object.create(null);\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n        this._adaptor.init();\n    }\n    validateRenderable(mesh) {\n        const meshData = this._getMeshData(mesh);\n        const wasBatched = meshData.batched;\n        const isBatched = mesh.batched;\n        meshData.batched = isBatched;\n        if (wasBatched !== isBatched) return true;\n        else if (isBatched) {\n            const geometry = mesh._geometry;\n            if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {\n                meshData.indexSize = geometry.indices.length;\n                meshData.vertexSize = geometry.positions.length;\n                return true;\n            }\n            const batchableMesh = this._getBatchableMesh(mesh);\n            const texture = mesh.texture;\n            if (batchableMesh.texture._source !== texture._source) {\n                if (batchableMesh.texture._source !== texture._source) return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, texture);\n            }\n        }\n        return false;\n    }\n    addRenderable(mesh, instructionSet) {\n        const batcher = this.renderer.renderPipes.batch;\n        const { batched: batched } = this._getMeshData(mesh);\n        if (batched) {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n            gpuBatchableMesh.texture = mesh._texture;\n            gpuBatchableMesh.geometry = mesh._geometry;\n            batcher.addToBatch(gpuBatchableMesh);\n        } else {\n            batcher.break(instructionSet);\n            instructionSet.add({\n                renderPipeId: \"mesh\",\n                mesh: mesh\n            });\n        }\n    }\n    updateRenderable(mesh) {\n        if (mesh.batched) {\n            const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];\n            gpuBatchableMesh.texture = mesh._texture;\n            gpuBatchableMesh.geometry = mesh._geometry;\n            gpuBatchableMesh.batcher.updateElement(gpuBatchableMesh);\n        }\n    }\n    destroyRenderable(mesh) {\n        this._meshDataHash[mesh.uid] = null;\n        const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];\n        if (gpuMesh) {\n            (0, $e98Fy.BigPool).return(gpuMesh);\n            this._gpuBatchableMeshHash[mesh.uid] = null;\n        }\n    }\n    execute({ mesh: mesh }) {\n        if (!mesh.isRenderable) return;\n        mesh.state.blendMode = mesh.groupBlendMode;\n        const localUniforms = this.localUniforms;\n        localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n        localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n        localUniforms.update();\n        (0, $1A6sa.color32BitToUniform)(mesh.groupColorAlpha, localUniforms.uniforms.uColor, 0);\n        this._adaptor.execute(this, mesh);\n    }\n    _getMeshData(mesh) {\n        return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);\n    }\n    _initMeshData(mesh) {\n        this._meshDataHash[mesh.uid] = {\n            batched: mesh.batched,\n            indexSize: mesh._geometry.indices?.length,\n            vertexSize: mesh._geometry.positions?.length\n        };\n        mesh.on(\"destroyed\", ()=>{\n            this.destroyRenderable(mesh);\n        });\n        return this._meshDataHash[mesh.uid];\n    }\n    _getBatchableMesh(mesh) {\n        return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);\n    }\n    _initBatchableMesh(mesh) {\n        const gpuMesh = (0, $e98Fy.BigPool).get((0, $bq09x.BatchableMesh));\n        gpuMesh.mesh = mesh;\n        gpuMesh.texture = mesh._texture;\n        gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;\n        this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;\n        gpuMesh.mesh = mesh;\n        return gpuMesh;\n    }\n    destroy() {\n        for(const i in this._gpuBatchableMeshHash)if (this._gpuBatchableMeshHash[i]) (0, $e98Fy.BigPool).return(this._gpuBatchableMeshHash[i]);\n        this._gpuBatchableMeshHash = null;\n        this._meshDataHash = null;\n        this.localUniforms = null;\n        this.localUniformsBindGroup = null;\n        this._adaptor.destroy();\n        this._adaptor = null;\n        this.renderer = null;\n    }\n}\n/** @ignore */ $c2a32bb93b0457d5$export$ec121977b4273ffd.extension = {\n    type: [\n        (0, $eVz1R.ExtensionType).WebGLPipes,\n        (0, $eVz1R.ExtensionType).WebGPUPipes,\n        (0, $eVz1R.ExtensionType).CanvasPipes\n    ],\n    name: \"mesh\"\n};\n\n});\nparcelRegister(\"bq09x\", function(module, exports) {\n\n$parcel$export(module.exports, \"BatchableMesh\", () => $fb7e6b6dd0e8e83d$export$2fa0f0ec877329e3);\n\"use strict\";\nclass $fb7e6b6dd0e8e83d$export$2fa0f0ec877329e3 {\n    constructor(){\n        this.batcher = null;\n        this.batch = null;\n        this.roundPixels = 0;\n        this._uvUpdateId = -1;\n        this._textureMatrixUpdateId = -1;\n    }\n    get blendMode() {\n        return this.mesh.groupBlendMode;\n    }\n    reset() {\n        this.mesh = null;\n        this.texture = null;\n        this.batcher = null;\n        this.batch = null;\n    }\n    packIndex(indexBuffer, index, indicesOffset) {\n        const indices = this.geometry.indices;\n        for(let i = 0; i < indices.length; i++)indexBuffer[index++] = indices[i] + indicesOffset;\n    }\n    packAttributes(float32View, uint32View, index, textureId) {\n        const mesh = this.mesh;\n        const geometry = this.geometry;\n        const wt = mesh.groupTransform;\n        const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n        const positions = geometry.positions;\n        const uvBuffer = geometry.getBuffer(\"aUV\");\n        const uvs = uvBuffer.data;\n        let transformedUvs = uvs;\n        const textureMatrix = this.texture.textureMatrix;\n        if (!textureMatrix.isSimple) {\n            transformedUvs = this._transformedUvs;\n            if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID) {\n                if (!transformedUvs || transformedUvs.length < uvs.length) transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n                this._textureMatrixUpdateId = textureMatrix._updateID;\n                this._uvUpdateId = uvBuffer._updateID;\n                textureMatrix.multiplyUvs(uvs, transformedUvs);\n            }\n        }\n        const abgr = mesh.groupColorAlpha;\n        for(let i = 0; i < positions.length; i += 2){\n            const x = positions[i];\n            const y = positions[i + 1];\n            float32View[index] = a * x + c * y + tx;\n            float32View[index + 1] = b * x + d * y + ty;\n            float32View[index + 2] = transformedUvs[i];\n            float32View[index + 3] = transformedUvs[i + 1];\n            uint32View[index + 4] = abgr;\n            uint32View[index + 5] = textureIdAndRound;\n            index += 6;\n        }\n    }\n    get vertexSize() {\n        return this.geometry.positions.length / 2;\n    }\n    get indexSize() {\n        return this.geometry.indices.length;\n    }\n}\n\n});\n\n\n\nparcelRegister(\"lT9Uv\", function(module, exports) {\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $7JqIa = parcelRequire(\"7JqIa\");\n\nvar $irQVi = parcelRequire(\"irQVi\");\n\"use strict\";\n(0, $eVz1R.extensions).add((0, $irQVi.CanvasTextSystem));\n(0, $eVz1R.extensions).add((0, $7JqIa.CanvasTextPipe));\n\n});\nparcelRegister(\"7JqIa\", function(module, exports) {\n\n$parcel$export(module.exports, \"CanvasTextPipe\", () => $26054a65a4f42ce4$export$ed0d779e44b53050);\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $1ZKfN = parcelRequire(\"1ZKfN\");\n\nvar $e98Fy = parcelRequire(\"e98Fy\");\n\nvar $8PFkM = parcelRequire(\"8PFkM\");\n\"use strict\";\nclass $26054a65a4f42ce4$export$ed0d779e44b53050 {\n    constructor(renderer){\n        this._gpuText = /* @__PURE__ */ Object.create(null);\n        this._renderer = renderer;\n    }\n    validateRenderable(text) {\n        const gpuText = this._getGpuText(text);\n        const newKey = text._getKey();\n        if (gpuText.currentKey !== newKey) {\n            const resolution = text.resolution ?? this._renderer.resolution;\n            const { width: width, height: height } = this._renderer.canvasText.getTextureSize(text.text, resolution, text._style);\n            if (// is only being used by this text:\n            this._renderer.canvasText.getReferenceCount(gpuText.currentKey) === 1 && width === gpuText.texture._source.width && height === gpuText.texture._source.height) return false;\n            return true;\n        }\n        return false;\n    }\n    addRenderable(text, _instructionSet) {\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n        if (text._didTextUpdate) this._updateText(text);\n        this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n    }\n    updateRenderable(text) {\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n        if (text._didTextUpdate) this._updateText(text);\n        batchableSprite.batcher.updateElement(batchableSprite);\n    }\n    destroyRenderable(text) {\n        this._destroyRenderableById(text.uid);\n    }\n    _destroyRenderableById(textUid) {\n        const gpuText = this._gpuText[textUid];\n        this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n        (0, $e98Fy.BigPool).return(gpuText.batchableSprite);\n        this._gpuText[textUid] = null;\n    }\n    _updateText(text) {\n        const newKey = text._getKey();\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n        if (gpuText.currentKey !== newKey) this._updateGpuText(text);\n        text._didTextUpdate = false;\n        const padding = text._style.padding;\n        (0, $1ZKfN.updateQuadBounds)(batchableSprite.bounds, text._anchor, batchableSprite.texture, padding);\n    }\n    _updateGpuText(text) {\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n        if (gpuText.texture) this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n        const resolution = text.resolution ?? this._renderer.resolution;\n        gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getTexture(text.text, resolution, text._style, text._getKey());\n        gpuText.currentKey = text._getKey();\n        batchableSprite.texture = gpuText.texture;\n    }\n    _getGpuText(text) {\n        return this._gpuText[text.uid] || this.initGpuText(text);\n    }\n    initGpuText(text) {\n        const gpuTextData = {\n            texture: null,\n            currentKey: \"--\",\n            batchableSprite: (0, $e98Fy.BigPool).get((0, $8PFkM.BatchableSprite))\n        };\n        gpuTextData.batchableSprite.renderable = text;\n        gpuTextData.batchableSprite.bounds = {\n            minX: 0,\n            maxX: 1,\n            minY: 0,\n            maxY: 0\n        };\n        gpuTextData.batchableSprite.roundPixels = this._renderer._roundPixels | text._roundPixels;\n        this._gpuText[text.uid] = gpuTextData;\n        this._updateText(text);\n        text.on(\"destroyed\", ()=>{\n            this.destroyRenderable(text);\n        });\n        return gpuTextData;\n    }\n    destroy() {\n        for(const i in this._gpuText)this._destroyRenderableById(i);\n        this._gpuText = null;\n        this._renderer = null;\n    }\n}\n/** @ignore */ $26054a65a4f42ce4$export$ed0d779e44b53050.extension = {\n    type: [\n        (0, $eVz1R.ExtensionType).WebGLPipes,\n        (0, $eVz1R.ExtensionType).WebGPUPipes,\n        (0, $eVz1R.ExtensionType).CanvasPipes\n    ],\n    name: \"text\"\n};\n\n});\n\nparcelRegister(\"irQVi\", function(module, exports) {\n\n$parcel$export(module.exports, \"CanvasTextSystem\", () => $0dc6e34005d06c5e$export$56e4907c2e518abc);\n\nvar $AHTcQ = parcelRequire(\"AHTcQ\");\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $domwE = parcelRequire(\"domwE\");\n\nvar $8zNlV = parcelRequire(\"8zNlV\");\n\nvar $7U2uj = parcelRequire(\"7U2uj\");\n\nvar $h6sd0 = parcelRequire(\"h6sd0\");\n\nvar $aq3uI = parcelRequire(\"aq3uI\");\n\nvar $ffIGX = parcelRequire(\"ffIGX\");\n\nvar $fMjVf = parcelRequire(\"fMjVf\");\n\nvar $eHP3T = parcelRequire(\"eHP3T\");\n\"use strict\";\nclass $0dc6e34005d06c5e$export$56e4907c2e518abc {\n    constructor(){\n        this._activeTextures = {};\n    }\n    getTextureSize(text, resolution, style) {\n        const measured = (0, $ffIGX.CanvasTextMetrics).measureText(text || \" \", style);\n        let width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n        let height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n        width = Math.ceil(width - 1e-6);\n        height = Math.ceil(height - 1e-6);\n        width = (0, $domwE.nextPow2)(width);\n        height = (0, $domwE.nextPow2)(height);\n        return {\n            width: width,\n            height: height\n        };\n    }\n    getTexture(text, resolution, style, textKey) {\n        if (this._activeTextures[textKey]) {\n            this._increaseReferenceCount(textKey);\n            return this._activeTextures[textKey].texture;\n        }\n        const measured = (0, $ffIGX.CanvasTextMetrics).measureText(text || \" \", style);\n        const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n        const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n        const canvasAndContext = (0, $8zNlV.CanvasPool).getOptimalCanvasAndContext(width, height);\n        const { canvas: canvas } = canvasAndContext;\n        this.renderTextToCanvas(text, style, resolution, canvasAndContext);\n        const texture = (0, $aq3uI.getPo2TextureFromSource)(canvas, width, height, resolution);\n        if (style.trim) {\n            const trimmed = (0, $h6sd0.getCanvasBoundingBox)(canvas, resolution);\n            texture.frame.copyFrom(trimmed);\n            texture.updateUvs();\n        }\n        this._activeTextures[textKey] = {\n            canvasAndContext: canvasAndContext,\n            texture: texture,\n            usageCount: 1\n        };\n        return texture;\n    }\n    _increaseReferenceCount(textKey) {\n        this._activeTextures[textKey].usageCount++;\n    }\n    decreaseReferenceCount(textKey) {\n        const activeTexture = this._activeTextures[textKey];\n        activeTexture.usageCount--;\n        if (activeTexture.usageCount === 0) {\n            (0, $8zNlV.CanvasPool).returnCanvasAndContext(activeTexture.canvasAndContext);\n            (0, $7U2uj.TexturePool).returnTexture(activeTexture.texture);\n            const source = activeTexture.texture.source;\n            source.resource = null;\n            source.uploadMethodId = \"unknown\";\n            source.alphaMode = \"no-premultiply-alpha\";\n            this._activeTextures[textKey] = null;\n        }\n    }\n    getReferenceCount(textKey) {\n        return this._activeTextures[textKey].usageCount;\n    }\n    /**\n   * Renders text to its canvas, and updates its texture.\n   *\n   * By default this is used internally to ensure the texture is correct before rendering,\n   * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,\n   * and then shared across multiple Sprites.\n   * @param text\n   * @param style\n   * @param resolution\n   * @param canvasAndContext\n   */ renderTextToCanvas(text, style, resolution, canvasAndContext) {\n        const { canvas: canvas, context: context } = canvasAndContext;\n        const font = (0, $fMjVf.fontStringFromTextStyle)(style);\n        const measured = (0, $ffIGX.CanvasTextMetrics).measureText(text || \" \", style);\n        const lines = measured.lines;\n        const lineHeight = measured.lineHeight;\n        const lineWidths = measured.lineWidths;\n        const maxLineWidth = measured.maxLineWidth;\n        const fontProperties = measured.fontProperties;\n        const height = canvas.height;\n        context.resetTransform();\n        context.scale(resolution, resolution);\n        context.clearRect(0, 0, measured.width + 4, measured.height + 4);\n        if (style._stroke?.width) {\n            const strokeStyle = style._stroke;\n            context.lineWidth = strokeStyle.width;\n            context.miterLimit = strokeStyle.miterLimit;\n            context.lineJoin = strokeStyle.join;\n            context.lineCap = strokeStyle.cap;\n        }\n        context.font = font;\n        let linePositionX;\n        let linePositionY;\n        const passesCount = style.dropShadow ? 2 : 1;\n        for(let i = 0; i < passesCount; ++i){\n            const isShadowPass = style.dropShadow && i === 0;\n            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;\n            const dsOffsetShadow = dsOffsetText * resolution;\n            if (isShadowPass) {\n                context.fillStyle = \"black\";\n                context.strokeStyle = \"black\";\n                const shadowOptions = style.dropShadow;\n                const dropShadowColor = shadowOptions.color;\n                const dropShadowAlpha = shadowOptions.alpha;\n                context.shadowColor = (0, $AHTcQ.Color).shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();\n                const dropShadowBlur = shadowOptions.blur * resolution;\n                const dropShadowDistance = shadowOptions.distance * resolution;\n                context.shadowBlur = dropShadowBlur;\n                context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n                context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance + dsOffsetShadow;\n            } else {\n                context.globalAlpha = style._fill?.alpha ?? 1;\n                context.fillStyle = style._fill ? (0, $eHP3T.getCanvasFillStyle)(style._fill, context) : null;\n                if (style._stroke?.width) context.strokeStyle = (0, $eHP3T.getCanvasFillStyle)(style._stroke, context);\n                context.shadowColor = \"black\";\n            }\n            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n            if (lineHeight - fontProperties.fontSize < 0) linePositionYShift = 0;\n            const strokeWidth = style._stroke?.width ?? 0;\n            for(let i2 = 0; i2 < lines.length; i2++){\n                linePositionX = strokeWidth / 2;\n                linePositionY = strokeWidth / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift;\n                if (style.align === \"right\") linePositionX += maxLineWidth - lineWidths[i2];\n                else if (style.align === \"center\") linePositionX += (maxLineWidth - lineWidths[i2]) / 2;\n                if (style._stroke) this._drawLetterSpacing(lines[i2], style, canvasAndContext, linePositionX + style.padding, linePositionY + style.padding - dsOffsetText, true);\n                if (style._fill !== void 0) this._drawLetterSpacing(lines[i2], style, canvasAndContext, linePositionX + style.padding, linePositionY + style.padding - dsOffsetText);\n            }\n        }\n    }\n    /**\n   * Render the text with letter-spacing.\n   * @param text - The text to draw\n   * @param style\n   * @param canvasAndContext\n   * @param x - Horizontal position to draw the text\n   * @param y - Vertical position to draw the text\n   * @param isStroke - Is this drawing for the outside stroke of the\n   *  text? If not, it's for the inside fill\n   */ _drawLetterSpacing(text, style, canvasAndContext, x, y, isStroke = false) {\n        const { context: context } = canvasAndContext;\n        const letterSpacing = style.letterSpacing;\n        let useExperimentalLetterSpacing = false;\n        if ((0, $ffIGX.CanvasTextMetrics).experimentalLetterSpacingSupported) {\n            if ((0, $ffIGX.CanvasTextMetrics).experimentalLetterSpacing) {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            } else {\n                context.letterSpacing = \"0px\";\n                context.textLetterSpacing = \"0px\";\n            }\n        }\n        if (letterSpacing === 0 || useExperimentalLetterSpacing) {\n            if (isStroke) context.strokeText(text, x, y);\n            else context.fillText(text, x, y);\n            return;\n        }\n        let currentPosition = x;\n        const stringArray = (0, $ffIGX.CanvasTextMetrics).graphemeSegmenter(text);\n        let previousWidth = context.measureText(text).width;\n        let currentWidth = 0;\n        for(let i = 0; i < stringArray.length; ++i){\n            const currentChar = stringArray[i];\n            if (isStroke) context.strokeText(currentChar, currentPosition, y);\n            else context.fillText(currentChar, currentPosition, y);\n            let textStr = \"\";\n            for(let j = i + 1; j < stringArray.length; ++j)textStr += stringArray[j];\n            currentWidth = context.measureText(textStr).width;\n            currentPosition += previousWidth - currentWidth + letterSpacing;\n            previousWidth = currentWidth;\n        }\n    }\n    destroy() {\n        this._activeTextures = null;\n    }\n}\n/** @ignore */ $0dc6e34005d06c5e$export$56e4907c2e518abc.extension = {\n    type: [\n        (0, $eVz1R.ExtensionType).WebGLSystem,\n        (0, $eVz1R.ExtensionType).WebGPUSystem,\n        (0, $eVz1R.ExtensionType).CanvasSystem\n    ],\n    name: \"canvasText\"\n};\n\n});\nparcelRegister(\"h6sd0\", function(module, exports) {\n\n$parcel$export(module.exports, \"getCanvasBoundingBox\", () => $56f0a2690b9dc8b2$export$550eedf6c679837d);\n\nvar $soqVu = parcelRequire(\"soqVu\");\n\"use strict\";\nfunction $56f0a2690b9dc8b2$var$checkRow(data, width, y) {\n    for(let x = 0, index = 4 * y * width; x < width; ++x, index += 4){\n        if (data[index + 3] !== 0) return false;\n    }\n    return true;\n}\nfunction $56f0a2690b9dc8b2$var$checkColumn(data, width, x, top, bottom) {\n    const stride = 4 * width;\n    for(let y = top, index = top * stride + 4 * x; y <= bottom; ++y, index += stride){\n        if (data[index + 3] !== 0) return false;\n    }\n    return true;\n}\nfunction $56f0a2690b9dc8b2$export$550eedf6c679837d(canvas, resolution = 1) {\n    const { width: width, height: height } = canvas;\n    const context = canvas.getContext(\"2d\", {\n        willReadFrequently: true\n    });\n    if (context === null) throw new TypeError(\"Failed to get canvas 2D context\");\n    const imageData = context.getImageData(0, 0, width, height);\n    const data = imageData.data;\n    let left = 0;\n    let top = 0;\n    let right = width - 1;\n    let bottom = height - 1;\n    while(top < height && $56f0a2690b9dc8b2$var$checkRow(data, width, top))++top;\n    if (top === height) return (0, $soqVu.Rectangle).EMPTY;\n    while($56f0a2690b9dc8b2$var$checkRow(data, width, bottom))--bottom;\n    while($56f0a2690b9dc8b2$var$checkColumn(data, width, left, top, bottom))++left;\n    while($56f0a2690b9dc8b2$var$checkColumn(data, width, right, top, bottom))--right;\n    ++right;\n    ++bottom;\n    return new (0, $soqVu.Rectangle)(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);\n}\n\n});\n\nparcelRegister(\"aq3uI\", function(module, exports) {\n\n$parcel$export(module.exports, \"getPo2TextureFromSource\", () => $b035aaddaf7b0631$export$80c61c6b7fb407a3);\n\nvar $7U2uj = parcelRequire(\"7U2uj\");\n\nvar $ggeMF = parcelRequire(\"ggeMF\");\n\"use strict\";\nconst $b035aaddaf7b0631$var$tempBounds = new (0, $ggeMF.Bounds)();\nfunction $b035aaddaf7b0631$export$80c61c6b7fb407a3(image, width, height, resolution) {\n    const bounds = $b035aaddaf7b0631$var$tempBounds;\n    bounds.minX = 0;\n    bounds.minY = 0;\n    bounds.maxX = image.width / resolution | 0;\n    bounds.maxY = image.height / resolution | 0;\n    const texture = (0, $7U2uj.TexturePool).getOptimalTexture(bounds.width, bounds.height, resolution, false);\n    texture.source.uploadMethodId = \"image\";\n    texture.source.resource = image;\n    texture.source.alphaMode = \"premultiply-alpha-on-upload\";\n    texture.frame.width = width / resolution;\n    texture.frame.height = height / resolution;\n    texture.source.emit(\"update\", texture.source);\n    texture.updateUvs();\n    return texture;\n}\n\n});\n\nparcelRegister(\"ffIGX\", function(module, exports) {\n\n$parcel$export(module.exports, \"CanvasTextMetrics\", () => $0a83834d09de39f8$export$b12f6bdc825d944f);\n\nvar $5m2Qn = parcelRequire(\"5m2Qn\");\n\nvar $fMjVf = parcelRequire(\"fMjVf\");\n\"use strict\";\nconst $0a83834d09de39f8$var$contextSettings = {\n    // TextMetrics requires getImageData readback for measuring fonts.\n    willReadFrequently: true\n};\nconst $0a83834d09de39f8$var$_CanvasTextMetrics = class _CanvasTextMetrics {\n    /**\n   * Checking that we can use modern canvas 2D API.\n   *\n   * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n   * @see TextMetrics.experimentalLetterSpacing\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing\n   * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n   */ static get experimentalLetterSpacingSupported() {\n        let result = _CanvasTextMetrics._experimentalLetterSpacingSupported;\n        if (result !== void 0) {\n            const proto = (0, $5m2Qn.DOMAdapter).get().getCanvasRenderingContext2D().prototype;\n            result = _CanvasTextMetrics._experimentalLetterSpacingSupported = \"letterSpacing\" in proto || \"textLetterSpacing\" in proto;\n        }\n        return result;\n    }\n    /**\n   * @param text - the text that was measured\n   * @param style - the style that was measured\n   * @param width - the measured width of the text\n   * @param height - the measured height of the text\n   * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n   * @param lineWidths - an array of the line widths for each line matched to `lines`\n   * @param lineHeight - the measured line height for this style\n   * @param maxLineWidth - the maximum line width for all measured lines\n   * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n   */ constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties){\n        this.text = text;\n        this.style = style;\n        this.width = width;\n        this.height = height;\n        this.lines = lines;\n        this.lineWidths = lineWidths;\n        this.lineHeight = lineHeight;\n        this.maxLineWidth = maxLineWidth;\n        this.fontProperties = fontProperties;\n    }\n    /**\n   * Measures the supplied string of text and returns a Rectangle.\n   * @param text - The text to measure.\n   * @param style - The text style to use for measuring\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @param wordWrap\n   * @returns Measured width and height of the text.\n   */ static measureText(text = \" \", style, canvas = _CanvasTextMetrics._canvas, wordWrap = style.wordWrap) {\n        const textKey = `${text}:${style.styleKey}`;\n        if (_CanvasTextMetrics._measurementCache[textKey]) return _CanvasTextMetrics._measurementCache[textKey];\n        const font = (0, $fMjVf.fontStringFromTextStyle)(style);\n        const fontProperties = _CanvasTextMetrics.measureFont(font);\n        if (fontProperties.fontSize === 0) {\n            fontProperties.fontSize = style.fontSize;\n            fontProperties.ascent = style.fontSize;\n        }\n        const context = _CanvasTextMetrics.__context;\n        context.font = font;\n        const outputText = wordWrap ? _CanvasTextMetrics._wordWrap(text, style, canvas) : text;\n        const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n        const lineWidths = new Array(lines.length);\n        let maxLineWidth = 0;\n        for(let i = 0; i < lines.length; i++){\n            const lineWidth = _CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);\n            lineWidths[i] = lineWidth;\n            maxLineWidth = Math.max(maxLineWidth, lineWidth);\n        }\n        const strokeWidth = style._stroke?.width || 0;\n        let width = maxLineWidth + strokeWidth;\n        if (style.dropShadow) width += style.dropShadow.distance;\n        const lineHeight = style.lineHeight || fontProperties.fontSize + strokeWidth;\n        let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth * 2) + (lines.length - 1) * (lineHeight + style.leading);\n        if (style.dropShadow) height += style.dropShadow.distance;\n        const measurements = new _CanvasTextMetrics(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);\n        return measurements;\n    }\n    static _measureText(text, letterSpacing, context) {\n        let useExperimentalLetterSpacing = false;\n        if (_CanvasTextMetrics.experimentalLetterSpacingSupported) {\n            if (_CanvasTextMetrics.experimentalLetterSpacing) {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            } else {\n                context.letterSpacing = \"0px\";\n                context.textLetterSpacing = \"0px\";\n            }\n        }\n        let width = context.measureText(text).width;\n        if (width > 0) {\n            if (useExperimentalLetterSpacing) width -= letterSpacing;\n            else width += (_CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n        }\n        return width;\n    }\n    /**\n   * Applies newlines to a string to have it optimally fit into the horizontal\n   * bounds set by the Text object's wordWrapWidth property.\n   * @param text - String to apply word wrapping to\n   * @param style - the style to use when wrapping\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @returns New string with new lines applied where required\n   */ static _wordWrap(text, style, canvas = _CanvasTextMetrics._canvas) {\n        const context = canvas.getContext(\"2d\", $0a83834d09de39f8$var$contextSettings);\n        let width = 0;\n        let line = \"\";\n        let lines = \"\";\n        const cache = /* @__PURE__ */ Object.create(null);\n        const { letterSpacing: letterSpacing, whiteSpace: whiteSpace } = style;\n        const collapseSpaces = _CanvasTextMetrics._collapseSpaces(whiteSpace);\n        const collapseNewlines = _CanvasTextMetrics._collapseNewlines(whiteSpace);\n        let canPrependSpaces = !collapseSpaces;\n        const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n        const tokens = _CanvasTextMetrics._tokenize(text);\n        for(let i = 0; i < tokens.length; i++){\n            let token = tokens[i];\n            if (_CanvasTextMetrics._isNewline(token)) {\n                if (!collapseNewlines) {\n                    lines += _CanvasTextMetrics._addLine(line);\n                    canPrependSpaces = !collapseSpaces;\n                    line = \"\";\n                    width = 0;\n                    continue;\n                }\n                token = \" \";\n            }\n            if (collapseSpaces) {\n                const currIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(token);\n                const lastIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);\n                if (currIsBreakingSpace && lastIsBreakingSpace) continue;\n            }\n            const tokenWidth = _CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context);\n            if (tokenWidth > wordWrapWidth) {\n                if (line !== \"\") {\n                    lines += _CanvasTextMetrics._addLine(line);\n                    line = \"\";\n                    width = 0;\n                }\n                if (_CanvasTextMetrics.canBreakWords(token, style.breakWords)) {\n                    const characters = _CanvasTextMetrics.wordWrapSplit(token);\n                    for(let j = 0; j < characters.length; j++){\n                        let char = characters[j];\n                        let lastChar = char;\n                        let k = 1;\n                        while(characters[j + k]){\n                            const nextChar = characters[j + k];\n                            if (!_CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) char += nextChar;\n                            else break;\n                            lastChar = nextChar;\n                            k++;\n                        }\n                        j += k - 1;\n                        const characterWidth = _CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context);\n                        if (characterWidth + width > wordWrapWidth) {\n                            lines += _CanvasTextMetrics._addLine(line);\n                            canPrependSpaces = false;\n                            line = \"\";\n                            width = 0;\n                        }\n                        line += char;\n                        width += characterWidth;\n                    }\n                } else {\n                    if (line.length > 0) {\n                        lines += _CanvasTextMetrics._addLine(line);\n                        line = \"\";\n                        width = 0;\n                    }\n                    const isLastToken = i === tokens.length - 1;\n                    lines += _CanvasTextMetrics._addLine(token, !isLastToken);\n                    canPrependSpaces = false;\n                    line = \"\";\n                    width = 0;\n                }\n            } else {\n                if (tokenWidth + width > wordWrapWidth) {\n                    canPrependSpaces = false;\n                    lines += _CanvasTextMetrics._addLine(line);\n                    line = \"\";\n                    width = 0;\n                }\n                if (line.length > 0 || !_CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces) {\n                    line += token;\n                    width += tokenWidth;\n                }\n            }\n        }\n        lines += _CanvasTextMetrics._addLine(line, false);\n        return lines;\n    }\n    /**\n   * Convienience function for logging each line added during the wordWrap method.\n   * @param line    - The line of text to add\n   * @param newLine - Add new line character to end\n   * @returns A formatted line\n   */ static _addLine(line, newLine = true) {\n        line = _CanvasTextMetrics._trimRight(line);\n        line = newLine ? `${line}\n` : line;\n        return line;\n    }\n    /**\n   * Gets & sets the widths of calculated characters in a cache object\n   * @param key            - The key\n   * @param letterSpacing  - The letter spacing\n   * @param cache          - The cache\n   * @param context        - The canvas context\n   * @returns The from cache.\n   */ static _getFromCache(key, letterSpacing, cache, context) {\n        let width = cache[key];\n        if (typeof width !== \"number\") {\n            width = _CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n            cache[key] = width;\n        }\n        return width;\n    }\n    /**\n   * Determines whether we should collapse breaking spaces.\n   * @param whiteSpace - The TextStyle property whiteSpace\n   * @returns Should collapse\n   */ static _collapseSpaces(whiteSpace) {\n        return whiteSpace === \"normal\" || whiteSpace === \"pre-line\";\n    }\n    /**\n   * Determines whether we should collapse newLine chars.\n   * @param whiteSpace - The white space\n   * @returns should collapse\n   */ static _collapseNewlines(whiteSpace) {\n        return whiteSpace === \"normal\";\n    }\n    /**\n   * Trims breaking whitespaces from string.\n   * @param text - The text\n   * @returns Trimmed string\n   */ static _trimRight(text) {\n        if (typeof text !== \"string\") return \"\";\n        for(let i = text.length - 1; i >= 0; i--){\n            const char = text[i];\n            if (!_CanvasTextMetrics.isBreakingSpace(char)) break;\n            text = text.slice(0, -1);\n        }\n        return text;\n    }\n    /**\n   * Determines if char is a newline.\n   * @param char - The character\n   * @returns True if newline, False otherwise.\n   */ static _isNewline(char) {\n        if (typeof char !== \"string\") return false;\n        return _CanvasTextMetrics._newlines.includes(char.charCodeAt(0));\n    }\n    /**\n   * Determines if char is a breaking whitespace.\n   *\n   * It allows one to determine whether char should be a breaking whitespace\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param char - The character\n   * @param [_nextChar] - The next character\n   * @returns True if whitespace, False otherwise.\n   */ static isBreakingSpace(char, _nextChar) {\n        if (typeof char !== \"string\") return false;\n        return _CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n    }\n    /**\n   * Splits a string into words, breaking-spaces and newLine characters\n   * @param text - The text\n   * @returns A tokenized array\n   */ static _tokenize(text) {\n        const tokens = [];\n        let token = \"\";\n        if (typeof text !== \"string\") return tokens;\n        for(let i = 0; i < text.length; i++){\n            const char = text[i];\n            const nextChar = text[i + 1];\n            if (_CanvasTextMetrics.isBreakingSpace(char, nextChar) || _CanvasTextMetrics._isNewline(char)) {\n                if (token !== \"\") {\n                    tokens.push(token);\n                    token = \"\";\n                }\n                tokens.push(char);\n                continue;\n            }\n            token += char;\n        }\n        if (token !== \"\") tokens.push(token);\n        return tokens;\n    }\n    /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It allows one to customise which words should break\n   * Examples are if the token is CJK or numbers.\n   * It must return a boolean.\n   * @param _token - The token\n   * @param breakWords - The style attr break words\n   * @returns Whether to break word or not\n   */ static canBreakWords(_token, breakWords) {\n        return breakWords;\n    }\n    /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It allows one to determine whether a pair of characters\n   * should be broken by newlines\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param _char - The character\n   * @param _nextChar - The next character\n   * @param _token - The token/word the characters are from\n   * @param _index - The index in the token of the char\n   * @param _breakWords - The style attr break words\n   * @returns whether to break word or not\n   */ static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {\n        return true;\n    }\n    /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It is called when a token (usually a word) has to be split into separate pieces\n   * in order to determine the point to break a word.\n   * It must return an array of characters.\n   * @param token - The token to split\n   * @returns The characters of the token\n   * @see CanvasTextMetrics.graphemeSegmenter\n   */ static wordWrapSplit(token) {\n        return _CanvasTextMetrics.graphemeSegmenter(token);\n    }\n    /**\n   * Calculates the ascent, descent and fontSize of a given font-style\n   * @param font - String representing the style of the font\n   * @returns Font properties object\n   */ static measureFont(font) {\n        if (_CanvasTextMetrics._fonts[font]) return _CanvasTextMetrics._fonts[font];\n        const context = _CanvasTextMetrics._context;\n        context.font = font;\n        const metrics = context.measureText(_CanvasTextMetrics.METRICS_STRING + _CanvasTextMetrics.BASELINE_SYMBOL);\n        const properties = {\n            ascent: metrics.actualBoundingBoxAscent,\n            descent: metrics.actualBoundingBoxDescent,\n            fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n        };\n        _CanvasTextMetrics._fonts[font] = properties;\n        return properties;\n    }\n    /**\n   * Clear font metrics in metrics cache.\n   * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n   */ static clearMetrics(font = \"\") {\n        if (font) delete _CanvasTextMetrics._fonts[font];\n        else _CanvasTextMetrics._fonts = {};\n    }\n    /**\n   * Cached canvas element for measuring text\n   * TODO: this should be private, but isn't because of backward compat, will fix later.\n   * @ignore\n   */ static get _canvas() {\n        if (!_CanvasTextMetrics.__canvas) {\n            let canvas;\n            try {\n                const c = new OffscreenCanvas(0, 0);\n                const context = c.getContext(\"2d\", $0a83834d09de39f8$var$contextSettings);\n                if (context?.measureText) {\n                    _CanvasTextMetrics.__canvas = c;\n                    return c;\n                }\n                canvas = (0, $5m2Qn.DOMAdapter).get().createCanvas();\n            } catch (ex) {\n                canvas = (0, $5m2Qn.DOMAdapter).get().createCanvas();\n            }\n            canvas.width = canvas.height = 10;\n            _CanvasTextMetrics.__canvas = canvas;\n        }\n        return _CanvasTextMetrics.__canvas;\n    }\n    /**\n   * TODO: this should be private, but isn't because of backward compat, will fix later.\n   * @ignore\n   */ static get _context() {\n        if (!_CanvasTextMetrics.__context) _CanvasTextMetrics.__context = _CanvasTextMetrics._canvas.getContext(\"2d\", $0a83834d09de39f8$var$contextSettings);\n        return _CanvasTextMetrics.__context;\n    }\n};\n/**\n * String used for calculate font metrics.\n * These characters are all tall to help calculate the height required for text.\n */ $0a83834d09de39f8$var$_CanvasTextMetrics.METRICS_STRING = \"|\\xc9q\\xc5\";\n/** Baseline symbol for calculate font metrics. */ $0a83834d09de39f8$var$_CanvasTextMetrics.BASELINE_SYMBOL = \"M\";\n/** Baseline multiplier for calculate font metrics. */ $0a83834d09de39f8$var$_CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;\n/** Height multiplier for setting height of canvas to calculate font metrics. */ $0a83834d09de39f8$var$_CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;\n/**\n * A Unicode \"character\", or \"grapheme cluster\", can be composed of multiple Unicode code points,\n * such as letters with diacritical marks (e.g. `'\\u0065\\u0301'`, letter e with acute)\n * or emojis with modifiers (e.g. `'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB'`, technologist).\n * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n * If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),\n * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.\n */ $0a83834d09de39f8$var$_CanvasTextMetrics.graphemeSegmenter = (()=>{\n    if (typeof Intl?.Segmenter === \"function\") {\n        const segmenter = new Intl.Segmenter();\n        return (s)=>[\n                ...segmenter.segment(s)\n            ].map((x)=>x.segment);\n    }\n    return (s)=>[\n            ...s\n        ];\n})();\n/**\n * New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n * lead to more accurate letter-spacing results because it does not try to manually draw\n * each character. However, this Chrome API is experimental and may not serve all cases yet.\n * @see TextMetrics.experimentalLetterSpacingSupported\n */ $0a83834d09de39f8$var$_CanvasTextMetrics.experimentalLetterSpacing = false;\n/** Cache of {@see TextMetrics.FontMetrics} objects. */ $0a83834d09de39f8$var$_CanvasTextMetrics._fonts = {};\n/** Cache of new line chars. */ $0a83834d09de39f8$var$_CanvasTextMetrics._newlines = [\n    10,\n    // line feed\n    13\n];\n/** Cache of breaking spaces. */ $0a83834d09de39f8$var$_CanvasTextMetrics._breakingSpaces = [\n    9,\n    // character tabulation\n    32,\n    // space\n    8192,\n    // en quad\n    8193,\n    // em quad\n    8194,\n    // en space\n    8195,\n    // em space\n    8196,\n    // three-per-em space\n    8197,\n    // four-per-em space\n    8198,\n    // six-per-em space\n    8200,\n    // punctuation space\n    8201,\n    // thin space\n    8202,\n    // hair space\n    8287,\n    // medium mathematical space\n    12288\n];\n$0a83834d09de39f8$var$_CanvasTextMetrics._measurementCache = {};\nlet $0a83834d09de39f8$export$b12f6bdc825d944f = $0a83834d09de39f8$var$_CanvasTextMetrics;\n\n});\nparcelRegister(\"fMjVf\", function(module, exports) {\n\n$parcel$export(module.exports, \"fontStringFromTextStyle\", () => $a79c0b5192d6420f$export$b7b5edb82ac3fc66);\n\"use strict\";\nconst $a79c0b5192d6420f$var$genericFontFamilies = [\n    \"serif\",\n    \"sans-serif\",\n    \"monospace\",\n    \"cursive\",\n    \"fantasy\",\n    \"system-ui\"\n];\nfunction $a79c0b5192d6420f$export$b7b5edb82ac3fc66(style) {\n    const fontSizeString = typeof style.fontSize === \"number\" ? `${style.fontSize}px` : style.fontSize;\n    let fontFamilies = style.fontFamily;\n    if (!Array.isArray(style.fontFamily)) fontFamilies = style.fontFamily.split(\",\");\n    for(let i = fontFamilies.length - 1; i >= 0; i--){\n        let fontFamily = fontFamilies[i].trim();\n        if (!/([\\\"\\'])[^\\'\\\"]+\\1/.test(fontFamily) && !$a79c0b5192d6420f$var$genericFontFamilies.includes(fontFamily)) fontFamily = `\"${fontFamily}\"`;\n        fontFamilies[i] = fontFamily;\n    }\n    return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(\",\")}`;\n}\n\n});\n\n\nparcelRegister(\"eHP3T\", function(module, exports) {\n\n$parcel$export(module.exports, \"getCanvasFillStyle\", () => $3cff3a2aec2a5913$export$c31af9427fa8602b);\n\nvar $AHTcQ = parcelRequire(\"AHTcQ\");\n\nvar $dNaJE = parcelRequire(\"dNaJE\");\n\nvar $5h88T = parcelRequire(\"5h88T\");\n\nvar $8CF4q = parcelRequire(\"8CF4q\");\n\nvar $j8pAr = parcelRequire(\"j8pAr\");\n\nvar $hZTCO = parcelRequire(\"hZTCO\");\n\"use strict\";\nfunction $3cff3a2aec2a5913$export$c31af9427fa8602b(fillStyle, context) {\n    if (fillStyle.texture === (0, $5h88T.Texture).WHITE && !fillStyle.fill) return (0, $AHTcQ.Color).shared.setValue(fillStyle.color).toHex();\n    else if (!fillStyle.fill) {\n        const pattern = context.createPattern(fillStyle.texture.source.resource, \"repeat\");\n        const tempMatrix = fillStyle.matrix.copyTo((0, $dNaJE.Matrix).shared);\n        tempMatrix.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);\n        pattern.setTransform(tempMatrix);\n        return pattern;\n    } else if (fillStyle.fill instanceof (0, $hZTCO.FillPattern)) {\n        const fillPattern = fillStyle.fill;\n        const pattern = context.createPattern(fillPattern.texture.source.resource, \"repeat\");\n        const tempMatrix = fillPattern.transform.copyTo((0, $dNaJE.Matrix).shared);\n        tempMatrix.scale(fillPattern.texture.frame.width, fillPattern.texture.frame.height);\n        pattern.setTransform(tempMatrix);\n        return pattern;\n    } else if (fillStyle.fill instanceof (0, $j8pAr.FillGradient)) {\n        const fillGradient = fillStyle.fill;\n        if (fillGradient.type === \"linear\") {\n            const gradient = context.createLinearGradient(fillGradient.x0, fillGradient.y0, fillGradient.x1, fillGradient.y1);\n            fillGradient.gradientStops.forEach((stop)=>{\n                gradient.addColorStop(stop.offset, (0, $AHTcQ.Color).shared.setValue(stop.color).toHex());\n            });\n            return gradient;\n        }\n    }\n    (0, $8CF4q.warn)(\"FillStyle not recognised\", fillStyle);\n    return \"red\";\n}\n\n});\nparcelRegister(\"j8pAr\", function(module, exports) {\n\n$parcel$export(module.exports, \"FillGradient\", () => $d135c51a7b448ab0$export$722a6ea8c60ca86);\n\nvar $AHTcQ = parcelRequire(\"AHTcQ\");\n\nvar $5m2Qn = parcelRequire(\"5m2Qn\");\n\nvar $dNaJE = parcelRequire(\"dNaJE\");\n\nvar $4XrO5 = parcelRequire(\"4XrO5\");\n\nvar $5h88T = parcelRequire(\"5h88T\");\n\nvar $l80qL = parcelRequire(\"l80qL\");\n\"use strict\";\nconst $d135c51a7b448ab0$var$_FillGradient = class _FillGradient {\n    constructor(x0, y0, x1, y1){\n        this.uid = (0, $l80qL.uid)(\"fillGradient\");\n        this.type = \"linear\";\n        this.gradientStops = [];\n        this.x0 = x0;\n        this.y0 = y0;\n        this.x1 = x1;\n        this.y1 = y1;\n    }\n    addColorStop(offset, color) {\n        this.gradientStops.push({\n            offset: offset,\n            color: (0, $AHTcQ.Color).shared.setValue(color).toHex()\n        });\n        return this;\n    }\n    // TODO move to the system!\n    buildLinearGradient() {\n        const defaultSize = _FillGradient.defaultTextureSize;\n        const { gradientStops: gradientStops } = this;\n        const canvas = (0, $5m2Qn.DOMAdapter).get().createCanvas();\n        canvas.width = defaultSize;\n        canvas.height = defaultSize;\n        const ctx = canvas.getContext(\"2d\");\n        const gradient = ctx.createLinearGradient(0, 0, _FillGradient.defaultTextureSize, 1);\n        for(let i = 0; i < gradientStops.length; i++){\n            const stop = gradientStops[i];\n            gradient.addColorStop(stop.offset, stop.color);\n        }\n        ctx.fillStyle = gradient;\n        ctx.fillRect(0, 0, defaultSize, defaultSize);\n        this.texture = new (0, $5h88T.Texture)({\n            source: new (0, $4XrO5.ImageSource)({\n                resource: canvas,\n                addressModeU: \"clamp-to-edge\",\n                addressModeV: \"repeat\"\n            })\n        });\n        const { x0: x0, y0: y0, x1: x1, y1: y1 } = this;\n        const m = new (0, $dNaJE.Matrix)();\n        const dx = x1 - x0;\n        const dy = y1 - y0;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n        const angle = Math.atan2(dy, dx);\n        m.translate(-x0, -y0);\n        m.scale(1 / defaultSize, 1 / defaultSize);\n        m.rotate(-angle);\n        m.scale(256 / dist, 1);\n        this.transform = m;\n    }\n};\n$d135c51a7b448ab0$var$_FillGradient.defaultTextureSize = 256;\nlet $d135c51a7b448ab0$export$722a6ea8c60ca86 = $d135c51a7b448ab0$var$_FillGradient;\n\n});\n\nparcelRegister(\"hZTCO\", function(module, exports) {\n\n$parcel$export(module.exports, \"FillPattern\", () => $c2e39672a8752c63$export$3d1378c7410cd8e);\n\nvar $dNaJE = parcelRequire(\"dNaJE\");\n\nvar $l80qL = parcelRequire(\"l80qL\");\n\"use strict\";\nconst $c2e39672a8752c63$var$repetitionMap = {\n    repeat: {\n        addressModeU: \"repeat\",\n        addressModeV: \"repeat\"\n    },\n    \"repeat-x\": {\n        addressModeU: \"repeat\",\n        addressModeV: \"clamp-to-edge\"\n    },\n    \"repeat-y\": {\n        addressModeU: \"clamp-to-edge\",\n        addressModeV: \"repeat\"\n    },\n    \"no-repeat\": {\n        addressModeU: \"clamp-to-edge\",\n        addressModeV: \"clamp-to-edge\"\n    }\n};\nclass $c2e39672a8752c63$export$3d1378c7410cd8e {\n    constructor(texture, repetition){\n        this.uid = (0, $l80qL.uid)(\"fillPattern\");\n        this.transform = new (0, $dNaJE.Matrix)();\n        this.texture = texture;\n        this.transform.scale(1 / texture.frame.width, 1 / texture.frame.height);\n        if (repetition) {\n            texture.source.style.addressModeU = $c2e39672a8752c63$var$repetitionMap[repetition].addressModeU;\n            texture.source.style.addressModeV = $c2e39672a8752c63$var$repetitionMap[repetition].addressModeV;\n        }\n    }\n    setTransform(transform) {\n        const texture = this.texture;\n        this.transform.copyFrom(transform);\n        this.transform.invert();\n        this.transform.scale(1 / texture.frame.width, 1 / texture.frame.height);\n    }\n}\n\n});\n\n\n\n\nparcelRegister(\"8Sz72\", function(module, exports) {\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $1PcaQ = parcelRequire(\"1PcaQ\");\n\nvar $3SZLI = parcelRequire(\"3SZLI\");\n\"use strict\";\n(0, $eVz1R.extensions).add((0, $3SZLI.BitmapTextPipe), (0, $1PcaQ.loadBitmapFont), (0, $1PcaQ.bitmapFontCachePlugin));\n\n});\nparcelRegister(\"1PcaQ\", function(module, exports) {\n\n$parcel$export(module.exports, \"bitmapFontCachePlugin\", () => $8c18b5020edeff18$export$778a313228f06f6c);\n$parcel$export(module.exports, \"loadBitmapFont\", () => $8c18b5020edeff18$export$402edee29ac8bed4);\n\nvar $kuLtH = parcelRequire(\"kuLtH\");\n\nvar $kY7V1 = parcelRequire(\"kY7V1\");\n\nvar $5m2Qn = parcelRequire(\"5m2Qn\");\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $kaDu9 = parcelRequire(\"kaDu9\");\n\nvar $7zh1j = parcelRequire(\"7zh1j\");\n\nvar $3RsiR = parcelRequire(\"3RsiR\");\n\nvar $9m29S = parcelRequire(\"9m29S\");\n\"use strict\";\nconst $8c18b5020edeff18$var$validExtensions = [\n    \".xml\",\n    \".fnt\"\n];\nconst $8c18b5020edeff18$export$778a313228f06f6c = {\n    extension: (0, $eVz1R.ExtensionType).CacheParser,\n    test: (asset)=>asset instanceof (0, $7zh1j.BitmapFont),\n    getCacheableAssets (keys, asset) {\n        const out = {};\n        keys.forEach((key)=>{\n            out[key] = asset;\n        });\n        out[`${asset.fontFamily}-bitmap`] = asset;\n        return out;\n    }\n};\nconst $8c18b5020edeff18$export$402edee29ac8bed4 = {\n    extension: {\n        type: (0, $eVz1R.ExtensionType).LoadParser,\n        priority: (0, $kuLtH.LoaderParserPriority).Normal\n    },\n    test (url) {\n        return $8c18b5020edeff18$var$validExtensions.includes((0, $kaDu9.path).extname(url).toLowerCase());\n    },\n    async testParse (data) {\n        return (0, $3RsiR.bitmapFontTextParser).test(data) || (0, $9m29S.bitmapFontXMLStringParser).test(data);\n    },\n    async parse (asset, data, loader) {\n        const bitmapFontData = (0, $3RsiR.bitmapFontTextParser).test(asset) ? (0, $3RsiR.bitmapFontTextParser).parse(asset) : (0, $9m29S.bitmapFontXMLStringParser).parse(asset);\n        const { src: src } = data;\n        const { pages: pages } = bitmapFontData;\n        const textureUrls = [];\n        for(let i = 0; i < pages.length; ++i){\n            const pageFile = pages[i].file;\n            let imagePath = (0, $kaDu9.path).join((0, $kaDu9.path).dirname(src), pageFile);\n            imagePath = (0, $kY7V1.copySearchParams)(imagePath, src);\n            textureUrls.push(imagePath);\n        }\n        const loadedTextures = await loader.load(textureUrls);\n        const textures = textureUrls.map((url)=>loadedTextures[url]);\n        const bitmapFont = new (0, $7zh1j.BitmapFont)({\n            data: bitmapFontData,\n            textures: textures\n        }, src);\n        return bitmapFont;\n    },\n    async load (url, _options) {\n        const response = await (0, $5m2Qn.DOMAdapter).get().fetch(url);\n        return await response.text();\n    },\n    async unload (bitmapFont, _resolvedAsset, loader) {\n        await Promise.all(bitmapFont.pages.map((page)=>loader.unload(page.texture.source._sourceOrigin)));\n        bitmapFont.destroy();\n    }\n};\n\n});\nparcelRegister(\"7zh1j\", function(module, exports) {\n\n$parcel$export(module.exports, \"BitmapFont\", () => $590c071e7d86b569$export$17957a09927cadc7);\n\nvar $soqVu = parcelRequire(\"soqVu\");\n\nvar $5h88T = parcelRequire(\"5h88T\");\n\nvar $gs09t = parcelRequire(\"gs09t\");\n\nvar $1TcZG = parcelRequire(\"1TcZG\");\n\"use strict\";\nclass $590c071e7d86b569$export$17957a09927cadc7 extends (0, $gs09t.AbstractBitmapFont) {\n    constructor(options, url){\n        super();\n        const { textures: textures, data: data } = options;\n        Object.keys(data.pages).forEach((key)=>{\n            const pageData = data.pages[parseInt(key, 10)];\n            const texture = textures[pageData.id];\n            this.pages.push({\n                texture: texture\n            });\n        });\n        Object.keys(data.chars).forEach((key)=>{\n            const charData = data.chars[key];\n            const textureSource = textures[charData.page].source;\n            const frameReal = new (0, $soqVu.Rectangle)(charData.x, charData.y, charData.width, charData.height);\n            const texture = new (0, $5h88T.Texture)({\n                source: textureSource,\n                frame: frameReal\n            });\n            this.chars[key] = {\n                id: key.codePointAt(0),\n                xOffset: charData.xOffset,\n                yOffset: charData.yOffset,\n                xAdvance: charData.xAdvance,\n                kerning: charData.kerning ?? {},\n                texture: texture\n            };\n        });\n        this.baseRenderedFontSize = data.fontSize;\n        this.baseMeasurementFontSize = data.fontSize;\n        this.fontMetrics = {\n            ascent: 0,\n            descent: 0,\n            fontSize: data.fontSize\n        };\n        this.baseLineOffset = data.baseLineOffset;\n        this.lineHeight = data.lineHeight;\n        this.fontFamily = data.fontFamily;\n        this.distanceField = data.distanceField ?? {\n            type: \"none\",\n            range: 0\n        };\n        this.url = url;\n    }\n    /** Destroys the BitmapFont object. */ destroy() {\n        super.destroy();\n        for(let i = 0; i < this.pages.length; i++){\n            const { texture: texture } = this.pages[i];\n            texture.destroy(true);\n        }\n        this.pages = null;\n    }\n    /**\n   * Generates a bitmap-font for the given style and character set\n   * @param options - Setup options for font generation.\n   * @returns Font generated by style options.\n   * @example\n   * import { BitmapFont, BitmapText } from 'pixi.js';\n   *\n   * BitmapFont.install('TitleFont', {\n   *     fontFamily: 'Arial',\n   *     fontSize: 12,\n   *     strokeThickness: 2,\n   *     fill: 'purple',\n   * });\n   *\n   * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });\n   */ static install(options) {\n        (0, $1TcZG.BitmapFontManager).install(options);\n    }\n    /**\n   * Uninstalls a bitmap font from the cache.\n   * @param {string} name - The name of the bitmap font to uninstall.\n   */ static uninstall(name) {\n        (0, $1TcZG.BitmapFontManager).uninstall(name);\n    }\n}\n\n});\nparcelRegister(\"gs09t\", function(module, exports) {\n\n$parcel$export(module.exports, \"AbstractBitmapFont\", () => $c82cc5325e5b223b$export$70779aee6e4c1309);\n\nvar $gpXaq = parcelRequire(\"gpXaq\");\n\nvar $eX50w = parcelRequire(\"eX50w\");\n\"use strict\";\nclass $c82cc5325e5b223b$export$70779aee6e4c1309 extends (0, (/*@__PURE__*/$parcel$interopDefault($gpXaq))) {\n    constructor(){\n        super(...arguments);\n        /** The map of characters by character code. */ this.chars = /* @__PURE__ */ Object.create(null);\n        /**\n     * The line-height of the font face in pixels.\n     * @type {number}\n     */ this.lineHeight = 0;\n        /**\n     * The name of the font face\n     * @type {string}\n     */ this.fontFamily = \"\";\n        /** The metrics of the font face. */ this.fontMetrics = {\n            fontSize: 0,\n            ascent: 0,\n            descent: 0\n        };\n        /**\n     * The offset of the font face from the baseline.\n     * @type {number}\n     */ this.baseLineOffset = 0;\n        /** The range and type of the distance field for this font. */ this.distanceField = {\n            type: \"none\",\n            range: 0\n        };\n        /** The map of base page textures (i.e., sheets of glyphs). */ this.pages = [];\n        /** The size of the font face in pixels. */ this.baseMeasurementFontSize = 100;\n        this.baseRenderedFontSize = 100;\n    }\n    /**\n   * The name of the font face.\n   * @deprecated since 8.0.0 Use `fontFamily` instead.\n   */ get font() {\n        (0, $eX50w.deprecation)((0, $eX50w.v8_0_0), \"BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.\");\n        return this.fontFamily;\n    }\n    /**\n   * The map of base page textures (i.e., sheets of glyphs).\n   * @deprecated since 8.0.0 Use `pages` instead.\n   */ get pageTextures() {\n        (0, $eX50w.deprecation)((0, $eX50w.v8_0_0), \"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.\");\n        return this.pages;\n    }\n    /**\n   * The size of the font face in pixels.\n   * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.\n   */ get size() {\n        (0, $eX50w.deprecation)((0, $eX50w.v8_0_0), \"BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.\");\n        return this.fontMetrics.fontSize;\n    }\n    /**\n   * The kind of distance field for this font or \"none\".\n   * @deprecated since 8.0.0 Use `distanceField.type` instead.\n   */ get distanceFieldRange() {\n        (0, $eX50w.deprecation)((0, $eX50w.v8_0_0), \"BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.\");\n        return this.distanceField.range;\n    }\n    /**\n   * The range of the distance field in pixels.\n   * @deprecated since 8.0.0 Use `distanceField.range` instead.\n   */ get distanceFieldType() {\n        (0, $eX50w.deprecation)((0, $eX50w.v8_0_0), \"BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.\");\n        return this.distanceField.type;\n    }\n    destroy(destroyTextures = false) {\n        this.emit(\"destroy\", this);\n        this.removeAllListeners();\n        for(const i in this.chars)this.chars[i].texture.destroy();\n        this.chars = null;\n        if (destroyTextures) {\n            this.pages.forEach((page)=>page.texture.destroy(true));\n            this.pages = null;\n        }\n    }\n}\n\n});\n\nparcelRegister(\"1TcZG\", function(module, exports) {\n\n$parcel$export(module.exports, \"BitmapFontManager\", () => $2163057b3bc5778f$export$d2ee57cdc0e1ed7f);\n\nvar $gYSnF = parcelRequire(\"gYSnF\");\n\nvar $eX50w = parcelRequire(\"eX50w\");\n\nvar $itLJu = parcelRequire(\"itLJu\");\n\nvar $54k6R = parcelRequire(\"54k6R\");\n\nvar $eGMbi = parcelRequire(\"eGMbi\");\n\nvar $7gvRa = parcelRequire(\"7gvRa\");\n\"use strict\";\nclass $2163057b3bc5778f$var$BitmapFontManagerClass {\n    constructor(){\n        /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.ALPHA })\n     */ this.ALPHA = [\n            [\n                \"a\",\n                \"z\"\n            ],\n            [\n                \"A\",\n                \"Z\"\n            ],\n            \" \"\n        ];\n        /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })\n     */ this.NUMERIC = [\n            [\n                \"0\",\n                \"9\"\n            ]\n        ];\n        /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */ this.ALPHANUMERIC = [\n            [\n                \"a\",\n                \"z\"\n            ],\n            [\n                \"A\",\n                \"Z\"\n            ],\n            [\n                \"0\",\n                \"9\"\n            ],\n            \" \"\n        ];\n        /**\n     * This character set consists of all the ASCII table.\n     * @member {string[][]}\n     * @see http://www.asciitable.com/\n     */ this.ASCII = [\n            [\n                \" \",\n                \"~\"\n            ]\n        ];\n        /** Default options for installing a new BitmapFont. */ this.defaultOptions = {\n            chars: this.ALPHANUMERIC,\n            resolution: 1,\n            padding: 4,\n            skipKerning: false\n        };\n    }\n    /**\n   * Get a font for the specified text and style.\n   * @param text - The text to get the font for\n   * @param style - The style to use\n   */ getFont(text, style) {\n        let fontFamilyKey = `${style.fontFamily}-bitmap`;\n        let overrideFill = true;\n        if (style._fill.fill) {\n            fontFamilyKey += style._fill.fill.uid;\n            overrideFill = false;\n        }\n        if (!(0, $gYSnF.Cache).has(fontFamilyKey)) {\n            const fnt = new (0, $54k6R.DynamicBitmapFont)({\n                style: style,\n                overrideFill: overrideFill,\n                overrideSize: true,\n                ...this.defaultOptions\n            });\n            fnt.once(\"destroy\", ()=>(0, $gYSnF.Cache).remove(fontFamilyKey));\n            (0, $gYSnF.Cache).set(fontFamilyKey, fnt);\n        }\n        const dynamicFont = (0, $gYSnF.Cache).get(fontFamilyKey);\n        dynamicFont.ensureCharacters?.(text);\n        return dynamicFont;\n    }\n    /**\n   * Get the layout of a text for the specified style.\n   * @param text - The text to get the layout for\n   * @param style - The style to use\n   */ getLayout(text, style) {\n        const bitmapFont = this.getFont(text, style);\n        return (0, $eGMbi.getBitmapTextLayout)(text.split(\"\"), style, bitmapFont);\n    }\n    /**\n   * Measure the text using the specified style.\n   * @param text - The text to measure\n   * @param style - The style to use\n   */ measureText(text, style) {\n        return this.getLayout(text, style);\n    }\n    // eslint-disable-next-line max-len\n    install(...args) {\n        let options = args[0];\n        if (typeof options === \"string\") {\n            options = {\n                name: options,\n                style: args[1],\n                chars: args[2]?.chars,\n                resolution: args[2]?.resolution,\n                padding: args[2]?.padding,\n                skipKerning: args[2]?.skipKerning\n            };\n            (0, $eX50w.deprecation)((0, $eX50w.v8_0_0), \"BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})\");\n        }\n        const name = options?.name;\n        if (!name) throw new Error(\"[BitmapFontManager] Property `name` is required.\");\n        options = {\n            ...this.defaultOptions,\n            ...options\n        };\n        const textStyle = options.style;\n        const style = textStyle instanceof (0, $itLJu.TextStyle) ? textStyle : new (0, $itLJu.TextStyle)(textStyle);\n        const overrideFill = style._fill.fill !== null && style._fill.fill !== void 0;\n        const font = new (0, $54k6R.DynamicBitmapFont)({\n            style: style,\n            overrideFill: overrideFill,\n            skipKerning: options.skipKerning,\n            padding: options.padding,\n            resolution: options.resolution,\n            overrideSize: false\n        });\n        const flatChars = (0, $7gvRa.resolveCharacters)(options.chars);\n        font.ensureCharacters(flatChars.join(\"\"));\n        (0, $gYSnF.Cache).set(`${name}-bitmap`, font);\n        font.once(\"destroy\", ()=>(0, $gYSnF.Cache).remove(`${name}-bitmap`));\n        return font;\n    }\n    /**\n   * Uninstalls a bitmap font from the cache.\n   * @param {string} name - The name of the bitmap font to uninstall.\n   */ uninstall(name) {\n        const cacheKey = `${name}-bitmap`;\n        const font = (0, $gYSnF.Cache).get(cacheKey);\n        if (font) {\n            (0, $gYSnF.Cache).remove(cacheKey);\n            font.destroy();\n        }\n    }\n}\nconst $2163057b3bc5778f$export$d2ee57cdc0e1ed7f = new $2163057b3bc5778f$var$BitmapFontManagerClass();\n\n});\nparcelRegister(\"itLJu\", function(module, exports) {\n\n$parcel$export(module.exports, \"TextStyle\", () => $679bde1e0a9776b1$export$1df879243bf2e42d);\n\nvar $gpXaq = parcelRequire(\"gpXaq\");\n\nvar $AHTcQ = parcelRequire(\"AHTcQ\");\n\nvar $eX50w = parcelRequire(\"eX50w\");\n\nvar $j8pAr = parcelRequire(\"j8pAr\");\n\nvar $hTvsP = parcelRequire(\"hTvsP\");\n\nvar $jwZTp = parcelRequire(\"jwZTp\");\n\nvar $gSm2a = parcelRequire(\"gSm2a\");\n\"use strict\";\nconst $679bde1e0a9776b1$var$_TextStyle = class _TextStyle extends (0, (/*@__PURE__*/$parcel$interopDefault($gpXaq))) {\n    constructor(style = {}){\n        super();\n        $679bde1e0a9776b1$var$convertV7Tov8Style(style);\n        const fullStyle = {\n            ..._TextStyle.defaultTextStyle,\n            ...style\n        };\n        for(const key in fullStyle){\n            const thisKey = key;\n            this[thisKey] = fullStyle[key];\n        }\n        this.update();\n    }\n    /**\n   * Alignment for multiline text, does not affect single line text.\n   * @member {'left'|'center'|'right'|'justify'}\n   */ get align() {\n        return this._align;\n    }\n    set align(value) {\n        this._align = value;\n        this.update();\n    }\n    /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */ get breakWords() {\n        return this._breakWords;\n    }\n    set breakWords(value) {\n        this._breakWords = value;\n        this.update();\n    }\n    /** Set a drop shadow for the text. */ get dropShadow() {\n        return this._dropShadow;\n    }\n    set dropShadow(value) {\n        if (value !== null && typeof value === \"object\") this._dropShadow = {\n            ..._TextStyle.defaultDropShadow,\n            ...value\n        };\n        else this._dropShadow = value ? {\n            ..._TextStyle.defaultDropShadow\n        } : null;\n        this.update();\n    }\n    /** The font family, can be a single font name, or a list of names where the first is the preferred font. */ get fontFamily() {\n        return this._fontFamily;\n    }\n    set fontFamily(value) {\n        this._fontFamily = value;\n        this.update();\n    }\n    /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */ get fontSize() {\n        return this._fontSize;\n    }\n    set fontSize(value) {\n        if (typeof value === \"string\") this._fontSize = parseInt(value, 10);\n        else this._fontSize = value;\n        this.update();\n    }\n    /**\n   * The font style.\n   * @member {'normal'|'italic'|'oblique'}\n   */ get fontStyle() {\n        return this._fontStyle;\n    }\n    set fontStyle(value) {\n        this._fontStyle = value;\n        this.update();\n    }\n    /**\n   * The font variant.\n   * @member {'normal'|'small-caps'}\n   */ get fontVariant() {\n        return this._fontVariant;\n    }\n    set fontVariant(value) {\n        this._fontVariant = value;\n        this.update();\n    }\n    /**\n   * The font weight.\n   * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n   */ get fontWeight() {\n        return this._fontWeight;\n    }\n    set fontWeight(value) {\n        this._fontWeight = value;\n        this.update();\n    }\n    /** The space between lines. */ get leading() {\n        return this._leading;\n    }\n    set leading(value) {\n        this._leading = value;\n        this.update();\n    }\n    /** The amount of spacing between letters, default is 0. */ get letterSpacing() {\n        return this._letterSpacing;\n    }\n    set letterSpacing(value) {\n        this._letterSpacing = value;\n        this.update();\n    }\n    /** The line height, a number that represents the vertical space that a letter uses. */ get lineHeight() {\n        return this._lineHeight;\n    }\n    set lineHeight(value) {\n        this._lineHeight = value;\n        this.update();\n    }\n    /**\n   * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n   * by adding padding to all sides of the text.\n   */ get padding() {\n        return this._padding;\n    }\n    set padding(value) {\n        this._padding = value;\n        this.update();\n    }\n    /** Trim transparent borders. This is an expensive operation so only use this if you have to! */ get trim() {\n        return this._trim;\n    }\n    set trim(value) {\n        this._trim = value;\n        this.update();\n    }\n    /**\n   * The baseline of the text that is rendered.\n   * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n   */ get textBaseline() {\n        return this._textBaseline;\n    }\n    set textBaseline(value) {\n        this._textBaseline = value;\n        this.update();\n    }\n    /**\n   * How newlines and spaces should be handled.\n   * Default is 'pre' (preserve, preserve).\n   *\n   *  value       | New lines     |   Spaces\n   *  ---         | ---           |   ---\n   * 'normal'     | Collapse      |   Collapse\n   * 'pre'        | Preserve      |   Preserve\n   * 'pre-line'   | Preserve      |   Collapse\n   * @member {'normal'|'pre'|'pre-line'}\n   */ get whiteSpace() {\n        return this._whiteSpace;\n    }\n    set whiteSpace(value) {\n        this._whiteSpace = value;\n        this.update();\n    }\n    /** Indicates if word wrap should be used. */ get wordWrap() {\n        return this._wordWrap;\n    }\n    set wordWrap(value) {\n        this._wordWrap = value;\n        this.update();\n    }\n    /** The width at which text will wrap, it needs wordWrap to be set to true. */ get wordWrapWidth() {\n        return this._wordWrapWidth;\n    }\n    set wordWrapWidth(value) {\n        this._wordWrapWidth = value;\n        this.update();\n    }\n    /** A fillstyle that will be used on the text e.g., 'red', '#00FF00'. */ get fill() {\n        return this._originalFill;\n    }\n    set fill(value) {\n        if (value === this._originalFill) return;\n        this._originalFill = value;\n        this._fill = (0, $jwZTp.convertFillInputToFillStyle)(value === 0 ? \"black\" : value, (0, $hTvsP.GraphicsContext).defaultFillStyle);\n        this.update();\n    }\n    /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */ get stroke() {\n        return this._originalStroke;\n    }\n    set stroke(value) {\n        if (value === this._originalStroke) return;\n        this._originalStroke = value;\n        this._stroke = (0, $jwZTp.convertFillInputToFillStyle)(value, (0, $hTvsP.GraphicsContext).defaultStrokeStyle);\n        this.update();\n    }\n    _generateKey() {\n        this._styleKey = (0, $gSm2a.generateTextStyleKey)(this);\n        return this._styleKey;\n    }\n    update() {\n        this._styleKey = null;\n        this.emit(\"update\", this);\n    }\n    /** Resets all properties to the default values */ reset() {\n        const defaultStyle = _TextStyle.defaultTextStyle;\n        for(const key in defaultStyle)this[key] = defaultStyle[key];\n    }\n    get styleKey() {\n        return this._styleKey || this._generateKey();\n    }\n    /**\n   * Creates a new TextStyle object with the same values as this one.\n   * @returns New cloned TextStyle object\n   */ clone() {\n        return new _TextStyle({\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this.dropShadow,\n            fill: this._fill,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            leading: this.leading,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke,\n            textBaseline: this.textBaseline,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth\n        });\n    }\n    /**\n   * Destroys this text style.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style\n   */ destroy(options = false) {\n        this.removeAllListeners();\n        const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n        if (destroyTexture) {\n            const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n            if (this._fill?.texture) this._fill.texture.destroy(destroyTextureSource);\n            if (this._originalFill?.texture) this._originalFill.texture.destroy(destroyTextureSource);\n            if (this._stroke?.texture) this._stroke.texture.destroy(destroyTextureSource);\n            if (this._originalStroke?.texture) this._originalStroke.texture.destroy(destroyTextureSource);\n        }\n        this._fill = null;\n        this._stroke = null;\n        this.dropShadow = null;\n        this._originalStroke = null;\n        this._originalFill = null;\n    }\n};\n/** The default drop shadow settings */ $679bde1e0a9776b1$var$_TextStyle.defaultDropShadow = {\n    /** Set alpha for the drop shadow */ alpha: 1,\n    /** Set a angle of the drop shadow */ angle: Math.PI / 6,\n    /** Set a shadow blur radius */ blur: 0,\n    /** A fill style to be used on the  e.g., 'red', '#00FF00' */ color: \"black\",\n    /** Set a distance of the drop shadow */ distance: 5\n};\n/** The default text style settings */ $679bde1e0a9776b1$var$_TextStyle.defaultTextStyle = {\n    /**\n   * See {@link TextStyle.align}\n   * @type {'left'|'center'|'right'|'justify'}\n   */ align: \"left\",\n    /** See {@link TextStyle.breakWords} */ breakWords: false,\n    /** See {@link TextStyle.dropShadow} */ dropShadow: null,\n    /**\n   * See {@link TextStyle.fill}\n   * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n   */ fill: \"black\",\n    /**\n   * See {@link TextStyle.fontFamily}\n   * @type {string|string[]}\n   */ fontFamily: \"Arial\",\n    /**\n   * See {@link TextStyle.fontSize}\n   * @type {number|string}\n   */ fontSize: 26,\n    /**\n   * See {@link TextStyle.fontStyle}\n   * @type {'normal'|'italic'|'oblique'}\n   */ fontStyle: \"normal\",\n    /**\n   * See {@link TextStyle.fontVariant}\n   * @type {'normal'|'small-caps'}\n   */ fontVariant: \"normal\",\n    /**\n   * See {@link TextStyle.fontWeight}\n   * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n   */ fontWeight: \"normal\",\n    /** See {@link TextStyle.leading} */ leading: 0,\n    /** See {@link TextStyle.letterSpacing} */ letterSpacing: 0,\n    /** See {@link TextStyle.lineHeight} */ lineHeight: 0,\n    /** See {@link TextStyle.padding} */ padding: 0,\n    /**\n   * See {@link TextStyle.stroke}\n   * @type {string|number}\n   */ stroke: null,\n    /**\n   * See {@link TextStyle.textBaseline}\n   * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n   */ textBaseline: \"alphabetic\",\n    /** See {@link TextStyle.trim} */ trim: false,\n    /**\n   * See {@link TextStyle.whiteSpace}\n   * @type {'normal'|'pre'|'pre-line'}\n   */ whiteSpace: \"pre\",\n    /** See {@link TextStyle.wordWrap} */ wordWrap: false,\n    /** See {@link TextStyle.wordWrapWidth} */ wordWrapWidth: 100\n};\nlet $679bde1e0a9776b1$export$1df879243bf2e42d = $679bde1e0a9776b1$var$_TextStyle;\nfunction $679bde1e0a9776b1$var$convertV7Tov8Style(style) {\n    const oldStyle = style;\n    if (typeof oldStyle.dropShadow === \"boolean\" && oldStyle.dropShadow) {\n        const defaults = $679bde1e0a9776b1$export$1df879243bf2e42d.defaultDropShadow;\n        style.dropShadow = {\n            alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,\n            angle: oldStyle.dropShadowAngle ?? defaults.angle,\n            blur: oldStyle.dropShadowBlur ?? defaults.blur,\n            color: oldStyle.dropShadowColor ?? defaults.color,\n            distance: oldStyle.dropShadowDistance ?? defaults.distance\n        };\n    }\n    if (oldStyle.strokeThickness) {\n        (0, $eX50w.deprecation)((0, $eX50w.v8_0_0), \"strokeThickness is now a part of stroke\");\n        const color = oldStyle.stroke;\n        style.stroke = {\n            color: color,\n            width: oldStyle.strokeThickness\n        };\n    }\n    if (Array.isArray(oldStyle.fill)) {\n        (0, $eX50w.deprecation)((0, $eX50w.v8_0_0), \"gradient fill is now a fill pattern: `new FillGradient(...)`\");\n        const gradientFill = new (0, $j8pAr.FillGradient)(0, 0, 0, style.fontSize * 1.7);\n        const fills = oldStyle.fill.map((color)=>(0, $AHTcQ.Color).shared.setValue(color).toNumber());\n        fills.forEach((number, index)=>{\n            const ratio = oldStyle.fillGradientStops[index] ?? index / fills.length;\n            gradientFill.addColorStop(ratio, number);\n        });\n        style.fill = {\n            fill: gradientFill\n        };\n    }\n}\n\n});\nparcelRegister(\"hTvsP\", function(module, exports) {\n\n$parcel$export(module.exports, \"GraphicsContext\", () => $f12b5912014640d6$export$cde35afe8b5f985);\n\nvar $gpXaq = parcelRequire(\"gpXaq\");\n\nvar $AHTcQ = parcelRequire(\"AHTcQ\");\n\nvar $dNaJE = parcelRequire(\"dNaJE\");\n\nvar $2NXni = parcelRequire(\"2NXni\");\n\nvar $5h88T = parcelRequire(\"5h88T\");\n\nvar $l80qL = parcelRequire(\"l80qL\");\n\nvar $eX50w = parcelRequire(\"eX50w\");\n\nvar $ggeMF = parcelRequire(\"ggeMF\");\n\nvar $awDzm = parcelRequire(\"awDzm\");\n\nvar $hFJzr = parcelRequire(\"hFJzr\");\n\nvar $jwZTp = parcelRequire(\"jwZTp\");\n\"use strict\";\nconst $f12b5912014640d6$var$tmpPoint = new (0, $2NXni.Point)();\nconst $f12b5912014640d6$var$tempMatrix = new (0, $dNaJE.Matrix)();\nconst $f12b5912014640d6$var$_GraphicsContext = class _GraphicsContext extends (0, (/*@__PURE__*/$parcel$interopDefault($gpXaq))) {\n    constructor(){\n        super(...arguments);\n        this.uid = (0, $l80qL.uid)(\"graphicsContext\");\n        this.dirty = true;\n        this.batchMode = \"auto\";\n        this.instructions = [];\n        this._activePath = new (0, $awDzm.GraphicsPath)();\n        this._transform = new (0, $dNaJE.Matrix)();\n        this._fillStyle = {\n            ..._GraphicsContext.defaultFillStyle\n        };\n        this._strokeStyle = {\n            ..._GraphicsContext.defaultStrokeStyle\n        };\n        this._stateStack = [];\n        this._tick = 0;\n        this._bounds = new (0, $ggeMF.Bounds)();\n        this._boundsDirty = true;\n    }\n    /**\n   * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,\n   * including the current drawing state, transformations, styles, and instructions.\n   * @returns A new GraphicsContext instance with the same properties and state as this one.\n   */ clone() {\n        const clone = new _GraphicsContext();\n        clone.batchMode = this.batchMode;\n        clone.instructions = this.instructions.slice();\n        clone._activePath = this._activePath.clone();\n        clone._transform = this._transform.clone();\n        clone._fillStyle = {\n            ...this._fillStyle\n        };\n        clone._strokeStyle = {\n            ...this._strokeStyle\n        };\n        clone._stateStack = this._stateStack.slice();\n        clone._bounds = this._bounds.clone();\n        clone._boundsDirty = true;\n        return clone;\n    }\n    /**\n   * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.\n   */ get fillStyle() {\n        return this._fillStyle;\n    }\n    set fillStyle(value) {\n        this._fillStyle = (0, $jwZTp.convertFillInputToFillStyle)(value, _GraphicsContext.defaultFillStyle);\n    }\n    /**\n   * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   */ get strokeStyle() {\n        return this._strokeStyle;\n    }\n    set strokeStyle(value) {\n        this._strokeStyle = (0, $jwZTp.convertFillInputToFillStyle)(value, _GraphicsContext.defaultStrokeStyle);\n    }\n    /**\n   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n   * pattern, or a more complex style defined by a FillStyle object.\n   * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,\n   *                or a FillStyle or ConvertedFillStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ setFillStyle(style) {\n        this._fillStyle = (0, $jwZTp.convertFillInputToFillStyle)(style, _GraphicsContext.defaultFillStyle);\n        return this;\n    }\n    /**\n   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n   *                or a StrokeStyle or ConvertedStrokeStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ setStrokeStyle(style) {\n        this._strokeStyle = (0, $jwZTp.convertFillInputToFillStyle)(style, _GraphicsContext.defaultStrokeStyle);\n        return this;\n    }\n    texture(texture, tint, dx, dy, dw, dh) {\n        this.instructions.push({\n            action: \"texture\",\n            data: {\n                image: texture,\n                dx: dx || 0,\n                dy: dy || 0,\n                dw: dw || texture.frame.width,\n                dh: dh || texture.frame.height,\n                transform: this._transform.clone(),\n                alpha: this._fillStyle.alpha,\n                style: tint ? (0, $AHTcQ.Color).shared.setValue(tint).toNumber() : 16777215\n            }\n        });\n        this.onUpdate();\n        return this;\n    }\n    /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ beginPath() {\n        this._activePath = new (0, $awDzm.GraphicsPath)();\n        return this;\n    }\n    fill(style, alpha) {\n        let path;\n        const lastInstruction = this.instructions[this.instructions.length - 1];\n        if (this._tick === 0 && lastInstruction && lastInstruction.action === \"stroke\") path = lastInstruction.data.path;\n        else path = this._activePath.clone();\n        if (!path) return this;\n        if (style != null) {\n            if (alpha !== void 0 && typeof style === \"number\") {\n                (0, $eX50w.deprecation)((0, $eX50w.v8_0_0), \"GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead\");\n                style = {\n                    color: style,\n                    alpha: alpha\n                };\n            }\n            this._fillStyle = (0, $jwZTp.convertFillInputToFillStyle)(style, _GraphicsContext.defaultFillStyle);\n        }\n        this.instructions.push({\n            action: \"fill\",\n            // TODO copy fill style!\n            data: {\n                style: this.fillStyle,\n                path: path\n            }\n        });\n        this.onUpdate();\n        this._initNextPathLocation();\n        this._tick = 0;\n        return this;\n    }\n    _initNextPathLocation() {\n        const { x: x, y: y } = this._activePath.getLastPoint((0, $2NXni.Point).shared);\n        this._activePath.clear();\n        this._activePath.moveTo(x, y);\n    }\n    /**\n   * Strokes the current path with the current stroke style. This method can take an optional\n   * FillStyleInputs parameter to define the stroke's appearance, including its color, width, and other properties.\n   * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ stroke(style) {\n        let path;\n        const lastInstruction = this.instructions[this.instructions.length - 1];\n        if (this._tick === 0 && lastInstruction && lastInstruction.action === \"fill\") path = lastInstruction.data.path;\n        else path = this._activePath.clone();\n        if (!path) return this;\n        if (style != null) this._strokeStyle = (0, $jwZTp.convertFillInputToFillStyle)(style, _GraphicsContext.defaultStrokeStyle);\n        this.instructions.push({\n            action: \"stroke\",\n            // TODO copy fill style!\n            data: {\n                style: this.strokeStyle,\n                path: path\n            }\n        });\n        this.onUpdate();\n        this._initNextPathLocation();\n        this._tick = 0;\n        return this;\n    }\n    /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n   * fail to cut correctly!\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ cut() {\n        for(let i = 0; i < 2; i++){\n            const lastInstruction = this.instructions[this.instructions.length - 1 - i];\n            const holePath = this._activePath.clone();\n            if (lastInstruction) {\n                if (lastInstruction.action === \"stroke\" || lastInstruction.action === \"fill\") {\n                    if (lastInstruction.data.hole) lastInstruction.data.hole.addPath(holePath);\n                    else {\n                        lastInstruction.data.hole = holePath;\n                        break;\n                    }\n                }\n            }\n        }\n        this._initNextPathLocation();\n        return this;\n    }\n    /**\n   * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n   * starting and ending angles, and direction.\n   * @param x - The x-coordinate of the arc's center.\n   * @param y - The y-coordinate of the arc's center.\n   * @param radius - The arc's radius.\n   * @param startAngle - The starting angle, in radians.\n   * @param endAngle - The ending angle, in radians.\n   * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n        this._tick++;\n        const t = this._transform;\n        this._activePath.arc(t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty, radius, startAngle, endAngle, counterclockwise);\n        return this;\n    }\n    /**\n   * Adds an arc to the current path with the given control points and radius, connected to the previous point\n   * by a straight line if necessary.\n   * @param x1 - The x-coordinate of the first control point.\n   * @param y1 - The y-coordinate of the first control point.\n   * @param x2 - The x-coordinate of the second control point.\n   * @param y2 - The y-coordinate of the second control point.\n   * @param radius - The arc's radius.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ arcTo(x1, y1, x2, y2, radius) {\n        this._tick++;\n        const t = this._transform;\n        this._activePath.arcTo(t.a * x1 + t.c * y1 + t.tx, t.b * x1 + t.d * y1 + t.ty, t.a * x2 + t.c * y2 + t.tx, t.b * x2 + t.d * y2 + t.ty, radius);\n        return this;\n    }\n    /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc's end point.\n   * @param y - The y-coordinate of the arc's end point.\n   * @returns The instance of the current object for chaining.\n   */ arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n        this._tick++;\n        const t = this._transform;\n        this._activePath.arcToSvg(rx, ry, xAxisRotation, // should we rotate this with transform??\n        largeArcFlag, sweepFlag, t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty);\n        return this;\n    }\n    /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */ bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n        this._tick++;\n        const t = this._transform;\n        this._activePath.bezierCurveTo(t.a * cp1x + t.c * cp1y + t.tx, t.b * cp1x + t.d * cp1y + t.ty, t.a * cp2x + t.c * cp2y + t.tx, t.b * cp2x + t.d * cp2y + t.ty, t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty, smoothness);\n        return this;\n    }\n    /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */ closePath() {\n        this._tick++;\n        this._activePath?.closePath();\n        return this;\n    }\n    /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @returns The instance of the current object for chaining.\n   */ ellipse(x, y, radiusX, radiusY) {\n        this._tick++;\n        this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());\n        return this;\n    }\n    /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @returns The instance of the current object for chaining.\n   */ circle(x, y, radius) {\n        this._tick++;\n        this._activePath.circle(x, y, radius, this._transform.clone());\n        return this;\n    }\n    /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @returns The instance of the current object for chaining.\n   */ path(path) {\n        this._tick++;\n        this._activePath.addPath(path, this._transform.clone());\n        return this;\n    }\n    /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */ lineTo(x, y) {\n        this._tick++;\n        const t = this._transform;\n        this._activePath.lineTo(t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty);\n        return this;\n    }\n    /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */ moveTo(x, y) {\n        this._tick++;\n        const t = this._transform;\n        const instructions = this._activePath.instructions;\n        const transformedX = t.a * x + t.c * y + t.tx;\n        const transformedY = t.b * x + t.d * y + t.ty;\n        if (instructions.length === 1 && instructions[0].action === \"moveTo\") {\n            instructions[0].data[0] = transformedX;\n            instructions[0].data[1] = transformedY;\n            return this;\n        }\n        this._activePath.moveTo(transformedX, transformedY);\n        return this;\n    }\n    /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cpx - The x-coordinate of the control point.\n   * @param cpy - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */ quadraticCurveTo(cpx, cpy, x, y, smoothness) {\n        this._tick++;\n        const t = this._transform;\n        this._activePath.quadraticCurveTo(t.a * cpx + t.c * cpy + t.tx, t.b * cpx + t.d * cpy + t.ty, t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty, smoothness);\n        return this;\n    }\n    /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @returns The instance of the current object for chaining.\n   */ rect(x, y, w, h) {\n        this._tick++;\n        this._activePath.rect(x, y, w, h, this._transform.clone());\n        return this;\n    }\n    /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n   * @returns The instance of the current object for chaining.\n   */ roundRect(x, y, w, h, radius) {\n        this._tick++;\n        this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());\n        return this;\n    }\n    /**\n   * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n   * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n   * rotated, or translated as needed.\n   * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates, of the polygon's vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   */ poly(points, close) {\n        this._tick++;\n        this._activePath.poly(points, close, this._transform.clone());\n        return this;\n    }\n    /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */ regularPoly(x, y, radius, sides, rotation = 0, transform) {\n        this._tick++;\n        this._activePath.regularPoly(x, y, radius, sides, rotation, transform);\n        return this;\n    }\n    /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @returns The instance of the current object for chaining.\n   */ roundPoly(x, y, radius, sides, corner, rotation) {\n        this._tick++;\n        this._activePath.roundPoly(x, y, radius, sides, corner, rotation);\n        return this;\n    }\n    /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */ roundShape(points, radius, useQuadratic, smoothness) {\n        this._tick++;\n        this._activePath.roundShape(points, radius, useQuadratic, smoothness);\n        return this;\n    }\n    /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */ filletRect(x, y, width, height, fillet) {\n        this._tick++;\n        this._activePath.filletRect(x, y, width, height, fillet);\n        return this;\n    }\n    /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */ chamferRect(x, y, width, height, chamfer, transform) {\n        this._tick++;\n        this._activePath.chamferRect(x, y, width, height, chamfer, transform);\n        return this;\n    }\n    /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */ star(x, y, points, radius, innerRadius = 0, rotation = 0) {\n        this._tick++;\n        this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());\n        return this;\n    }\n    /**\n   * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n   * defined in SVG format to be drawn within the graphics context.\n   * @param svg - The SVG string to be parsed and rendered.\n   */ svg(svg) {\n        this._tick++;\n        (0, $hFJzr.SVGParser)(svg, this);\n        return this;\n    }\n    /**\n   * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n   * This includes transformations, fill styles, and stroke styles.\n   */ restore() {\n        const state = this._stateStack.pop();\n        if (state) {\n            this._transform = state.transform;\n            this._fillStyle = state.fillStyle;\n            this._strokeStyle = state.strokeStyle;\n        }\n        return this;\n    }\n    /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */ save() {\n        this._stateStack.push({\n            transform: this._transform.clone(),\n            fillStyle: {\n                ...this._fillStyle\n            },\n            strokeStyle: {\n                ...this._strokeStyle\n            }\n        });\n        return this;\n    }\n    /**\n   * Returns the current transformation matrix of the graphics context.\n   * @returns The current transformation matrix.\n   */ getTransform() {\n        return this._transform;\n    }\n    /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ resetTransform() {\n        this._transform.identity();\n        return this;\n    }\n    /**\n   * Applies a rotation transformation to the graphics context around the current origin.\n   * @param angle - The angle of rotation in radians.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ rotate(angle) {\n        this._transform.rotate(angle);\n        return this;\n    }\n    /**\n   * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n   * @param x - The scale factor in the horizontal direction.\n   * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ scale(x, y = x) {\n        this._transform.scale(x, y);\n        return this;\n    }\n    setTransform(a, b, c, d, dx, dy) {\n        if (a instanceof (0, $dNaJE.Matrix)) {\n            this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);\n            return this;\n        }\n        this._transform.set(a, b, c, d, dx, dy);\n        return this;\n    }\n    transform(a, b, c, d, dx, dy) {\n        if (a instanceof (0, $dNaJE.Matrix)) {\n            this._transform.append(a);\n            return this;\n        }\n        $f12b5912014640d6$var$tempMatrix.set(a, b, c, d, dx, dy);\n        this._transform.append($f12b5912014640d6$var$tempMatrix);\n        return this;\n    }\n    /**\n   * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n   * @param x - The amount to translate in the horizontal direction.\n   * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ translate(x, y = x) {\n        this._transform.translate(x, y);\n        return this;\n    }\n    /**\n   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n   * and optionally resetting transformations to the identity matrix.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ clear() {\n        this.instructions.length = 0;\n        this.resetTransform();\n        this.onUpdate();\n        return this;\n    }\n    onUpdate() {\n        if (this.dirty) return;\n        this.emit(\"update\", this, 16);\n        this.dirty = true;\n        this._boundsDirty = true;\n    }\n    /** The bounds of the graphic shape. */ get bounds() {\n        if (!this._boundsDirty) return this._bounds;\n        const bounds = this._bounds;\n        bounds.clear();\n        for(let i = 0; i < this.instructions.length; i++){\n            const instruction = this.instructions[i];\n            const action = instruction.action;\n            if (action === \"fill\") {\n                const data = instruction.data;\n                bounds.addBounds(data.path.bounds);\n            } else if (action === \"texture\") {\n                const data = instruction.data;\n                bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);\n            }\n            if (action === \"stroke\") {\n                const data = instruction.data;\n                const padding = data.style.width / 2;\n                const _bounds = data.path.bounds;\n                bounds.addFrame(_bounds.minX - padding, _bounds.minY - padding, _bounds.maxX + padding, _bounds.maxY + padding);\n            }\n        }\n        return bounds;\n    }\n    /**\n   * Check to see if a point is contained within this geometry.\n   * @param point - Point to check if it's contained.\n   * @returns {boolean} `true` if the point is contained within geometry.\n   */ containsPoint(point) {\n        if (!this.bounds.containsPoint(point.x, point.y)) return false;\n        const instructions = this.instructions;\n        let hasHit = false;\n        for(let k = 0; k < instructions.length; k++){\n            const instruction = instructions[k];\n            const data = instruction.data;\n            const path = data.path;\n            if (!instruction.action || !path) continue;\n            const style = data.style;\n            const shapes = path.shapePath.shapePrimitives;\n            for(let i = 0; i < shapes.length; i++){\n                const shape = shapes[i].shape;\n                if (!style || !shape) continue;\n                const transform = shapes[i].transform;\n                const transformedPoint = transform ? transform.applyInverse(point, $f12b5912014640d6$var$tmpPoint) : point;\n                if (instruction.action === \"fill\") hasHit = shape.contains(transformedPoint.x, transformedPoint.y);\n                else hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, style.width);\n                const holes = data.hole;\n                if (holes) {\n                    const holeShapes = holes.shapePath?.shapePrimitives;\n                    if (holeShapes) {\n                        for(let j = 0; j < holeShapes.length; j++)if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y)) hasHit = false;\n                    }\n                }\n                if (hasHit) return true;\n            }\n        }\n        return hasHit;\n    }\n    /**\n   * Destroys the GraphicsData object.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?\n   * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?\n   */ destroy(options = false) {\n        this._stateStack.length = 0;\n        this._transform = null;\n        this.emit(\"destroy\", this);\n        this.removeAllListeners();\n        const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n        if (destroyTexture) {\n            const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n            if (this._fillStyle.texture) this._fillStyle.texture.destroy(destroyTextureSource);\n            if (this._strokeStyle.texture) this._strokeStyle.texture.destroy(destroyTextureSource);\n        }\n        this._fillStyle = null;\n        this._strokeStyle = null;\n        this.instructions = null;\n        this._activePath = null;\n        this._bounds = null;\n        this._stateStack = null;\n        this.customShader = null;\n        this._transform = null;\n    }\n};\n/** The default fill style to use when none is provided. */ $f12b5912014640d6$var$_GraphicsContext.defaultFillStyle = {\n    /** The color to use for the fill. */ color: 16777215,\n    /** The alpha value to use for the fill. */ alpha: 1,\n    /** The texture to use for the fill. */ texture: (0, $5h88T.Texture).WHITE,\n    /** The matrix to apply. */ matrix: null,\n    /** The fill pattern to use. */ fill: null\n};\n/** The default stroke style to use when none is provided. */ $f12b5912014640d6$var$_GraphicsContext.defaultStrokeStyle = {\n    /** The width of the stroke. */ width: 1,\n    /** The color to use for the stroke. */ color: 16777215,\n    /** The alpha value to use for the stroke. */ alpha: 1,\n    /** The alignment of the stroke. */ alignment: 0.5,\n    /** The miter limit to use. */ miterLimit: 10,\n    /** The line cap style to use. */ cap: \"butt\",\n    /** The line join style to use. */ join: \"miter\",\n    /** The texture to use for the fill. */ texture: (0, $5h88T.Texture).WHITE,\n    /** The matrix to apply. */ matrix: null,\n    /** The fill pattern to use. */ fill: null\n};\nlet $f12b5912014640d6$export$cde35afe8b5f985 = $f12b5912014640d6$var$_GraphicsContext;\n\n});\nparcelRegister(\"awDzm\", function(module, exports) {\n\n$parcel$export(module.exports, \"GraphicsPath\", () => $efcc084ee73dba51$export$7e54506375634c19);\n\nvar $2NXni = parcelRequire(\"2NXni\");\n\nvar $l80qL = parcelRequire(\"l80qL\");\n\nvar $8CF4q = parcelRequire(\"8CF4q\");\n\nvar $98ho4 = parcelRequire(\"98ho4\");\n\nvar $7rqBZ = parcelRequire(\"7rqBZ\");\n\"use strict\";\nclass $efcc084ee73dba51$export$7e54506375634c19 {\n    /**\n   * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n   * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n   */ constructor(instructions){\n        this.instructions = [];\n        this.uid = (0, $l80qL.uid)(\"graphicsPath\");\n        this._dirty = true;\n        if (typeof instructions === \"string\") (0, $98ho4.SVGToGraphicsPath)(instructions, this);\n        else this.instructions = instructions?.slice() ?? [];\n    }\n    /**\n   * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n   * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n   */ get shapePath() {\n        if (!this._shapePath) this._shapePath = new (0, $7rqBZ.ShapePath)(this);\n        if (this._dirty) {\n            this._dirty = false;\n            this._shapePath.buildPath();\n        }\n        return this._shapePath;\n    }\n    /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @param transform - An optional transformation to apply to the added path.\n   * @returns The instance of the current object for chaining.\n   */ addPath(path, transform) {\n        path = path.clone();\n        this.instructions.push({\n            action: \"addPath\",\n            data: [\n                path,\n                transform\n            ]\n        });\n        this._dirty = true;\n        return this;\n    }\n    arc(...args) {\n        this.instructions.push({\n            action: \"arc\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    arcTo(...args) {\n        this.instructions.push({\n            action: \"arcTo\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    arcToSvg(...args) {\n        this.instructions.push({\n            action: \"arcToSvg\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    bezierCurveTo(...args) {\n        this.instructions.push({\n            action: \"bezierCurveTo\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires two points: the second control point and the end point. The first control point is assumed to be\n   * The starting point is the last point in the current path.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */ bezierCurveToShort(cp2x, cp2y, x, y, smoothness) {\n        const last = this.instructions[this.instructions.length - 1];\n        const lastPoint = this.getLastPoint((0, $2NXni.Point).shared);\n        let cp1x = 0;\n        let cp1y = 0;\n        if (!last || last.action !== \"bezierCurveTo\") {\n            cp1x = lastPoint.x;\n            cp1y = lastPoint.y;\n        } else {\n            cp1x = last.data[2];\n            cp1y = last.data[3];\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n            cp1x = currentX + (currentX - cp1x);\n            cp1y = currentY + (currentY - cp1y);\n        }\n        this.instructions.push({\n            action: \"bezierCurveTo\",\n            data: [\n                cp1x,\n                cp1y,\n                cp2x,\n                cp2y,\n                x,\n                y,\n                smoothness\n            ]\n        });\n        this._dirty = true;\n        return this;\n    }\n    /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */ closePath() {\n        this.instructions.push({\n            action: \"closePath\",\n            data: []\n        });\n        this._dirty = true;\n        return this;\n    }\n    ellipse(...args) {\n        this.instructions.push({\n            action: \"ellipse\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    lineTo(...args) {\n        this.instructions.push({\n            action: \"lineTo\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    moveTo(...args) {\n        this.instructions.push({\n            action: \"moveTo\",\n            data: args\n        });\n        return this;\n    }\n    quadraticCurveTo(...args) {\n        this.instructions.push({\n            action: \"quadraticCurveTo\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    /**\n   * Adds a quadratic curve to the path. It uses the previous point as the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */ quadraticCurveToShort(x, y, smoothness) {\n        const last = this.instructions[this.instructions.length - 1];\n        const lastPoint = this.getLastPoint((0, $2NXni.Point).shared);\n        let cpx1 = 0;\n        let cpy1 = 0;\n        if (!last || last.action !== \"quadraticCurveTo\") {\n            cpx1 = lastPoint.x;\n            cpy1 = lastPoint.y;\n        } else {\n            cpx1 = last.data[0];\n            cpy1 = last.data[1];\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n            cpx1 = currentX + (currentX - cpx1);\n            cpy1 = currentY + (currentY - cpy1);\n        }\n        this.instructions.push({\n            action: \"quadraticCurveTo\",\n            data: [\n                cpx1,\n                cpy1,\n                x,\n                y,\n                smoothness\n            ]\n        });\n        this._dirty = true;\n        return this;\n    }\n    /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */ rect(x, y, w, h, transform) {\n        this.instructions.push({\n            action: \"rect\",\n            data: [\n                x,\n                y,\n                w,\n                h,\n                transform\n            ]\n        });\n        this._dirty = true;\n        return this;\n    }\n    /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */ circle(x, y, radius, transform) {\n        this.instructions.push({\n            action: \"circle\",\n            data: [\n                x,\n                y,\n                radius,\n                transform\n            ]\n        });\n        this._dirty = true;\n        return this;\n    }\n    roundRect(...args) {\n        this.instructions.push({\n            action: \"roundRect\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    poly(...args) {\n        this.instructions.push({\n            action: \"poly\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    regularPoly(...args) {\n        this.instructions.push({\n            action: \"regularPoly\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    roundPoly(...args) {\n        this.instructions.push({\n            action: \"roundPoly\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    roundShape(...args) {\n        this.instructions.push({\n            action: \"roundShape\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    filletRect(...args) {\n        this.instructions.push({\n            action: \"filletRect\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    chamferRect(...args) {\n        this.instructions.push({\n            action: \"chamferRect\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @param transform - An optional `Matrix` object to apply a transformation to the star.\n   * This can include rotations, scaling, and translations.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */ // eslint-disable-next-line max-len\n    star(x, y, points, radius, innerRadius, rotation, transform) {\n        innerRadius = innerRadius || radius / 2;\n        const startAngle = -1 * Math.PI / 2 + rotation;\n        const len = points * 2;\n        const delta = Math.PI * 2 / len;\n        const polygon = [];\n        for(let i = 0; i < len; i++){\n            const r = i % 2 ? innerRadius : radius;\n            const angle = i * delta + startAngle;\n            polygon.push(x + r * Math.cos(angle), y + r * Math.sin(angle));\n        }\n        this.poly(polygon, true, transform);\n        return this;\n    }\n    /**\n   * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n   * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n   * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n   * do not affect the original `GraphicsPath` and vice versa.\n   * @param deep - A boolean flag indicating whether the clone should be deep.\n   * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n   */ clone(deep = false) {\n        const newGraphicsPath2D = new $efcc084ee73dba51$export$7e54506375634c19();\n        if (!deep) newGraphicsPath2D.instructions = this.instructions.slice();\n        else for(let i = 0; i < this.instructions.length; i++){\n            const instruction = this.instructions[i];\n            newGraphicsPath2D.instructions.push({\n                action: instruction.action,\n                data: instruction.data.slice()\n            });\n        }\n        return newGraphicsPath2D;\n    }\n    clear() {\n        this.instructions.length = 0;\n        this._dirty = true;\n        return this;\n    }\n    /**\n   * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n   * This method enables the modification of the path's geometry according to the provided\n   * transformation matrix, which can include translations, rotations, scaling, and skewing.\n   *\n   * Each drawing instruction in the path is updated to reflect the transformation,\n   * ensuring the visual representation of the path is consistent with the applied matrix.\n   *\n   * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n   * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,\n   * allowing for fine-grained control over the path's appearance.\n   * @param matrix - A `Matrix` object representing the transformation to apply.\n   * @returns The instance of the current object for chaining further operations.\n   */ transform(matrix) {\n        if (matrix.isIdentity()) return this;\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n        let x = 0;\n        let y = 0;\n        let cpx1 = 0;\n        let cpy1 = 0;\n        let cpx2 = 0;\n        let cpy2 = 0;\n        let rx = 0;\n        let ry = 0;\n        for(let i = 0; i < this.instructions.length; i++){\n            const instruction = this.instructions[i];\n            const data = instruction.data;\n            switch(instruction.action){\n                case \"moveTo\":\n                case \"lineTo\":\n                    x = data[0];\n                    y = data[1];\n                    data[0] = a * x + c * y + tx;\n                    data[1] = b * x + d * y + ty;\n                    break;\n                case \"bezierCurveTo\":\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n                    cpx2 = data[2];\n                    cpy2 = data[3];\n                    x = data[4];\n                    y = data[5];\n                    data[0] = a * cpx1 + c * cpy1 + tx;\n                    data[1] = b * cpx1 + d * cpy1 + ty;\n                    data[2] = a * cpx2 + c * cpy2 + tx;\n                    data[3] = b * cpx2 + d * cpy2 + ty;\n                    data[4] = a * x + c * y + tx;\n                    data[5] = b * x + d * y + ty;\n                    break;\n                case \"quadraticCurveTo\":\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n                    x = data[2];\n                    y = data[3];\n                    data[0] = a * cpx1 + c * cpy1 + tx;\n                    data[1] = b * cpx1 + d * cpy1 + ty;\n                    data[2] = a * x + c * y + tx;\n                    data[3] = b * x + d * y + ty;\n                    break;\n                case \"arcToSvg\":\n                    x = data[5];\n                    y = data[6];\n                    rx = data[0];\n                    ry = data[1];\n                    data[0] = a * rx + c * ry;\n                    data[1] = b * rx + d * ry;\n                    data[5] = a * x + c * y + tx;\n                    data[6] = b * x + d * y + ty;\n                    break;\n                case \"circle\":\n                    data[4] = $efcc084ee73dba51$var$adjustTransform(data[3], matrix);\n                    break;\n                case \"rect\":\n                    data[4] = $efcc084ee73dba51$var$adjustTransform(data[4], matrix);\n                    break;\n                case \"ellipse\":\n                    data[8] = $efcc084ee73dba51$var$adjustTransform(data[8], matrix);\n                    break;\n                case \"roundRect\":\n                    data[5] = $efcc084ee73dba51$var$adjustTransform(data[5], matrix);\n                    break;\n                case \"addPath\":\n                    data[0].transform(matrix);\n                    break;\n                case \"poly\":\n                    data[2] = $efcc084ee73dba51$var$adjustTransform(data[2], matrix);\n                    break;\n                default:\n                    (0, $8CF4q.warn)(\"unknown transform action\", instruction.action);\n                    break;\n            }\n        }\n        this._dirty = true;\n        return this;\n    }\n    get bounds() {\n        return this.shapePath.bounds;\n    }\n    /**\n   * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n   * This method is useful for operations that depend on the path's current endpoint,\n   * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n   * ensuring the last point's position is accurately determined regardless of the path's complexity.\n   *\n   * If the last instruction is a `closePath`, the method iterates backward through the instructions\n   *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n   * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n   * the last point from the nested path.\n   * @param out - A `Point` object where the last point's coordinates will be stored.\n   * This object is modified directly to contain the result.\n   * @returns The `Point` object containing the last point's coordinates.\n   */ getLastPoint(out) {\n        let index = this.instructions.length - 1;\n        let lastInstruction = this.instructions[index];\n        if (!lastInstruction) {\n            out.x = 0;\n            out.y = 0;\n            return out;\n        }\n        while(lastInstruction.action === \"closePath\"){\n            index--;\n            if (index < 0) {\n                out.x = 0;\n                out.y = 0;\n                return out;\n            }\n            lastInstruction = this.instructions[index];\n        }\n        switch(lastInstruction.action){\n            case \"moveTo\":\n            case \"lineTo\":\n                out.x = lastInstruction.data[0];\n                out.y = lastInstruction.data[1];\n                break;\n            case \"quadraticCurveTo\":\n                out.x = lastInstruction.data[2];\n                out.y = lastInstruction.data[3];\n                break;\n            case \"bezierCurveTo\":\n                out.x = lastInstruction.data[4];\n                out.y = lastInstruction.data[5];\n                break;\n            case \"arc\":\n            case \"arcToSvg\":\n                out.x = lastInstruction.data[5];\n                out.y = lastInstruction.data[6];\n                break;\n            case \"addPath\":\n                lastInstruction.data[0].getLastPoint(out);\n                break;\n        }\n        return out;\n    }\n}\nfunction $efcc084ee73dba51$var$adjustTransform(currentMatrix, transform) {\n    if (currentMatrix) return currentMatrix.prepend(transform);\n    return transform.clone();\n}\n\n});\nparcelRegister(\"98ho4\", function(module, exports) {\n\n$parcel$export(module.exports, \"SVGToGraphicsPath\", () => $cd83cfe628f68b58$export$14a4a8042d02aa8d);\n\nvar $eJJJX = parcelRequire(\"eJJJX\");\n\nvar $8CF4q = parcelRequire(\"8CF4q\");\n\"use strict\";\nfunction $cd83cfe628f68b58$export$14a4a8042d02aa8d(svgPath, path) {\n    const commands = (0, (/*@__PURE__*/$parcel$interopDefault($eJJJX)))(svgPath);\n    const subpaths = [];\n    let currentSubPath = null;\n    let lastX = 0;\n    let lastY = 0;\n    for(let i = 0; i < commands.length; i++){\n        const command = commands[i];\n        const type = command[0];\n        const data = command;\n        switch(type){\n            case \"M\":\n                lastX = data[1];\n                lastY = data[2];\n                path.moveTo(lastX, lastY);\n                break;\n            case \"m\":\n                lastX += data[1];\n                lastY += data[2];\n                path.moveTo(lastX, lastY);\n                break;\n            case \"H\":\n                lastX = data[1];\n                path.lineTo(lastX, lastY);\n                break;\n            case \"h\":\n                lastX += data[1];\n                path.lineTo(lastX, lastY);\n                break;\n            case \"V\":\n                lastY = data[1];\n                path.lineTo(lastX, lastY);\n                break;\n            case \"v\":\n                lastY += data[1];\n                path.lineTo(lastX, lastY);\n                break;\n            case \"L\":\n                lastX = data[1];\n                lastY = data[2];\n                path.lineTo(lastX, lastY);\n                break;\n            case \"l\":\n                lastX += data[1];\n                lastY += data[2];\n                path.lineTo(lastX, lastY);\n                break;\n            case \"C\":\n                lastX = data[5];\n                lastY = data[6];\n                path.bezierCurveTo(data[1], data[2], data[3], data[4], lastX, lastY);\n                break;\n            case \"c\":\n                path.bezierCurveTo(lastX + data[1], lastY + data[2], lastX + data[3], lastY + data[4], lastX + data[5], lastY + data[6]);\n                lastX += data[5];\n                lastY += data[6];\n                break;\n            case \"S\":\n                lastX = data[3];\n                lastY = data[4];\n                path.bezierCurveToShort(data[1], data[2], lastX, lastY);\n                break;\n            case \"s\":\n                path.bezierCurveToShort(lastX + data[1], lastY + data[2], lastX + data[3], lastY + data[4]);\n                lastX += data[3];\n                lastY += data[4];\n                break;\n            case \"Q\":\n                lastX = data[3];\n                lastY = data[4];\n                path.quadraticCurveTo(data[1], data[2], lastX, lastY);\n                break;\n            case \"q\":\n                path.quadraticCurveTo(lastX + data[1], lastY + data[2], lastX + data[3], lastY + data[4]);\n                lastX += data[3];\n                lastY += data[4];\n                break;\n            case \"T\":\n                lastX = data[1];\n                lastY = data[2];\n                path.quadraticCurveToShort(lastX, lastY);\n                break;\n            case \"t\":\n                lastX += data[1];\n                lastY += data[2];\n                path.quadraticCurveToShort(lastX, lastY);\n                break;\n            case \"A\":\n                lastX = data[6];\n                lastY = data[7];\n                path.arcToSvg(data[1], data[2], data[3], data[4], data[5], lastX, lastY);\n                break;\n            case \"a\":\n                lastX += data[6];\n                lastY += data[7];\n                path.arcToSvg(data[1], data[2], data[3], data[4], data[5], lastX, lastY);\n                break;\n            case \"Z\":\n            case \"z\":\n                path.closePath();\n                if (subpaths.length > 0) {\n                    currentSubPath = subpaths.pop();\n                    if (currentSubPath) {\n                        lastX = currentSubPath.startX;\n                        lastY = currentSubPath.startY;\n                    } else {\n                        lastX = 0;\n                        lastY = 0;\n                    }\n                }\n                currentSubPath = null;\n                break;\n            default:\n                (0, $8CF4q.warn)(`Unknown SVG path command: ${type}`);\n        }\n        if (type !== \"Z\" && type !== \"z\") {\n            if (currentSubPath === null) {\n                currentSubPath = {\n                    startX: lastX,\n                    startY: lastY\n                };\n                subpaths.push(currentSubPath);\n            }\n        }\n    }\n    return path;\n}\n\n});\nparcelRegister(\"eJJJX\", function(module, exports) {\nmodule.exports = $aba8bfb3df0db863$var$parse;\n/**\n * expected argument lengths\n * @type {Object}\n */ var $aba8bfb3df0db863$var$length = {\n    a: 7,\n    c: 6,\n    h: 1,\n    l: 2,\n    m: 2,\n    q: 4,\n    s: 4,\n    t: 2,\n    v: 1,\n    z: 0\n};\n/**\n * segment pattern\n * @type {RegExp}\n */ var $aba8bfb3df0db863$var$segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * @param {String} path\n * @return {Array}\n */ function $aba8bfb3df0db863$var$parse(path) {\n    var data = [];\n    path.replace($aba8bfb3df0db863$var$segment, function(_, command, args) {\n        var type = command.toLowerCase();\n        args = $aba8bfb3df0db863$var$parseValues(args);\n        // overloaded moveTo\n        if (type == \"m\" && args.length > 2) {\n            data.push([\n                command\n            ].concat(args.splice(0, 2)));\n            type = \"l\";\n            command = command == \"m\" ? \"l\" : \"L\";\n        }\n        while(true){\n            if (args.length == $aba8bfb3df0db863$var$length[type]) {\n                args.unshift(command);\n                return data.push(args);\n            }\n            if (args.length < $aba8bfb3df0db863$var$length[type]) throw new Error(\"malformed path data\");\n            data.push([\n                command\n            ].concat(args.splice(0, $aba8bfb3df0db863$var$length[type])));\n        }\n    });\n    return data;\n}\nvar $aba8bfb3df0db863$var$number = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig;\nfunction $aba8bfb3df0db863$var$parseValues(args) {\n    var numbers = args.match($aba8bfb3df0db863$var$number);\n    return numbers ? numbers.map(Number) : [];\n}\n\n});\n\n\nparcelRegister(\"7rqBZ\", function(module, exports) {\n\n$parcel$export(module.exports, \"ShapePath\", () => $883b5996078d1cf3$export$148534a3c727230b);\n\nvar $jaTjj = parcelRequire(\"jaTjj\");\n\nvar $asIJc = parcelRequire(\"asIJc\");\n\nvar $67pKq = parcelRequire(\"67pKq\");\n\nvar $soqVu = parcelRequire(\"soqVu\");\n\nvar $guUt8 = parcelRequire(\"guUt8\");\n\nvar $ggeMF = parcelRequire(\"ggeMF\");\n\nvar $67FNK = parcelRequire(\"67FNK\");\n\nvar $hYods = parcelRequire(\"hYods\");\n\nvar $dMnI7 = parcelRequire(\"dMnI7\");\n\nvar $1DEaT = parcelRequire(\"1DEaT\");\n\nvar $j5RWP = parcelRequire(\"j5RWP\");\n\nvar $5fPVY = parcelRequire(\"5fPVY\");\n\"use strict\";\nconst $883b5996078d1cf3$var$tempRectangle = new (0, $soqVu.Rectangle)();\nclass $883b5996078d1cf3$export$148534a3c727230b {\n    constructor(graphicsPath2D){\n        /** The list of shape primitives that make up the path. */ this.shapePrimitives = [];\n        this._currentPoly = null;\n        this._bounds = new (0, $ggeMF.Bounds)();\n        this._graphicsPath2D = graphicsPath2D;\n    }\n    /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */ moveTo(x, y) {\n        this.startPoly(x, y);\n        return this;\n    }\n    /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */ lineTo(x, y) {\n        this._ensurePoly();\n        const points = this._currentPoly.points;\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n        if (fromX !== x || fromY !== y) points.push(x, y);\n        return this;\n    }\n    /**\n   * Adds an arc to the path. The arc is centered at (x, y)\n   *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n   * @param x - The x-coordinate of the arc's center.\n   * @param y - The y-coordinate of the arc's center.\n   * @param radius - The radius of the arc.\n   * @param startAngle - The starting angle of the arc, in radians.\n   * @param endAngle - The ending angle of the arc, in radians.\n   * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n   * @returns The instance of the current object for chaining.\n   */ arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n        this._ensurePoly(false);\n        const points = this._currentPoly.points;\n        (0, $dMnI7.buildArc)(points, x, y, radius, startAngle, endAngle, counterclockwise);\n        return this;\n    }\n    /**\n   * Adds an arc to the path with the arc tangent to the line joining two specified points.\n   * The arc radius is specified by `radius`.\n   * @param x1 - The x-coordinate of the first point.\n   * @param y1 - The y-coordinate of the first point.\n   * @param x2 - The x-coordinate of the second point.\n   * @param y2 - The y-coordinate of the second point.\n   * @param radius - The radius of the arc.\n   * @returns The instance of the current object for chaining.\n   */ arcTo(x1, y1, x2, y2, radius) {\n        this._ensurePoly();\n        const points = this._currentPoly.points;\n        (0, $1DEaT.buildArcTo)(points, x1, y1, x2, y2, radius);\n        return this;\n    }\n    /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc's end point.\n   * @param y - The y-coordinate of the arc's end point.\n   * @returns The instance of the current object for chaining.\n   */ arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n        const points = this._currentPoly.points;\n        (0, $j5RWP.buildArcToSvg)(points, this._currentPoly.lastX, this._currentPoly.lastY, x, y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag);\n        return this;\n    }\n    /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */ bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n        this._ensurePoly();\n        const currentPoly = this._currentPoly;\n        (0, $67FNK.buildAdaptiveBezier)(this._currentPoly.points, currentPoly.lastX, currentPoly.lastY, cp1x, cp1y, cp2x, cp2y, x, y, smoothness);\n        return this;\n    }\n    /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the control point.\n   * @param cp1y - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */ quadraticCurveTo(cp1x, cp1y, x, y, smoothing) {\n        this._ensurePoly();\n        const currentPoly = this._currentPoly;\n        (0, $hYods.buildAdaptiveQuadratic)(this._currentPoly.points, currentPoly.lastX, currentPoly.lastY, cp1x, cp1y, x, y, smoothing);\n        return this;\n    }\n    /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */ closePath() {\n        this.endPoly(true);\n        return this;\n    }\n    /**\n   * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n   * @param path - The `GraphicsPath` object representing the path to add.\n   * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n   * @returns The instance of the current object for chaining.\n   */ addPath(path, transform) {\n        this.endPoly();\n        if (transform && !transform.isIdentity()) {\n            path = path.clone(true);\n            path.transform(transform);\n        }\n        for(let i = 0; i < path.instructions.length; i++){\n            const instruction = path.instructions[i];\n            this[instruction.action](...instruction.data);\n        }\n        return this;\n    }\n    /**\n   * Finalizes the drawing of the current path. Optionally, it can close the path.\n   * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n   */ finish(closePath = false) {\n        this.endPoly(closePath);\n    }\n    /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */ rect(x, y, w, h, transform) {\n        this.drawShape(new (0, $soqVu.Rectangle)(x, y, w, h), transform);\n        return this;\n    }\n    /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */ circle(x, y, radius, transform) {\n        this.drawShape(new (0, $jaTjj.Circle)(x, y, radius), transform);\n        return this;\n    }\n    /**\n   * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n   * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates of the polygon's vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */ poly(points, close, transform) {\n        const polygon = new (0, $67pKq.Polygon)(points);\n        polygon.closePath = close;\n        this.drawShape(polygon, transform);\n        return this;\n    }\n    /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */ regularPoly(x, y, radius, sides, rotation = 0, transform) {\n        sides = Math.max(sides | 0, 3);\n        const startAngle = -1 * Math.PI / 2 + rotation;\n        const delta = Math.PI * 2 / sides;\n        const polygon = [];\n        for(let i = 0; i < sides; i++){\n            const angle = i * delta + startAngle;\n            polygon.push(x + radius * Math.cos(angle), y + radius * Math.sin(angle));\n        }\n        this.poly(polygon, true, transform);\n        return this;\n    }\n    /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n   * @returns The instance of the current object for chaining.\n   */ roundPoly(x, y, radius, sides, corner, rotation = 0, smoothness) {\n        sides = Math.max(sides | 0, 3);\n        if (corner <= 0) return this.regularPoly(x, y, radius, sides, rotation);\n        const sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;\n        corner = Math.min(corner, sideLength);\n        const startAngle = -1 * Math.PI / 2 + rotation;\n        const delta = Math.PI * 2 / sides;\n        const internalAngle = (sides - 2) * Math.PI / sides / 2;\n        for(let i = 0; i < sides; i++){\n            const angle = i * delta + startAngle;\n            const x0 = x + radius * Math.cos(angle);\n            const y0 = y + radius * Math.sin(angle);\n            const a1 = angle + Math.PI + internalAngle;\n            const a2 = angle - Math.PI - internalAngle;\n            const x1 = x0 + corner * Math.cos(a1);\n            const y1 = y0 + corner * Math.sin(a1);\n            const x3 = x0 + corner * Math.cos(a2);\n            const y3 = y0 + corner * Math.sin(a2);\n            if (i === 0) this.moveTo(x1, y1);\n            else this.lineTo(x1, y1);\n            this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n        }\n        return this.closePath();\n    }\n    /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */ roundShape(points, radius, useQuadratic = false, smoothness) {\n        if (points.length < 3) return this;\n        if (useQuadratic) (0, $5fPVY.roundedShapeQuadraticCurve)(this, points, radius, smoothness);\n        else (0, $5fPVY.roundedShapeArc)(this, points, radius);\n        return this.closePath();\n    }\n    /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */ filletRect(x, y, width, height, fillet) {\n        if (fillet === 0) return this.rect(x, y, width, height);\n        const maxFillet = Math.min(width, height) / 2;\n        const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n        const right = x + width;\n        const bottom = y + height;\n        const dir = inset < 0 ? -inset : 0;\n        const size = Math.abs(inset);\n        return this.moveTo(x, y + size).arcTo(x + dir, y + dir, x + size, y, size).lineTo(right - size, y).arcTo(right - dir, y + dir, right, y + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x + width - size, bottom, size).lineTo(x + size, bottom).arcTo(x + dir, bottom - dir, x, bottom - size, size).closePath();\n    }\n    /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */ chamferRect(x, y, width, height, chamfer, transform) {\n        if (chamfer <= 0) return this.rect(x, y, width, height);\n        const inset = Math.min(chamfer, Math.min(width, height) / 2);\n        const right = x + width;\n        const bottom = y + height;\n        const points = [\n            x + inset,\n            y,\n            right - inset,\n            y,\n            right,\n            y + inset,\n            right,\n            bottom - inset,\n            right - inset,\n            bottom,\n            x + inset,\n            bottom,\n            x,\n            bottom - inset,\n            x,\n            y + inset\n        ];\n        for(let i = points.length - 1; i >= 2; i -= 2)if (points[i] === points[i - 2] && points[i - 1] === points[i - 3]) points.splice(i - 1, 2);\n        return this.poly(points, true, transform);\n    }\n    /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n   * @returns The instance of the current object for chaining.\n   */ ellipse(x, y, radiusX, radiusY, transform) {\n        this.drawShape(new (0, $asIJc.Ellipse)(x, y, radiusX, radiusY), transform);\n        return this;\n    }\n    /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */ roundRect(x, y, w, h, radius, transform) {\n        this.drawShape(new (0, $guUt8.RoundedRectangle)(x, y, w, h, radius), transform);\n        return this;\n    }\n    /**\n   * Draws a given shape on the canvas.\n   * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n   * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n   * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n   * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n   * scaling, and translations.\n   * @returns The instance of the current object for chaining.\n   */ drawShape(shape, matrix) {\n        this.endPoly();\n        this.shapePrimitives.push({\n            shape: shape,\n            transform: matrix\n        });\n        return this;\n    }\n    /**\n   * Starts a new polygon path from the specified starting point.\n   * This method initializes a new polygon or ends the current one if it exists.\n   * @param x - The x-coordinate of the starting point of the new polygon.\n   * @param y - The y-coordinate of the starting point of the new polygon.\n   * @returns The instance of the current object for chaining.\n   */ startPoly(x, y) {\n        let currentPoly = this._currentPoly;\n        if (currentPoly) this.endPoly();\n        currentPoly = new (0, $67pKq.Polygon)();\n        currentPoly.points.push(x, y);\n        this._currentPoly = currentPoly;\n        return this;\n    }\n    /**\n   * Ends the current polygon path. If `closePath` is set to true,\n   * the path is closed by connecting the last point to the first one.\n   * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n   * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n   *  back to the starting point. False by default.\n   * @returns The instance of the current object for chaining.\n   */ endPoly(closePath = false) {\n        const shape = this._currentPoly;\n        if (shape && shape.points.length > 2) {\n            shape.closePath = closePath;\n            this.shapePrimitives.push({\n                shape: shape\n            });\n        }\n        this._currentPoly = null;\n        return this;\n    }\n    _ensurePoly(start = true) {\n        if (this._currentPoly) return;\n        this._currentPoly = new (0, $67pKq.Polygon)();\n        if (start) {\n            const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n            if (lastShape) {\n                let lx = lastShape.shape.x;\n                let ly = lastShape.shape.y;\n                if (!lastShape.transform.isIdentity()) {\n                    const t = lastShape.transform;\n                    const tempX = lx;\n                    lx = t.a * lx + t.c * ly + t.tx;\n                    ly = t.b * tempX + t.d * ly + t.ty;\n                }\n                this._currentPoly.points.push(lx, ly);\n            } else this._currentPoly.points.push(0, 0);\n        }\n    }\n    /** Builds the path. */ buildPath() {\n        const path = this._graphicsPath2D;\n        this.shapePrimitives.length = 0;\n        this._currentPoly = null;\n        for(let i = 0; i < path.instructions.length; i++){\n            const instruction = path.instructions[i];\n            this[instruction.action](...instruction.data);\n        }\n        this.finish();\n    }\n    /** Gets the bounds of the path. */ get bounds() {\n        const bounds = this._bounds;\n        bounds.clear();\n        const shapePrimitives = this.shapePrimitives;\n        for(let i = 0; i < shapePrimitives.length; i++){\n            const shapePrimitive = shapePrimitives[i];\n            const boundsRect = shapePrimitive.shape.getBounds($883b5996078d1cf3$var$tempRectangle);\n            if (shapePrimitive.transform) bounds.addRect(boundsRect, shapePrimitive.transform);\n            else bounds.addRect(boundsRect);\n        }\n        return bounds;\n    }\n}\n\n});\nparcelRegister(\"jaTjj\", function(module, exports) {\n\n$parcel$export(module.exports, \"Circle\", () => $10653db1cf8e73c3$export$c89a927ffc67e6fa);\n\nvar $soqVu = parcelRequire(\"soqVu\");\n\"use strict\";\nclass $10653db1cf8e73c3$export$c89a927ffc67e6fa {\n    /**\n   * @param x - The X coordinate of the center of this circle\n   * @param y - The Y coordinate of the center of this circle\n   * @param radius - The radius of the circle\n   */ constructor(x = 0, y = 0, radius = 0){\n        /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'circle'\n     */ this.type = \"circle\";\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n    }\n    /**\n   * Creates a clone of this Circle instance\n   * @returns A copy of the Circle\n   */ clone() {\n        return new $10653db1cf8e73c3$export$c89a927ffc67e6fa(this.x, this.y, this.radius);\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this circle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Circle\n   */ contains(x, y) {\n        if (this.radius <= 0) return false;\n        const r2 = this.radius * this.radius;\n        let dx = this.x - x;\n        let dy = this.y - y;\n        dx *= dx;\n        dy *= dy;\n        return dx + dy <= r2;\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this circle including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param width - The width of the line to check\n   * @returns Whether the x/y coordinates are within this Circle\n   */ strokeContains(x, y, width) {\n        if (this.radius === 0) return false;\n        const dx = this.x - x;\n        const dy = this.y - y;\n        const r = this.radius;\n        const w2 = width / 2;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        return distance < r + w2 && distance > r - w2;\n    }\n    /**\n   * Returns the framing rectangle of the circle as a Rectangle object\n   * @param out\n   * @returns The framing rectangle\n   */ getBounds(out) {\n        out = out || new (0, $soqVu.Rectangle)();\n        out.x = this.x - this.radius;\n        out.y = this.y - this.radius;\n        out.width = this.radius * 2;\n        out.height = this.radius * 2;\n        return out;\n    }\n    /**\n   * Copies another circle to this one.\n   * @param circle - The circle to copy from.\n   * @returns Returns itself.\n   */ copyFrom(circle) {\n        this.x = circle.x;\n        this.y = circle.y;\n        this.radius = circle.radius;\n        return this;\n    }\n    /**\n   * Copies this circle to another one.\n   * @param circle - The circle to copy to.\n   * @returns Returns given parameter.\n   */ copyTo(circle) {\n        circle.copyFrom(this);\n        return circle;\n    }\n    toString() {\n        return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;\n    }\n}\n\n});\n\nparcelRegister(\"asIJc\", function(module, exports) {\n\n$parcel$export(module.exports, \"Ellipse\", () => $db837e087942ed80$export$80b0269ab108fa11);\n\nvar $soqVu = parcelRequire(\"soqVu\");\n\"use strict\";\nclass $db837e087942ed80$export$80b0269ab108fa11 {\n    /**\n   * @param x - The X coordinate of the center of this ellipse\n   * @param y - The Y coordinate of the center of this ellipse\n   * @param halfWidth - The half width of this ellipse\n   * @param halfHeight - The half height of this ellipse\n   */ constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0){\n        /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'ellipse'\n     */ this.type = \"ellipse\";\n        this.x = x;\n        this.y = y;\n        this.halfWidth = halfWidth;\n        this.halfHeight = halfHeight;\n    }\n    /**\n   * Creates a clone of this Ellipse instance\n   * @returns {Ellipse} A copy of the ellipse\n   */ clone() {\n        return new $db837e087942ed80$export$80b0269ab108fa11(this.x, this.y, this.halfWidth, this.halfHeight);\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this ellipse\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coords are within this ellipse\n   */ contains(x, y) {\n        if (this.halfWidth <= 0 || this.halfHeight <= 0) return false;\n        let normx = (x - this.x) / this.halfWidth;\n        let normy = (y - this.y) / this.halfHeight;\n        normx *= normx;\n        normy *= normy;\n        return normx + normy <= 1;\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this ellipse including stroke\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param width\n   * @returns Whether the x/y coords are within this ellipse\n   */ strokeContains(x, y, width) {\n        const { halfWidth: halfWidth, halfHeight: halfHeight } = this;\n        if (halfWidth <= 0 || halfHeight <= 0) return false;\n        const halfStrokeWidth = width / 2;\n        const innerA = halfWidth - halfStrokeWidth;\n        const innerB = halfHeight - halfStrokeWidth;\n        const outerA = halfWidth + halfStrokeWidth;\n        const outerB = halfHeight + halfStrokeWidth;\n        const normalizedX = x - this.x;\n        const normalizedY = y - this.y;\n        const innerEllipse = normalizedX * normalizedX / (innerA * innerA) + normalizedY * normalizedY / (innerB * innerB);\n        const outerEllipse = normalizedX * normalizedX / (outerA * outerA) + normalizedY * normalizedY / (outerB * outerB);\n        return innerEllipse > 1 && outerEllipse <= 1;\n    }\n    /**\n   * Returns the framing rectangle of the ellipse as a Rectangle object\n   * @returns The framing rectangle\n   */ getBounds() {\n        return new (0, $soqVu.Rectangle)(this.x - this.halfWidth, this.y - this.halfHeight, this.halfWidth * 2, this.halfHeight * 2);\n    }\n    /**\n   * Copies another ellipse to this one.\n   * @param ellipse - The ellipse to copy from.\n   * @returns Returns itself.\n   */ copyFrom(ellipse) {\n        this.x = ellipse.x;\n        this.y = ellipse.y;\n        this.halfWidth = ellipse.halfWidth;\n        this.halfHeight = ellipse.halfHeight;\n        return this;\n    }\n    /**\n   * Copies this ellipse to another one.\n   * @param ellipse - The ellipse to copy to.\n   * @returns Returns given parameter.\n   */ copyTo(ellipse) {\n        ellipse.copyFrom(this);\n        return ellipse;\n    }\n    toString() {\n        return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;\n    }\n}\n\n});\n\nparcelRegister(\"67pKq\", function(module, exports) {\n\n$parcel$export(module.exports, \"Polygon\", () => $0bf946332d4367d9$export$7d31b617c820d435);\n\nvar $3qFiz = parcelRequire(\"3qFiz\");\n\nvar $soqVu = parcelRequire(\"soqVu\");\n\"use strict\";\nclass $0bf946332d4367d9$export$7d31b617c820d435 {\n    /**\n   * @param points - This can be an array of Points\n   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n   *  the arguments passed can be all the points of the polygon e.g.\n   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat\n   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n   */ constructor(...points){\n        /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'polygon'\n     */ this.type = \"polygon\";\n        let flat = Array.isArray(points[0]) ? points[0] : points;\n        if (typeof flat[0] !== \"number\") {\n            const p = [];\n            for(let i = 0, il = flat.length; i < il; i++)p.push(flat[i].x, flat[i].y);\n            flat = p;\n        }\n        this.points = flat;\n        this.closePath = true;\n    }\n    /**\n   * Creates a clone of this polygon.\n   * @returns - A copy of the polygon.\n   */ clone() {\n        const points = this.points.slice();\n        const polygon = new $0bf946332d4367d9$export$7d31b617c820d435(points);\n        polygon.closePath = this.closePath;\n        return polygon;\n    }\n    /**\n   * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this polygon.\n   */ contains(x, y) {\n        let inside = false;\n        const length = this.points.length / 2;\n        for(let i = 0, j = length - 1; i < length; j = i++){\n            const xi = this.points[i * 2];\n            const yi = this.points[i * 2 + 1];\n            const xj = this.points[j * 2];\n            const yj = this.points[j * 2 + 1];\n            const intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;\n            if (intersect) inside = !inside;\n        }\n        return inside;\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this polygon including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this polygon\n   */ strokeContains(x, y, strokeWidth) {\n        const halfStrokeWidth = strokeWidth / 2;\n        const halfStrokeWidthSqrd = halfStrokeWidth * halfStrokeWidth;\n        const { points: points } = this;\n        for(let i = 0; i < points.length; i += 2){\n            const x1 = points[i];\n            const y1 = points[i + 1];\n            const x2 = points[(i + 2) % points.length];\n            const y2 = points[(i + 3) % points.length];\n            const distanceSqrd = (0, $3qFiz.squaredDistanceToLineSegment)(x, y, x1, y1, x2, y2);\n            if (distanceSqrd <= halfStrokeWidthSqrd) return true;\n        }\n        return false;\n    }\n    /**\n   * Returns the framing rectangle of the polygon as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */ getBounds(out) {\n        out = out || new (0, $soqVu.Rectangle)();\n        const points = this.points;\n        let minX = Infinity;\n        let maxX = -Infinity;\n        let minY = Infinity;\n        let maxY = -Infinity;\n        for(let i = 0, n = points.length; i < n; i += 2){\n            const x = points[i];\n            const y = points[i + 1];\n            minX = x < minX ? x : minX;\n            maxX = x > maxX ? x : maxX;\n            minY = y < minY ? y : minY;\n            maxY = y > maxY ? y : maxY;\n        }\n        out.x = minX;\n        out.width = maxX - minX;\n        out.y = minY;\n        out.height = maxY - minY;\n        return out;\n    }\n    /**\n   * Copies another polygon to this one.\n   * @param polygon - The polygon to copy from.\n   * @returns Returns itself.\n   */ copyFrom(polygon) {\n        this.points = polygon.points.slice();\n        this.closePath = polygon.closePath;\n        return this;\n    }\n    /**\n   * Copies this polygon to another one.\n   * @param polygon - The polygon to copy to.\n   * @returns Returns given parameter.\n   */ copyTo(polygon) {\n        polygon.copyFrom(this);\n        return polygon;\n    }\n    toString() {\n        return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint)=>`${pointsDesc}, ${currentPoint}`, \"\")}]`;\n    }\n    /**\n   * Get the last X coordinate of the polygon\n   * @readonly\n   */ get lastX() {\n        return this.points[this.points.length - 2];\n    }\n    /**\n   * Get the last Y coordinate of the polygon\n   * @readonly\n   */ get lastY() {\n        return this.points[this.points.length - 1];\n    }\n    /**\n   * Get the first X coordinate of the polygon\n   * @readonly\n   */ get x() {\n        return this.points[this.points.length - 2];\n    }\n    /**\n   * Get the first Y coordinate of the polygon\n   * @readonly\n   */ get y() {\n        return this.points[this.points.length - 1];\n    }\n}\n\n});\nparcelRegister(\"3qFiz\", function(module, exports) {\n\n$parcel$export(module.exports, \"squaredDistanceToLineSegment\", () => $fd3b27189267ad33$export$db32ff20ff695a);\n\"use strict\";\nfunction $fd3b27189267ad33$export$db32ff20ff695a(x, y, x1, y1, x2, y2) {\n    const a = x - x1;\n    const b = y - y1;\n    const c = x2 - x1;\n    const d = y2 - y1;\n    const dot = a * c + b * d;\n    const lenSq = c * c + d * d;\n    let param = -1;\n    if (lenSq !== 0) param = dot / lenSq;\n    let xx;\n    let yy;\n    if (param < 0) {\n        xx = x1;\n        yy = y1;\n    } else if (param > 1) {\n        xx = x2;\n        yy = y2;\n    } else {\n        xx = x1 + param * c;\n        yy = y1 + param * d;\n    }\n    const dx = x - xx;\n    const dy = y - yy;\n    return dx * dx + dy * dy;\n}\n\n});\n\n\nparcelRegister(\"guUt8\", function(module, exports) {\n\n$parcel$export(module.exports, \"RoundedRectangle\", () => $9aaa16b8073529a2$export$d55ab2e3dc5a4263);\n\nvar $soqVu = parcelRequire(\"soqVu\");\n\"use strict\";\nconst $9aaa16b8073529a2$var$isCornerWithinStroke = (pX, pY, cornerX, cornerY, radius, halfStrokeWidth)=>{\n    const dx = pX - cornerX;\n    const dy = pY - cornerY;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    return distance >= radius - halfStrokeWidth && distance <= radius + halfStrokeWidth;\n};\nclass $9aaa16b8073529a2$export$d55ab2e3dc5a4263 {\n    /**\n   * @param x - The X coordinate of the upper-left corner of the rounded rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\n   * @param width - The overall width of this rounded rectangle\n   * @param height - The overall height of this rounded rectangle\n   * @param radius - Controls the radius of the rounded corners\n   */ constructor(x = 0, y = 0, width = 0, height = 0, radius = 20){\n        /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'roundedRectangle'\n     */ this.type = \"roundedRectangle\";\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.radius = radius;\n    }\n    /**\n   * Returns the framing rectangle of the rounded rectangle as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */ getBounds(out) {\n        out = out || new (0, $soqVu.Rectangle)();\n        out.x = this.x;\n        out.y = this.y;\n        out.width = this.width;\n        out.height = this.height;\n        return out;\n    }\n    /**\n   * Creates a clone of this Rounded Rectangle.\n   * @returns - A copy of the rounded rectangle.\n   */ clone() {\n        return new $9aaa16b8073529a2$export$d55ab2e3dc5a4263(this.x, this.y, this.width, this.height, this.radius);\n    }\n    /**\n   * Copies another rectangle to this one.\n   * @param rectangle - The rectangle to copy from.\n   * @returns Returns itself.\n   */ copyFrom(rectangle) {\n        this.x = rectangle.x;\n        this.y = rectangle.y;\n        this.width = rectangle.width;\n        this.height = rectangle.height;\n        return this;\n    }\n    /**\n   * Copies this rectangle to another one.\n   * @param rectangle - The rectangle to copy to.\n   * @returns Returns given parameter.\n   */ copyTo(rectangle) {\n        rectangle.copyFrom(this);\n        return rectangle;\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this Rounded Rectangle.\n   */ contains(x, y) {\n        if (this.width <= 0 || this.height <= 0) return false;\n        if (x >= this.x && x <= this.x + this.width) {\n            if (y >= this.y && y <= this.y + this.height) {\n                const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n                if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius) return true;\n                let dx = x - (this.x + radius);\n                let dy = y - (this.y + radius);\n                const radius2 = radius * radius;\n                if (dx * dx + dy * dy <= radius2) return true;\n                dx = x - (this.x + this.width - radius);\n                if (dx * dx + dy * dy <= radius2) return true;\n                dy = y - (this.y + this.height - radius);\n                if (dx * dx + dy * dy <= radius2) return true;\n                dx = x - (this.x + radius);\n                if (dx * dx + dy * dy <= radius2) return true;\n            }\n        }\n        return false;\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n   * @param pX - The X coordinate of the point to test\n   * @param pY - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this rectangle\n   */ strokeContains(pX, pY, strokeWidth) {\n        const { x: x, y: y, width: width, height: height, radius: radius } = this;\n        const halfStrokeWidth = strokeWidth / 2;\n        const innerX = x + radius;\n        const innerY = y + radius;\n        const innerWidth = width - radius * 2;\n        const innerHeight = height - radius * 2;\n        const rightBound = x + width;\n        const bottomBound = y + height;\n        if ((pX >= x - halfStrokeWidth && pX <= x + halfStrokeWidth || pX >= rightBound - halfStrokeWidth && pX <= rightBound + halfStrokeWidth) && pY >= innerY && pY <= innerY + innerHeight) return true;\n        if ((pY >= y - halfStrokeWidth && pY <= y + halfStrokeWidth || pY >= bottomBound - halfStrokeWidth && pY <= bottomBound + halfStrokeWidth) && pX >= innerX && pX <= innerX + innerWidth) return true;\n        return(// Top-left\n        pX < innerX && pY < innerY && $9aaa16b8073529a2$var$isCornerWithinStroke(pX, pY, innerX, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY < innerY && $9aaa16b8073529a2$var$isCornerWithinStroke(pX, pY, rightBound - radius, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY > bottomBound - radius && $9aaa16b8073529a2$var$isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius, radius, halfStrokeWidth) || pX < innerX && pY > bottomBound - radius && $9aaa16b8073529a2$var$isCornerWithinStroke(pX, pY, innerX, bottomBound - radius, radius, halfStrokeWidth));\n    }\n    toString() {\n        return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;\n    }\n}\n\n});\n\nparcelRegister(\"67FNK\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildAdaptiveBezier\", () => $d2f144dff168992b$export$7dab5eac414ecba2);\n\nvar $bBCDe = parcelRequire(\"bBCDe\");\n\"use strict\";\nconst $d2f144dff168992b$var$RECURSION_LIMIT = 8;\nconst $d2f144dff168992b$var$FLT_EPSILON = 11920929e-14;\nconst $d2f144dff168992b$var$PATH_DISTANCE_EPSILON = 1;\nconst $d2f144dff168992b$var$curveAngleToleranceEpsilon = 0.01;\nconst $d2f144dff168992b$var$mAngleTolerance = 0;\nconst $d2f144dff168992b$var$mCuspLimit = 0;\nfunction $d2f144dff168992b$export$7dab5eac414ecba2(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {\n    const scale = 1;\n    const smoothing = Math.min(0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? (0, $bBCDe.GraphicsContextSystem).defaultOptions.bezierSmoothness));\n    let distanceTolerance = ($d2f144dff168992b$var$PATH_DISTANCE_EPSILON - smoothing) / scale;\n    distanceTolerance *= distanceTolerance;\n    $d2f144dff168992b$var$begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);\n    return points;\n}\nfunction $d2f144dff168992b$var$begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {\n    $d2f144dff168992b$var$recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);\n    points.push(eX, eY);\n}\nfunction $d2f144dff168992b$var$recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {\n    if (level > $d2f144dff168992b$var$RECURSION_LIMIT) return;\n    const pi = Math.PI;\n    const x12 = (x1 + x2) / 2;\n    const y12 = (y1 + y2) / 2;\n    const x23 = (x2 + x3) / 2;\n    const y23 = (y2 + y3) / 2;\n    const x34 = (x3 + x4) / 2;\n    const y34 = (y3 + y4) / 2;\n    const x123 = (x12 + x23) / 2;\n    const y123 = (y12 + y23) / 2;\n    const x234 = (x23 + x34) / 2;\n    const y234 = (y23 + y34) / 2;\n    const x1234 = (x123 + x234) / 2;\n    const y1234 = (y123 + y234) / 2;\n    if (level > 0) {\n        let dx = x4 - x1;\n        let dy = y4 - y1;\n        const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);\n        const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);\n        let da1;\n        let da2;\n        if (d2 > $d2f144dff168992b$var$FLT_EPSILON && d3 > $d2f144dff168992b$var$FLT_EPSILON) {\n            if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {\n                if ($d2f144dff168992b$var$mAngleTolerance < $d2f144dff168992b$var$curveAngleToleranceEpsilon) {\n                    points.push(x1234, y1234);\n                    return;\n                }\n                const a23 = Math.atan2(y3 - y2, x3 - x2);\n                da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));\n                da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);\n                if (da1 >= pi) da1 = 2 * pi - da1;\n                if (da2 >= pi) da2 = 2 * pi - da2;\n                if (da1 + da2 < $d2f144dff168992b$var$mAngleTolerance) {\n                    points.push(x1234, y1234);\n                    return;\n                }\n                if ($d2f144dff168992b$var$mCuspLimit !== 0) {\n                    if (da1 > $d2f144dff168992b$var$mCuspLimit) {\n                        points.push(x2, y2);\n                        return;\n                    }\n                    if (da2 > $d2f144dff168992b$var$mCuspLimit) {\n                        points.push(x3, y3);\n                        return;\n                    }\n                }\n            }\n        } else if (d2 > $d2f144dff168992b$var$FLT_EPSILON) {\n            if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {\n                if ($d2f144dff168992b$var$mAngleTolerance < $d2f144dff168992b$var$curveAngleToleranceEpsilon) {\n                    points.push(x1234, y1234);\n                    return;\n                }\n                da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n                if (da1 >= pi) da1 = 2 * pi - da1;\n                if (da1 < $d2f144dff168992b$var$mAngleTolerance) {\n                    points.push(x2, y2);\n                    points.push(x3, y3);\n                    return;\n                }\n                if ($d2f144dff168992b$var$mCuspLimit !== 0) {\n                    if (da1 > $d2f144dff168992b$var$mCuspLimit) {\n                        points.push(x2, y2);\n                        return;\n                    }\n                }\n            }\n        } else if (d3 > $d2f144dff168992b$var$FLT_EPSILON) {\n            if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {\n                if ($d2f144dff168992b$var$mAngleTolerance < $d2f144dff168992b$var$curveAngleToleranceEpsilon) {\n                    points.push(x1234, y1234);\n                    return;\n                }\n                da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));\n                if (da1 >= pi) da1 = 2 * pi - da1;\n                if (da1 < $d2f144dff168992b$var$mAngleTolerance) {\n                    points.push(x2, y2);\n                    points.push(x3, y3);\n                    return;\n                }\n                if ($d2f144dff168992b$var$mCuspLimit !== 0) {\n                    if (da1 > $d2f144dff168992b$var$mCuspLimit) {\n                        points.push(x3, y3);\n                        return;\n                    }\n                }\n            }\n        } else {\n            dx = x1234 - (x1 + x4) / 2;\n            dy = y1234 - (y1 + y4) / 2;\n            if (dx * dx + dy * dy <= distanceTolerance) {\n                points.push(x1234, y1234);\n                return;\n            }\n        }\n    }\n    $d2f144dff168992b$var$recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);\n    $d2f144dff168992b$var$recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);\n}\n\n});\n\nparcelRegister(\"hYods\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildAdaptiveQuadratic\", () => $249f722f6952cd8d$export$d53ce9debfe7a6c2);\n\nvar $bBCDe = parcelRequire(\"bBCDe\");\n\"use strict\";\nconst $249f722f6952cd8d$var$RECURSION_LIMIT = 8;\nconst $249f722f6952cd8d$var$FLT_EPSILON = 11920929e-14;\nconst $249f722f6952cd8d$var$PATH_DISTANCE_EPSILON = 1;\nconst $249f722f6952cd8d$var$curveAngleToleranceEpsilon = 0.01;\nconst $249f722f6952cd8d$var$mAngleTolerance = 0;\nfunction $249f722f6952cd8d$export$d53ce9debfe7a6c2(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {\n    const scale = 1;\n    const smoothing = Math.min(0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? (0, $bBCDe.GraphicsContextSystem).defaultOptions.bezierSmoothness));\n    let distanceTolerance = ($249f722f6952cd8d$var$PATH_DISTANCE_EPSILON - smoothing) / scale;\n    distanceTolerance *= distanceTolerance;\n    $249f722f6952cd8d$var$begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);\n    return points;\n}\nfunction $249f722f6952cd8d$var$begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {\n    $249f722f6952cd8d$var$recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);\n    points.push(eX, eY);\n}\nfunction $249f722f6952cd8d$var$recursive(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {\n    if (level > $249f722f6952cd8d$var$RECURSION_LIMIT) return;\n    const pi = Math.PI;\n    const x12 = (x1 + x2) / 2;\n    const y12 = (y1 + y2) / 2;\n    const x23 = (x2 + x3) / 2;\n    const y23 = (y2 + y3) / 2;\n    const x123 = (x12 + x23) / 2;\n    const y123 = (y12 + y23) / 2;\n    let dx = x3 - x1;\n    let dy = y3 - y1;\n    const d = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);\n    if (d > $249f722f6952cd8d$var$FLT_EPSILON) {\n        if (d * d <= distanceTolerance * (dx * dx + dy * dy)) {\n            if ($249f722f6952cd8d$var$mAngleTolerance < $249f722f6952cd8d$var$curveAngleToleranceEpsilon) {\n                points.push(x123, y123);\n                return;\n            }\n            let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n            if (da >= pi) da = 2 * pi - da;\n            if (da < $249f722f6952cd8d$var$mAngleTolerance) {\n                points.push(x123, y123);\n                return;\n            }\n        }\n    } else {\n        dx = x123 - (x1 + x3) / 2;\n        dy = y123 - (y1 + y3) / 2;\n        if (dx * dx + dy * dy <= distanceTolerance) {\n            points.push(x123, y123);\n            return;\n        }\n    }\n    $249f722f6952cd8d$var$recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);\n    $249f722f6952cd8d$var$recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);\n}\n\n});\n\nparcelRegister(\"dMnI7\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildArc\", () => $6989b84ced0da47e$export$ed8eebdc6998f0f6);\n\"use strict\";\nfunction $6989b84ced0da47e$export$ed8eebdc6998f0f6(points, x, y, radius, start, end, clockwise, steps) {\n    let dist = Math.abs(start - end);\n    if (!clockwise && start > end) dist = 2 * Math.PI - dist;\n    else if (clockwise && end > start) dist = 2 * Math.PI - dist;\n    steps = steps || Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI)));\n    steps = Math.max(steps, 3);\n    let f = dist / steps;\n    let t = start;\n    f *= clockwise ? -1 : 1;\n    for(let i = 0; i < steps + 1; i++){\n        const cs = Math.cos(t);\n        const sn = Math.sin(t);\n        const nx = x + cs * radius;\n        const ny = y + sn * radius;\n        points.push(nx, ny);\n        t += f;\n    }\n}\n\n});\n\nparcelRegister(\"1DEaT\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildArcTo\", () => $af8dfaaf6c5d82fa$export$d46b7933b415e02f);\n\nvar $dMnI7 = parcelRequire(\"dMnI7\");\n\"use strict\";\nfunction $af8dfaaf6c5d82fa$export$d46b7933b415e02f(points, x1, y1, x2, y2, radius) {\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n    const a1 = fromY - y1;\n    const b1 = fromX - x1;\n    const a2 = y2 - y1;\n    const b2 = x2 - x1;\n    const mm = Math.abs(a1 * b2 - b1 * a2);\n    if (mm < 1e-8 || radius === 0) {\n        if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) points.push(x1, y1);\n        return;\n    }\n    const dd = a1 * a1 + b1 * b1;\n    const cc = a2 * a2 + b2 * b2;\n    const tt = a1 * a2 + b1 * b2;\n    const k1 = radius * Math.sqrt(dd) / mm;\n    const k2 = radius * Math.sqrt(cc) / mm;\n    const j1 = k1 * tt / dd;\n    const j2 = k2 * tt / cc;\n    const cx = k1 * b2 + k2 * b1;\n    const cy = k1 * a2 + k2 * a1;\n    const px = b1 * (k2 + j1);\n    const py = a1 * (k2 + j1);\n    const qx = b2 * (k1 + j2);\n    const qy = a2 * (k1 + j2);\n    const startAngle = Math.atan2(py - cy, px - cx);\n    const endAngle = Math.atan2(qy - cy, qx - cx);\n    (0, $dMnI7.buildArc)(points, cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);\n}\n\n});\n\nparcelRegister(\"j5RWP\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildArcToSvg\", () => $8f96af1b23509e17$export$71ccaa6dca53075e);\n\nvar $67FNK = parcelRequire(\"67FNK\");\n\"use strict\";\nconst $8f96af1b23509e17$var$TAU = Math.PI * 2;\nconst $8f96af1b23509e17$var$out = {\n    centerX: 0,\n    centerY: 0,\n    ang1: 0,\n    ang2: 0\n};\nconst $8f96af1b23509e17$var$mapToEllipse = ({ x: x, y: y }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2)=>{\n    x *= rx;\n    y *= ry;\n    const xp = cosPhi * x - sinPhi * y;\n    const yp = sinPhi * x + cosPhi * y;\n    out2.x = xp + centerX;\n    out2.y = yp + centerY;\n    return out2;\n};\nfunction $8f96af1b23509e17$var$approxUnitArc(ang1, ang2) {\n    const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n    const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;\n    const x1 = Math.cos(ang1);\n    const y1 = Math.sin(ang1);\n    const x2 = Math.cos(ang1 + ang2);\n    const y2 = Math.sin(ang1 + ang2);\n    return [\n        {\n            x: x1 - y1 * a,\n            y: y1 + x1 * a\n        },\n        {\n            x: x2 + y2 * a,\n            y: y2 - x2 * a\n        },\n        {\n            x: x2,\n            y: y2\n        }\n    ];\n}\nconst $8f96af1b23509e17$var$vectorAngle = (ux, uy, vx, vy)=>{\n    const sign = ux * vy - uy * vx < 0 ? -1 : 1;\n    let dot = ux * vx + uy * vy;\n    if (dot > 1) dot = 1;\n    if (dot < -1) dot = -1;\n    return sign * Math.acos(dot);\n};\nconst $8f96af1b23509e17$var$getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2)=>{\n    const rxSq = Math.pow(rx, 2);\n    const rySq = Math.pow(ry, 2);\n    const pxpSq = Math.pow(pxp, 2);\n    const pypSq = Math.pow(pyp, 2);\n    let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;\n    if (radicant < 0) radicant = 0;\n    radicant /= rxSq * pypSq + rySq * pxpSq;\n    radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n    const centerXp = radicant * rx / ry * pyp;\n    const centerYp = radicant * -ry / rx * pxp;\n    const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;\n    const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;\n    const vx1 = (pxp - centerXp) / rx;\n    const vy1 = (pyp - centerYp) / ry;\n    const vx2 = (-pxp - centerXp) / rx;\n    const vy2 = (-pyp - centerYp) / ry;\n    const ang1 = $8f96af1b23509e17$var$vectorAngle(1, 0, vx1, vy1);\n    let ang2 = $8f96af1b23509e17$var$vectorAngle(vx1, vy1, vx2, vy2);\n    if (sweepFlag === 0 && ang2 > 0) ang2 -= $8f96af1b23509e17$var$TAU;\n    if (sweepFlag === 1 && ang2 < 0) ang2 += $8f96af1b23509e17$var$TAU;\n    out2.centerX = centerX;\n    out2.centerY = centerY;\n    out2.ang1 = ang1;\n    out2.ang2 = ang2;\n};\nfunction $8f96af1b23509e17$export$71ccaa6dca53075e(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {\n    if (rx === 0 || ry === 0) return;\n    const sinPhi = Math.sin(xAxisRotation * $8f96af1b23509e17$var$TAU / 360);\n    const cosPhi = Math.cos(xAxisRotation * $8f96af1b23509e17$var$TAU / 360);\n    const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;\n    const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;\n    if (pxp === 0 && pyp === 0) return;\n    rx = Math.abs(rx);\n    ry = Math.abs(ry);\n    const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n    if (lambda > 1) {\n        rx *= Math.sqrt(lambda);\n        ry *= Math.sqrt(lambda);\n    }\n    $8f96af1b23509e17$var$getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, $8f96af1b23509e17$var$out);\n    let { ang1: ang1, ang2: ang2 } = $8f96af1b23509e17$var$out;\n    const { centerX: centerX, centerY: centerY } = $8f96af1b23509e17$var$out;\n    let ratio = Math.abs(ang2) / ($8f96af1b23509e17$var$TAU / 4);\n    if (Math.abs(1 - ratio) < 1e-7) ratio = 1;\n    const segments = Math.max(Math.ceil(ratio), 1);\n    ang2 /= segments;\n    let lastX = points[points.length - 2];\n    let lastY = points[points.length - 1];\n    const outCurvePoint = {\n        x: 0,\n        y: 0\n    };\n    for(let i = 0; i < segments; i++){\n        const curve = $8f96af1b23509e17$var$approxUnitArc(ang1, ang2);\n        const { x: x1, y: y1 } = $8f96af1b23509e17$var$mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        const { x: x2, y: y2 } = $8f96af1b23509e17$var$mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        const { x: x, y: y } = $8f96af1b23509e17$var$mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        (0, $67FNK.buildAdaptiveBezier)(points, lastX, lastY, x1, y1, x2, y2, x, y);\n        lastX = x;\n        lastY = y;\n        ang1 += ang2;\n    }\n}\n\n});\n\nparcelRegister(\"5fPVY\", function(module, exports) {\n\n$parcel$export(module.exports, \"roundedShapeArc\", () => $c691bb6c363f5133$export$ae1f43bc280f09be);\n$parcel$export(module.exports, \"roundedShapeQuadraticCurve\", () => $c691bb6c363f5133$export$cf503f371c53af9e);\n\"use strict\";\nfunction $c691bb6c363f5133$export$ae1f43bc280f09be(g, points, radius) {\n    const vecFrom = (p, pp)=>{\n        const x = pp.x - p.x;\n        const y = pp.y - p.y;\n        const len = Math.sqrt(x * x + y * y);\n        const nx = x / len;\n        const ny = y / len;\n        return {\n            len: len,\n            nx: nx,\n            ny: ny\n        };\n    };\n    const sharpCorner = (i, p)=>{\n        if (i === 0) g.moveTo(p.x, p.y);\n        else g.lineTo(p.x, p.y);\n    };\n    let p1 = points[points.length - 1];\n    for(let i = 0; i < points.length; i++){\n        const p2 = points[i % points.length];\n        const pRadius = p2.radius ?? radius;\n        if (pRadius <= 0) {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n        const p3 = points[(i + 1) % points.length];\n        const v1 = vecFrom(p2, p1);\n        const v2 = vecFrom(p2, p3);\n        if (v1.len < 1e-4 || v2.len < 1e-4) {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n        let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);\n        let radDirection = 1;\n        let drawDirection = false;\n        if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {\n            if (angle < 0) angle = Math.PI + angle;\n            else {\n                angle = Math.PI - angle;\n                radDirection = -1;\n                drawDirection = true;\n            }\n        } else if (angle > 0) {\n            radDirection = -1;\n            drawDirection = true;\n        }\n        const halfAngle = angle / 2;\n        let cRadius;\n        let lenOut = Math.abs(Math.cos(halfAngle) * pRadius / Math.sin(halfAngle));\n        if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {\n            lenOut = Math.min(v1.len / 2, v2.len / 2);\n            cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));\n        } else cRadius = pRadius;\n        const cX = p2.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;\n        const cY = p2.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;\n        const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;\n        const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;\n        if (i === 0) g.moveTo(cX + Math.cos(startAngle) * cRadius, cY + Math.sin(startAngle) * cRadius);\n        g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n        p1 = p2;\n    }\n}\nfunction $c691bb6c363f5133$export$cf503f371c53af9e(g, points, radius, smoothness) {\n    const distance = (p1, p2)=>Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);\n    const pointLerp = (p1, p2, t)=>({\n            x: p1.x + (p2.x - p1.x) * t,\n            y: p1.y + (p2.y - p1.y) * t\n        });\n    const numPoints = points.length;\n    for(let i = 0; i < numPoints; i++){\n        const thisPoint = points[(i + 1) % numPoints];\n        const pRadius = thisPoint.radius ?? radius;\n        if (pRadius <= 0) {\n            if (i === 0) g.moveTo(thisPoint.x, thisPoint.y);\n            else g.lineTo(thisPoint.x, thisPoint.y);\n            continue;\n        }\n        const lastPoint = points[i];\n        const nextPoint = points[(i + 2) % numPoints];\n        const lastEdgeLength = distance(lastPoint, thisPoint);\n        let start;\n        if (lastEdgeLength < 1e-4) start = thisPoint;\n        else {\n            const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n            start = pointLerp(thisPoint, lastPoint, lastOffsetDistance / lastEdgeLength);\n        }\n        const nextEdgeLength = distance(nextPoint, thisPoint);\n        let end;\n        if (nextEdgeLength < 1e-4) end = thisPoint;\n        else {\n            const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n            end = pointLerp(thisPoint, nextPoint, nextOffsetDistance / nextEdgeLength);\n        }\n        if (i === 0) g.moveTo(start.x, start.y);\n        else g.lineTo(start.x, start.y);\n        g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);\n    }\n}\n\n});\n\n\n\nparcelRegister(\"hFJzr\", function(module, exports) {\n\n$parcel$export(module.exports, \"SVGParser\", () => $0de3ca2e98777172$export$2cc2aaca18109aab);\n\nvar $AHTcQ = parcelRequire(\"AHTcQ\");\n\nvar $awDzm = parcelRequire(\"awDzm\");\n\"use strict\";\nfunction $0de3ca2e98777172$export$2cc2aaca18109aab(svg, graphicsContext) {\n    if (typeof svg === \"string\") {\n        const div = document.createElement(\"div\");\n        div.innerHTML = svg.trim();\n        svg = div.querySelector(\"svg\");\n    }\n    const session = {\n        context: graphicsContext,\n        path: new (0, $awDzm.GraphicsPath)()\n    };\n    $0de3ca2e98777172$var$renderChildren(svg, session, null, null);\n    return graphicsContext;\n}\nfunction $0de3ca2e98777172$var$renderChildren(svg, session, fillStyle, strokeStyle) {\n    const children = svg.children;\n    const { fillStyle: f1, strokeStyle: s1 } = $0de3ca2e98777172$var$parseStyle(svg);\n    if (f1 && fillStyle) fillStyle = {\n        ...fillStyle,\n        ...f1\n    };\n    else if (f1) fillStyle = f1;\n    if (s1 && strokeStyle) strokeStyle = {\n        ...strokeStyle,\n        ...s1\n    };\n    else if (s1) strokeStyle = s1;\n    session.context.fillStyle = fillStyle;\n    session.context.strokeStyle = strokeStyle;\n    let x;\n    let y;\n    let x1;\n    let y1;\n    let x2;\n    let y2;\n    let cx;\n    let cy;\n    let r;\n    let rx;\n    let ry;\n    let points;\n    let pointsString;\n    let d;\n    let graphicsPath;\n    let width;\n    let height;\n    switch(svg.nodeName.toLowerCase()){\n        case \"path\":\n            d = svg.getAttribute(\"d\");\n            graphicsPath = new (0, $awDzm.GraphicsPath)(d);\n            session.context.path(graphicsPath);\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n            break;\n        case \"circle\":\n            cx = $0de3ca2e98777172$var$parseFloatAttribute(svg, \"cx\", 0);\n            cy = $0de3ca2e98777172$var$parseFloatAttribute(svg, \"cy\", 0);\n            r = $0de3ca2e98777172$var$parseFloatAttribute(svg, \"r\", 0);\n            session.context.ellipse(cx, cy, r, r);\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n            break;\n        case \"rect\":\n            x = $0de3ca2e98777172$var$parseFloatAttribute(svg, \"x\", 0);\n            y = $0de3ca2e98777172$var$parseFloatAttribute(svg, \"y\", 0);\n            width = $0de3ca2e98777172$var$parseFloatAttribute(svg, \"width\", 0);\n            height = $0de3ca2e98777172$var$parseFloatAttribute(svg, \"height\", 0);\n            rx = $0de3ca2e98777172$var$parseFloatAttribute(svg, \"rx\", 0);\n            ry = $0de3ca2e98777172$var$parseFloatAttribute(svg, \"ry\", 0);\n            if (rx || ry) session.context.roundRect(x, y, width, height, rx || ry);\n            else session.context.rect(x, y, width, height);\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n            break;\n        case \"ellipse\":\n            cx = $0de3ca2e98777172$var$parseFloatAttribute(svg, \"cx\", 0);\n            cy = $0de3ca2e98777172$var$parseFloatAttribute(svg, \"cy\", 0);\n            rx = $0de3ca2e98777172$var$parseFloatAttribute(svg, \"rx\", 0);\n            ry = $0de3ca2e98777172$var$parseFloatAttribute(svg, \"ry\", 0);\n            session.context.beginPath();\n            session.context.ellipse(cx, cy, rx, ry);\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n            break;\n        case \"line\":\n            x1 = $0de3ca2e98777172$var$parseFloatAttribute(svg, \"x1\", 0);\n            y1 = $0de3ca2e98777172$var$parseFloatAttribute(svg, \"y1\", 0);\n            x2 = $0de3ca2e98777172$var$parseFloatAttribute(svg, \"x2\", 0);\n            y2 = $0de3ca2e98777172$var$parseFloatAttribute(svg, \"y2\", 0);\n            session.context.beginPath();\n            session.context.moveTo(x1, y1);\n            session.context.lineTo(x2, y2);\n            if (strokeStyle) session.context.stroke();\n            break;\n        case \"polygon\":\n            pointsString = svg.getAttribute(\"points\");\n            points = pointsString.match(/\\d+/g).map((n)=>parseInt(n, 10));\n            session.context.poly(points, true);\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n            break;\n        case \"polyline\":\n            pointsString = svg.getAttribute(\"points\");\n            points = pointsString.match(/\\d+/g).map((n)=>parseInt(n, 10));\n            session.context.poly(points, false);\n            if (strokeStyle) session.context.stroke();\n            break;\n        case \"g\":\n        case \"svg\":\n            break;\n        default:\n            console.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);\n            break;\n    }\n    for(let i = 0; i < children.length; i++)$0de3ca2e98777172$var$renderChildren(children[i], session, fillStyle, strokeStyle);\n}\nfunction $0de3ca2e98777172$var$parseFloatAttribute(svg, id, defaultValue) {\n    const value = svg.getAttribute(id);\n    return value ? Number(value) : defaultValue;\n}\nfunction $0de3ca2e98777172$var$parseStyle(svg) {\n    const style = svg.getAttribute(\"style\");\n    const strokeStyle = {};\n    const fillStyle = {};\n    let useFill = false;\n    let useStroke = false;\n    if (style) {\n        const styleParts = style.split(\";\");\n        for(let i = 0; i < styleParts.length; i++){\n            const stylePart = styleParts[i];\n            const [key, value] = stylePart.split(\":\");\n            switch(key){\n                case \"stroke\":\n                    if (value !== \"none\") {\n                        strokeStyle.color = (0, $AHTcQ.Color).shared.setValue(value).toNumber();\n                        useStroke = true;\n                    }\n                    break;\n                case \"stroke-width\":\n                    strokeStyle.width = Number(value);\n                    break;\n                case \"fill\":\n                    if (value !== \"none\") {\n                        useFill = true;\n                        fillStyle.color = (0, $AHTcQ.Color).shared.setValue(value).toNumber();\n                    }\n                    break;\n                case \"fill-opacity\":\n                    fillStyle.alpha = Number(value);\n                    break;\n                case \"stroke-opacity\":\n                    strokeStyle.alpha = Number(value);\n                    break;\n                case \"opacity\":\n                    fillStyle.alpha = Number(value);\n                    strokeStyle.alpha = Number(value);\n                    break;\n            }\n        }\n    } else {\n        const stroke = svg.getAttribute(\"stroke\");\n        if (stroke && stroke !== \"none\") {\n            useStroke = true;\n            strokeStyle.color = (0, $AHTcQ.Color).shared.setValue(stroke).toNumber();\n            strokeStyle.width = $0de3ca2e98777172$var$parseFloatAttribute(svg, \"stroke-width\", 1);\n        }\n        const fill = svg.getAttribute(\"fill\");\n        if (fill && fill !== \"none\") {\n            useFill = true;\n            fillStyle.color = (0, $AHTcQ.Color).shared.setValue(fill).toNumber();\n        }\n    }\n    return {\n        strokeStyle: useStroke ? strokeStyle : null,\n        fillStyle: useFill ? fillStyle : null\n    };\n}\n\n});\n\nparcelRegister(\"jwZTp\", function(module, exports) {\n\n$parcel$export(module.exports, \"convertFillInputToFillStyle\", () => $ebc1b92119e4a307$export$816bdeacb94f608f);\n\nvar $AHTcQ = parcelRequire(\"AHTcQ\");\n\nvar $dNaJE = parcelRequire(\"dNaJE\");\n\nvar $5h88T = parcelRequire(\"5h88T\");\n\nvar $j8pAr = parcelRequire(\"j8pAr\");\n\nvar $hZTCO = parcelRequire(\"hZTCO\");\n\"use strict\";\nfunction $ebc1b92119e4a307$export$816bdeacb94f608f(value, defaultStyle) {\n    if (value === void 0 || value === null) return null;\n    let fillStyleToParse;\n    let styleToMerge;\n    if (value?.fill) {\n        styleToMerge = value.fill;\n        fillStyleToParse = {\n            ...defaultStyle,\n            ...value\n        };\n    } else {\n        styleToMerge = value;\n        fillStyleToParse = defaultStyle;\n    }\n    if ((0, $AHTcQ.Color).isColorLike(styleToMerge)) {\n        const temp = (0, $AHTcQ.Color).shared.setValue(styleToMerge ?? 0);\n        const opts = {\n            ...fillStyleToParse,\n            color: temp.toNumber(),\n            alpha: temp.alpha === 1 ? fillStyleToParse.alpha : temp.alpha,\n            texture: (0, $5h88T.Texture).WHITE\n        };\n        return opts;\n    } else if (styleToMerge instanceof (0, $hZTCO.FillPattern)) {\n        const pattern = styleToMerge;\n        return {\n            ...fillStyleToParse,\n            color: 16777215,\n            texture: pattern.texture,\n            matrix: pattern.transform,\n            fill: fillStyleToParse.fill ?? null\n        };\n    } else if (styleToMerge instanceof (0, $j8pAr.FillGradient)) {\n        const gradient = styleToMerge;\n        gradient.buildLinearGradient();\n        return {\n            ...fillStyleToParse,\n            color: 16777215,\n            texture: gradient.texture,\n            matrix: gradient.transform\n        };\n    }\n    const style = {\n        ...defaultStyle,\n        ...value\n    };\n    if (style.texture) {\n        if (style.texture !== (0, $5h88T.Texture).WHITE) {\n            const m = style.matrix?.invert() || new (0, $dNaJE.Matrix)();\n            m.scale(1 / style.texture.frame.width, 1 / style.texture.frame.height);\n            style.matrix = m;\n        }\n        const sourceStyle = style.texture.source.style;\n        if (sourceStyle.addressMode === \"clamp-to-edge\") sourceStyle.addressMode = \"repeat\";\n    }\n    const color = (0, $AHTcQ.Color).shared.setValue(style.color);\n    style.alpha *= color.alpha;\n    style.color = color.toNumber();\n    style.matrix = style.matrix ? style.matrix.clone() : null;\n    return style;\n}\n\n});\n\n\nparcelRegister(\"gSm2a\", function(module, exports) {\n\n$parcel$export(module.exports, \"generateTextStyleKey\", () => $bd4fc7f01fbab292$export$8a3681e2b47964bb);\n\"use strict\";\nconst $bd4fc7f01fbab292$var$valuesToIterateForKeys = [\n    \"_fontFamily\",\n    \"_fontStyle\",\n    \"_fontSize\",\n    \"_fontVariant\",\n    \"_fontWeight\",\n    \"_breakWords\",\n    \"_align\",\n    \"_leading\",\n    \"_letterSpacing\",\n    \"_lineHeight\",\n    \"_textBaseline\",\n    \"_whiteSpace\",\n    \"_wordWrap\",\n    \"_wordWrapWidth\",\n    \"_padding\",\n    \"_cssOverrides\",\n    \"_trim\"\n];\nfunction $bd4fc7f01fbab292$export$8a3681e2b47964bb(style) {\n    const key = [];\n    let index = 0;\n    for(let i = 0; i < $bd4fc7f01fbab292$var$valuesToIterateForKeys.length; i++){\n        const prop = $bd4fc7f01fbab292$var$valuesToIterateForKeys[i];\n        key[index++] = style[prop];\n    }\n    index = $bd4fc7f01fbab292$var$addFillStyleKey(style._fill, key, index);\n    index = $bd4fc7f01fbab292$var$addStokeStyleKey(style._stroke, key, index);\n    return key.join(\"-\");\n}\nfunction $bd4fc7f01fbab292$var$addFillStyleKey(fillStyle, key, index) {\n    if (!fillStyle) return index;\n    key[index++] = fillStyle.color;\n    key[index++] = fillStyle.alpha;\n    key[index++] = fillStyle.fill?.uid;\n    return index;\n}\nfunction $bd4fc7f01fbab292$var$addStokeStyleKey(strokeStyle, key, index) {\n    if (!strokeStyle) return index;\n    index = $bd4fc7f01fbab292$var$addFillStyleKey(strokeStyle, key, index);\n    key[index++] = strokeStyle.width;\n    key[index++] = strokeStyle.alignment;\n    key[index++] = strokeStyle.cap;\n    key[index++] = strokeStyle.join;\n    key[index++] = strokeStyle.miterLimit;\n    return index;\n}\n\n});\n\n\nparcelRegister(\"54k6R\", function(module, exports) {\n\n$parcel$export(module.exports, \"DynamicBitmapFont\", () => $1e992dce2d092f08$export$bce21273d0a2e6c7);\n\nvar $AHTcQ = parcelRequire(\"AHTcQ\");\n\nvar $soqVu = parcelRequire(\"soqVu\");\n\nvar $8zNlV = parcelRequire(\"8zNlV\");\n\nvar $4XrO5 = parcelRequire(\"4XrO5\");\n\nvar $5h88T = parcelRequire(\"5h88T\");\n\nvar $eX50w = parcelRequire(\"eX50w\");\n\nvar $ffIGX = parcelRequire(\"ffIGX\");\n\nvar $fMjVf = parcelRequire(\"fMjVf\");\n\nvar $eHP3T = parcelRequire(\"eHP3T\");\n\nvar $gs09t = parcelRequire(\"gs09t\");\n\nvar $7gvRa = parcelRequire(\"7gvRa\");\n\"use strict\";\nclass $1e992dce2d092f08$export$bce21273d0a2e6c7 extends (0, $gs09t.AbstractBitmapFont) {\n    /**\n   * @param options - The options for the dynamic bitmap font.\n   */ constructor(options){\n        super();\n        /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */ this.resolution = 1;\n        /** The pages of the font. */ this.pages = [];\n        this._padding = 4;\n        this._measureCache = /* @__PURE__ */ Object.create(null);\n        this._currentChars = [];\n        this._currentX = 0;\n        this._currentY = 0;\n        this._currentPageIndex = -1;\n        this._skipKerning = false;\n        const dynamicOptions = options;\n        const style = dynamicOptions.style.clone();\n        if (dynamicOptions.overrideFill) {\n            style._fill.color = 16777215;\n            style._fill.alpha = 1;\n            style._fill.texture = (0, $5h88T.Texture).WHITE;\n            style._fill.fill = null;\n        }\n        const requestedFontSize = style.fontSize;\n        style.fontSize = this.baseMeasurementFontSize;\n        const font = (0, $fMjVf.fontStringFromTextStyle)(style);\n        if (dynamicOptions.overrideSize) {\n            if (style._stroke) style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n        } else style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n        this._style = style;\n        this._skipKerning = dynamicOptions.skipKerning ?? false;\n        this.resolution = dynamicOptions.resolution ?? 1;\n        this._padding = dynamicOptions.padding ?? 4;\n        this.fontMetrics = (0, $ffIGX.CanvasTextMetrics).measureFont(font);\n        this.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n    }\n    ensureCharacters(chars) {\n        const charList = (0, $7gvRa.resolveCharacters)(chars).filter((char)=>!this._currentChars.includes(char)).filter((char, index, self)=>self.indexOf(char) === index);\n        if (!charList.length) return;\n        this._currentChars = [\n            ...this._currentChars,\n            ...charList\n        ];\n        let pageData;\n        if (this._currentPageIndex === -1) pageData = this._nextPage();\n        else pageData = this.pages[this._currentPageIndex];\n        let { canvas: canvas, context: context } = pageData.canvasAndContext;\n        let textureSource = pageData.texture.source;\n        const style = this._style;\n        let currentX = this._currentX;\n        let currentY = this._currentY;\n        const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n        const padding = this._padding * fontScale;\n        const widthScale = style.fontStyle === \"italic\" ? 2 : 1;\n        let maxCharHeight = 0;\n        let skipTexture = false;\n        for(let i = 0; i < charList.length; i++){\n            const char = charList[i];\n            const metrics = (0, $ffIGX.CanvasTextMetrics).measureText(char, style, canvas, false);\n            metrics.lineHeight = metrics.height;\n            const width = widthScale * metrics.width * fontScale;\n            const height = metrics.height * fontScale;\n            const paddedWidth = width + padding * 2;\n            const paddedHeight = height + padding * 2;\n            skipTexture = false;\n            if (char !== \"\\n\" && char !== \"\\r\" && char !== \"\t\" && char !== \" \") {\n                skipTexture = true;\n                maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));\n            }\n            if (currentX + paddedWidth > 512) {\n                currentY += maxCharHeight;\n                maxCharHeight = paddedHeight;\n                currentX = 0;\n                if (currentY + maxCharHeight > 512) {\n                    textureSource.update();\n                    const pageData2 = this._nextPage();\n                    canvas = pageData2.canvasAndContext.canvas;\n                    context = pageData2.canvasAndContext.context;\n                    textureSource = pageData2.texture.source;\n                    currentY = 0;\n                }\n            }\n            const xAdvance = width / fontScale - (style.dropShadow?.distance ?? 0) - (style._stroke?.width ?? 0);\n            this.chars[char] = {\n                id: char.codePointAt(0),\n                xOffset: -this._padding,\n                yOffset: -this._padding,\n                xAdvance: xAdvance,\n                kerning: {}\n            };\n            if (skipTexture) {\n                this._drawGlyph(context, metrics, currentX + padding, currentY + padding, fontScale, style);\n                const px = textureSource.width * fontScale;\n                const py = textureSource.height * fontScale;\n                const frame = new (0, $soqVu.Rectangle)(currentX / px * textureSource.width, currentY / py * textureSource.height, paddedWidth / px * textureSource.width, paddedHeight / py * textureSource.height);\n                this.chars[char].texture = new (0, $5h88T.Texture)({\n                    source: textureSource,\n                    frame: frame\n                });\n                currentX += Math.ceil(paddedWidth);\n            }\n        }\n        textureSource.update();\n        this._currentX = currentX;\n        this._currentY = currentY;\n        this._skipKerning && this._applyKerning(charList, context);\n    }\n    /**\n   * @deprecated since 8.0.0\n   * The map of base page textures (i.e., sheets of glyphs).\n   */ get pageTextures() {\n        (0, $eX50w.deprecation)((0, $eX50w.v8_0_0), \"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.\");\n        return this.pages;\n    }\n    _applyKerning(newChars, context) {\n        const measureCache = this._measureCache;\n        for(let i = 0; i < newChars.length; i++){\n            const first = newChars[i];\n            for(let j = 0; j < this._currentChars.length; j++){\n                const second = this._currentChars[j];\n                let c1 = measureCache[first];\n                if (!c1) c1 = measureCache[first] = context.measureText(first).width;\n                let c2 = measureCache[second];\n                if (!c2) c2 = measureCache[second] = context.measureText(second).width;\n                let total = context.measureText(first + second).width;\n                let amount = total - (c1 + c2);\n                if (amount) this.chars[first].kerning[second] = amount;\n                total = context.measureText(first + second).width;\n                amount = total - (c1 + c2);\n                if (amount) this.chars[second].kerning[first] = amount;\n            }\n        }\n    }\n    _nextPage() {\n        this._currentPageIndex++;\n        const textureResolution = this.resolution;\n        const canvasAndContext = (0, $8zNlV.CanvasPool).getOptimalCanvasAndContext(512, 512, textureResolution);\n        this._setupContext(canvasAndContext.context, this._style, textureResolution);\n        const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n        const texture = new (0, $5h88T.Texture)({\n            source: new (0, $4XrO5.ImageSource)({\n                resource: canvasAndContext.canvas,\n                resolution: resolution,\n                alphaMode: \"premultiply-alpha-on-upload\"\n            })\n        });\n        const pageData = {\n            canvasAndContext: canvasAndContext,\n            texture: texture\n        };\n        this.pages[this._currentPageIndex] = pageData;\n        return pageData;\n    }\n    // canvas style!\n    _setupContext(context, style, resolution) {\n        style.fontSize = this.baseRenderedFontSize;\n        context.scale(resolution, resolution);\n        context.font = (0, $fMjVf.fontStringFromTextStyle)(style);\n        style.fontSize = this.baseMeasurementFontSize;\n        context.textBaseline = style.textBaseline;\n        const stroke = style._stroke;\n        const strokeThickness = stroke?.width ?? 0;\n        if (stroke) {\n            context.lineWidth = strokeThickness;\n            context.lineJoin = stroke.join;\n            context.miterLimit = stroke.miterLimit;\n            context.strokeStyle = (0, $eHP3T.getCanvasFillStyle)(stroke, context);\n        }\n        if (style._fill) context.fillStyle = (0, $eHP3T.getCanvasFillStyle)(style._fill, context);\n        if (style.dropShadow) {\n            const shadowOptions = style.dropShadow;\n            const rgb = (0, $AHTcQ.Color).shared.setValue(shadowOptions.color).toArray();\n            const dropShadowBlur = shadowOptions.blur * resolution;\n            const dropShadowDistance = shadowOptions.distance * resolution;\n            context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n            context.shadowBlur = dropShadowBlur;\n            context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n            context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n        } else {\n            context.shadowColor = \"black\";\n            context.shadowBlur = 0;\n            context.shadowOffsetX = 0;\n            context.shadowOffsetY = 0;\n        }\n    }\n    _drawGlyph(context, metrics, x, y, fontScale, style) {\n        const char = metrics.text;\n        const fontProperties = metrics.fontProperties;\n        const stroke = style._stroke;\n        const strokeThickness = (stroke?.width ?? 0) * fontScale;\n        const tx = x + strokeThickness / 2;\n        const ty = y - strokeThickness / 2;\n        const descent = fontProperties.descent * fontScale;\n        const lineHeight = metrics.lineHeight * fontScale;\n        if (style.stroke && strokeThickness) context.strokeText(char, tx, ty + lineHeight - descent);\n        if (style._fill) context.fillText(char, tx, ty + lineHeight - descent);\n    }\n    destroy() {\n        super.destroy();\n        for(let i = 0; i < this.pages.length; i++){\n            const { canvasAndContext: canvasAndContext, texture: texture } = this.pages[i];\n            (0, $8zNlV.CanvasPool).returnCanvasAndContext(canvasAndContext);\n            texture.destroy(true);\n        }\n        this.pages = null;\n    }\n}\n\n});\nparcelRegister(\"7gvRa\", function(module, exports) {\n\n$parcel$export(module.exports, \"resolveCharacters\", () => $772414f75058615d$export$221291e5031b03d8);\n\"use strict\";\nfunction $772414f75058615d$export$221291e5031b03d8(chars) {\n    if (chars === \"\") return [];\n    if (typeof chars === \"string\") chars = [\n        chars\n    ];\n    const result = [];\n    for(let i = 0, j = chars.length; i < j; i++){\n        const item = chars[i];\n        if (Array.isArray(item)) {\n            if (item.length !== 2) throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n            if (item[0].length === 0 || item[1].length === 0) throw new Error(\"[BitmapFont]: Invalid character delimiter.\");\n            const startCode = item[0].charCodeAt(0);\n            const endCode = item[1].charCodeAt(0);\n            if (endCode < startCode) throw new Error(\"[BitmapFont]: Invalid character range.\");\n            for(let i2 = startCode, j2 = endCode; i2 <= j2; i2++)result.push(String.fromCharCode(i2));\n        } else result.push(...Array.from(item));\n    }\n    if (result.length === 0) throw new Error(\"[BitmapFont]: Empty set when resolving characters.\");\n    return result;\n}\n\n});\n\n\nparcelRegister(\"eGMbi\", function(module, exports) {\n\n$parcel$export(module.exports, \"getBitmapTextLayout\", () => $028c474438cf8b60$export$beeb37b3e20d3ee4);\n\"use strict\";\nfunction $028c474438cf8b60$export$beeb37b3e20d3ee4(chars, style, font) {\n    const layoutData = {\n        width: 0,\n        height: 0,\n        offsetY: 0,\n        scale: style.fontSize / font.baseMeasurementFontSize,\n        lines: [\n            {\n                width: 0,\n                charPositions: [],\n                spaceWidth: 0,\n                spacesIndex: [],\n                chars: []\n            }\n        ]\n    };\n    layoutData.offsetY = font.baseLineOffset;\n    let currentLine = layoutData.lines[0];\n    let previousChar = null;\n    let firstWord = true;\n    const currentWord = {\n        spaceWord: false,\n        width: 0,\n        start: 0,\n        index: 0,\n        // use index to not modify the array as we use it a lot!\n        positions: [],\n        chars: []\n    };\n    const nextWord = (word)=>{\n        const start = currentLine.width;\n        for(let j = 0; j < currentWord.index; j++){\n            const position = word.positions[j];\n            currentLine.chars.push(word.chars[j]);\n            currentLine.charPositions.push(position + start);\n        }\n        currentLine.width += word.width;\n        firstWord = false;\n        currentWord.width = 0;\n        currentWord.index = 0;\n        currentWord.chars.length = 0;\n    };\n    const nextLine = ()=>{\n        let index = currentLine.chars.length - 1;\n        let lastChar = currentLine.chars[index];\n        while(lastChar === \" \"){\n            currentLine.width -= font.chars[lastChar].xAdvance;\n            lastChar = currentLine.chars[--index];\n        }\n        layoutData.width = Math.max(layoutData.width, currentLine.width);\n        currentLine = {\n            width: 0,\n            charPositions: [],\n            chars: [],\n            spaceWidth: 0,\n            spacesIndex: []\n        };\n        firstWord = true;\n        layoutData.lines.push(currentLine);\n        layoutData.height += font.lineHeight;\n    };\n    const scale = font.baseMeasurementFontSize / style.fontSize;\n    const adjustedLetterSpacing = style.letterSpacing * scale;\n    const adjustedWordWrapWidth = style.wordWrapWidth * scale;\n    for(let i = 0; i < chars.length + 1; i++){\n        let char;\n        const isEnd = i === chars.length;\n        if (!isEnd) char = chars[i];\n        const charData = font.chars[char] || font.chars[\" \"];\n        const isSpace = /(?:\\s)/.test(char);\n        const isWordBreak = isSpace || char === \"\\r\" || char === \"\\n\" || isEnd;\n        if (isWordBreak) {\n            const addWordToNextLine = !firstWord && style.wordWrap && currentLine.width + currentWord.width - adjustedLetterSpacing > adjustedWordWrapWidth;\n            if (addWordToNextLine) {\n                nextLine();\n                nextWord(currentWord);\n                if (!isEnd) currentLine.charPositions.push(0);\n            } else {\n                currentWord.start = currentLine.width;\n                nextWord(currentWord);\n                if (!isEnd) currentLine.charPositions.push(0);\n            }\n            if (char === \"\\r\" || char === \"\\n\") {\n                if (currentLine.width !== 0) nextLine();\n            } else if (!isEnd) {\n                const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;\n                currentLine.width += spaceWidth;\n                currentLine.spaceWidth = spaceWidth;\n                currentLine.spacesIndex.push(currentLine.charPositions.length);\n                currentLine.chars.push(char);\n            }\n        } else {\n            const kerning = charData.kerning[previousChar] || 0;\n            const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;\n            currentWord.positions[currentWord.index++] = currentWord.width + kerning;\n            currentWord.chars.push(char);\n            currentWord.width += nextCharWidth;\n        }\n        previousChar = char;\n    }\n    nextLine();\n    if (style.align === \"center\") $028c474438cf8b60$var$alignCenter(layoutData);\n    else if (style.align === \"right\") $028c474438cf8b60$var$alignRight(layoutData);\n    else if (style.align === \"justify\") $028c474438cf8b60$var$alignJustify(layoutData);\n    return layoutData;\n}\nfunction $028c474438cf8b60$var$alignCenter(measurementData) {\n    for(let i = 0; i < measurementData.lines.length; i++){\n        const line = measurementData.lines[i];\n        const offset = measurementData.width / 2 - line.width / 2;\n        for(let j = 0; j < line.charPositions.length; j++)line.charPositions[j] += offset;\n    }\n}\nfunction $028c474438cf8b60$var$alignRight(measurementData) {\n    for(let i = 0; i < measurementData.lines.length; i++){\n        const line = measurementData.lines[i];\n        const offset = measurementData.width - line.width;\n        for(let j = 0; j < line.charPositions.length; j++)line.charPositions[j] += offset;\n    }\n}\nfunction $028c474438cf8b60$var$alignJustify(measurementData) {\n    const width = measurementData.width;\n    for(let i = 0; i < measurementData.lines.length; i++){\n        const line = measurementData.lines[i];\n        let indy = 0;\n        let spaceIndex = line.spacesIndex[indy++];\n        let offset = 0;\n        const totalSpaces = line.spacesIndex.length;\n        const newSpaceWidth = (width - line.width) / totalSpaces;\n        const spaceWidth = newSpaceWidth;\n        for(let j = 0; j < line.charPositions.length; j++){\n            if (j === spaceIndex) {\n                spaceIndex = line.spacesIndex[indy++];\n                offset += spaceWidth;\n            }\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\n});\n\n\n\nparcelRegister(\"3RsiR\", function(module, exports) {\n\n$parcel$export(module.exports, \"bitmapFontTextParser\", () => $3043c13693a01c73$export$4c1815a0944ccac0);\n\"use strict\";\nconst $3043c13693a01c73$export$4c1815a0944ccac0 = {\n    test (data) {\n        return typeof data === \"string\" && data.startsWith(\"info face=\");\n    },\n    parse (txt) {\n        const items = txt.match(/^[a-z]+\\s+.+$/gm);\n        const rawData = {\n            info: [],\n            common: [],\n            page: [],\n            char: [],\n            chars: [],\n            kerning: [],\n            kernings: [],\n            distanceField: []\n        };\n        for(const i in items){\n            const name = items[i].match(/^[a-z]+/gm)[0];\n            const attributeList = items[i].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm);\n            const itemData = {};\n            for(const i2 in attributeList){\n                const split = attributeList[i2].split(\"=\");\n                const key = split[0];\n                const strValue = split[1].replace(/\"/gm, \"\");\n                const floatValue = parseFloat(strValue);\n                const value = isNaN(floatValue) ? strValue : floatValue;\n                itemData[key] = value;\n            }\n            rawData[name].push(itemData);\n        }\n        const font = {\n            chars: {},\n            pages: [],\n            lineHeight: 0,\n            fontSize: 0,\n            fontFamily: \"\",\n            distanceField: null,\n            baseLineOffset: 0\n        };\n        const [info] = rawData.info;\n        const [common] = rawData.common;\n        const [distanceField] = rawData.distanceField ?? [];\n        if (distanceField) font.distanceField = {\n            range: parseInt(distanceField.distanceRange, 10),\n            type: distanceField.fieldType\n        };\n        font.fontSize = parseInt(info.size, 10);\n        font.fontFamily = info.face;\n        font.lineHeight = parseInt(common.lineHeight, 10);\n        const page = rawData.page;\n        for(let i = 0; i < page.length; i++)font.pages.push({\n            id: parseInt(page[i].id, 10) || 0,\n            file: page[i].file\n        });\n        const map = {};\n        font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);\n        const char = rawData.char;\n        for(let i = 0; i < char.length; i++){\n            const charNode = char[i];\n            const id = parseInt(charNode.id, 10);\n            let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id);\n            if (letter === \"space\") letter = \" \";\n            map[id] = letter;\n            font.chars[letter] = {\n                id: id,\n                // texture deets..\n                page: parseInt(charNode.page, 10) || 0,\n                x: parseInt(charNode.x, 10),\n                y: parseInt(charNode.y, 10),\n                width: parseInt(charNode.width, 10),\n                height: parseInt(charNode.height, 10),\n                xOffset: parseInt(charNode.xoffset, 10),\n                yOffset: parseInt(charNode.yoffset, 10),\n                xAdvance: parseInt(charNode.xadvance, 10),\n                kerning: {}\n            };\n        }\n        const kerning = rawData.kerning || [];\n        for(let i = 0; i < kerning.length; i++){\n            const first = parseInt(kerning[i].first, 10);\n            const second = parseInt(kerning[i].second, 10);\n            const amount = parseInt(kerning[i].amount, 10);\n            font.chars[map[second]].kerning[map[first]] = amount;\n        }\n        return font;\n    }\n};\n\n});\n\nparcelRegister(\"9m29S\", function(module, exports) {\n\n$parcel$export(module.exports, \"bitmapFontXMLStringParser\", () => $de1ded80582c8f01$export$bfc0a19e2e2cc16);\n\nvar $5m2Qn = parcelRequire(\"5m2Qn\");\n\nvar $93yhf = parcelRequire(\"93yhf\");\n\"use strict\";\nconst $de1ded80582c8f01$export$bfc0a19e2e2cc16 = {\n    test (data) {\n        if (typeof data === \"string\" && data.includes(\"<font>\")) return (0, $93yhf.bitmapFontXMLParser).test((0, $5m2Qn.DOMAdapter).get().parseXML(data));\n        return false;\n    },\n    parse (data) {\n        return (0, $93yhf.bitmapFontXMLParser).parse((0, $5m2Qn.DOMAdapter).get().parseXML(data));\n    }\n};\n\n});\nparcelRegister(\"93yhf\", function(module, exports) {\n\n$parcel$export(module.exports, \"bitmapFontXMLParser\", () => $82c0d553a5133ca6$export$7a7adbcafc5cf8e3);\n\"use strict\";\nconst $82c0d553a5133ca6$export$7a7adbcafc5cf8e3 = {\n    test (data) {\n        const xml = data;\n        return typeof xml !== \"string\" && \"getElementsByTagName\" in xml && xml.getElementsByTagName(\"page\").length && xml.getElementsByTagName(\"info\")[0].getAttribute(\"face\") !== null;\n    },\n    parse (xml) {\n        const data = {\n            chars: {},\n            pages: [],\n            lineHeight: 0,\n            fontSize: 0,\n            fontFamily: \"\",\n            distanceField: null,\n            baseLineOffset: 0\n        };\n        const info = xml.getElementsByTagName(\"info\")[0];\n        const common = xml.getElementsByTagName(\"common\")[0];\n        const distanceField = xml.getElementsByTagName(\"distanceField\")[0];\n        if (distanceField) data.distanceField = {\n            type: distanceField.getAttribute(\"fieldType\"),\n            range: parseInt(distanceField.getAttribute(\"distanceRange\"), 10)\n        };\n        const page = xml.getElementsByTagName(\"page\");\n        const char = xml.getElementsByTagName(\"char\");\n        const kerning = xml.getElementsByTagName(\"kerning\");\n        data.fontSize = parseInt(info.getAttribute(\"size\"), 10);\n        data.fontFamily = info.getAttribute(\"face\");\n        data.lineHeight = parseInt(common.getAttribute(\"lineHeight\"), 10);\n        for(let i = 0; i < page.length; i++)data.pages.push({\n            id: parseInt(page[i].getAttribute(\"id\"), 10) || 0,\n            file: page[i].getAttribute(\"file\")\n        });\n        const map = {};\n        data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute(\"base\"), 10);\n        for(let i = 0; i < char.length; i++){\n            const charNode = char[i];\n            const id = parseInt(charNode.getAttribute(\"id\"), 10);\n            let letter = charNode.getAttribute(\"letter\") ?? charNode.getAttribute(\"char\") ?? String.fromCharCode(id);\n            if (letter === \"space\") letter = \" \";\n            map[id] = letter;\n            data.chars[letter] = {\n                id: id,\n                // texture deets..\n                page: parseInt(charNode.getAttribute(\"page\"), 10) || 0,\n                x: parseInt(charNode.getAttribute(\"x\"), 10),\n                y: parseInt(charNode.getAttribute(\"y\"), 10),\n                width: parseInt(charNode.getAttribute(\"width\"), 10),\n                height: parseInt(charNode.getAttribute(\"height\"), 10),\n                // render deets..\n                xOffset: parseInt(charNode.getAttribute(\"xoffset\"), 10),\n                yOffset: parseInt(charNode.getAttribute(\"yoffset\"), 10),\n                // + baseLineOffset,\n                xAdvance: parseInt(charNode.getAttribute(\"xadvance\"), 10),\n                kerning: {}\n            };\n        }\n        for(let i = 0; i < kerning.length; i++){\n            const first = parseInt(kerning[i].getAttribute(\"first\"), 10);\n            const second = parseInt(kerning[i].getAttribute(\"second\"), 10);\n            const amount = parseInt(kerning[i].getAttribute(\"amount\"), 10);\n            data.chars[map[second]].kerning[map[first]] = amount;\n        }\n        return data;\n    }\n};\n\n});\n\n\n\nparcelRegister(\"3SZLI\", function(module, exports) {\n\n$parcel$export(module.exports, \"BitmapTextPipe\", () => $524e8a09c9dd1295$export$83d8b05a29a5f8ed);\n\nvar $gYSnF = parcelRequire(\"gYSnF\");\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $e98Fy = parcelRequire(\"e98Fy\");\n\nvar $C9JRY = parcelRequire(\"C9JRY\");\n\nvar $gbb6L = parcelRequire(\"gbb6L\");\n\nvar $1TcZG = parcelRequire(\"1TcZG\");\n\nvar $eGMbi = parcelRequire(\"eGMbi\");\n\"use strict\";\nclass $524e8a09c9dd1295$export$83d8b05a29a5f8ed {\n    constructor(renderer){\n        this._gpuBitmapText = {};\n        this._renderer = renderer;\n    }\n    validateRenderable(bitmapText) {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n        if (bitmapText._didTextUpdate) {\n            bitmapText._didTextUpdate = false;\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n        return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n    }\n    addRenderable(bitmapText, instructionSet) {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n        $524e8a09c9dd1295$var$syncWithProxy(bitmapText, graphicsRenderable);\n        if (bitmapText._didTextUpdate) {\n            bitmapText._didTextUpdate = false;\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n        this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n        if (graphicsRenderable.context.customShader) this._updateDistanceField(bitmapText);\n    }\n    destroyRenderable(bitmapText) {\n        this._destroyRenderableByUid(bitmapText.uid);\n    }\n    _destroyRenderableByUid(renderableUid) {\n        (0, $e98Fy.BigPool).return(this._gpuBitmapText[renderableUid]);\n        this._gpuBitmapText[renderableUid] = null;\n    }\n    updateRenderable(bitmapText) {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n        $524e8a09c9dd1295$var$syncWithProxy(bitmapText, graphicsRenderable);\n        this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n        if (graphicsRenderable.context.customShader) this._updateDistanceField(bitmapText);\n    }\n    _updateContext(bitmapText, proxyGraphics) {\n        const { context: context } = proxyGraphics;\n        const bitmapFont = (0, $1TcZG.BitmapFontManager).getFont(bitmapText.text, bitmapText._style);\n        context.clear();\n        if (bitmapFont.distanceField.type !== \"none\") {\n            if (!context.customShader) {\n                if (!this._sdfShader) this._sdfShader = new (0, $gbb6L.SdfShader)();\n                context.customShader = this._sdfShader;\n            }\n        }\n        const chars = Array.from(bitmapText.text);\n        const style = bitmapText._style;\n        let currentY = (style._stroke?.width || 0) / 2;\n        currentY += bitmapFont.baseLineOffset;\n        const bitmapTextLayout = (0, $eGMbi.getBitmapTextLayout)(chars, style, bitmapFont);\n        let index = 0;\n        const padding = style.padding;\n        const scale = bitmapTextLayout.scale;\n        context.translate(-bitmapText._anchor._x * bitmapTextLayout.width - padding, -bitmapText._anchor._y * (bitmapTextLayout.height + bitmapTextLayout.offsetY) - padding).scale(scale, scale);\n        const tint = style._fill.color;\n        for(let i = 0; i < bitmapTextLayout.lines.length; i++){\n            const line = bitmapTextLayout.lines[i];\n            for(let j = 0; j < line.charPositions.length; j++){\n                const char = chars[index++];\n                const charData = bitmapFont.chars[char];\n                if (charData?.texture) context.texture(charData.texture, tint ? tint : \"black\", Math.round(line.charPositions[j] + charData.xOffset), Math.round(currentY + charData.yOffset));\n            }\n            currentY += bitmapFont.lineHeight;\n        }\n    }\n    _getGpuBitmapText(bitmapText) {\n        return this._gpuBitmapText[bitmapText.uid] || this.initGpuText(bitmapText);\n    }\n    initGpuText(bitmapText) {\n        const proxyRenderable = (0, $e98Fy.BigPool).get((0, $C9JRY.Graphics));\n        this._gpuBitmapText[bitmapText.uid] = proxyRenderable;\n        this._updateContext(bitmapText, proxyRenderable);\n        bitmapText.on(\"destroyed\", ()=>{\n            this.destroyRenderable(bitmapText);\n        });\n        return this._gpuBitmapText[bitmapText.uid];\n    }\n    _updateDistanceField(bitmapText) {\n        const context = this._getGpuBitmapText(bitmapText).context;\n        const fontFamily = bitmapText._style.fontFamily;\n        const dynamicFont = (0, $gYSnF.Cache).get(`${fontFamily}-bitmap`);\n        const { a: a, b: b, c: c, d: d } = bitmapText.groupTransform;\n        const dx = Math.sqrt(a * a + b * b);\n        const dy = Math.sqrt(c * c + d * d);\n        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n        const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n        const resolution = bitmapText.resolution ?? this._renderer.resolution;\n        const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale) * resolution;\n        context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n    }\n    destroy() {\n        for(const uid in this._gpuBitmapText)this._destroyRenderableByUid(uid);\n        this._gpuBitmapText = null;\n        this._sdfShader?.destroy(true);\n        this._sdfShader = null;\n        this._renderer = null;\n    }\n}\n/** @ignore */ $524e8a09c9dd1295$export$83d8b05a29a5f8ed.extension = {\n    type: [\n        (0, $eVz1R.ExtensionType).WebGLPipes,\n        (0, $eVz1R.ExtensionType).WebGPUPipes,\n        (0, $eVz1R.ExtensionType).CanvasPipes\n    ],\n    name: \"bitmapText\"\n};\nfunction $524e8a09c9dd1295$var$syncWithProxy(container, proxy) {\n    proxy.groupTransform = container.groupTransform;\n    proxy.groupColorAlpha = container.groupColorAlpha;\n    proxy.groupColor = container.groupColor;\n    proxy.groupBlendMode = container.groupBlendMode;\n    proxy.globalDisplayStatus = container.globalDisplayStatus;\n    proxy.groupTransform = container.groupTransform;\n    proxy.localDisplayStatus = container.localDisplayStatus;\n    proxy.groupAlpha = container.groupAlpha;\n    proxy._roundPixels = container._roundPixels;\n}\n\n});\nparcelRegister(\"C9JRY\", function(module, exports) {\n\n$parcel$export(module.exports, \"Graphics\", () => $2ae58bdad7aea42d$export$29d3e417456abdad);\n\nvar $eX50w = parcelRequire(\"eX50w\");\n\nvar $lR3Ev = parcelRequire(\"lR3Ev\");\n\nvar $hTvsP = parcelRequire(\"hTvsP\");\n\"use strict\";\nclass $2ae58bdad7aea42d$export$29d3e417456abdad extends (0, $lR3Ev.Container) {\n    /**\n   * @param options - Options for the Graphics.\n   */ constructor(options){\n        if (options instanceof (0, $hTvsP.GraphicsContext)) options = {\n            context: options\n        };\n        const { context: context, roundPixels: roundPixels, ...rest } = options || {};\n        super({\n            label: \"Graphics\",\n            ...rest\n        });\n        this.canBundle = true;\n        this.renderPipeId = \"graphics\";\n        this._roundPixels = 0;\n        if (!context) this._context = this._ownedContext = new (0, $hTvsP.GraphicsContext)();\n        else this._context = context;\n        this._context.on(\"update\", this.onViewUpdate, this);\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n    }\n    set context(context) {\n        if (context === this._context) return;\n        this._context.off(\"update\", this.onViewUpdate, this);\n        this._context = context;\n        this._context.on(\"update\", this.onViewUpdate, this);\n        this.onViewUpdate();\n    }\n    get context() {\n        return this._context;\n    }\n    /**\n   * The local bounds of the graphic.\n   * @type {rendering.Bounds}\n   */ get bounds() {\n        return this._context.bounds;\n    }\n    /**\n   * Adds the bounds of this object to the bounds object.\n   * @param bounds - The output bounds object.\n   */ addBounds(bounds) {\n        bounds.addBounds(this._context.bounds);\n    }\n    /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */ containsPoint(point) {\n        return this._context.containsPoint(point);\n    }\n    /**\n   *  Whether or not to round the x/y position of the graphic.\n   * @type {boolean}\n   */ get roundPixels() {\n        return !!this._roundPixels;\n    }\n    set roundPixels(value) {\n        this._roundPixels = value ? 1 : 0;\n    }\n    onViewUpdate() {\n        this._didChangeId += 4096;\n        this._didGraphicsUpdate = true;\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n        if (this.renderGroup) this.renderGroup.onChildViewUpdate(this);\n    }\n    /**\n   * Destroys this graphics renderable and optionally its context.\n   * @param options - Options parameter. A boolean will act as if all options\n   *\n   * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n   * then the context will still be destroyed.\n   *\n   * If you want to explicitly not destroy this context that this graphics created,\n   * then you should pass destroy({ context: false })\n   *\n   * If the context was passed in as an argument to the constructor then it will not be destroyed\n   * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context\n   * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context\n   * @param {boolean} [options.context=false] - Should destroy the context\n   */ destroy(options) {\n        if (this._ownedContext && !options) this._ownedContext.destroy(options);\n        else if (options === true || options?.context === true) this._context.destroy(options);\n        this._ownedContext = null;\n        this._context = null;\n        super.destroy(options);\n    }\n    _callContextMethod(method, args) {\n        this.context[method](...args);\n        return this;\n    }\n    // --------------------------------------- GraphicsContext methods ---------------------------------------\n    /**\n   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n   * pattern, or a more complex style defined by a FillStyle object.\n   * @param {FillStyleInputs} args - The fill style to apply. This can be a simple color, a gradient or\n   * pattern object, or a FillStyle or ConvertedFillStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ setFillStyle(...args) {\n        return this._callContextMethod(\"setFillStyle\", args);\n    }\n    /**\n   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   * @param {FillStyleInputs} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n   * or a StrokeStyle or ConvertedStrokeStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ setStrokeStyle(...args) {\n        return this._callContextMethod(\"setStrokeStyle\", args);\n    }\n    fill(...args) {\n        return this._callContextMethod(\"fill\", args);\n    }\n    /**\n   * Strokes the current path with the current stroke style. This method can take an optional\n   * FillStyleInputs parameter to define the stroke's appearance, including its color, width, and other properties.\n   * @param {FillStyleInputs} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more\n   * complex style object. If omitted, uses the current stroke style.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ stroke(...args) {\n        return this._callContextMethod(\"stroke\", args);\n    }\n    texture(...args) {\n        return this._callContextMethod(\"texture\", args);\n    }\n    /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ beginPath() {\n        return this._callContextMethod(\"beginPath\", []);\n    }\n    /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n   * fail to cut correctly!\n   */ cut() {\n        return this._callContextMethod(\"cut\", []);\n    }\n    arc(...args) {\n        return this._callContextMethod(\"arc\", args);\n    }\n    arcTo(...args) {\n        return this._callContextMethod(\"arcTo\", args);\n    }\n    arcToSvg(...args) {\n        return this._callContextMethod(\"arcToSvg\", args);\n    }\n    bezierCurveTo(...args) {\n        return this._callContextMethod(\"bezierCurveTo\", args);\n    }\n    /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */ closePath() {\n        return this._callContextMethod(\"closePath\", []);\n    }\n    ellipse(...args) {\n        return this._callContextMethod(\"ellipse\", args);\n    }\n    circle(...args) {\n        return this._callContextMethod(\"circle\", args);\n    }\n    path(...args) {\n        return this._callContextMethod(\"path\", args);\n    }\n    lineTo(...args) {\n        return this._callContextMethod(\"lineTo\", args);\n    }\n    moveTo(...args) {\n        return this._callContextMethod(\"moveTo\", args);\n    }\n    quadraticCurveTo(...args) {\n        return this._callContextMethod(\"quadraticCurveTo\", args);\n    }\n    rect(...args) {\n        return this._callContextMethod(\"rect\", args);\n    }\n    roundRect(...args) {\n        return this._callContextMethod(\"roundRect\", args);\n    }\n    poly(...args) {\n        return this._callContextMethod(\"poly\", args);\n    }\n    regularPoly(...args) {\n        return this._callContextMethod(\"regularPoly\", args);\n    }\n    roundPoly(...args) {\n        return this._callContextMethod(\"roundPoly\", args);\n    }\n    roundShape(...args) {\n        return this._callContextMethod(\"roundShape\", args);\n    }\n    filletRect(...args) {\n        return this._callContextMethod(\"filletRect\", args);\n    }\n    chamferRect(...args) {\n        return this._callContextMethod(\"chamferRect\", args);\n    }\n    star(...args) {\n        return this._callContextMethod(\"star\", args);\n    }\n    svg(...args) {\n        return this._callContextMethod(\"svg\", args);\n    }\n    restore(...args) {\n        return this._callContextMethod(\"restore\", args);\n    }\n    /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */ save() {\n        return this._callContextMethod(\"save\", []);\n    }\n    /**\n   * Returns the current transformation matrix of the graphics context.\n   * @returns The current transformation matrix.\n   */ getTransform() {\n        return this.context.getTransform();\n    }\n    /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing\n   * any transformations (rotation, scaling, translation) previously applied.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ resetTransform() {\n        return this._callContextMethod(\"resetTransform\", []);\n    }\n    rotateTransform(...args) {\n        return this._callContextMethod(\"rotate\", args);\n    }\n    scaleTransform(...args) {\n        return this._callContextMethod(\"scale\", args);\n    }\n    setTransform(...args) {\n        return this._callContextMethod(\"setTransform\", args);\n    }\n    transform(...args) {\n        return this._callContextMethod(\"transform\", args);\n    }\n    translateTransform(...args) {\n        return this._callContextMethod(\"translate\", args);\n    }\n    /**\n   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n   * and optionally resetting transformations to the identity matrix.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ clear() {\n        return this._callContextMethod(\"clear\", []);\n    }\n    /**\n   * The fill style to use.\n   * @type {ConvertedFillStyle}\n   */ get fillStyle() {\n        return this._context.fillStyle;\n    }\n    set fillStyle(value) {\n        this._context.fillStyle = value;\n    }\n    /**\n   * The stroke style to use.\n   * @type {ConvertedStrokeStyle}\n   */ get strokeStyle() {\n        return this._context.strokeStyle;\n    }\n    set strokeStyle(value) {\n        this._context.strokeStyle = value;\n    }\n    /**\n   * Creates a new Graphics object.\n   * Note that only the context of the object is cloned, not its transform (position,scale,etc)\n   * @param deep - Whether to create a deep clone of the graphics object. If false, the context\n   * will be shared between the two objects (default false). If true, the context will be\n   * cloned (recommended if you need to modify the context in any way).\n   * @returns - A clone of the graphics object\n   */ clone(deep = false) {\n        if (deep) return new $2ae58bdad7aea42d$export$29d3e417456abdad(this._context.clone());\n        this._ownedContext = null;\n        const clone = new $2ae58bdad7aea42d$export$29d3e417456abdad(this._context);\n        return clone;\n    }\n    // -------- v7 deprecations ---------\n    /**\n   * @param width\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n   */ lineStyle(width, color, alpha) {\n        (0, $eX50w.deprecation)((0, $eX50w.v8_0_0), \"Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.\");\n        const strokeStyle = {};\n        width && (strokeStyle.width = width);\n        color && (strokeStyle.color = color);\n        alpha && (strokeStyle.alpha = alpha);\n        this.context.strokeStyle = strokeStyle;\n        return this;\n    }\n    /**\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */ beginFill(color, alpha) {\n        (0, $eX50w.deprecation)((0, $eX50w.v8_0_0), \"Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.\");\n        const fillStyle = {};\n        color && (fillStyle.color = color);\n        alpha && (fillStyle.alpha = alpha);\n        this.context.fillStyle = fillStyle;\n        return this;\n    }\n    /**\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */ endFill() {\n        (0, $eX50w.deprecation)((0, $eX50w.v8_0_0), \"Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.\");\n        this.context.fill();\n        const strokeStyle = this.context.strokeStyle;\n        if (strokeStyle.width !== (0, $hTvsP.GraphicsContext).defaultStrokeStyle.width || strokeStyle.color !== (0, $hTvsP.GraphicsContext).defaultStrokeStyle.color || strokeStyle.alpha !== (0, $hTvsP.GraphicsContext).defaultStrokeStyle.alpha) this.context.stroke();\n        return this;\n    }\n    /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n   */ drawCircle(...args) {\n        (0, $eX50w.deprecation)((0, $eX50w.v8_0_0), \"Graphics#drawCircle has been renamed to Graphics#circle\");\n        return this._callContextMethod(\"circle\", args);\n    }\n    /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n   */ drawEllipse(...args) {\n        (0, $eX50w.deprecation)((0, $eX50w.v8_0_0), \"Graphics#drawEllipse has been renamed to Graphics#ellipse\");\n        return this._callContextMethod(\"ellipse\", args);\n    }\n    /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n   */ drawPolygon(...args) {\n        (0, $eX50w.deprecation)((0, $eX50w.v8_0_0), \"Graphics#drawPolygon has been renamed to Graphics#poly\");\n        return this._callContextMethod(\"poly\", args);\n    }\n    /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n   */ drawRect(...args) {\n        (0, $eX50w.deprecation)((0, $eX50w.v8_0_0), \"Graphics#drawRect has been renamed to Graphics#rect\");\n        return this._callContextMethod(\"rect\", args);\n    }\n    /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n   */ drawRoundedRect(...args) {\n        (0, $eX50w.deprecation)((0, $eX50w.v8_0_0), \"Graphics#drawRoundedRect has been renamed to Graphics#roundRect\");\n        return this._callContextMethod(\"roundRect\", args);\n    }\n    /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n   */ drawStar(...args) {\n        (0, $eX50w.deprecation)((0, $eX50w.v8_0_0), \"Graphics#drawStar has been renamed to Graphics#star\");\n        return this._callContextMethod(\"star\", args);\n    }\n}\n\n});\n\nparcelRegister(\"gbb6L\", function(module, exports) {\n\n$parcel$export(module.exports, \"SdfShader\", () => $7154b99db6760bb9$export$f19b070f8409d54d);\n\nvar $dNaJE = parcelRequire(\"dNaJE\");\n\nvar $fIcRj = parcelRequire(\"fIcRj\");\n\nvar $1amHU = parcelRequire(\"1amHU\");\n\nvar $6NJrS = parcelRequire(\"6NJrS\");\n\nvar $8WJj9 = parcelRequire(\"8WJj9\");\n\nvar $eJTyi = parcelRequire(\"eJTyi\");\n\nvar $gxQKX = parcelRequire(\"gxQKX\");\n\nvar $7cNGO = parcelRequire(\"7cNGO\");\n\nvar $lJEsO = parcelRequire(\"lJEsO\");\n\nvar $iEsAD = parcelRequire(\"iEsAD\");\n\nvar $hAVGf = parcelRequire(\"hAVGf\");\n\"use strict\";\nclass $7154b99db6760bb9$export$f19b070f8409d54d extends (0, $7cNGO.Shader) {\n    constructor(){\n        const uniforms = new (0, $lJEsO.UniformGroup)({\n            uColor: {\n                value: new Float32Array([\n                    1,\n                    1,\n                    1,\n                    1\n                ]),\n                type: \"vec4<f32>\"\n            },\n            uTransformMatrix: {\n                value: new (0, $dNaJE.Matrix)(),\n                type: \"mat3x3<f32>\"\n            },\n            uDistance: {\n                value: 4,\n                type: \"f32\"\n            },\n            uRound: {\n                value: 0,\n                type: \"f32\"\n            }\n        });\n        const gpuProgram = (0, $1amHU.compileHighShaderGpuProgram)({\n            name: \"sdf-shader\",\n            bits: [\n                (0, $6NJrS.colorBit),\n                (0, $8WJj9.generateTextureBatchBit)((0, $fIcRj.MAX_TEXTURES)),\n                (0, $iEsAD.localUniformMSDFBit),\n                (0, $hAVGf.mSDFBit),\n                (0, $eJTyi.roundPixelsBit)\n            ]\n        });\n        const glProgram = (0, $1amHU.compileHighShaderGlProgram)({\n            name: \"sdf-shader\",\n            bits: [\n                (0, $6NJrS.colorBitGl),\n                (0, $8WJj9.generateTextureBatchBitGl)((0, $fIcRj.MAX_TEXTURES)),\n                (0, $iEsAD.localUniformMSDFBitGl),\n                (0, $hAVGf.mSDFBitGl),\n                (0, $eJTyi.roundPixelsBitGl)\n            ]\n        });\n        super({\n            glProgram: glProgram,\n            gpuProgram: gpuProgram,\n            resources: {\n                localUniforms: uniforms,\n                batchSamplers: (0, $gxQKX.batchSamplersUniformGroup)\n            }\n        });\n    }\n}\n\n});\nparcelRegister(\"iEsAD\", function(module, exports) {\n\n$parcel$export(module.exports, \"localUniformMSDFBit\", () => $c2607a74b5017ccb$export$95191d1d81ffe694);\n$parcel$export(module.exports, \"localUniformMSDFBitGl\", () => $c2607a74b5017ccb$export$7542046ad25e8068);\n\"use strict\";\nconst $c2607a74b5017ccb$export$95191d1d81ffe694 = {\n    name: \"local-uniform-msdf-bit\",\n    vertex: {\n        header: /* wgsl */ `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */ `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */ `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n    fragment: {\n        header: /* wgsl */ `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `,\n        main: /* wgsl */ ` \n            outColor = vColor * calculateMSDFAlpha(outColor, localUniforms.uDistance);\n        `\n    }\n};\nconst $c2607a74b5017ccb$export$7542046ad25e8068 = {\n    name: \"local-uniform-msdf-bit\",\n    vertex: {\n        header: /* glsl */ `\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */ `\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `,\n        end: /* glsl */ `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n    fragment: {\n        header: /* glsl */ `\n            uniform float uDistance;\n         `,\n        main: /* glsl */ ` \n            outColor = vColor * calculateMSDFAlpha(outColor, uDistance);\n        `\n    }\n};\n\n});\n\nparcelRegister(\"hAVGf\", function(module, exports) {\n\n$parcel$export(module.exports, \"mSDFBit\", () => $865390956a8ffae6$export$382a0eb192cd0a47);\n$parcel$export(module.exports, \"mSDFBitGl\", () => $865390956a8ffae6$export$52c5bf2a8ebe1f2a);\n\"use strict\";\nconst $865390956a8ffae6$export$382a0eb192cd0a47 = {\n    name: \"msdf-bit\",\n    fragment: {\n        header: /* wgsl */ `\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, distance:f32) -> f32 {\n                \n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n            \n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                return alpha;\n            }\n        `\n    }\n};\nconst $865390956a8ffae6$export$52c5bf2a8ebe1f2a = {\n    name: \"msdf-bit\",\n    fragment: {\n        header: /* glsl */ `\n            float calculateMSDFAlpha(vec4 msdfColor, float distance) {\n                \n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n               \n                // SDF\n                median = min(median, msdfColor.a);\n            \n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n           \n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                return alpha;\n            }\n        `\n    }\n};\n\n});\n\n\n\n\nparcelRegister(\"85BOi\", function(module, exports) {\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $2fk0k = parcelRequire(\"2fk0k\");\n\nvar $5RICQ = parcelRequire(\"5RICQ\");\n\"use strict\";\n(0, $eVz1R.extensions).add((0, $5RICQ.HTMLTextSystem));\n(0, $eVz1R.extensions).add((0, $2fk0k.HTMLTextPipe));\n\n});\nparcelRegister(\"2fk0k\", function(module, exports) {\n\n$parcel$export(module.exports, \"HTMLTextPipe\", () => $240efd22d51d4bb6$export$ffcef6958193be1c);\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $5h88T = parcelRequire(\"5h88T\");\n\nvar $1ZKfN = parcelRequire(\"1ZKfN\");\n\nvar $e98Fy = parcelRequire(\"e98Fy\");\n\nvar $8PFkM = parcelRequire(\"8PFkM\");\n\"use strict\";\nclass $240efd22d51d4bb6$export$ffcef6958193be1c {\n    constructor(renderer){\n        this._gpuText = /* @__PURE__ */ Object.create(null);\n        this._renderer = renderer;\n    }\n    validateRenderable(htmlText) {\n        const gpuText = this._getGpuText(htmlText);\n        const newKey = htmlText._getKey();\n        if (gpuText.textureNeedsUploading) {\n            gpuText.textureNeedsUploading = false;\n            return true;\n        }\n        if (gpuText.currentKey !== newKey) return true;\n        return false;\n    }\n    addRenderable(htmlText) {\n        const gpuText = this._getGpuText(htmlText);\n        const batchableSprite = gpuText.batchableSprite;\n        if (htmlText._didTextUpdate) this._updateText(htmlText);\n        this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n    }\n    updateRenderable(htmlText) {\n        const gpuText = this._getGpuText(htmlText);\n        const batchableSprite = gpuText.batchableSprite;\n        if (htmlText._didTextUpdate) this._updateText(htmlText);\n        batchableSprite.batcher.updateElement(batchableSprite);\n    }\n    destroyRenderable(htmlText) {\n        this._destroyRenderableById(htmlText.uid);\n    }\n    _destroyRenderableById(htmlTextUid) {\n        const gpuText = this._gpuText[htmlTextUid];\n        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n        (0, $e98Fy.BigPool).return(gpuText.batchableSprite);\n        this._gpuText[htmlTextUid] = null;\n    }\n    _updateText(htmlText) {\n        const newKey = htmlText._getKey();\n        const gpuText = this._getGpuText(htmlText);\n        const batchableSprite = gpuText.batchableSprite;\n        if (gpuText.currentKey !== newKey) this._updateGpuText(htmlText).catch((e)=>{\n            console.error(e);\n        });\n        htmlText._didTextUpdate = false;\n        const padding = htmlText._style.padding;\n        (0, $1ZKfN.updateQuadBounds)(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n    }\n    async _updateGpuText(htmlText) {\n        htmlText._didTextUpdate = false;\n        const gpuText = this._getGpuText(htmlText);\n        if (gpuText.generatingTexture) return;\n        const newKey = htmlText._getKey();\n        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n        gpuText.generatingTexture = true;\n        gpuText.currentKey = newKey;\n        const resolution = htmlText.resolution ?? this._renderer.resolution;\n        const texture = await this._renderer.htmlText.getManagedTexture(htmlText.text, resolution, htmlText._style, htmlText._getKey());\n        const batchableSprite = gpuText.batchableSprite;\n        batchableSprite.texture = gpuText.texture = texture;\n        gpuText.generatingTexture = false;\n        gpuText.textureNeedsUploading = true;\n        htmlText.onViewUpdate();\n        const padding = htmlText._style.padding;\n        (0, $1ZKfN.updateQuadBounds)(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n    }\n    _getGpuText(htmlText) {\n        return this._gpuText[htmlText.uid] || this.initGpuText(htmlText);\n    }\n    initGpuText(htmlText) {\n        const gpuTextData = {\n            texture: (0, $5h88T.Texture).EMPTY,\n            currentKey: \"--\",\n            batchableSprite: (0, $e98Fy.BigPool).get((0, $8PFkM.BatchableSprite)),\n            textureNeedsUploading: false,\n            generatingTexture: false\n        };\n        const batchableSprite = gpuTextData.batchableSprite;\n        batchableSprite.renderable = htmlText;\n        batchableSprite.texture = (0, $5h88T.Texture).EMPTY;\n        batchableSprite.bounds = {\n            minX: 0,\n            maxX: 1,\n            minY: 0,\n            maxY: 0\n        };\n        batchableSprite.roundPixels = this._renderer._roundPixels | htmlText._roundPixels;\n        this._gpuText[htmlText.uid] = gpuTextData;\n        htmlText.on(\"destroyed\", ()=>{\n            this.destroyRenderable(htmlText);\n        });\n        return gpuTextData;\n    }\n    destroy() {\n        for(const i in this._gpuText)this._destroyRenderableById(i);\n        this._gpuText = null;\n        this._renderer = null;\n    }\n}\n/** @ignore */ $240efd22d51d4bb6$export$ffcef6958193be1c.extension = {\n    type: [\n        (0, $eVz1R.ExtensionType).WebGLPipes,\n        (0, $eVz1R.ExtensionType).WebGPUPipes,\n        (0, $eVz1R.ExtensionType).CanvasPipes\n    ],\n    name: \"htmlText\"\n};\n\n});\n\nparcelRegister(\"5RICQ\", function(module, exports) {\n\n$parcel$export(module.exports, \"HTMLTextSystem\", () => $8f99d4c922228ac3$export$f1b82676a746d8e9);\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $7U2uj = parcelRequire(\"7U2uj\");\n\nvar $dgEnR = parcelRequire(\"dgEnR\");\n\nvar $lX2W5 = parcelRequire(\"lX2W5\");\n\nvar $8CF4q = parcelRequire(\"8CF4q\");\n\nvar $e98Fy = parcelRequire(\"e98Fy\");\n\nvar $aq3uI = parcelRequire(\"aq3uI\");\n\nvar $fCTRI = parcelRequire(\"fCTRI\");\n\nvar $ioRFn = parcelRequire(\"ioRFn\");\n\nvar $ima1e = parcelRequire(\"ima1e\");\n\nvar $eITko = parcelRequire(\"eITko\");\n\nvar $4jNdA = parcelRequire(\"4jNdA\");\n\nvar $dN8mg = parcelRequire(\"dN8mg\");\n\nvar $4JtMi = parcelRequire(\"4JtMi\");\n\nvar $8Aoo3 = parcelRequire(\"8Aoo3\");\n\"use strict\";\nclass $8f99d4c922228ac3$export$f1b82676a746d8e9 {\n    constructor(renderer){\n        this._activeTextures = {};\n        this._renderer = renderer;\n        this._createCanvas = renderer.type === (0, $dgEnR.RendererType).WEBGPU;\n    }\n    getTexture(options) {\n        return this._buildTexturePromise(options.text, options.resolution, options.style);\n    }\n    getManagedTexture(text, resolution, style, textKey) {\n        if (this._activeTextures[textKey]) {\n            this._increaseReferenceCount(textKey);\n            return this._activeTextures[textKey].promise;\n        }\n        const promise = this._buildTexturePromise(text, resolution, style).then((texture)=>{\n            this._activeTextures[textKey].texture = texture;\n            return texture;\n        });\n        this._activeTextures[textKey] = {\n            texture: null,\n            promise: promise,\n            usageCount: 1\n        };\n        return promise;\n    }\n    async _buildTexturePromise(text, resolution, style) {\n        const htmlTextData = (0, $e98Fy.BigPool).get((0, $fCTRI.HTMLTextRenderData));\n        const fontFamilies = (0, $ima1e.extractFontFamilies)(text, style);\n        const fontCSS = await (0, $eITko.getFontCss)(fontFamilies, style, (0, $ioRFn.HTMLTextStyle).defaultTextStyle);\n        const measured = (0, $8Aoo3.measureHtmlText)(text, style, fontCSS, htmlTextData);\n        const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n        const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n        const image = htmlTextData.image;\n        image.width = width | 0;\n        image.height = height | 0;\n        const svgURL = (0, $4jNdA.getSVGUrl)(text, style, resolution, fontCSS, htmlTextData);\n        await (0, $4JtMi.loadSVGImage)(image, svgURL, (0, $lX2W5.isSafari)() && fontFamilies.length > 0);\n        let resource = image;\n        if (this._createCanvas) resource = (0, $dN8mg.getTemporaryCanvasFromImage)(image, resolution);\n        const texture = (0, $aq3uI.getPo2TextureFromSource)(resource, image.width, image.height, resolution);\n        if (this._createCanvas) this._renderer.texture.initSource(texture.source);\n        (0, $e98Fy.BigPool).return(htmlTextData);\n        return texture;\n    }\n    _increaseReferenceCount(textKey) {\n        this._activeTextures[textKey].usageCount++;\n    }\n    decreaseReferenceCount(textKey) {\n        const activeTexture = this._activeTextures[textKey];\n        if (!activeTexture) return;\n        activeTexture.usageCount--;\n        if (activeTexture.usageCount === 0) {\n            if (activeTexture.texture) this._cleanUp(activeTexture);\n            else activeTexture.promise.then((texture)=>{\n                activeTexture.texture = texture;\n                this._cleanUp(activeTexture);\n            }).catch(()=>{\n                (0, $8CF4q.warn)(\"HTMLTextSystem: Failed to clean texture\");\n            });\n            this._activeTextures[textKey] = null;\n        }\n    }\n    _cleanUp(activeTexture) {\n        (0, $7U2uj.TexturePool).returnTexture(activeTexture.texture);\n        activeTexture.texture.source.resource = null;\n        activeTexture.texture.source.uploadMethodId = \"unknown\";\n    }\n    getReferenceCount(textKey) {\n        return this._activeTextures[textKey].usageCount;\n    }\n    destroy() {\n        this._activeTextures = null;\n    }\n}\n/** @ignore */ $8f99d4c922228ac3$export$f1b82676a746d8e9.extension = {\n    type: [\n        (0, $eVz1R.ExtensionType).WebGLSystem,\n        (0, $eVz1R.ExtensionType).WebGPUSystem,\n        (0, $eVz1R.ExtensionType).CanvasSystem\n    ],\n    name: \"htmlText\"\n};\n$8f99d4c922228ac3$export$f1b82676a746d8e9.defaultFontOptions = {\n    fontFamily: \"Arial\",\n    fontStyle: \"normal\",\n    fontWeight: \"normal\"\n};\n\n});\nparcelRegister(\"lX2W5\", function(module, exports) {\n\n$parcel$export(module.exports, \"isSafari\", () => $d7b63cd773b2d56c$export$95df08bae54cb4df);\n\nvar $5m2Qn = parcelRequire(\"5m2Qn\");\n\"use strict\";\nfunction $d7b63cd773b2d56c$export$95df08bae54cb4df() {\n    const { userAgent: userAgent } = (0, $5m2Qn.DOMAdapter).get().getNavigator();\n    return /^((?!chrome|android).)*safari/i.test(userAgent);\n}\n\n});\n\nparcelRegister(\"fCTRI\", function(module, exports) {\n\n$parcel$export(module.exports, \"HTMLTextRenderData\", () => $7f6451c7d6b3e38c$export$47ab50939402e24e);\n\"use strict\";\nconst $7f6451c7d6b3e38c$export$5211e83ad76beaeb = \"http://www.w3.org/2000/svg\";\nconst $7f6451c7d6b3e38c$export$ff15d493b5bfa767 = \"http://www.w3.org/1999/xhtml\";\nclass $7f6451c7d6b3e38c$export$47ab50939402e24e {\n    constructor(){\n        this.svgRoot = document.createElementNS($7f6451c7d6b3e38c$export$5211e83ad76beaeb, \"svg\");\n        this.foreignObject = document.createElementNS($7f6451c7d6b3e38c$export$5211e83ad76beaeb, \"foreignObject\");\n        this.domElement = document.createElementNS($7f6451c7d6b3e38c$export$ff15d493b5bfa767, \"div\");\n        this.styleElement = document.createElementNS($7f6451c7d6b3e38c$export$ff15d493b5bfa767, \"style\");\n        this.image = new Image();\n        const { foreignObject: foreignObject, svgRoot: svgRoot, styleElement: styleElement, domElement: domElement } = this;\n        foreignObject.setAttribute(\"width\", \"10000\");\n        foreignObject.setAttribute(\"height\", \"10000\");\n        foreignObject.style.overflow = \"hidden\";\n        svgRoot.appendChild(foreignObject);\n        foreignObject.appendChild(styleElement);\n        foreignObject.appendChild(domElement);\n    }\n}\n\n});\n\nparcelRegister(\"ioRFn\", function(module, exports) {\n\n$parcel$export(module.exports, \"HTMLTextStyle\", () => $dd45ef77773e899a$export$a2664b42ece43c6c);\n\nvar $8CF4q = parcelRequire(\"8CF4q\");\n\nvar $itLJu = parcelRequire(\"itLJu\");\n\nvar $gSm2a = parcelRequire(\"gSm2a\");\n\nvar $au3DA = parcelRequire(\"au3DA\");\n\"use strict\";\nclass $dd45ef77773e899a$export$a2664b42ece43c6c extends (0, $itLJu.TextStyle) {\n    constructor(options = {}){\n        super(options);\n        this._cssOverrides = [];\n        this.cssOverrides ?? (this.cssOverrides = options.cssOverrides);\n        this.tagStyles = options.tagStyles ?? {};\n    }\n    /** List of style overrides that will be applied to the HTML text. */ set cssOverrides(value) {\n        this._cssOverrides = value instanceof Array ? value : [\n            value\n        ];\n        this.update();\n    }\n    get cssOverrides() {\n        return this._cssOverrides;\n    }\n    _generateKey() {\n        this._styleKey = (0, $gSm2a.generateTextStyleKey)(this) + this._cssOverrides.join(\"-\");\n        return this._styleKey;\n    }\n    update() {\n        this._cssStyle = null;\n        super.update();\n    }\n    /**\n   * Creates a new HTMLTextStyle object with the same values as this one.\n   * @returns New cloned HTMLTextStyle object\n   */ clone() {\n        return new $dd45ef77773e899a$export$a2664b42ece43c6c({\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this.dropShadow,\n            fill: this._fill,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth,\n            cssOverrides: this.cssOverrides\n        });\n    }\n    get cssStyle() {\n        if (!this._cssStyle) this._cssStyle = (0, $au3DA.textStyleToCSS)(this);\n        return this._cssStyle;\n    }\n    /**\n   * Add a style override, this can be any CSS property\n   * it will override any built-in style. This is the\n   * property and the value as a string (e.g., `color: red`).\n   * This will override any other internal style.\n   * @param {string} value - CSS style(s) to add.\n   * @example\n   * style.addOverride('background-color: red');\n   */ addOverride(...value) {\n        const toAdd = value.filter((v)=>!this.cssOverrides.includes(v));\n        if (toAdd.length > 0) {\n            this.cssOverrides.push(...toAdd);\n            this.update();\n        }\n    }\n    /**\n   * Remove any overrides that match the value.\n   * @param {string} value - CSS style to remove.\n   * @example\n   * style.removeOverride('background-color: red');\n   */ removeOverride(...value) {\n        const toRemove = value.filter((v)=>this.cssOverrides.includes(v));\n        if (toRemove.length > 0) {\n            this.cssOverrides = this.cssOverrides.filter((v)=>!toRemove.includes(v));\n            this.update();\n        }\n    }\n    set fill(value) {\n        if (typeof value !== \"string\" && typeof value !== \"number\") (0, $8CF4q.warn)(\"[HTMLTextStyle] only color fill is not supported by HTMLText\");\n        super.fill = value;\n    }\n    set stroke(value) {\n        if (value && typeof value !== \"string\" && typeof value !== \"number\") (0, $8CF4q.warn)(\"[HTMLTextStyle] only color stroke is not supported by HTMLText\");\n        super.stroke = value;\n    }\n}\n\n});\nparcelRegister(\"au3DA\", function(module, exports) {\n\n$parcel$export(module.exports, \"textStyleToCSS\", () => $43dfd7f97fe8e53b$export$8daecfbc002513c1);\n\nvar $AHTcQ = parcelRequire(\"AHTcQ\");\n\"use strict\";\nfunction $43dfd7f97fe8e53b$export$8daecfbc002513c1(style) {\n    const stroke = style._stroke;\n    const fill = style._fill;\n    const cssStyleString = [\n        `color: ${(0, $AHTcQ.Color).shared.setValue(fill.color).toHex()}`,\n        `font-size: ${style.fontSize}px`,\n        `font-family: ${style.fontFamily}`,\n        `font-weight: ${style.fontWeight}`,\n        `font-style: ${style.fontStyle}`,\n        `font-variant: ${style.fontVariant}`,\n        `letter-spacing: ${style.letterSpacing}px`,\n        `text-align: ${style.align}`,\n        `padding: ${style.padding}px`,\n        `white-space: ${style.whiteSpace === \"pre\" && style.wordWrap ? \"pre-wrap\" : style.whiteSpace}`,\n        ...style.lineHeight ? [\n            `line-height: ${style.lineHeight}px`\n        ] : [],\n        ...style.wordWrap ? [\n            `word-wrap: ${style.breakWords ? \"break-all\" : \"break-word\"}`,\n            `max-width: ${style.wordWrapWidth}px`\n        ] : [],\n        ...stroke ? [\n            $43dfd7f97fe8e53b$var$strokeToCSS(stroke)\n        ] : [],\n        ...style.dropShadow ? [\n            $43dfd7f97fe8e53b$var$dropShadowToCSS(style.dropShadow)\n        ] : [],\n        ...style.cssOverrides\n    ].join(\";\");\n    const cssStyles = [\n        `div { ${cssStyleString} }`\n    ];\n    $43dfd7f97fe8e53b$var$tagStyleToCSS(style.tagStyles, cssStyles);\n    return cssStyles.join(\" \");\n}\nfunction $43dfd7f97fe8e53b$var$dropShadowToCSS(dropShadowStyle) {\n    const color = (0, $AHTcQ.Color).shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();\n    const x = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);\n    const y = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);\n    const position = `${x}px ${y}px`;\n    if (dropShadowStyle.blur > 0) return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;\n    return `text-shadow: ${position} ${color}`;\n}\nfunction $43dfd7f97fe8e53b$var$strokeToCSS(stroke) {\n    return [\n        `-webkit-text-stroke-width: ${stroke.width}px`,\n        `-webkit-text-stroke-color: ${(0, $AHTcQ.Color).shared.setValue(stroke.color).toHex()}`,\n        `text-stroke-width: ${stroke.width}px`,\n        `text-stroke-color: ${(0, $AHTcQ.Color).shared.setValue(stroke.color).toHex()}`,\n        \"paint-order: stroke\"\n    ].join(\";\");\n}\nconst $43dfd7f97fe8e53b$var$templates = {\n    fontSize: `font-size: {{VALUE}}px`,\n    fontFamily: `font-family: {{VALUE}}`,\n    fontWeight: `font-weight: {{VALUE}}`,\n    fontStyle: `font-style: {{VALUE}}`,\n    fontVariant: `font-variant: {{VALUE}}`,\n    letterSpacing: `letter-spacing: {{VALUE}}px`,\n    align: `text-align: {{VALUE}}`,\n    padding: `padding: {{VALUE}}px`,\n    whiteSpace: `white-space: {{VALUE}}`,\n    lineHeight: `line-height: {{VALUE}}px`,\n    wordWrapWidth: `max-width: {{VALUE}}px`\n};\nconst $43dfd7f97fe8e53b$var$transform = {\n    fill: (value)=>`color: ${(0, $AHTcQ.Color).shared.setValue(value).toHex()}`,\n    breakWords: (value)=>`word-wrap: ${value ? \"break-all\" : \"break-word\"}`,\n    stroke: $43dfd7f97fe8e53b$var$strokeToCSS,\n    dropShadow: $43dfd7f97fe8e53b$var$dropShadowToCSS\n};\nfunction $43dfd7f97fe8e53b$var$tagStyleToCSS(tagStyles, out) {\n    for(const i in tagStyles){\n        const tagStyle = tagStyles[i];\n        const cssTagStyle = [];\n        for(const j in tagStyle){\n            if ($43dfd7f97fe8e53b$var$transform[j]) cssTagStyle.push($43dfd7f97fe8e53b$var$transform[j](tagStyle[j]));\n            else if ($43dfd7f97fe8e53b$var$templates[j]) cssTagStyle.push($43dfd7f97fe8e53b$var$templates[j].replace(\"{{VALUE}}\", tagStyle[j]));\n        }\n        out.push(`${i} { ${cssTagStyle.join(\";\")} }`);\n    }\n}\n\n});\n\n\nparcelRegister(\"ima1e\", function(module, exports) {\n\n$parcel$export(module.exports, \"extractFontFamilies\", () => $d97dc040521de188$export$464e4dcbf779d16c);\n\"use strict\";\nfunction $d97dc040521de188$export$464e4dcbf779d16c(text, style) {\n    const fontFamily = style.fontFamily;\n    const fontFamilies = [];\n    const dedupe = {};\n    const regex = /font-family:([^;\"\\s]+)/g;\n    const matches = text.match(regex);\n    function addFontFamily(fontFamily2) {\n        if (!dedupe[fontFamily2]) {\n            fontFamilies.push(fontFamily2);\n            dedupe[fontFamily2] = true;\n        }\n    }\n    if (Array.isArray(fontFamily)) for(let i = 0; i < fontFamily.length; i++)addFontFamily(fontFamily[i]);\n    else addFontFamily(fontFamily);\n    if (matches) matches.forEach((match)=>{\n        const fontFamily2 = match.split(\":\")[1].trim();\n        addFontFamily(fontFamily2);\n    });\n    for(const i in style.tagStyles){\n        const fontFamily2 = style.tagStyles[i].fontFamily;\n        addFontFamily(fontFamily2);\n    }\n    return fontFamilies;\n}\n\n});\n\nparcelRegister(\"eITko\", function(module, exports) {\n\n$parcel$export(module.exports, \"getFontCss\", () => $52f8eba0d0420032$export$634b39f5e6e8534d);\n\nvar $gYSnF = parcelRequire(\"gYSnF\");\n\nvar $9uPNF = parcelRequire(\"9uPNF\");\n\"use strict\";\nconst $52f8eba0d0420032$export$9b6075a0351ad0f8 = /* @__PURE__ */ new Map();\nasync function $52f8eba0d0420032$export$634b39f5e6e8534d(fontFamilies, style, defaultOptions) {\n    const fontPromises = fontFamilies.filter((fontFamily)=>(0, $gYSnF.Cache).has(`${fontFamily}-and-url`)).map((fontFamily, i)=>{\n        if (!$52f8eba0d0420032$export$9b6075a0351ad0f8.has(fontFamily)) {\n            const { url: url } = (0, $gYSnF.Cache).get(`${fontFamily}-and-url`);\n            if (i === 0) $52f8eba0d0420032$export$9b6075a0351ad0f8.set(fontFamily, (0, $9uPNF.loadFontCSS)(style, url));\n            else $52f8eba0d0420032$export$9b6075a0351ad0f8.set(fontFamily, (0, $9uPNF.loadFontCSS)({\n                fontWeight: defaultOptions.fontWeight,\n                fontStyle: defaultOptions.fontStyle,\n                fontFamily: fontFamily\n            }, url));\n        }\n        return $52f8eba0d0420032$export$9b6075a0351ad0f8.get(fontFamily);\n    });\n    return (await Promise.all(fontPromises)).join(\"\\n\");\n}\n\n});\nparcelRegister(\"9uPNF\", function(module, exports) {\n\n$parcel$export(module.exports, \"loadFontCSS\", () => $fd9009d6662e5087$export$d5a8e182a5491db2);\n\nvar $67eDB = parcelRequire(\"67eDB\");\n\"use strict\";\nasync function $fd9009d6662e5087$export$d5a8e182a5491db2(style, url) {\n    const dataSrc = await (0, $67eDB.loadFontAsBase64)(url);\n    return `@font-face {\n        font-family: \"${style.fontFamily}\";\n        src: url('${dataSrc}');\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n    }`;\n}\n\n});\nparcelRegister(\"67eDB\", function(module, exports) {\n\n$parcel$export(module.exports, \"loadFontAsBase64\", () => $9101e6ed68a6d748$export$21404a5ba2126552);\n\nvar $5m2Qn = parcelRequire(\"5m2Qn\");\n\"use strict\";\nasync function $9101e6ed68a6d748$export$21404a5ba2126552(url) {\n    const response = await (0, $5m2Qn.DOMAdapter).get().fetch(url);\n    const blob = await response.blob();\n    const reader = new FileReader();\n    const dataSrc = await new Promise((resolve, reject)=>{\n        reader.onloadend = ()=>resolve(reader.result);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n    });\n    return dataSrc;\n}\n\n});\n\n\n\nparcelRegister(\"4jNdA\", function(module, exports) {\n\n$parcel$export(module.exports, \"getSVGUrl\", () => $b575faec2ef0da29$export$98b744dca5b9429f);\n\"use strict\";\nfunction $b575faec2ef0da29$export$98b744dca5b9429f(text, style, resolution, fontCSS, htmlTextData) {\n    const { domElement: domElement, styleElement: styleElement, svgRoot: svgRoot } = htmlTextData;\n    domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n    domElement.setAttribute(\"style\", `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n    styleElement.textContent = fontCSS;\n    const { width: width, height: height } = htmlTextData.image;\n    svgRoot.setAttribute(\"width\", width.toString());\n    svgRoot.setAttribute(\"height\", height.toString());\n    return new XMLSerializer().serializeToString(svgRoot);\n}\n\n});\n\nparcelRegister(\"dN8mg\", function(module, exports) {\n\n$parcel$export(module.exports, \"getTemporaryCanvasFromImage\", () => $3e0486db38f293a4$export$d871fed544c30b4e);\n\nvar $8zNlV = parcelRequire(\"8zNlV\");\n\"use strict\";\nfunction $3e0486db38f293a4$export$d871fed544c30b4e(image, resolution) {\n    const canvasAndContext = (0, $8zNlV.CanvasPool).getOptimalCanvasAndContext(image.width, image.height, resolution);\n    const { context: context } = canvasAndContext;\n    context.clearRect(0, 0, image.width, image.height);\n    context.drawImage(image, 0, 0);\n    (0, $8zNlV.CanvasPool).returnCanvasAndContext(canvasAndContext);\n    return canvasAndContext.canvas;\n}\n\n});\n\nparcelRegister(\"4JtMi\", function(module, exports) {\n\n$parcel$export(module.exports, \"loadSVGImage\", () => $0e67ac1d5a4c17bc$export$31cf685397f1a12a);\n\"use strict\";\nfunction $0e67ac1d5a4c17bc$export$31cf685397f1a12a(image, url, delay) {\n    return new Promise(async (resolve)=>{\n        if (delay) await new Promise((resolve2)=>setTimeout(resolve2, 100));\n        image.onload = ()=>{\n            resolve();\n        };\n        image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n        image.crossOrigin = \"anonymous\";\n    });\n}\n\n});\n\nparcelRegister(\"8Aoo3\", function(module, exports) {\n\n$parcel$export(module.exports, \"measureHtmlText\", () => $4ae7f08d3391dc86$export$9df7f2a259800030);\n\nvar $ffIGX = parcelRequire(\"ffIGX\");\n\nvar $fCTRI = parcelRequire(\"fCTRI\");\n\"use strict\";\nlet $4ae7f08d3391dc86$var$tempHTMLTextRenderData;\nfunction $4ae7f08d3391dc86$export$9df7f2a259800030(text, style, fontStyleCSS, htmlTextRenderData) {\n    htmlTextRenderData = htmlTextRenderData || $4ae7f08d3391dc86$var$tempHTMLTextRenderData || ($4ae7f08d3391dc86$var$tempHTMLTextRenderData = new (0, $fCTRI.HTMLTextRenderData)());\n    const { domElement: domElement, styleElement: styleElement, svgRoot: svgRoot } = htmlTextRenderData;\n    domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n    domElement.setAttribute(\"style\", \"transform-origin: top left; display: inline-block\");\n    if (fontStyleCSS) styleElement.textContent = fontStyleCSS;\n    document.body.appendChild(svgRoot);\n    const contentBounds = domElement.getBoundingClientRect();\n    svgRoot.remove();\n    const descenderPadding = (0, $ffIGX.CanvasTextMetrics).measureFont(style.fontStyle).descent;\n    return {\n        width: contentBounds.width,\n        height: contentBounds.height + descenderPadding\n    };\n}\n\n});\n\n\n\nparcelRegister(\"3aSYR\", function(module, exports) {\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $lBnsB = parcelRequire(\"lBnsB\");\n\"use strict\";\n(0, $eVz1R.extensions).add((0, $lBnsB.TilingSpritePipe));\n\n});\nparcelRegister(\"lBnsB\", function(module, exports) {\n\n$parcel$export(module.exports, \"TilingSpritePipe\", () => $f74dcbc6c5a684c6$export$b56051ebf906ec5d);\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $4rJn2 = parcelRequire(\"4rJn2\");\n\nvar $dgEnR = parcelRequire(\"dgEnR\");\n\nvar $1A6sa = parcelRequire(\"1A6sa\");\n\nvar $bq09x = parcelRequire(\"bq09x\");\n\nvar $egBuP = parcelRequire(\"egBuP\");\n\nvar $6uHq8 = parcelRequire(\"6uHq8\");\n\nvar $kw4QU = parcelRequire(\"kw4QU\");\n\nvar $95QaC = parcelRequire(\"95QaC\");\n\nvar $eFs8Y = parcelRequire(\"eFs8Y\");\n\"use strict\";\nconst $f74dcbc6c5a684c6$var$sharedQuad = new (0, $kw4QU.QuadGeometry)();\nclass $f74dcbc6c5a684c6$export$b56051ebf906ec5d {\n    constructor(renderer){\n        this._tilingSpriteDataHash = /* @__PURE__ */ Object.create(null);\n        this._renderer = renderer;\n    }\n    validateRenderable(renderable) {\n        const tilingSpriteData = this._getTilingSpriteData(renderable);\n        const couldBatch = tilingSpriteData.canBatch;\n        this._updateCanBatch(renderable);\n        const canBatch = tilingSpriteData.canBatch;\n        if (canBatch && canBatch === couldBatch) {\n            const { batchableMesh: batchableMesh } = tilingSpriteData;\n            if (batchableMesh.texture._source !== renderable.texture._source) return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, renderable.texture);\n        }\n        return couldBatch !== canBatch;\n    }\n    addRenderable(tilingSprite, instructionSet) {\n        const batcher = this._renderer.renderPipes.batch;\n        this._updateCanBatch(tilingSprite);\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n        const { geometry: geometry, canBatch: canBatch } = tilingSpriteData;\n        if (canBatch) {\n            tilingSpriteData.batchableMesh || (tilingSpriteData.batchableMesh = new (0, $bq09x.BatchableMesh)());\n            const batchableMesh = tilingSpriteData.batchableMesh;\n            if (tilingSprite._didTilingSpriteUpdate) {\n                tilingSprite._didTilingSpriteUpdate = false;\n                this._updateBatchableMesh(tilingSprite);\n                batchableMesh.geometry = geometry;\n                batchableMesh.mesh = tilingSprite;\n                batchableMesh.texture = tilingSprite._texture;\n            }\n            batchableMesh.roundPixels = this._renderer._roundPixels | tilingSprite._roundPixels;\n            batcher.addToBatch(batchableMesh);\n        } else {\n            batcher.break(instructionSet);\n            tilingSpriteData.shader || (tilingSpriteData.shader = new (0, $6uHq8.TilingSpriteShader)());\n            this.updateRenderable(tilingSprite);\n            instructionSet.add(tilingSprite);\n        }\n    }\n    execute(tilingSprite) {\n        const { shader: shader } = this._tilingSpriteDataHash[tilingSprite.uid];\n        shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n        const localUniforms = shader.resources.localUniforms.uniforms;\n        localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n        localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n        (0, $1A6sa.color32BitToUniform)(tilingSprite.groupColorAlpha, localUniforms.uColor, 0);\n        this._renderer.encoder.draw({\n            geometry: $f74dcbc6c5a684c6$var$sharedQuad,\n            shader: shader,\n            state: (0, $4rJn2.State).default2d\n        });\n    }\n    updateRenderable(tilingSprite) {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n        const { canBatch: canBatch } = tilingSpriteData;\n        if (canBatch) {\n            const { batchableMesh: batchableMesh } = tilingSpriteData;\n            if (tilingSprite._didTilingSpriteUpdate) this._updateBatchableMesh(tilingSprite);\n            batchableMesh.batcher.updateElement(batchableMesh);\n        } else if (tilingSprite._didTilingSpriteUpdate) {\n            const { shader: shader } = tilingSpriteData;\n            shader.updateUniforms(tilingSprite.width, tilingSprite.height, tilingSprite._tileTransform.matrix, tilingSprite.anchor.x, tilingSprite.anchor.y, tilingSprite.texture);\n        }\n        tilingSprite._didTilingSpriteUpdate = false;\n    }\n    destroyRenderable(tilingSprite) {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n        tilingSpriteData.batchableMesh = null;\n        tilingSpriteData.shader?.destroy();\n        this._tilingSpriteDataHash[tilingSprite.uid] = null;\n    }\n    _getTilingSpriteData(renderable) {\n        return this._tilingSpriteDataHash[renderable.uid] || this._initTilingSpriteData(renderable);\n    }\n    _initTilingSpriteData(tilingSprite) {\n        const geometry = new (0, $egBuP.MeshGeometry)({\n            indices: $f74dcbc6c5a684c6$var$sharedQuad.indices,\n            positions: $f74dcbc6c5a684c6$var$sharedQuad.positions.slice(),\n            uvs: $f74dcbc6c5a684c6$var$sharedQuad.uvs.slice()\n        });\n        this._tilingSpriteDataHash[tilingSprite.uid] = {\n            canBatch: true,\n            renderable: tilingSprite,\n            geometry: geometry\n        };\n        tilingSprite.on(\"destroyed\", ()=>{\n            this.destroyRenderable(tilingSprite);\n        });\n        return this._tilingSpriteDataHash[tilingSprite.uid];\n    }\n    _updateBatchableMesh(tilingSprite) {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n        const { geometry: geometry } = renderableData;\n        const style = tilingSprite.texture.source.style;\n        if (style.addressMode !== \"repeat\") {\n            style.addressMode = \"repeat\";\n            style.update();\n        }\n        (0, $eFs8Y.setUvs)(tilingSprite, geometry.uvs);\n        (0, $95QaC.setPositions)(tilingSprite, geometry.positions);\n    }\n    destroy() {\n        for(const i in this._tilingSpriteDataHash)this.destroyRenderable(this._tilingSpriteDataHash[i].renderable);\n        this._tilingSpriteDataHash = null;\n        this._renderer = null;\n    }\n    _updateCanBatch(tilingSprite) {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n        const texture = tilingSprite.texture;\n        let _nonPowOf2wrapping = true;\n        if (this._renderer.type === (0, $dgEnR.RendererType).WEBGL) _nonPowOf2wrapping = this._renderer.context.supports.nonPowOf2wrapping;\n        renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n        return renderableData.canBatch;\n    }\n}\n/** @ignore */ $f74dcbc6c5a684c6$export$b56051ebf906ec5d.extension = {\n    type: [\n        (0, $eVz1R.ExtensionType).WebGLPipes,\n        (0, $eVz1R.ExtensionType).WebGPUPipes,\n        (0, $eVz1R.ExtensionType).CanvasPipes\n    ],\n    name: \"tilingSprite\"\n};\n\n});\nparcelRegister(\"egBuP\", function(module, exports) {\n\n$parcel$export(module.exports, \"MeshGeometry\", () => $d22d58fb5edad5e0$export$8d075a36a73d54bc);\n\nvar $2qhsM = parcelRequire(\"2qhsM\");\n\nvar $cnPar = parcelRequire(\"cnPar\");\n\nvar $kFbJv = parcelRequire(\"kFbJv\");\n\nvar $eX50w = parcelRequire(\"eX50w\");\n\"use strict\";\nconst $d22d58fb5edad5e0$var$_MeshGeometry = class _MeshGeometry extends (0, $kFbJv.Geometry) {\n    constructor(...args){\n        let options = args[0] ?? {};\n        if (options instanceof Float32Array) {\n            (0, $eX50w.deprecation)((0, $eX50w.v8_0_0), \"use new MeshGeometry({ positions, uvs, indices }) instead\");\n            options = {\n                positions: options,\n                uvs: args[1],\n                indices: args[2]\n            };\n        }\n        options = {\n            ..._MeshGeometry.defaultOptions,\n            ...options\n        };\n        const positions = options.positions || new Float32Array([\n            0,\n            0,\n            1,\n            0,\n            1,\n            1,\n            0,\n            1\n        ]);\n        const uvs = options.uvs || new Float32Array([\n            0,\n            0,\n            1,\n            0,\n            1,\n            1,\n            0,\n            1\n        ]);\n        const indices = options.indices || new Uint32Array([\n            0,\n            1,\n            2,\n            0,\n            2,\n            3\n        ]);\n        const shrinkToFit = options.shrinkBuffersToFit;\n        const positionBuffer = new (0, $2qhsM.Buffer)({\n            data: positions,\n            label: \"attribute-mesh-positions\",\n            shrinkToFit: shrinkToFit,\n            usage: (0, $cnPar.BufferUsage).VERTEX | (0, $cnPar.BufferUsage).COPY_DST\n        });\n        const uvBuffer = new (0, $2qhsM.Buffer)({\n            data: uvs,\n            label: \"attribute-mesh-uvs\",\n            shrinkToFit: shrinkToFit,\n            usage: (0, $cnPar.BufferUsage).VERTEX | (0, $cnPar.BufferUsage).COPY_DST\n        });\n        const indexBuffer = new (0, $2qhsM.Buffer)({\n            data: indices,\n            label: \"index-mesh-buffer\",\n            shrinkToFit: shrinkToFit,\n            usage: (0, $cnPar.BufferUsage).INDEX | (0, $cnPar.BufferUsage).COPY_DST\n        });\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: positionBuffer,\n                    format: \"float32x2\",\n                    stride: 8,\n                    offset: 0\n                },\n                aUV: {\n                    buffer: uvBuffer,\n                    format: \"float32x2\",\n                    stride: 8,\n                    offset: 0\n                }\n            },\n            indexBuffer: indexBuffer,\n            topology: options.topology\n        });\n        this.batchMode = \"auto\";\n    }\n    /** The positions of the mesh. */ get positions() {\n        return this.attributes.aPosition.buffer.data;\n    }\n    set positions(value) {\n        this.attributes.aPosition.buffer.data = value;\n    }\n    /** The UVs of the mesh. */ get uvs() {\n        return this.attributes.aUV.buffer.data;\n    }\n    set uvs(value) {\n        this.attributes.aUV.buffer.data = value;\n    }\n    /** The indices of the mesh. */ get indices() {\n        return this.indexBuffer.data;\n    }\n    set indices(value) {\n        this.indexBuffer.data = value;\n    }\n};\n$d22d58fb5edad5e0$var$_MeshGeometry.defaultOptions = {\n    topology: \"triangle-list\",\n    shrinkBuffersToFit: false\n};\nlet $d22d58fb5edad5e0$export$8d075a36a73d54bc = $d22d58fb5edad5e0$var$_MeshGeometry;\n\n});\n\nparcelRegister(\"6uHq8\", function(module, exports) {\n\n$parcel$export(module.exports, \"TilingSpriteShader\", () => $8e66c909c6201b01$export$d1a26cc57b383809);\n\nvar $dNaJE = parcelRequire(\"dNaJE\");\n\nvar $1amHU = parcelRequire(\"1amHU\");\n\nvar $bwYhl = parcelRequire(\"bwYhl\");\n\nvar $eJTyi = parcelRequire(\"eJTyi\");\n\nvar $7cNGO = parcelRequire(\"7cNGO\");\n\nvar $lJEsO = parcelRequire(\"lJEsO\");\n\nvar $5h88T = parcelRequire(\"5h88T\");\n\nvar $lSjtG = parcelRequire(\"lSjtG\");\n\"use strict\";\nlet $8e66c909c6201b01$var$gpuProgram;\nlet $8e66c909c6201b01$var$glProgram;\nclass $8e66c909c6201b01$export$d1a26cc57b383809 extends (0, $7cNGO.Shader) {\n    constructor(){\n        $8e66c909c6201b01$var$gpuProgram ?? ($8e66c909c6201b01$var$gpuProgram = (0, $1amHU.compileHighShaderGpuProgram)({\n            name: \"tiling-sprite-shader\",\n            bits: [\n                (0, $bwYhl.localUniformBit),\n                (0, $lSjtG.tilingBit),\n                (0, $eJTyi.roundPixelsBit)\n            ]\n        }));\n        $8e66c909c6201b01$var$glProgram ?? ($8e66c909c6201b01$var$glProgram = (0, $1amHU.compileHighShaderGlProgram)({\n            name: \"tiling-sprite-shader\",\n            bits: [\n                (0, $bwYhl.localUniformBitGl),\n                (0, $lSjtG.tilingBitGl),\n                (0, $eJTyi.roundPixelsBitGl)\n            ]\n        }));\n        const tilingUniforms = new (0, $lJEsO.UniformGroup)({\n            uMapCoord: {\n                value: new (0, $dNaJE.Matrix)(),\n                type: \"mat3x3<f32>\"\n            },\n            uClampFrame: {\n                value: new Float32Array([\n                    0,\n                    0,\n                    1,\n                    1\n                ]),\n                type: \"vec4<f32>\"\n            },\n            uClampOffset: {\n                value: new Float32Array([\n                    0,\n                    0\n                ]),\n                type: \"vec2<f32>\"\n            },\n            uTextureTransform: {\n                value: new (0, $dNaJE.Matrix)(),\n                type: \"mat3x3<f32>\"\n            },\n            uSizeAnchor: {\n                value: new Float32Array([\n                    100,\n                    100,\n                    0.5,\n                    0.5\n                ]),\n                type: \"vec4<f32>\"\n            }\n        });\n        super({\n            glProgram: $8e66c909c6201b01$var$glProgram,\n            gpuProgram: $8e66c909c6201b01$var$gpuProgram,\n            resources: {\n                localUniforms: new (0, $lJEsO.UniformGroup)({\n                    uTransformMatrix: {\n                        value: new (0, $dNaJE.Matrix)(),\n                        type: \"mat3x3<f32>\"\n                    },\n                    uColor: {\n                        value: new Float32Array([\n                            1,\n                            1,\n                            1,\n                            1\n                        ]),\n                        type: \"vec4<f32>\"\n                    },\n                    uRound: {\n                        value: 0,\n                        type: \"f32\"\n                    }\n                }),\n                tilingUniforms: tilingUniforms,\n                uTexture: (0, $5h88T.Texture).EMPTY.source,\n                uSampler: (0, $5h88T.Texture).EMPTY.source.style\n            }\n        });\n    }\n    updateUniforms(width, height, matrix, anchorX, anchorY, texture) {\n        const tilingUniforms = this.resources.tilingUniforms;\n        const textureWidth = texture.width;\n        const textureHeight = texture.height;\n        const textureMatrix = texture.textureMatrix;\n        const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n        uTextureTransform.set(matrix.a * textureWidth / width, matrix.b * textureWidth / height, matrix.c * textureHeight / width, matrix.d * textureHeight / height, matrix.tx / width, matrix.ty / height);\n        uTextureTransform.invert();\n        tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n        tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n        tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n        tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n        tilingUniforms.uniforms.uSizeAnchor[0] = width;\n        tilingUniforms.uniforms.uSizeAnchor[1] = height;\n        tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n        tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n        if (texture) {\n            this.resources.uTexture = texture.source;\n            this.resources.uSampler = texture.source.style;\n        }\n    }\n}\n\n});\nparcelRegister(\"lSjtG\", function(module, exports) {\n\n$parcel$export(module.exports, \"tilingBit\", () => $87b0144914f9a241$export$7551c6773b6af70d);\n$parcel$export(module.exports, \"tilingBitGl\", () => $87b0144914f9a241$export$a104558c66046525);\n\"use strict\";\nconst $87b0144914f9a241$export$7551c6773b6af70d = {\n    name: \"tiling-bit\",\n    vertex: {\n        header: /* wgsl */ `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */ `\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n    },\n    fragment: {\n        header: /* wgsl */ `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */ `\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            } \n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    }\n};\nconst $87b0144914f9a241$export$a104558c66046525 = {\n    name: \"tiling-bit\",\n    vertex: {\n        header: /* glsl */ `\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n        \n        `,\n        main: /* glsl */ `\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n    },\n    fragment: {\n        header: /* glsl */ `\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `,\n        main: /* glsl */ `\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n        \n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n    \n        `\n    }\n};\n\n});\n\n\nparcelRegister(\"kw4QU\", function(module, exports) {\n\n$parcel$export(module.exports, \"QuadGeometry\", () => $e8f84e9bd56edc52$export$d27e254c8c1b5a0e);\n\nvar $egBuP = parcelRequire(\"egBuP\");\n\"use strict\";\nclass $e8f84e9bd56edc52$export$d27e254c8c1b5a0e extends (0, $egBuP.MeshGeometry) {\n    constructor(){\n        super({\n            positions: new Float32Array([\n                0,\n                0,\n                1,\n                0,\n                1,\n                1,\n                0,\n                1\n            ]),\n            uvs: new Float32Array([\n                0,\n                0,\n                1,\n                0,\n                1,\n                1,\n                0,\n                1\n            ]),\n            indices: new Uint32Array([\n                0,\n                1,\n                2,\n                0,\n                2,\n                3\n            ])\n        });\n    }\n}\n\n});\n\nparcelRegister(\"95QaC\", function(module, exports) {\n\n$parcel$export(module.exports, \"setPositions\", () => $7efff6096e850f81$export$7d390d1e3efa819a);\n\"use strict\";\nfunction $7efff6096e850f81$export$7d390d1e3efa819a(tilingSprite, positions) {\n    const anchorX = tilingSprite.anchor.x;\n    const anchorY = tilingSprite.anchor.y;\n    positions[0] = -anchorX * tilingSprite.width;\n    positions[1] = -anchorY * tilingSprite.height;\n    positions[2] = (1 - anchorX) * tilingSprite.width;\n    positions[3] = -anchorY * tilingSprite.height;\n    positions[4] = (1 - anchorX) * tilingSprite.width;\n    positions[5] = (1 - anchorY) * tilingSprite.height;\n    positions[6] = -anchorX * tilingSprite.width;\n    positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n\n});\n\nparcelRegister(\"eFs8Y\", function(module, exports) {\n\n$parcel$export(module.exports, \"setUvs\", () => $329c27945ef19020$export$f99a1f47283a6d20);\n\nvar $dNaJE = parcelRequire(\"dNaJE\");\n\nvar $69HXm = parcelRequire(\"69HXm\");\n\"use strict\";\nfunction $329c27945ef19020$export$f99a1f47283a6d20(tilingSprite, uvs) {\n    const texture = tilingSprite.texture;\n    const width = texture.frame.width;\n    const height = texture.frame.height;\n    let anchorX = 0;\n    let anchorY = 0;\n    if (tilingSprite._applyAnchorToTexture) {\n        anchorX = tilingSprite.anchor.x;\n        anchorY = tilingSprite.anchor.y;\n    }\n    uvs[0] = uvs[6] = -anchorX;\n    uvs[2] = uvs[4] = 1 - anchorX;\n    uvs[1] = uvs[3] = -anchorY;\n    uvs[5] = uvs[7] = 1 - anchorY;\n    const textureMatrix = (0, $dNaJE.Matrix).shared;\n    textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n    textureMatrix.tx /= tilingSprite.width;\n    textureMatrix.ty /= tilingSprite.height;\n    textureMatrix.invert();\n    textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n    (0, $69HXm.applyMatrix)(uvs, 2, 0, textureMatrix);\n}\n\n});\nparcelRegister(\"69HXm\", function(module, exports) {\n\n$parcel$export(module.exports, \"applyMatrix\", () => $a68854535b202106$export$8e14504c3429ee65);\n\"use strict\";\nfunction $a68854535b202106$export$8e14504c3429ee65(array, stride, offset, matrix) {\n    let index = 0;\n    const size = array.length / (stride || 2);\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    offset *= stride;\n    while(index < size){\n        const x = array[offset];\n        const y = array[offset + 1];\n        array[offset] = a * x + c * y + tx;\n        array[offset + 1] = b * x + d * y + ty;\n        offset += stride;\n        index++;\n    }\n}\n\n});\n\n\n\n\nparcelRegister(\"gOfig\", function(module, exports) {\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $7hs4B = parcelRequire(\"7hs4B\");\n\"use strict\";\n(0, $eVz1R.extensions).add((0, $7hs4B.NineSliceSpritePipe));\n\n});\nparcelRegister(\"7hs4B\", function(module, exports) {\n\n$parcel$export(module.exports, \"NineSliceSpritePipe\", () => $3197407932be8e47$export$69030e8b070eaa80);\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $e98Fy = parcelRequire(\"e98Fy\");\n\nvar $bq09x = parcelRequire(\"bq09x\");\n\nvar $jxmLS = parcelRequire(\"jxmLS\");\n\"use strict\";\nclass $3197407932be8e47$export$69030e8b070eaa80 {\n    constructor(renderer){\n        this._gpuSpriteHash = /* @__PURE__ */ Object.create(null);\n        this._renderer = renderer;\n    }\n    addRenderable(sprite, _instructionSet) {\n        const gpuSprite = this._getGpuSprite(sprite);\n        if (sprite._didSpriteUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite);\n    }\n    updateRenderable(sprite) {\n        const gpuSprite = this._gpuSpriteHash[sprite.uid];\n        if (sprite._didSpriteUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n        gpuSprite.batcher.updateElement(gpuSprite);\n    }\n    validateRenderable(sprite) {\n        const texture = sprite._texture;\n        const gpuSprite = this._getGpuSprite(sprite);\n        if (gpuSprite.texture._source !== texture._source) return !gpuSprite.batcher.checkAndUpdateTexture(gpuSprite, texture);\n        return false;\n    }\n    destroyRenderable(sprite) {\n        const batchableSprite = this._gpuSpriteHash[sprite.uid];\n        (0, $e98Fy.BigPool).return(batchableSprite);\n        this._gpuSpriteHash[sprite.uid] = null;\n    }\n    _updateBatchableSprite(sprite, batchableSprite) {\n        sprite._didSpriteUpdate = false;\n        batchableSprite.geometry.update(sprite);\n        batchableSprite.texture = sprite._texture;\n    }\n    _getGpuSprite(sprite) {\n        return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);\n    }\n    _initGPUSprite(sprite) {\n        const batchableMesh = new (0, $bq09x.BatchableMesh)();\n        batchableMesh.geometry = new (0, $jxmLS.NineSliceGeometry)();\n        batchableMesh.mesh = sprite;\n        batchableMesh.texture = sprite._texture;\n        batchableMesh.roundPixels = this._renderer._roundPixels | sprite._roundPixels;\n        this._gpuSpriteHash[sprite.uid] = batchableMesh;\n        sprite.on(\"destroyed\", ()=>{\n            this.destroyRenderable(sprite);\n        });\n        return batchableMesh;\n    }\n    destroy() {\n        for(const i in this._gpuSpriteHash){\n            const batchableMesh = this._gpuSpriteHash[i];\n            batchableMesh.geometry.destroy();\n        }\n        this._gpuSpriteHash = null;\n        this._renderer = null;\n    }\n}\n/** @ignore */ $3197407932be8e47$export$69030e8b070eaa80.extension = {\n    type: [\n        (0, $eVz1R.ExtensionType).WebGLPipes,\n        (0, $eVz1R.ExtensionType).WebGPUPipes,\n        (0, $eVz1R.ExtensionType).CanvasPipes\n    ],\n    name: \"nineSliceSprite\"\n};\n\n});\nparcelRegister(\"jxmLS\", function(module, exports) {\n\n$parcel$export(module.exports, \"NineSliceGeometry\", () => $8d665aef35d21487$export$a1f405faf7381142);\n\nvar $ifiML = parcelRequire(\"ifiML\");\n\"use strict\";\nconst $8d665aef35d21487$var$_NineSliceGeometry = class _NineSliceGeometry extends (0, $ifiML.PlaneGeometry) {\n    constructor(options = {}){\n        options = {\n            ..._NineSliceGeometry.defaultOptions,\n            ...options\n        };\n        super({\n            width: options.width,\n            height: options.height,\n            verticesX: 4,\n            verticesY: 4\n        });\n        this.update(options);\n    }\n    /**\n   * Updates the NineSliceGeometry with the options.\n   * @param options - The options of the NineSliceGeometry.\n   */ update(options) {\n        this.width = options.width ?? this.width;\n        this.height = options.height ?? this.height;\n        this._originalWidth = options.originalWidth ?? this._originalWidth;\n        this._originalHeight = options.originalHeight ?? this._originalHeight;\n        this._leftWidth = options.leftWidth ?? this._leftWidth;\n        this._rightWidth = options.rightWidth ?? this._rightWidth;\n        this._topHeight = options.topHeight ?? this._topHeight;\n        this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n        this.updateUvs();\n        this.updatePositions();\n    }\n    /** Updates the positions of the vertices. */ updatePositions() {\n        const positions = this.positions;\n        const w = this._leftWidth + this._rightWidth;\n        const scaleW = this.width > w ? 1 : this.width / w;\n        const h = this._topHeight + this._bottomHeight;\n        const scaleH = this.height > h ? 1 : this.height / h;\n        const scale = Math.min(scaleW, scaleH);\n        positions[9] = positions[11] = positions[13] = positions[15] = this._topHeight * scale;\n        positions[17] = positions[19] = positions[21] = positions[23] = this.height - this._bottomHeight * scale;\n        positions[25] = positions[27] = positions[29] = positions[31] = this.height;\n        positions[2] = positions[10] = positions[18] = positions[26] = this._leftWidth * scale;\n        positions[4] = positions[12] = positions[20] = positions[28] = this.width - this._rightWidth * scale;\n        positions[6] = positions[14] = positions[22] = positions[30] = this.width;\n        this.getBuffer(\"aPosition\").update();\n    }\n    /** Updates the UVs of the vertices. */ updateUvs() {\n        const uvs = this.uvs;\n        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n        const _uvw = 1 / this._originalWidth;\n        const _uvh = 1 / this._originalHeight;\n        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;\n        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;\n        this.getBuffer(\"aUV\").update();\n    }\n};\n/** The default options for the NineSliceGeometry. */ $8d665aef35d21487$var$_NineSliceGeometry.defaultOptions = {\n    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */ width: 100,\n    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */ height: 100,\n    /** The width of the left column. */ leftWidth: 10,\n    /** The height of the top row. */ topHeight: 10,\n    /** The width of the right column. */ rightWidth: 10,\n    /** The height of the bottom row. */ bottomHeight: 10,\n    /** The original width of the texture */ originalWidth: 100,\n    /** The original height of the texture */ originalHeight: 100\n};\nlet $8d665aef35d21487$export$a1f405faf7381142 = $8d665aef35d21487$var$_NineSliceGeometry;\n\n});\nparcelRegister(\"ifiML\", function(module, exports) {\n\n$parcel$export(module.exports, \"PlaneGeometry\", () => $fde9f2079ac32f4e$export$967d831af31f69ce);\n\nvar $eX50w = parcelRequire(\"eX50w\");\n\nvar $egBuP = parcelRequire(\"egBuP\");\n\"use strict\";\nconst $fde9f2079ac32f4e$var$_PlaneGeometry = class _PlaneGeometry extends (0, $egBuP.MeshGeometry) {\n    constructor(...args){\n        super({});\n        let options = args[0] ?? {};\n        if (typeof options === \"number\") {\n            (0, $eX50w.deprecation)((0, $eX50w.v8_0_0), \"PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead\");\n            options = {\n                width: options,\n                height: args[1],\n                verticesX: args[2],\n                verticesY: args[3]\n            };\n        }\n        this.build(options);\n    }\n    /**\n   * Refreshes plane coordinates\n   * @param options - Options to be applied to plane geometry\n   */ build(options) {\n        options = {\n            ..._PlaneGeometry.defaultOptions,\n            ...options\n        };\n        this.verticesX = this.verticesX ?? options.verticesX;\n        this.verticesY = this.verticesY ?? options.verticesY;\n        this.width = this.width ?? options.width;\n        this.height = this.height ?? options.height;\n        const total = this.verticesX * this.verticesY;\n        const verts = [];\n        const uvs = [];\n        const indices = [];\n        const verticesX = this.verticesX - 1;\n        const verticesY = this.verticesY - 1;\n        const sizeX = this.width / verticesX;\n        const sizeY = this.height / verticesY;\n        for(let i = 0; i < total; i++){\n            const x = i % this.verticesX;\n            const y = i / this.verticesX | 0;\n            verts.push(x * sizeX, y * sizeY);\n            uvs.push(x / verticesX, y / verticesY);\n        }\n        const totalSub = verticesX * verticesY;\n        for(let i = 0; i < totalSub; i++){\n            const xpos = i % verticesX;\n            const ypos = i / verticesX | 0;\n            const value = ypos * this.verticesX + xpos;\n            const value2 = ypos * this.verticesX + xpos + 1;\n            const value3 = (ypos + 1) * this.verticesX + xpos;\n            const value4 = (ypos + 1) * this.verticesX + xpos + 1;\n            indices.push(value, value2, value3, value2, value4, value3);\n        }\n        this.buffers[0].data = new Float32Array(verts);\n        this.buffers[1].data = new Float32Array(uvs);\n        this.indexBuffer.data = new Uint32Array(indices);\n        this.buffers[0].update();\n        this.buffers[1].update();\n        this.indexBuffer.update();\n    }\n};\n$fde9f2079ac32f4e$var$_PlaneGeometry.defaultOptions = {\n    width: 100,\n    height: 100,\n    verticesX: 10,\n    verticesY: 10\n};\nlet $fde9f2079ac32f4e$export$967d831af31f69ce = $fde9f2079ac32f4e$var$_PlaneGeometry;\n\n});\n\n\n\n\nparcelRegister(\"bMKF0\", function(module, exports) {\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $j8qo9 = parcelRequire(\"j8qo9\");\n\nvar $aicvc = parcelRequire(\"aicvc\");\n\"use strict\";\n(0, $eVz1R.extensions).add((0, $aicvc.FilterSystem));\n(0, $eVz1R.extensions).add((0, $j8qo9.FilterPipe));\n\n});\nparcelRegister(\"j8qo9\", function(module, exports) {\n\n$parcel$export(module.exports, \"FilterPipe\", () => $5644f4d93a0a9bb1$export$26a654548ff780c7);\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\"use strict\";\nclass $5644f4d93a0a9bb1$export$26a654548ff780c7 {\n    constructor(renderer){\n        this._renderer = renderer;\n    }\n    push(filterEffect, container, instructionSet) {\n        const renderPipes = this._renderer.renderPipes;\n        renderPipes.batch.break(instructionSet);\n        instructionSet.add({\n            renderPipeId: \"filter\",\n            canBundle: false,\n            action: \"pushFilter\",\n            container: container,\n            filterEffect: filterEffect\n        });\n    }\n    pop(_filterEffect, _container, instructionSet) {\n        this._renderer.renderPipes.batch.break(instructionSet);\n        instructionSet.add({\n            renderPipeId: \"filter\",\n            action: \"popFilter\",\n            canBundle: false\n        });\n    }\n    execute(instruction) {\n        if (instruction.action === \"pushFilter\") this._renderer.filter.push(instruction);\n        else if (instruction.action === \"popFilter\") this._renderer.filter.pop();\n    }\n    destroy() {\n        this._renderer = null;\n    }\n}\n$5644f4d93a0a9bb1$export$26a654548ff780c7.extension = {\n    type: [\n        (0, $eVz1R.ExtensionType).WebGLPipes,\n        (0, $eVz1R.ExtensionType).WebGPUPipes,\n        (0, $eVz1R.ExtensionType).CanvasPipes\n    ],\n    name: \"filter\"\n};\n\n});\n\nparcelRegister(\"aicvc\", function(module, exports) {\n\n$parcel$export(module.exports, \"FilterSystem\", () => $f28e0c22fb11341c$export$e94225c0dfac29cf);\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $dNaJE = parcelRequire(\"dNaJE\");\n\nvar $2NXni = parcelRequire(\"2NXni\");\n\nvar $86NKO = parcelRequire(\"86NKO\");\n\nvar $kFbJv = parcelRequire(\"kFbJv\");\n\nvar $lJEsO = parcelRequire(\"lJEsO\");\n\nvar $5h88T = parcelRequire(\"5h88T\");\n\nvar $7U2uj = parcelRequire(\"7U2uj\");\n\nvar $dgEnR = parcelRequire(\"dgEnR\");\n\nvar $ggeMF = parcelRequire(\"ggeMF\");\n\nvar $ljoAU = parcelRequire(\"ljoAU\");\n\nvar $7H3Wm = parcelRequire(\"7H3Wm\");\n\nvar $8CF4q = parcelRequire(\"8CF4q\");\n\"use strict\";\nconst $f28e0c22fb11341c$var$quadGeometry = new (0, $kFbJv.Geometry)({\n    attributes: {\n        aPosition: {\n            buffer: new Float32Array([\n                0,\n                0,\n                1,\n                0,\n                1,\n                1,\n                0,\n                1\n            ]),\n            location: 0,\n            format: \"float32x2\",\n            stride: 8,\n            offset: 0\n        }\n    },\n    indexBuffer: new Uint32Array([\n        0,\n        1,\n        2,\n        0,\n        2,\n        3\n    ])\n});\nclass $f28e0c22fb11341c$export$e94225c0dfac29cf {\n    constructor(renderer){\n        this._filterStackIndex = 0;\n        this._filterStack = [];\n        this._filterGlobalUniforms = new (0, $lJEsO.UniformGroup)({\n            uInputSize: {\n                value: new Float32Array(4),\n                type: \"vec4<f32>\"\n            },\n            uInputPixel: {\n                value: new Float32Array(4),\n                type: \"vec4<f32>\"\n            },\n            uInputClamp: {\n                value: new Float32Array(4),\n                type: \"vec4<f32>\"\n            },\n            uOutputFrame: {\n                value: new Float32Array(4),\n                type: \"vec4<f32>\"\n            },\n            uGlobalFrame: {\n                value: new Float32Array(4),\n                type: \"vec4<f32>\"\n            },\n            uOutputTexture: {\n                value: new Float32Array(4),\n                type: \"vec4<f32>\"\n            }\n        });\n        this._globalFilterBindGroup = new (0, $86NKO.BindGroup)({});\n        this.renderer = renderer;\n    }\n    /**\n   * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n   * @readonly\n   */ get activeBackTexture() {\n        return this._activeFilterData?.backTexture;\n    }\n    push(instruction) {\n        const renderer = this.renderer;\n        const filters = instruction.filterEffect.filters;\n        if (!this._filterStack[this._filterStackIndex]) this._filterStack[this._filterStackIndex] = this._getFilterData();\n        const filterData = this._filterStack[this._filterStackIndex];\n        this._filterStackIndex++;\n        if (filters.length === 0) {\n            filterData.skip = true;\n            return;\n        }\n        const bounds = filterData.bounds;\n        if (instruction.renderables) (0, $7H3Wm.getGlobalRenderableBounds)(instruction.renderables, bounds);\n        else if (instruction.filterEffect.filterArea) {\n            bounds.clear();\n            bounds.addRect(instruction.filterEffect.filterArea);\n            bounds.applyMatrix(instruction.container.worldTransform);\n        } else (0, $ljoAU.getFastGlobalBounds)(instruction.container, bounds);\n        const colorTextureSource = renderer.renderTarget.rootRenderTarget.colorTexture.source;\n        let resolution = colorTextureSource._resolution;\n        let padding = 0;\n        let antialias = colorTextureSource.antialias;\n        let blendRequired = false;\n        let enabled = false;\n        for(let i = 0; i < filters.length; i++){\n            const filter = filters[i];\n            resolution = Math.min(resolution, filter.resolution);\n            padding += filter.padding;\n            if (filter.antialias !== \"inherit\") {\n                if (filter.antialias === \"on\") antialias = true;\n                else antialias = false;\n            }\n            const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n            if (!isCompatible) {\n                enabled = false;\n                break;\n            }\n            if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {\n                (0, $8CF4q.warn)(\"Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.\");\n                enabled = false;\n                break;\n            }\n            enabled = filter.enabled || enabled;\n            blendRequired = blendRequired || filter.blendRequired;\n        }\n        if (!enabled) {\n            filterData.skip = true;\n            return;\n        }\n        const viewPort = renderer.renderTarget.rootViewPort;\n        bounds.scale(resolution).fitBounds(0, viewPort.width, 0, viewPort.height).scale(1 / resolution).pad(padding).ceil();\n        if (!bounds.isPositive) {\n            filterData.skip = true;\n            return;\n        }\n        filterData.skip = false;\n        filterData.bounds = bounds;\n        filterData.blendRequired = blendRequired;\n        filterData.container = instruction.container;\n        filterData.filterEffect = instruction.filterEffect;\n        filterData.previousRenderSurface = renderer.renderTarget.renderSurface;\n        filterData.inputTexture = (0, $7U2uj.TexturePool).getOptimalTexture(bounds.width, bounds.height, resolution, antialias);\n        renderer.renderTarget.bind(filterData.inputTexture, true);\n        renderer.globalUniforms.push({\n            offset: bounds\n        });\n    }\n    pop() {\n        const renderer = this.renderer;\n        this._filterStackIndex--;\n        const filterData = this._filterStack[this._filterStackIndex];\n        if (filterData.skip) return;\n        this._activeFilterData = filterData;\n        const inputTexture = filterData.inputTexture;\n        const bounds = filterData.bounds;\n        let backTexture = (0, $5h88T.Texture).EMPTY;\n        renderer.renderTarget.finishRenderPass();\n        if (filterData.blendRequired) {\n            const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;\n            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);\n            backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);\n        }\n        filterData.backTexture = backTexture;\n        const filters = filterData.filterEffect.filters;\n        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n        this._globalFilterBindGroup.setResource(backTexture.source, 3);\n        renderer.globalUniforms.pop();\n        if (filters.length === 1) {\n            filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);\n            (0, $7U2uj.TexturePool).returnTexture(inputTexture);\n        } else {\n            let flip = filterData.inputTexture;\n            let flop = (0, $7U2uj.TexturePool).getOptimalTexture(bounds.width, bounds.height, flip.source._resolution, false);\n            let i = 0;\n            for(i = 0; i < filters.length - 1; ++i){\n                const filter = filters[i];\n                filter.apply(this, flip, flop, true);\n                const t = flip;\n                flip = flop;\n                flop = t;\n            }\n            filters[i].apply(this, flip, filterData.previousRenderSurface, false);\n            (0, $7U2uj.TexturePool).returnTexture(flip);\n            (0, $7U2uj.TexturePool).returnTexture(flop);\n        }\n        if (filterData.blendRequired) (0, $7U2uj.TexturePool).returnTexture(backTexture);\n    }\n    getBackTexture(lastRenderSurface, bounds, previousBounds) {\n        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n        const backTexture = (0, $7U2uj.TexturePool).getOptimalTexture(bounds.width, bounds.height, backgroundResolution, false);\n        let x = bounds.minX;\n        let y = bounds.minY;\n        if (previousBounds) {\n            x -= previousBounds.minX;\n            y -= previousBounds.minY;\n        }\n        x = Math.floor(x * backgroundResolution);\n        y = Math.floor(y * backgroundResolution);\n        const width = Math.ceil(bounds.width * backgroundResolution);\n        const height = Math.ceil(bounds.height * backgroundResolution);\n        this.renderer.renderTarget.copyToTexture(lastRenderSurface, backTexture, {\n            x: x,\n            y: y\n        }, {\n            width: width,\n            height: height\n        }, {\n            x: 0,\n            y: 0\n        });\n        return backTexture;\n    }\n    applyFilter(filter, input, output, clear) {\n        const renderer = this.renderer;\n        const filterData = this._filterStack[this._filterStackIndex];\n        const bounds = filterData.bounds;\n        const offset = (0, $2NXni.Point).shared;\n        const previousRenderSurface = filterData.previousRenderSurface;\n        const isFinalTarget = previousRenderSurface === output;\n        let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n        let currentIndex = this._filterStackIndex - 1;\n        while(currentIndex > 0 && this._filterStack[currentIndex].skip)--currentIndex;\n        if (currentIndex > 0) resolution = this._filterStack[currentIndex].inputTexture.source._resolution;\n        const filterUniforms = this._filterGlobalUniforms;\n        const uniforms = filterUniforms.uniforms;\n        const outputFrame = uniforms.uOutputFrame;\n        const inputSize = uniforms.uInputSize;\n        const inputPixel = uniforms.uInputPixel;\n        const inputClamp = uniforms.uInputClamp;\n        const globalFrame = uniforms.uGlobalFrame;\n        const outputTexture = uniforms.uOutputTexture;\n        if (isFinalTarget) {\n            let lastIndex = this._filterStackIndex;\n            while(lastIndex > 0){\n                lastIndex--;\n                const filterData2 = this._filterStack[this._filterStackIndex - 1];\n                if (!filterData2.skip) {\n                    offset.x = filterData2.bounds.minX;\n                    offset.y = filterData2.bounds.minY;\n                    break;\n                }\n            }\n            outputFrame[0] = bounds.minX - offset.x;\n            outputFrame[1] = bounds.minY - offset.y;\n        } else {\n            outputFrame[0] = 0;\n            outputFrame[1] = 0;\n        }\n        outputFrame[2] = input.frame.width;\n        outputFrame[3] = input.frame.height;\n        inputSize[0] = input.source.width;\n        inputSize[1] = input.source.height;\n        inputSize[2] = 1 / inputSize[0];\n        inputSize[3] = 1 / inputSize[1];\n        inputPixel[0] = input.source.pixelWidth;\n        inputPixel[1] = input.source.pixelHeight;\n        inputPixel[2] = 1 / inputPixel[0];\n        inputPixel[3] = 1 / inputPixel[1];\n        inputClamp[0] = 0.5 * inputPixel[2];\n        inputClamp[1] = 0.5 * inputPixel[3];\n        inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];\n        inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];\n        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n        globalFrame[0] = offset.x * resolution;\n        globalFrame[1] = offset.y * resolution;\n        globalFrame[2] = rootTexture.source.width * resolution;\n        globalFrame[3] = rootTexture.source.height * resolution;\n        const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n        renderer.renderTarget.bind(output, !!clear);\n        if (output instanceof (0, $5h88T.Texture)) {\n            outputTexture[0] = output.frame.width;\n            outputTexture[1] = output.frame.height;\n        } else {\n            outputTexture[0] = renderTarget.width;\n            outputTexture[1] = renderTarget.height;\n        }\n        outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n        filterUniforms.update();\n        if (renderer.renderPipes.uniformBatch) {\n            const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(filterUniforms);\n            this._globalFilterBindGroup.setResource(batchUniforms, 0);\n        } else this._globalFilterBindGroup.setResource(filterUniforms, 0);\n        this._globalFilterBindGroup.setResource(input.source, 1);\n        this._globalFilterBindGroup.setResource(input.source.style, 2);\n        filter.groups[0] = this._globalFilterBindGroup;\n        renderer.encoder.draw({\n            geometry: $f28e0c22fb11341c$var$quadGeometry,\n            shader: filter,\n            state: filter._state,\n            topology: \"triangle-list\"\n        });\n        if (renderer.type === (0, $dgEnR.RendererType).WEBGL) renderer.renderTarget.finishRenderPass();\n    }\n    _getFilterData() {\n        return {\n            skip: false,\n            inputTexture: null,\n            bounds: new (0, $ggeMF.Bounds)(),\n            container: null,\n            filterEffect: null,\n            blendRequired: false,\n            previousRenderSurface: null\n        };\n    }\n    /**\n   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n   *\n   * Use `outputMatrix * vTextureCoord` in the shader.\n   * @param outputMatrix - The matrix to output to.\n   * @param {Sprite} sprite - The sprite to map to.\n   * @returns The mapped matrix.\n   */ calculateSpriteMatrix(outputMatrix, sprite) {\n        const data = this._activeFilterData;\n        const mappedMatrix = outputMatrix.set(data.inputTexture._source.width, 0, 0, data.inputTexture._source.height, data.bounds.minX, data.bounds.minY);\n        const worldTransform = sprite.worldTransform.copyTo((0, $dNaJE.Matrix).shared);\n        worldTransform.invert();\n        mappedMatrix.prepend(worldTransform);\n        mappedMatrix.scale(1 / sprite.texture.frame.width, 1 / sprite.texture.frame.height);\n        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n        return mappedMatrix;\n    }\n}\n/** @ignore */ $f28e0c22fb11341c$export$e94225c0dfac29cf.extension = {\n    type: [\n        (0, $eVz1R.ExtensionType).WebGLSystem,\n        (0, $eVz1R.ExtensionType).WebGPUSystem\n    ],\n    name: \"filter\"\n};\n\n});\nparcelRegister(\"ljoAU\", function(module, exports) {\n\n$parcel$export(module.exports, \"getFastGlobalBounds\", () => $10d95b085aa60563$export$ec3cb2102fa5391a);\n\nvar $dNaJE = parcelRequire(\"dNaJE\");\n\nvar $96ND8 = parcelRequire(\"96ND8\");\n\"use strict\";\nconst $10d95b085aa60563$var$tempMatrix = new (0, $dNaJE.Matrix)();\nfunction $10d95b085aa60563$export$ec3cb2102fa5391a(target, bounds) {\n    bounds.clear();\n    $10d95b085aa60563$export$b7169265e2c9b9ba(target, bounds);\n    if (!bounds.isValid) bounds.set(0, 0, 0, 0);\n    if (!target.isRenderGroupRoot) bounds.applyMatrix(target.renderGroup.worldTransform);\n    else bounds.applyMatrix(target.renderGroup.localTransform);\n    return bounds;\n}\nfunction $10d95b085aa60563$export$b7169265e2c9b9ba(target, bounds) {\n    if (target.localDisplayStatus !== 7 || !target.measurable) return;\n    const manageEffects = !!target.effects.length;\n    let localBounds = bounds;\n    if (target.isRenderGroupRoot || manageEffects) localBounds = (0, $96ND8.boundsPool).get().clear();\n    if (target.boundsArea) bounds.addRect(target.boundsArea, target.worldTransform);\n    else {\n        if (target.renderPipeId) {\n            const viewBounds = target.bounds;\n            localBounds.addFrame(viewBounds.minX, viewBounds.minY, viewBounds.maxX, viewBounds.maxY, target.groupTransform);\n        }\n        const children = target.children;\n        for(let i = 0; i < children.length; i++)$10d95b085aa60563$export$b7169265e2c9b9ba(children[i], localBounds);\n    }\n    if (manageEffects) {\n        let advanced = false;\n        for(let i = 0; i < target.effects.length; i++)if (target.effects[i].addBounds) {\n            if (!advanced) {\n                advanced = true;\n                localBounds.applyMatrix(target.renderGroup.worldTransform);\n            }\n            target.effects[i].addBounds(localBounds, true);\n        }\n        if (advanced) {\n            localBounds.applyMatrix(target.renderGroup.worldTransform.copyTo($10d95b085aa60563$var$tempMatrix).invert());\n            bounds.addBounds(localBounds, target.relativeGroupTransform);\n        }\n        bounds.addBounds(localBounds);\n        (0, $96ND8.boundsPool).return(localBounds);\n    } else if (target.isRenderGroupRoot) {\n        bounds.addBounds(localBounds, target.relativeGroupTransform);\n        (0, $96ND8.boundsPool).return(localBounds);\n    }\n}\n\n});\n\nparcelRegister(\"7H3Wm\", function(module, exports) {\n\n$parcel$export(module.exports, \"getGlobalRenderableBounds\", () => $8f724647b1119eb0$export$11abb8ef28048394);\n\"use strict\";\nfunction $8f724647b1119eb0$export$11abb8ef28048394(renderables, bounds) {\n    bounds.clear();\n    const tempMatrix = bounds.matrix;\n    for(let i = 0; i < renderables.length; i++){\n        const renderable = renderables[i];\n        if (renderable.globalDisplayStatus < 7) continue;\n        bounds.matrix = renderable.worldTransform;\n        renderable.addBounds(bounds);\n    }\n    bounds.matrix = tempMatrix;\n    return bounds;\n}\n\n});\n\n\n\n\n//# sourceMappingURL=browserAll.356f161c.js.map\n","import { extensions } from '../extensions/Extensions.mjs';\nimport { ResizePlugin } from './ResizePlugin.mjs';\nimport { TickerPlugin } from './TickerPlugin.mjs';\n\n\"use strict\";\nextensions.add(ResizePlugin);\nextensions.add(TickerPlugin);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../extensions/Extensions';\nimport { ResizePlugin } from './ResizePlugin';\nimport { TickerPlugin } from './TickerPlugin';\n\nextensions.add(ResizePlugin);\nextensions.add(TickerPlugin);\n","import { ExtensionType } from '../extensions/Extensions.mjs';\n\n\"use strict\";\nclass ResizePlugin {\n  /**\n   * Initialize the plugin with scope of application instance\n   * @static\n   * @private\n   * @param {object} [options] - See application options\n   */\n  static init(options) {\n    Object.defineProperty(\n      this,\n      \"resizeTo\",\n      /**\n       * The HTML element or window to automatically resize the\n       * renderer's view element to match width and height.\n       * @member {Window|HTMLElement}\n       * @name resizeTo\n       * @memberof app.Application#\n       */\n      {\n        set(dom) {\n          globalThis.removeEventListener(\"resize\", this.queueResize);\n          this._resizeTo = dom;\n          if (dom) {\n            globalThis.addEventListener(\"resize\", this.queueResize);\n            this.resize();\n          }\n        },\n        get() {\n          return this._resizeTo;\n        }\n      }\n    );\n    this.queueResize = () => {\n      if (!this._resizeTo) {\n        return;\n      }\n      this._cancelResize();\n      this._resizeId = requestAnimationFrame(() => this.resize());\n    };\n    this._cancelResize = () => {\n      if (this._resizeId) {\n        cancelAnimationFrame(this._resizeId);\n        this._resizeId = null;\n      }\n    };\n    this.resize = () => {\n      if (!this._resizeTo) {\n        return;\n      }\n      this._cancelResize();\n      let width;\n      let height;\n      if (this._resizeTo === globalThis.window) {\n        width = globalThis.innerWidth;\n        height = globalThis.innerHeight;\n      } else {\n        const { clientWidth, clientHeight } = this._resizeTo;\n        width = clientWidth;\n        height = clientHeight;\n      }\n      this.renderer.resize(width, height);\n      this.render();\n    };\n    this._resizeId = null;\n    this._resizeTo = null;\n    this.resizeTo = options.resizeTo || null;\n  }\n  /**\n   * Clean up the ticker, scoped to application\n   * @static\n   * @private\n   */\n  static destroy() {\n    globalThis.removeEventListener(\"resize\", this.queueResize);\n    this._cancelResize();\n    this._cancelResize = null;\n    this.queueResize = null;\n    this.resizeTo = null;\n    this.resize = null;\n  }\n}\n/** @ignore */\nResizePlugin.extension = ExtensionType.Application;\n\nexport { ResizePlugin };\n//# sourceMappingURL=ResizePlugin.mjs.map\n","import { ExtensionType } from '../extensions/Extensions';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\nimport type { Renderer } from '../rendering/renderers/types';\n\ntype ResizeableRenderer = Pick<Renderer, 'resize'>;\n\n/**\n * Application options for the {@link app.ResizePlugin}.\n * @memberof app\n * @property {Window|HTMLElement} [resizeTo=window] - Element to automatically resize the renderer to.\n */\nexport interface ResizePluginOptions\n{\n    /**\n     * Element to automatically resize the renderer to.\n     * @memberof app.ApplicationOptions\n     */\n    resizeTo?: Window | HTMLElement;\n}\n\n/**\n * Middleware for Application's resize functionality.\n *\n * Adds the following methods to {@link app.Application}:\n * * {@link app.Application#resizeTo}\n * * {@link app.Application#resize}\n * * {@link app.Application#queueResize}\n * * {@link app.Application#cancelResize}\n * @example\n * import { extensions, ResizePlugin } from 'pixi.js';\n *\n * extensions.add(ResizePlugin);\n * @memberof app\n */\nexport class ResizePlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n\n    public static resizeTo: Window | HTMLElement;\n    public static resize: () => void;\n    public static renderer: ResizeableRenderer;\n    public static queueResize: () => void;\n    public static render: () => void;\n    private static _resizeId: number;\n    private static _resizeTo: Window | HTMLElement;\n    private static _cancelResize: () => void;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @static\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options: ResizePluginOptions): void\n    {\n        Object.defineProperty(this, 'resizeTo',\n            /**\n             * The HTML element or window to automatically resize the\n             * renderer's view element to match width and height.\n             * @member {Window|HTMLElement}\n             * @name resizeTo\n             * @memberof app.Application#\n             */\n            {\n                set(dom: Window | HTMLElement)\n                {\n                    globalThis.removeEventListener('resize', this.queueResize);\n                    this._resizeTo = dom;\n                    if (dom)\n                    {\n                        globalThis.addEventListener('resize', this.queueResize);\n                        this.resize();\n                    }\n                },\n                get()\n                {\n                    return this._resizeTo;\n                },\n            });\n\n        /**\n         * Resize is throttled, so it's safe to call this multiple times per frame and it'll\n         * only be called once.\n         * @memberof app.Application#\n         * @method queueResize\n         * @private\n         */\n        this.queueResize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            this._cancelResize();\n\n            // // Throttle resize events per raf\n            this._resizeId = requestAnimationFrame(() => this.resize());\n        };\n\n        /**\n         * Cancel the resize queue.\n         * @memberof app.Application#\n         * @method cancelResize\n         * @private\n         */\n        this._cancelResize = (): void =>\n        {\n            if (this._resizeId)\n            {\n                cancelAnimationFrame(this._resizeId);\n                this._resizeId = null;\n            }\n        };\n\n        /**\n         * Execute an immediate resize on the renderer, this is not\n         * throttled and can be expensive to call many times in a row.\n         * Will resize only if `resizeTo` property is set.\n         * @memberof app.Application#\n         * @method resize\n         */\n        this.resize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            // clear queue resize\n            this._cancelResize();\n\n            let width: number;\n            let height: number;\n\n            // Resize to the window\n            if (this._resizeTo === globalThis.window)\n            {\n                width = globalThis.innerWidth;\n                height = globalThis.innerHeight;\n            }\n            // Resize to other HTML entities\n            else\n            {\n                const { clientWidth, clientHeight } = this._resizeTo as HTMLElement;\n\n                width = clientWidth;\n                height = clientHeight;\n            }\n\n            this.renderer.resize(width, height);\n            this.render();\n        };\n\n        // On resize\n        this._resizeId = null;\n        this._resizeTo = null;\n        this.resizeTo = options.resizeTo || null;\n    }\n\n    /**\n     * Clean up the ticker, scoped to application\n     * @static\n     * @private\n     */\n    public static destroy(): void\n    {\n        globalThis.removeEventListener('resize', this.queueResize);\n        this._cancelResize();\n        this._cancelResize = null;\n        this.queueResize = null;\n        this.resizeTo = null;\n        this.resize = null;\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions.mjs';\nimport { UPDATE_PRIORITY } from '../ticker/const.mjs';\nimport { Ticker } from '../ticker/Ticker.mjs';\n\n\"use strict\";\nclass TickerPlugin {\n  /**\n   * Initialize the plugin with scope of application instance\n   * @static\n   * @private\n   * @param {object} [options] - See application options\n   */\n  static init(options) {\n    options = Object.assign({\n      autoStart: true,\n      sharedTicker: false\n    }, options);\n    Object.defineProperty(\n      this,\n      \"ticker\",\n      {\n        set(ticker) {\n          if (this._ticker) {\n            this._ticker.remove(this.render, this);\n          }\n          this._ticker = ticker;\n          if (ticker) {\n            ticker.add(this.render, this, UPDATE_PRIORITY.LOW);\n          }\n        },\n        get() {\n          return this._ticker;\n        }\n      }\n    );\n    this.stop = () => {\n      this._ticker.stop();\n    };\n    this.start = () => {\n      this._ticker.start();\n    };\n    this._ticker = null;\n    this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();\n    if (options.autoStart) {\n      this.start();\n    }\n  }\n  /**\n   * Clean up the ticker, scoped to application.\n   * @static\n   * @private\n   */\n  static destroy() {\n    if (this._ticker) {\n      const oldTicker = this._ticker;\n      this.ticker = null;\n      oldTicker.destroy();\n    }\n  }\n}\n/** @ignore */\nTickerPlugin.extension = ExtensionType.Application;\n\nexport { TickerPlugin };\n//# sourceMappingURL=TickerPlugin.mjs.map\n","import { ExtensionType } from '../extensions/Extensions';\nimport { UPDATE_PRIORITY } from '../ticker/const';\nimport { Ticker } from '../ticker/Ticker';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Application options for the {@link app.TickerPluginOptions}.\n * @memberof app\n * @property {boolean} [autoStart=true] - Automatically starts the rendering after the construction.\n * **Note**: Setting this parameter to `false` does NOT stop the shared ticker even if you set\n * `options.sharedTicker` to `true` in case that it is already started. Stop it by your own.\n * @property {boolean} [sharedTicker=false] - Set`true` to use `Ticker.shared`, `false` to create new ticker.\n * If set to `false`, you cannot register a handler to occur before anything that runs on the shared ticker.\n * The system ticker will always run before both the shared ticker and the app ticker.\n */\nexport interface TickerPluginOptions\n{\n    /**\n     * Automatically starts the rendering after the construction.\n     *  **Note**: Setting this parameter to `false` does NOT stop the shared ticker even if you set\n     *  `options.sharedTicker` to `true` in case that it is already started. Stop it by your own.\n     * @memberof app.ApplicationOptions\n     * @default true\n     */\n    autoStart?: boolean;\n    /**\n     * Set`true` to use `Ticker.shared`, `false` to create new ticker.\n     *  If set to `false`, you cannot register a handler to occur before anything that runs on the shared ticker.\n     *  The system ticker will always run before both the shared ticker and the app ticker.\n     * @memberof app.ApplicationOptions\n     * @default false\n     */\n    sharedTicker?: boolean;\n}\n\n/**\n * Middleware for Application's {@link ticker.Ticker} functionality.\n *\n * Adds the following methods to {@link app.Application}:\n * * {@link app.Application#start}\n * * {@link app.Application#stop}\n * * {@link app.Application#ticker}\n * @example\n * import { extensions, TickerPlugin } from 'pixi.js';\n *\n * extensions.add(TickerPlugin);\n * @memberof app\n */\nexport class TickerPlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n\n    public static start: () => void;\n    public static stop: () => void;\n    private static _ticker: Ticker;\n    public static ticker: Ticker;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @static\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options?: PixiMixins.ApplicationOptions): void\n    {\n        // Set default\n        options = Object.assign({\n            autoStart: true,\n            sharedTicker: false,\n        }, options);\n\n        // Create ticker setter\n        Object.defineProperty(this, 'ticker',\n            {\n                set(ticker)\n                {\n                    if (this._ticker)\n                    {\n                        this._ticker.remove(this.render, this);\n                    }\n                    this._ticker = ticker;\n                    if (ticker)\n                    {\n                        ticker.add(this.render, this, UPDATE_PRIORITY.LOW);\n                    }\n                },\n                get()\n                {\n                    return this._ticker;\n                },\n            });\n\n        /**\n         * Convenience method for stopping the render.\n         * @method\n         * @memberof app.Application\n         * @instance\n         */\n        this.stop = (): void =>\n        {\n            this._ticker.stop();\n        };\n\n        /**\n         * Convenience method for starting the render.\n         * @method\n         * @memberof app.Application\n         * @instance\n         */\n        this.start = (): void =>\n        {\n            this._ticker.start();\n        };\n\n        /**\n         * Internal reference to the ticker.\n         * @type {Ticker}\n         * @name _ticker\n         * @memberof app.Application#\n         * @private\n         */\n        this._ticker = null;\n\n        /**\n         * Ticker for doing render updates.\n         * @type {ticker.Ticker}\n         * @name ticker\n         * @memberof app.Application#\n         * @default Ticker.shared\n         */\n        this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();\n\n        // Start the rendering\n        if (options.autoStart)\n        {\n            this.start();\n        }\n    }\n\n    /**\n     * Clean up the ticker, scoped to application.\n     * @static\n     * @private\n     */\n    public static destroy(): void\n    {\n        if (this._ticker)\n        {\n            const oldTicker = this._ticker;\n\n            this.ticker = null;\n            oldTicker.destroy();\n        }\n    }\n}\n","\"use strict\";\nvar UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"INTERACTION\"] = 50] = \"INTERACTION\";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"HIGH\"] = 25] = \"HIGH\";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"NORMAL\"] = 0] = \"NORMAL\";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"LOW\"] = -25] = \"LOW\";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"UTILITY\"] = -50] = \"UTILITY\";\n  return UPDATE_PRIORITY2;\n})(UPDATE_PRIORITY || {});\n\nexport { UPDATE_PRIORITY };\n//# sourceMappingURL=const.mjs.map\n","/**\n * Represents the update priorities used by internal Pixi classes when registered with\n * the {@link ticker.Ticker} object. Higher priority items are updated first and lower\n * priority items, such as render, should go later.\n * @static\n * @enum {number}\n * @memberof ticker\n */\nexport enum UPDATE_PRIORITY\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    /**\n     * Highest priority used for interaction events in {@link EventSystem}\n     * @default 50\n     */\n    INTERACTION = 50,\n    /**\n     * High priority updating, used by {@link AnimatedSprite}\n     * @default 25\n     */\n    HIGH = 25,\n    /**\n     * Default priority for ticker events, see {@link Ticker#add}.\n     * @default 0\n     */\n    NORMAL = 0,\n    /**\n     * Low priority used for {@link Application} rendering.\n     * @default -25\n     */\n    LOW = -25,\n    /**\n     * Lowest priority used for {@link BasePrepare} utility.\n     * @default -50\n     */\n    UTILITY = -50,\n}\n","import { UPDATE_PRIORITY } from './const.mjs';\nimport { TickerListener } from './TickerListener.mjs';\n\n\"use strict\";\nconst _Ticker = class _Ticker {\n  constructor() {\n    /**\n     * Whether or not this ticker should invoke the method\n     * {@link ticker.Ticker#start|start} automatically when a listener is added.\n     */\n    this.autoStart = false;\n    /**\n     * Scalar time value from last frame to this frame.\n     * This value is capped by setting {@link ticker.Ticker#minFPS|minFPS}\n     * and is scaled with {@link ticker.Ticker#speed|speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     */\n    this.deltaTime = 1;\n    /**\n     * The last time {@link ticker.Ticker#update|update} was invoked.\n     * This value is also reset internally outside of invoking\n     * update, but only when a new animation frame is requested.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 s.\n     */\n    this.lastTime = -1;\n    /**\n     * Factor of current {@link ticker.Ticker#deltaTime|deltaTime}.\n     * @example\n     * // Scales ticker.deltaTime to what would be\n     * // the equivalent of approximately 120 FPS\n     * ticker.speed = 2;\n     */\n    this.speed = 1;\n    /**\n     * Whether or not this ticker has been started.\n     * `true` if {@link ticker.Ticker#start|start} has been called.\n     * `false` if {@link ticker.Ticker#stop|Stop} has been called.\n     * While `false`, this value may change to `true` in the\n     * event of {@link ticker.Ticker#autoStart|autoStart} being `true`\n     * and a listener is added.\n     */\n    this.started = false;\n    /** Internal current frame request ID */\n    this._requestId = null;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the maximum allowed milliseconds between updates.\n     */\n    this._maxElapsedMS = 100;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the minimum allowed milliseconds between updates.\n     */\n    this._minElapsedMS = 0;\n    /** If enabled, deleting is disabled.*/\n    this._protected = false;\n    /** The last time keyframe was executed. Maintains a relatively fixed interval with the previous value. */\n    this._lastFrame = -1;\n    this._head = new TickerListener(null, null, Infinity);\n    this.deltaMS = 1 / _Ticker.targetFPMS;\n    this.elapsedMS = 1 / _Ticker.targetFPMS;\n    this._tick = (time) => {\n      this._requestId = null;\n      if (this.started) {\n        this.update(time);\n        if (this.started && this._requestId === null && this._head.next) {\n          this._requestId = requestAnimationFrame(this._tick);\n        }\n      }\n    };\n  }\n  /**\n   * Conditionally requests a new animation frame.\n   * If a frame has not already been requested, and if the internal\n   * emitter has listeners, a new frame is requested.\n   * @private\n   */\n  _requestIfNeeded() {\n    if (this._requestId === null && this._head.next) {\n      this.lastTime = performance.now();\n      this._lastFrame = this.lastTime;\n      this._requestId = requestAnimationFrame(this._tick);\n    }\n  }\n  /**\n   * Conditionally cancels a pending animation frame.\n   * @private\n   */\n  _cancelIfNeeded() {\n    if (this._requestId !== null) {\n      cancelAnimationFrame(this._requestId);\n      this._requestId = null;\n    }\n  }\n  /**\n   * Conditionally requests a new animation frame.\n   * If the ticker has been started it checks if a frame has not already\n   * been requested, and if the internal emitter has listeners. If these\n   * conditions are met, a new frame is requested. If the ticker has not\n   * been started, but autoStart is `true`, then the ticker starts now,\n   * and continues with the previous conditions to request a new frame.\n   * @private\n   */\n  _startIfPossible() {\n    if (this.started) {\n      this._requestIfNeeded();\n    } else if (this.autoStart) {\n      this.start();\n    }\n  }\n  /**\n   * Register a handler for tick events. Calls continuously unless\n   * it is removed or the ticker is stopped.\n   * @param fn - The listener function to be added for updates\n   * @param context - The listener context\n   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */\n  add(fn, context, priority = UPDATE_PRIORITY.NORMAL) {\n    return this._addListener(new TickerListener(fn, context, priority));\n  }\n  /**\n   * Add a handler for the tick event which is only execute once.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */\n  addOnce(fn, context, priority = UPDATE_PRIORITY.NORMAL) {\n    return this._addListener(new TickerListener(fn, context, priority, true));\n  }\n  /**\n   * Internally adds the event handler so that it can be sorted by priority.\n   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n   * before the rendering.\n   * @private\n   * @param listener - Current listener being added.\n   * @returns This instance of a ticker\n   */\n  _addListener(listener) {\n    let current = this._head.next;\n    let previous = this._head;\n    if (!current) {\n      listener.connect(previous);\n    } else {\n      while (current) {\n        if (listener.priority > current.priority) {\n          listener.connect(previous);\n          break;\n        }\n        previous = current;\n        current = current.next;\n      }\n      if (!listener.previous) {\n        listener.connect(previous);\n      }\n    }\n    this._startIfPossible();\n    return this;\n  }\n  /**\n   * Removes any handlers matching the function and context parameters.\n   * If no handlers are left after removing, then it cancels the animation frame.\n   * @param fn - The listener function to be removed\n   * @param context - The listener context to be removed\n   * @returns This instance of a ticker\n   */\n  remove(fn, context) {\n    let listener = this._head.next;\n    while (listener) {\n      if (listener.match(fn, context)) {\n        listener = listener.destroy();\n      } else {\n        listener = listener.next;\n      }\n    }\n    if (!this._head.next) {\n      this._cancelIfNeeded();\n    }\n    return this;\n  }\n  /**\n   * The number of listeners on this ticker, calculated by walking through linked list\n   * @readonly\n   * @member {number}\n   */\n  get count() {\n    if (!this._head) {\n      return 0;\n    }\n    let count = 0;\n    let current = this._head;\n    while (current = current.next) {\n      count++;\n    }\n    return count;\n  }\n  /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */\n  start() {\n    if (!this.started) {\n      this.started = true;\n      this._requestIfNeeded();\n    }\n  }\n  /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */\n  stop() {\n    if (this.started) {\n      this.started = false;\n      this._cancelIfNeeded();\n    }\n  }\n  /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */\n  destroy() {\n    if (!this._protected) {\n      this.stop();\n      let listener = this._head.next;\n      while (listener) {\n        listener = listener.destroy(true);\n      }\n      this._head.destroy();\n      this._head = null;\n    }\n  }\n  /**\n   * Triggers an update. An update entails setting the\n   * current {@link ticker.Ticker#elapsedMS|elapsedMS},\n   * the current {@link ticker.Ticker#deltaTime|deltaTime},\n   * invoking all listeners with current deltaTime,\n   * and then finally setting {@link ticker.Ticker#lastTime|lastTime}\n   * with the value of currentTime that was provided.\n   * This method will be called automatically by animation\n   * frame callbacks if the ticker instance has been started\n   * and listeners are added.\n   * @param {number} [currentTime=performance.now()] - the current time of execution\n   */\n  update(currentTime = performance.now()) {\n    let elapsedMS;\n    if (currentTime > this.lastTime) {\n      elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n      if (elapsedMS > this._maxElapsedMS) {\n        elapsedMS = this._maxElapsedMS;\n      }\n      elapsedMS *= this.speed;\n      if (this._minElapsedMS) {\n        const delta = currentTime - this._lastFrame | 0;\n        if (delta < this._minElapsedMS) {\n          return;\n        }\n        this._lastFrame = currentTime - delta % this._minElapsedMS;\n      }\n      this.deltaMS = elapsedMS;\n      this.deltaTime = this.deltaMS * _Ticker.targetFPMS;\n      const head = this._head;\n      let listener = head.next;\n      while (listener) {\n        listener = listener.emit(this);\n      }\n      if (!head.next) {\n        this._cancelIfNeeded();\n      }\n    } else {\n      this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n    }\n    this.lastTime = currentTime;\n  }\n  /**\n   * The frames per second at which this ticker is running.\n   * The default is approximately 60 in most modern browsers.\n   * **Note:** This does not factor in the value of\n   * {@link ticker.Ticker#speed|speed}, which is specific\n   * to scaling {@link ticker.Ticker#deltaTime|deltaTime}.\n   * @member {number}\n   * @readonly\n   */\n  get FPS() {\n    return 1e3 / this.elapsedMS;\n  }\n  /**\n   * Manages the maximum amount of milliseconds allowed to\n   * elapse between invoking {@link ticker.Ticker#update|update}.\n   * This value is used to cap {@link ticker.Ticker#deltaTime|deltaTime},\n   * but does not effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n   * When setting this property it is clamped to a value between\n   * `0` and `Ticker.targetFPMS * 1000`.\n   * @member {number}\n   * @default 10\n   */\n  get minFPS() {\n    return 1e3 / this._maxElapsedMS;\n  }\n  set minFPS(fps) {\n    const minFPS = Math.min(this.maxFPS, fps);\n    const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);\n    this._maxElapsedMS = 1 / minFPMS;\n  }\n  /**\n   * Manages the minimum amount of milliseconds required to\n   * elapse between invoking {@link ticker.Ticker#update|update}.\n   * This will effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n   * Otherwise it will be at least `minFPS`\n   * @member {number}\n   * @default 0\n   */\n  get maxFPS() {\n    if (this._minElapsedMS) {\n      return Math.round(1e3 / this._minElapsedMS);\n    }\n    return 0;\n  }\n  set maxFPS(fps) {\n    if (fps === 0) {\n      this._minElapsedMS = 0;\n    } else {\n      const maxFPS = Math.max(this.minFPS, fps);\n      this._minElapsedMS = 1 / (maxFPS / 1e3);\n    }\n  }\n  /**\n   * The shared ticker instance used by {@link AnimatedSprite} and by\n   * {@link VideoResource} to update animation frames / video textures.\n   *\n   * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.\n   *\n   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n   * @example\n   * import { Ticker } from 'pixi.js';\n   *\n   * const ticker = Ticker.shared;\n   * // Set this to prevent starting this ticker when listeners are added.\n   * // By default this is true only for the Ticker.shared instance.\n   * ticker.autoStart = false;\n   *\n   * // FYI, call this to ensure the ticker is stopped. It should be stopped\n   * // if you have not attempted to render anything yet.\n   * ticker.stop();\n   *\n   * // Call this when you are ready for a running shared ticker.\n   * ticker.start();\n   * @example\n   * import { autoDetectRenderer, Container } from 'pixi.js';\n   *\n   * // You may use the shared ticker to render...\n   * const renderer = autoDetectRenderer();\n   * const stage = new Container();\n   * document.body.appendChild(renderer.view);\n   * ticker.add((time) => renderer.render(stage));\n   *\n   * // Or you can just update it manually.\n   * ticker.autoStart = false;\n   * ticker.stop();\n   * const animate = (time) => {\n   *     ticker.update(time);\n   *     renderer.render(stage);\n   *     requestAnimationFrame(animate);\n   * };\n   * animate(performance.now());\n   * @member {ticker.Ticker}\n   * @readonly\n   * @static\n   */\n  static get shared() {\n    if (!_Ticker._shared) {\n      const shared = _Ticker._shared = new _Ticker();\n      shared.autoStart = true;\n      shared._protected = true;\n    }\n    return _Ticker._shared;\n  }\n  /**\n   * The system ticker instance used by {@link BasePrepare} for core timing\n   * functionality that shouldn't usually need to be paused, unlike the `shared`\n   * ticker which drives visual animations and rendering which may want to be paused.\n   *\n   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n   * @member {ticker.Ticker}\n   * @readonly\n   * @static\n   */\n  static get system() {\n    if (!_Ticker._system) {\n      const system = _Ticker._system = new _Ticker();\n      system.autoStart = true;\n      system._protected = true;\n    }\n    return _Ticker._system;\n  }\n};\n/**\n * Target frames per millisecond.\n * @static\n */\n_Ticker.targetFPMS = 0.06;\nlet Ticker = _Ticker;\n\nexport { Ticker };\n//# sourceMappingURL=Ticker.mjs.map\n","import { UPDATE_PRIORITY } from './const';\nimport { TickerListener } from './TickerListener';\n\n/**\n * A callback which can be added to a ticker.\n * ```js\n * ticker.add(() => {\n *    // do something every frame\n * });\n * ```\n * @memberof ticker\n */\nexport type TickerCallback<T> = (this: T, ticker: Ticker) => any;\n\n/**\n * {@link ticker.Ticker|Tickers} provide periodic callbacks based on the system clock.\n * Your game update logic will generally be run in response to a tick once per frame.\n * You can have multiple tickers in use at one time.\n * ```js\n * import { Ticker } from 'pixi.js';\n *\n * const callback = (ticker: Ticker) => {\n *    // do something on the next animation frame\n * };\n *\n * // create a ticker\n * const ticker = new Ticker();\n *\n * // register the callback and start the ticker\n * ticker.add(callback);\n * ticker.start();\n * ```\n *\n * You can always use the {@link ticker.Ticker.shared|shared} ticker that Pixi renders with by default.\n * ```js\n * Ticker.shared.add(callback);\n * ```\n * @namespace ticker\n */\n\n/**\n * A Ticker class that runs an update loop that other objects listen to.\n *\n * This class is composed around listeners meant for execution on the next requested animation frame.\n * Animation frames are requested only when necessary, e.g. When the ticker is started and the emitter has listeners.\n * @class\n * @memberof ticker\n */\nexport class Ticker\n{\n    /**\n     * Target frames per millisecond.\n     * @static\n     */\n    public static targetFPMS = 0.06;\n\n    /** The private shared ticker instance */\n    private static _shared: Ticker;\n    /** The private system ticker instance  */\n    private static _system: Ticker;\n\n    /**\n     * Whether or not this ticker should invoke the method\n     * {@link ticker.Ticker#start|start} automatically when a listener is added.\n     */\n    public autoStart = false;\n    /**\n     * Scalar time value from last frame to this frame.\n     * This value is capped by setting {@link ticker.Ticker#minFPS|minFPS}\n     * and is scaled with {@link ticker.Ticker#speed|speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     */\n    public deltaTime = 1;\n    /**\n     * Scaler time elapsed in milliseconds from last frame to this frame.\n     * This value is capped by setting {@link ticker.Ticker#minFPS|minFPS}\n     * and is scaled with {@link ticker.Ticker#speed|speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 s.\n     * Defaults to target frame time\n     * @default 16.66\n     */\n    public deltaMS: number;\n    /**\n     * Time elapsed in milliseconds from last frame to this frame.\n     * Opposed to what the scalar {@link ticker.Ticker#deltaTime|deltaTime}\n     * is based, this value is neither capped nor scaled.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 s.\n     * Defaults to target frame time\n     * @default 16.66\n     */\n    public elapsedMS: number;\n    /**\n     * The last time {@link ticker.Ticker#update|update} was invoked.\n     * This value is also reset internally outside of invoking\n     * update, but only when a new animation frame is requested.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 s.\n     */\n    public lastTime = -1;\n    /**\n     * Factor of current {@link ticker.Ticker#deltaTime|deltaTime}.\n     * @example\n     * // Scales ticker.deltaTime to what would be\n     * // the equivalent of approximately 120 FPS\n     * ticker.speed = 2;\n     */\n    public speed = 1;\n    /**\n     * Whether or not this ticker has been started.\n     * `true` if {@link ticker.Ticker#start|start} has been called.\n     * `false` if {@link ticker.Ticker#stop|Stop} has been called.\n     * While `false`, this value may change to `true` in the\n     * event of {@link ticker.Ticker#autoStart|autoStart} being `true`\n     * and a listener is added.\n     */\n    public started = false;\n\n    /** The first listener. All new listeners added are chained on this. */\n    private _head: TickerListener;\n    /** Internal current frame request ID */\n    private _requestId: number = null;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the maximum allowed milliseconds between updates.\n     */\n    private _maxElapsedMS = 100;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the minimum allowed milliseconds between updates.\n     */\n    private _minElapsedMS = 0;\n    /** If enabled, deleting is disabled.*/\n    private _protected = false;\n    /** The last time keyframe was executed. Maintains a relatively fixed interval with the previous value. */\n    private _lastFrame = -1;\n    /**\n     * Internal tick method bound to ticker instance.\n     * This is because in early 2015, Function.bind\n     * is still 60% slower in high performance scenarios.\n     * Also separating frame requests from update method\n     * so listeners may be called at any time and with\n     * any animation API, just invoke ticker.update(time).\n     * @param time - Time since last tick.\n     */\n    private readonly _tick: (time: number) => any;\n\n    constructor()\n    {\n        this._head = new TickerListener(null, null, Infinity);\n        this.deltaMS = 1 / Ticker.targetFPMS;\n        this.elapsedMS = 1 / Ticker.targetFPMS;\n\n        this._tick = (time: number): void =>\n        {\n            this._requestId = null;\n\n            if (this.started)\n            {\n                // Invoke listeners now\n                this.update(time);\n                // Listener side effects may have modified ticker state.\n                if (this.started && this._requestId === null && this._head.next)\n                {\n                    this._requestId = requestAnimationFrame(this._tick);\n                }\n            }\n        };\n    }\n\n    /**\n     * Conditionally requests a new animation frame.\n     * If a frame has not already been requested, and if the internal\n     * emitter has listeners, a new frame is requested.\n     * @private\n     */\n    private _requestIfNeeded(): void\n    {\n        if (this._requestId === null && this._head.next)\n        {\n            // ensure callbacks get correct delta\n            this.lastTime = performance.now();\n            this._lastFrame = this.lastTime;\n            this._requestId = requestAnimationFrame(this._tick);\n        }\n    }\n\n    /**\n     * Conditionally cancels a pending animation frame.\n     * @private\n     */\n    private _cancelIfNeeded(): void\n    {\n        if (this._requestId !== null)\n        {\n            cancelAnimationFrame(this._requestId);\n            this._requestId = null;\n        }\n    }\n\n    /**\n     * Conditionally requests a new animation frame.\n     * If the ticker has been started it checks if a frame has not already\n     * been requested, and if the internal emitter has listeners. If these\n     * conditions are met, a new frame is requested. If the ticker has not\n     * been started, but autoStart is `true`, then the ticker starts now,\n     * and continues with the previous conditions to request a new frame.\n     * @private\n     */\n    private _startIfPossible(): void\n    {\n        if (this.started)\n        {\n            this._requestIfNeeded();\n        }\n        else if (this.autoStart)\n        {\n            this.start();\n        }\n    }\n\n    /**\n     * Register a handler for tick events. Calls continuously unless\n     * it is removed or the ticker is stopped.\n     * @param fn - The listener function to be added for updates\n     * @param context - The listener context\n     * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n     * @returns This instance of a ticker\n     */\n    public add<T = any>(fn: TickerCallback<T>, context?: T, priority: number = UPDATE_PRIORITY.NORMAL): this\n    {\n        return this._addListener(new TickerListener(fn, context, priority));\n    }\n\n    /**\n     * Add a handler for the tick event which is only execute once.\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n     * @returns This instance of a ticker\n     */\n    public addOnce<T = any>(fn: TickerCallback<T>, context?: T, priority: number = UPDATE_PRIORITY.NORMAL): this\n    {\n        return this._addListener(new TickerListener(fn, context, priority, true));\n    }\n\n    /**\n     * Internally adds the event handler so that it can be sorted by priority.\n     * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n     * before the rendering.\n     * @private\n     * @param listener - Current listener being added.\n     * @returns This instance of a ticker\n     */\n    private _addListener(listener: TickerListener): this\n    {\n        // For attaching to head\n        let current = this._head.next;\n        let previous = this._head;\n\n        // Add the first item\n        if (!current)\n        {\n            listener.connect(previous);\n        }\n        else\n        {\n            // Go from highest to lowest priority\n            while (current)\n            {\n                if (listener.priority > current.priority)\n                {\n                    listener.connect(previous);\n                    break;\n                }\n                previous = current;\n                current = current.next;\n            }\n\n            // Not yet connected\n            if (!listener.previous)\n            {\n                listener.connect(previous);\n            }\n        }\n\n        this._startIfPossible();\n\n        return this;\n    }\n\n    /**\n     * Removes any handlers matching the function and context parameters.\n     * If no handlers are left after removing, then it cancels the animation frame.\n     * @param fn - The listener function to be removed\n     * @param context - The listener context to be removed\n     * @returns This instance of a ticker\n     */\n    public remove<T = any>(fn: TickerCallback<T>, context?: T): this\n    {\n        let listener = this._head.next;\n\n        while (listener)\n        {\n            // We found a match, lets remove it\n            // no break to delete all possible matches\n            // incase a listener was added 2+ times\n            if (listener.match(fn, context))\n            {\n                listener = listener.destroy();\n            }\n            else\n            {\n                listener = listener.next;\n            }\n        }\n\n        if (!this._head.next)\n        {\n            this._cancelIfNeeded();\n        }\n\n        return this;\n    }\n\n    /**\n     * The number of listeners on this ticker, calculated by walking through linked list\n     * @readonly\n     * @member {number}\n     */\n    get count(): number\n    {\n        if (!this._head)\n        {\n            return 0;\n        }\n\n        let count = 0;\n        let current = this._head;\n\n        while ((current = current.next))\n        {\n            count++;\n        }\n\n        return count;\n    }\n\n    /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */\n    public start(): void\n    {\n        if (!this.started)\n        {\n            this.started = true;\n            this._requestIfNeeded();\n        }\n    }\n\n    /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */\n    public stop(): void\n    {\n        if (this.started)\n        {\n            this.started = false;\n            this._cancelIfNeeded();\n        }\n    }\n\n    /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */\n    public destroy(): void\n    {\n        if (!this._protected)\n        {\n            this.stop();\n\n            let listener = this._head.next;\n\n            while (listener)\n            {\n                listener = listener.destroy(true);\n            }\n\n            this._head.destroy();\n            this._head = null;\n        }\n    }\n\n    /**\n     * Triggers an update. An update entails setting the\n     * current {@link ticker.Ticker#elapsedMS|elapsedMS},\n     * the current {@link ticker.Ticker#deltaTime|deltaTime},\n     * invoking all listeners with current deltaTime,\n     * and then finally setting {@link ticker.Ticker#lastTime|lastTime}\n     * with the value of currentTime that was provided.\n     * This method will be called automatically by animation\n     * frame callbacks if the ticker instance has been started\n     * and listeners are added.\n     * @param {number} [currentTime=performance.now()] - the current time of execution\n     */\n    public update(currentTime: number = performance.now()): void\n    {\n        let elapsedMS;\n\n        // If the difference in time is zero or negative, we ignore most of the work done here.\n        // If there is no valid difference, then should be no reason to let anyone know about it.\n        // A zero delta, is exactly that, nothing should update.\n        //\n        // The difference in time can be negative, and no this does not mean time traveling.\n        // This can be the result of a race condition between when an animation frame is requested\n        // on the current JavaScript engine event loop, and when the ticker's start method is invoked\n        // (which invokes the internal _requestIfNeeded method). If a frame is requested before\n        // _requestIfNeeded is invoked, then the callback for the animation frame the ticker requests,\n        // can receive a time argument that can be less than the lastTime value that was set within\n        // _requestIfNeeded. This difference is in microseconds, but this is enough to cause problems.\n        //\n        // This check covers this browser engine timing issue, as well as if consumers pass an invalid\n        // currentTime value. This may happen if consumers opt-out of the autoStart, and update themselves.\n\n        if (currentTime > this.lastTime)\n        {\n            // Save uncapped elapsedMS for measurement\n            elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n\n            // cap the milliseconds elapsed used for deltaTime\n            if (elapsedMS > this._maxElapsedMS)\n            {\n                elapsedMS = this._maxElapsedMS;\n            }\n\n            elapsedMS *= this.speed;\n\n            // If not enough time has passed, exit the function.\n            // Get ready for next frame by setting _lastFrame, but based on _minElapsedMS\n            // adjustment to ensure a relatively stable interval.\n            if (this._minElapsedMS)\n            {\n                const delta = currentTime - this._lastFrame | 0;\n\n                if (delta < this._minElapsedMS)\n                {\n                    return;\n                }\n\n                this._lastFrame = currentTime - (delta % this._minElapsedMS);\n            }\n\n            this.deltaMS = elapsedMS;\n            this.deltaTime = this.deltaMS * Ticker.targetFPMS;\n\n            // Cache a local reference, in-case ticker is destroyed\n            // during the emit, we can still check for head.next\n            const head = this._head;\n\n            // Invoke listeners added to internal emitter\n            let listener = head.next;\n\n            while (listener)\n            {\n                listener = listener.emit(this);\n            }\n\n            if (!head.next)\n            {\n                this._cancelIfNeeded();\n            }\n        }\n        else\n        {\n            this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n        }\n\n        this.lastTime = currentTime;\n    }\n\n    /**\n     * The frames per second at which this ticker is running.\n     * The default is approximately 60 in most modern browsers.\n     * **Note:** This does not factor in the value of\n     * {@link ticker.Ticker#speed|speed}, which is specific\n     * to scaling {@link ticker.Ticker#deltaTime|deltaTime}.\n     * @member {number}\n     * @readonly\n     */\n    get FPS(): number\n    {\n        return 1000 / this.elapsedMS;\n    }\n\n    /**\n     * Manages the maximum amount of milliseconds allowed to\n     * elapse between invoking {@link ticker.Ticker#update|update}.\n     * This value is used to cap {@link ticker.Ticker#deltaTime|deltaTime},\n     * but does not effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n     * When setting this property it is clamped to a value between\n     * `0` and `Ticker.targetFPMS * 1000`.\n     * @member {number}\n     * @default 10\n     */\n    get minFPS(): number\n    {\n        return 1000 / this._maxElapsedMS;\n    }\n\n    set minFPS(fps: number)\n    {\n        // Minimum must be below the maxFPS\n        const minFPS = Math.min(this.maxFPS, fps);\n\n        // Must be at least 0, but below 1 / Ticker.targetFPMS\n        const minFPMS = Math.min(Math.max(0, minFPS) / 1000, Ticker.targetFPMS);\n\n        this._maxElapsedMS = 1 / minFPMS;\n    }\n\n    /**\n     * Manages the minimum amount of milliseconds required to\n     * elapse between invoking {@link ticker.Ticker#update|update}.\n     * This will effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n     * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n     * Otherwise it will be at least `minFPS`\n     * @member {number}\n     * @default 0\n     */\n    get maxFPS(): number\n    {\n        if (this._minElapsedMS)\n        {\n            return Math.round(1000 / this._minElapsedMS);\n        }\n\n        return 0;\n    }\n\n    set maxFPS(fps: number)\n    {\n        if (fps === 0)\n        {\n            this._minElapsedMS = 0;\n        }\n        else\n        {\n            // Max must be at least the minFPS\n            const maxFPS = Math.max(this.minFPS, fps);\n\n            this._minElapsedMS = 1 / (maxFPS / 1000);\n        }\n    }\n\n    /**\n     * The shared ticker instance used by {@link AnimatedSprite} and by\n     * {@link VideoResource} to update animation frames / video textures.\n     *\n     * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.\n     *\n     * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n     * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n     * @example\n     * import { Ticker } from 'pixi.js';\n     *\n     * const ticker = Ticker.shared;\n     * // Set this to prevent starting this ticker when listeners are added.\n     * // By default this is true only for the Ticker.shared instance.\n     * ticker.autoStart = false;\n     *\n     * // FYI, call this to ensure the ticker is stopped. It should be stopped\n     * // if you have not attempted to render anything yet.\n     * ticker.stop();\n     *\n     * // Call this when you are ready for a running shared ticker.\n     * ticker.start();\n     * @example\n     * import { autoDetectRenderer, Container } from 'pixi.js';\n     *\n     * // You may use the shared ticker to render...\n     * const renderer = autoDetectRenderer();\n     * const stage = new Container();\n     * document.body.appendChild(renderer.view);\n     * ticker.add((time) => renderer.render(stage));\n     *\n     * // Or you can just update it manually.\n     * ticker.autoStart = false;\n     * ticker.stop();\n     * const animate = (time) => {\n     *     ticker.update(time);\n     *     renderer.render(stage);\n     *     requestAnimationFrame(animate);\n     * };\n     * animate(performance.now());\n     * @member {ticker.Ticker}\n     * @readonly\n     * @static\n     */\n    static get shared(): Ticker\n    {\n        if (!Ticker._shared)\n        {\n            const shared = Ticker._shared = new Ticker();\n\n            shared.autoStart = true;\n            shared._protected = true;\n        }\n\n        return Ticker._shared;\n    }\n\n    /**\n     * The system ticker instance used by {@link BasePrepare} for core timing\n     * functionality that shouldn't usually need to be paused, unlike the `shared`\n     * ticker which drives visual animations and rendering which may want to be paused.\n     *\n     * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n     * @member {ticker.Ticker}\n     * @readonly\n     * @static\n     */\n    static get system(): Ticker\n    {\n        if (!Ticker._system)\n        {\n            const system = Ticker._system = new Ticker();\n\n            system.autoStart = true;\n            system._protected = true;\n        }\n\n        return Ticker._system;\n    }\n}\n","\"use strict\";\nclass TickerListener {\n  /**\n   * Constructor\n   * @private\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param priority - The priority for emitting\n   * @param once - If the handler should fire once\n   */\n  constructor(fn, context = null, priority = 0, once = false) {\n    /** The next item in chain. */\n    this.next = null;\n    /** The previous item in chain. */\n    this.previous = null;\n    /** `true` if this listener has been destroyed already. */\n    this._destroyed = false;\n    this._fn = fn;\n    this._context = context;\n    this.priority = priority;\n    this._once = once;\n  }\n  /**\n   * Simple compare function to figure out if a function and context match.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @returns `true` if the listener match the arguments\n   */\n  match(fn, context = null) {\n    return this._fn === fn && this._context === context;\n  }\n  /**\n   * Emit by calling the current function.\n   * @param ticker - The ticker emitting.\n   * @returns Next ticker\n   */\n  emit(ticker) {\n    if (this._fn) {\n      if (this._context) {\n        this._fn.call(this._context, ticker);\n      } else {\n        this._fn(ticker);\n      }\n    }\n    const redirect = this.next;\n    if (this._once) {\n      this.destroy(true);\n    }\n    if (this._destroyed) {\n      this.next = null;\n    }\n    return redirect;\n  }\n  /**\n   * Connect to the list.\n   * @param previous - Input node, previous listener\n   */\n  connect(previous) {\n    this.previous = previous;\n    if (previous.next) {\n      previous.next.previous = this;\n    }\n    this.next = previous.next;\n    previous.next = this;\n  }\n  /**\n   * Destroy and don't use after this.\n   * @param hard - `true` to remove the `next` reference, this\n   *        is considered a hard destroy. Soft destroy maintains the next reference.\n   * @returns The listener to redirect while emitting or removing.\n   */\n  destroy(hard = false) {\n    this._destroyed = true;\n    this._fn = null;\n    this._context = null;\n    if (this.previous) {\n      this.previous.next = this.next;\n    }\n    if (this.next) {\n      this.next.previous = this.previous;\n    }\n    const redirect = this.next;\n    this.next = hard ? null : redirect;\n    this.previous = null;\n    return redirect;\n  }\n}\n\nexport { TickerListener };\n//# sourceMappingURL=TickerListener.mjs.map\n","import type { Ticker, TickerCallback } from './Ticker';\n\n/**\n * Internal class for handling the priority sorting of ticker handlers.\n * @private\n * @class\n */\nexport class TickerListener<T = any>\n{\n    /** The current priority. */\n    public priority: number;\n    /** The next item in chain. */\n    public next: TickerListener = null;\n    /** The previous item in chain. */\n    public previous: TickerListener = null;\n\n    /** The handler function to execute. */\n    private _fn: TickerCallback<T>;\n    /** The calling to execute. */\n    private _context: T;\n    /** If this should only execute once. */\n    private readonly _once: boolean;\n    /** `true` if this listener has been destroyed already. */\n    private _destroyed = false;\n\n    /**\n     * Constructor\n     * @private\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @param priority - The priority for emitting\n     * @param once - If the handler should fire once\n     */\n    constructor(fn: TickerCallback<T>, context: T = null, priority = 0, once = false)\n    {\n        this._fn = fn;\n        this._context = context;\n        this.priority = priority;\n        this._once = once;\n    }\n\n    /**\n     * Simple compare function to figure out if a function and context match.\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @returns `true` if the listener match the arguments\n     */\n    public match(fn: TickerCallback<T>, context: any = null): boolean\n    {\n        return this._fn === fn && this._context === context;\n    }\n\n    /**\n     * Emit by calling the current function.\n     * @param ticker - The ticker emitting.\n     * @returns Next ticker\n     */\n    public emit(ticker: Ticker): TickerListener\n    {\n        if (this._fn)\n        {\n            if (this._context)\n            {\n                this._fn.call(this._context, ticker);\n            }\n            else\n            {\n                (this as TickerListener<any>)._fn(ticker);\n            }\n        }\n\n        const redirect = this.next;\n\n        if (this._once)\n        {\n            this.destroy(true);\n        }\n\n        // Soft-destroying should remove\n        // the next reference\n        if (this._destroyed)\n        {\n            this.next = null;\n        }\n\n        return redirect;\n    }\n\n    /**\n     * Connect to the list.\n     * @param previous - Input node, previous listener\n     */\n    public connect(previous: TickerListener): void\n    {\n        this.previous = previous;\n        if (previous.next)\n        {\n            previous.next.previous = this;\n        }\n        this.next = previous.next;\n        previous.next = this;\n    }\n\n    /**\n     * Destroy and don't use after this.\n     * @param hard - `true` to remove the `next` reference, this\n     *        is considered a hard destroy. Soft destroy maintains the next reference.\n     * @returns The listener to redirect while emitting or removing.\n     */\n    public destroy(hard = false): TickerListener\n    {\n        this._destroyed = true;\n        this._fn = null;\n        this._context = null;\n\n        // Disconnect, hook up next and previous\n        if (this.previous)\n        {\n            this.previous.next = this.next;\n        }\n\n        if (this.next)\n        {\n            this.next.previous = this.previous;\n        }\n\n        // Redirect to the next item\n        const redirect = this.next;\n\n        // Remove references\n        this.next = hard ? null : redirect;\n        this.previous = null;\n\n        return redirect;\n    }\n}\n","import { extensions } from '../extensions/Extensions.mjs';\nimport { spritesheetAsset } from './spritesheetAsset.mjs';\n\n\"use strict\";\nextensions.add(spritesheetAsset);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../extensions/Extensions';\nimport { spritesheetAsset } from './spritesheetAsset';\n\nextensions.add(spritesheetAsset);\n","import { LoaderParserPriority } from '../assets/loader/parsers/LoaderParser.mjs';\nimport { Resolver } from '../assets/resolver/Resolver.mjs';\nimport { copySearchParams } from '../assets/utils/copySearchParams.mjs';\nimport { ExtensionType } from '../extensions/Extensions.mjs';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture.mjs';\nimport { path } from '../utils/path.mjs';\nimport { Spritesheet } from './Spritesheet.mjs';\n\n\"use strict\";\nconst validImages = [\n  \"jpg\",\n  \"png\",\n  \"jpeg\",\n  \"avif\",\n  \"webp\",\n  \"basis\",\n  \"etc2\",\n  \"bc7\",\n  \"bc6h\",\n  \"bc5\",\n  \"bc4\",\n  \"bc3\",\n  \"bc2\",\n  \"bc1\",\n  \"eac\",\n  \"astc\"\n];\nfunction getCacheableAssets(keys, asset, ignoreMultiPack) {\n  const out = {};\n  keys.forEach((key) => {\n    out[key] = asset;\n  });\n  Object.keys(asset.textures).forEach((key) => {\n    out[key] = asset.textures[key];\n  });\n  if (!ignoreMultiPack) {\n    const basePath = path.dirname(keys[0]);\n    asset.linkedSheets.forEach((item, i) => {\n      const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, true);\n      Object.assign(out, out2);\n    });\n  }\n  return out;\n}\nconst spritesheetAsset = {\n  extension: ExtensionType.Asset,\n  /** Handle the caching of the related Spritesheet Textures */\n  cache: {\n    test: (asset) => asset instanceof Spritesheet,\n    getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)\n  },\n  /** Resolve the resolution of the asset. */\n  resolver: {\n    test: (value) => {\n      const tempURL = value.split(\"?\")[0];\n      const split = tempURL.split(\".\");\n      const extension = split.pop();\n      const format = split.pop();\n      return extension === \"json\" && validImages.includes(format);\n    },\n    parse: (value) => {\n      const split = value.split(\".\");\n      return {\n        resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? \"1\"),\n        format: split[split.length - 2],\n        src: value\n      };\n    }\n  },\n  /**\n   * Loader plugin that parses sprite sheets!\n   * once the JSON has been loaded this checks to see if the JSON is spritesheet data.\n   * If it is, we load the spritesheets image and parse the data into Spritesheet\n   * All textures in the sprite sheet are then added to the cache\n   */\n  loader: {\n    name: \"spritesheetLoader\",\n    extension: {\n      type: ExtensionType.LoadParser,\n      priority: LoaderParserPriority.Normal\n    },\n    async testParse(asset, options) {\n      return path.extname(options.src).toLowerCase() === \".json\" && !!asset.frames;\n    },\n    async parse(asset, options, loader) {\n      const {\n        texture: imageTexture,\n        // if user need to use preloaded texture\n        imageFilename\n        // if user need to use custom filename (not from jsonFile.meta.image)\n      } = options?.data ?? {};\n      let basePath = path.dirname(options.src);\n      if (basePath && basePath.lastIndexOf(\"/\") !== basePath.length - 1) {\n        basePath += \"/\";\n      }\n      let texture;\n      if (imageTexture instanceof Texture) {\n        texture = imageTexture;\n      } else {\n        const imagePath = copySearchParams(basePath + (imageFilename ?? asset.meta.image), options.src);\n        const assets = await loader.load([imagePath]);\n        texture = assets[imagePath];\n      }\n      const spritesheet = new Spritesheet(\n        texture.source,\n        asset\n      );\n      await spritesheet.parse();\n      const multiPacks = asset?.meta?.related_multi_packs;\n      if (Array.isArray(multiPacks)) {\n        const promises = [];\n        for (const item of multiPacks) {\n          if (typeof item !== \"string\") {\n            continue;\n          }\n          let itemUrl = basePath + item;\n          if (options.data?.ignoreMultiPack) {\n            continue;\n          }\n          itemUrl = copySearchParams(itemUrl, options.src);\n          promises.push(loader.load({\n            src: itemUrl,\n            data: {\n              ignoreMultiPack: true\n            }\n          }));\n        }\n        const res = await Promise.all(promises);\n        spritesheet.linkedSheets = res;\n        res.forEach((item) => {\n          item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));\n        });\n      }\n      return spritesheet;\n    },\n    async unload(spritesheet, _resolvedAsset, loader) {\n      await loader.unload(spritesheet.textureSource._sourceOrigin);\n      spritesheet.destroy(false);\n    }\n  }\n};\n\nexport { spritesheetAsset };\n//# sourceMappingURL=spritesheetAsset.mjs.map\n","import { LoaderParserPriority } from '../assets/loader/parsers/LoaderParser';\nimport { Resolver } from '../assets/resolver/Resolver';\nimport { copySearchParams } from '../assets/utils/copySearchParams';\nimport { ExtensionType } from '../extensions/Extensions';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { path } from '../utils/path';\nimport { Spritesheet } from './Spritesheet';\n\nimport type { AssetExtension } from '../assets/AssetExtension';\nimport type { Loader } from '../assets/loader/Loader';\nimport type { ResolvedAsset, UnresolvedAsset } from '../assets/types';\nimport type { SpritesheetData } from './Spritesheet';\n\nexport interface SpriteSheetJson extends SpritesheetData\n{\n    meta: {\n        image: string;\n        scale: string;\n        // eslint-disable-next-line camelcase\n        related_multi_packs?: string[];\n    };\n}\n\nconst validImages = ['jpg', 'png', 'jpeg', 'avif', 'webp',\n    'basis', 'etc2', 'bc7', 'bc6h', 'bc5', 'bc4', 'bc3', 'bc2', 'bc1', 'eac', 'astc'];\n\nfunction getCacheableAssets(keys: string[], asset: Spritesheet, ignoreMultiPack: boolean)\n{\n    const out: Record<string, any> = {};\n\n    keys.forEach((key: string) =>\n    {\n        out[key] = asset;\n    });\n\n    Object.keys(asset.textures).forEach((key) =>\n    {\n        out[key] = asset.textures[key];\n    });\n\n    if (!ignoreMultiPack)\n    {\n        const basePath = path.dirname(keys[0]);\n\n        asset.linkedSheets.forEach((item: Spritesheet, i) =>\n        {\n            const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, true);\n\n            Object.assign(out, out2);\n        });\n    }\n\n    return out;\n}\n\n/**\n * Asset extension for loading spritesheets\n * @example\n * import { Assets } from 'pixi.js';\n *\n * Assets.load({\n *     alias: 'spritesheet',\n *     src: 'path/to/spritesheet.json',\n *     data: {\n *         ignoreMultiPack: true,\n *     }\n * })\n * @type {AssetExtension}\n * @memberof assets\n */\nexport const spritesheetAsset = {\n    extension: ExtensionType.Asset,\n    /** Handle the caching of the related Spritesheet Textures */\n    cache: {\n        test: (asset: Spritesheet) => asset instanceof Spritesheet,\n        getCacheableAssets: (keys: string[], asset: Spritesheet) => getCacheableAssets(keys, asset, false),\n    },\n    /** Resolve the resolution of the asset. */\n    resolver: {\n        test: (value: string): boolean =>\n        {\n            const tempURL = value.split('?')[0];\n            const split = tempURL.split('.');\n            const extension = split.pop();\n            const format = split.pop();\n\n            return extension === 'json' && validImages.includes(format);\n        },\n        parse: (value: string): UnresolvedAsset =>\n        {\n            const split = value.split('.');\n\n            return {\n                resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n                format: split[split.length - 2],\n                src: value,\n            };\n        },\n    },\n    /**\n     * Loader plugin that parses sprite sheets!\n     * once the JSON has been loaded this checks to see if the JSON is spritesheet data.\n     * If it is, we load the spritesheets image and parse the data into Spritesheet\n     * All textures in the sprite sheet are then added to the cache\n     */\n    loader: {\n        name: 'spritesheetLoader',\n\n        extension: {\n            type: ExtensionType.LoadParser,\n            priority: LoaderParserPriority.Normal,\n        },\n\n        async testParse(asset: SpriteSheetJson, options: ResolvedAsset): Promise<boolean>\n        {\n            return (path.extname(options.src).toLowerCase() === '.json' && !!asset.frames);\n        },\n\n        async parse(\n            asset: SpriteSheetJson,\n            options: ResolvedAsset<{texture: Texture, imageFilename: string, ignoreMultiPack: boolean}>,\n            loader: Loader\n        ): Promise<Spritesheet>\n        {\n            const {\n                texture: imageTexture, // if user need to use preloaded texture\n                imageFilename // if user need to use custom filename (not from jsonFile.meta.image)\n            } = options?.data ?? {};\n\n            let basePath = path.dirname(options.src);\n\n            if (basePath && basePath.lastIndexOf('/') !== (basePath.length - 1))\n            {\n                basePath += '/';\n            }\n\n            let texture: Texture;\n\n            if (imageTexture instanceof Texture)\n            {\n                texture = imageTexture;\n            }\n            else\n            {\n                const imagePath = copySearchParams(basePath + (imageFilename ?? asset.meta.image), options.src);\n\n                const assets = await loader.load<Texture>([imagePath]);\n\n                texture = assets[imagePath];\n            }\n\n            const spritesheet = new Spritesheet(\n                texture.source,\n                asset,\n            );\n\n            await spritesheet.parse();\n\n            // Check and add the multi atlas\n            // Heavily influenced and based on https://github.com/rocket-ua/pixi-tps-loader/blob/master/src/ResourceLoader.js\n            // eslint-disable-next-line camelcase\n            const multiPacks = asset?.meta?.related_multi_packs;\n\n            if (Array.isArray(multiPacks))\n            {\n                const promises: Promise<Spritesheet<SpriteSheetJson>>[] = [];\n\n                for (const item of multiPacks)\n                {\n                    if (typeof item !== 'string')\n                    {\n                        continue;\n                    }\n\n                    let itemUrl = basePath + item;\n\n                    // Check if the file wasn't already added as multipack\n                    if (options.data?.ignoreMultiPack)\n                    {\n                        continue;\n                    }\n\n                    itemUrl = copySearchParams(itemUrl, options.src);\n\n                    promises.push(loader.load<Spritesheet<SpriteSheetJson>>({\n                        src: itemUrl,\n                        data: {\n                            ignoreMultiPack: true,\n                        }\n                    }));\n                }\n\n                const res = await Promise.all(promises);\n\n                spritesheet.linkedSheets = res;\n                res.forEach((item) =>\n                {\n                    item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => (sp !== item)));\n                });\n            }\n\n            return spritesheet;\n        },\n\n        async unload(spritesheet: Spritesheet, _resolvedAsset, loader)\n        {\n            await loader.unload(spritesheet.textureSource._sourceOrigin);\n\n            spritesheet.destroy(false);\n        },\n    },\n} as AssetExtension<Spritesheet | SpriteSheetJson>;\n","\"use strict\";\nvar LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {\n  LoaderParserPriority2[LoaderParserPriority2[\"Low\"] = 0] = \"Low\";\n  LoaderParserPriority2[LoaderParserPriority2[\"Normal\"] = 1] = \"Normal\";\n  LoaderParserPriority2[LoaderParserPriority2[\"High\"] = 2] = \"High\";\n  return LoaderParserPriority2;\n})(LoaderParserPriority || {});\n\nexport { LoaderParserPriority };\n//# sourceMappingURL=LoaderParser.mjs.map\n","import type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { ResolvedAsset } from '../../types';\nimport type { Loader } from '../Loader';\n\n/**\n * The extension priority for loader parsers.\n * Helpful when managing multiple parsers that share the same extension test.\n * The higher priority parsers will be checked first.\n * @enum {number}\n */\nexport enum LoaderParserPriority\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    /** Generic parsers: txt, json, webfonts */\n    Low = 0,\n    /** PixiJS assets with generic extensions: spritesheets, bitmapfonts  */\n    Normal = 1,\n    /** Specific texture types: svg, png, ktx, dds, basis */\n    High = 2,\n}\n\n/**\n * The interface to define a loader parser *(all functions are optional)*.\n *\n * When you create a `parser` object, the flow for every asset loaded is:\n *\n * 1. `parser.test()` - Each URL to load will be tested here, if the test is passed the assets are\n * loaded using the load function below. Good place to test for things like file extensions!\n * 2. `parser.load()` - This is the promise that loads the URL provided resolves with a loaded asset\n * if returned by the parser.\n * 3. `parser.testParse()` - This function is used to test if the parse function should be run on the\n *  asset If this returns true then parse is called with the asset\n * 4. `parse.parse()` - Gets called on the asset it testParse passes. Useful to convert a raw asset\n *  into something more useful\n *\n * <br/>\n * Some loaders may only be used for parsing, some only for loading, and some for both!\n * @memberof assets\n */\nexport interface LoaderParser<ASSET = any, META_DATA = any, CONFIG = Record<string, any>>\n{\n    /** Should be ExtensionType.LoaderParser */\n    extension?: ExtensionMetadata;\n\n    /** A config to adjust the parser */\n    config?: CONFIG;\n\n    /** The name of the parser (this can be used when specifying loadParser in a ResolvedAsset) */\n    name: string;\n\n    /**\n     * Each URL to load will be tested here,\n     * if the test is passed the assets are loaded using the load function below.\n     * Good place to test for things like file extensions!\n     * @param url - The URL to test\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    test?: (url: string, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => boolean;\n\n    /**\n     * This is the promise that loads the URL provided\n     * resolves with a loaded asset if returned by the parser.\n     * @param url - The URL to load\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    load?: <T>(url: string, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<T>;\n\n    /**\n     * This function is used to test if the parse function should be run on the asset\n     * If this returns true then parse is called with the asset\n     * @param asset - The loaded asset data\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    testParse?: (asset: ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<boolean>;\n\n    /**\n     * Gets called on the asset it testParse passes. Useful to convert a raw asset into something more useful\n     * @param asset - The loaded asset data\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    parse?: <T>(asset: ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<T>;\n\n    /**\n     * If an asset is parsed using this parser, the unload function will be called when the user requests an asset\n     * to be unloaded. This is useful for things like sounds or textures that can be unloaded from memory\n     * @param asset - The asset to unload/destroy\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    unload?: (asset: ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<void>;\n}\n","import { warn } from '../../utils/logging/warn.mjs';\nimport { path } from '../../utils/path.mjs';\nimport { convertToList } from '../utils/convertToList.mjs';\nimport { createStringVariations } from '../utils/createStringVariations.mjs';\nimport { isSingleItem } from '../utils/isSingleItem.mjs';\n\n\"use strict\";\nclass Resolver {\n  constructor() {\n    this._defaultBundleIdentifierOptions = {\n      connector: \"-\",\n      createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,\n      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, \"\")\n    };\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._parsers = [];\n    this._resolverHash = {};\n    this._bundles = {};\n  }\n  /**\n   * Override how the resolver deals with generating bundle ids.\n   * must be called before any bundles are added\n   * @param bundleIdentifier - the bundle identifier options\n   */\n  setBundleIdentifier(bundleIdentifier) {\n    this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n    this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n    this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n    if (this._extractAssetIdFromBundle(\"foo\", this._createBundleAssetId(\"foo\", \"bar\")) !== \"bar\") {\n      throw new Error(\"[Resolver] GenerateBundleAssetId are not working correctly\");\n    }\n  }\n  /**\n   * Let the resolver know which assets you prefer to use when resolving assets.\n   * Multiple prefer user defined rules can be added.\n   * @example\n   * resolver.prefer({\n   *     // first look for something with the correct format, and then then correct resolution\n   *     priority: ['format', 'resolution'],\n   *     params:{\n   *         format:'webp', // prefer webp images\n   *         resolution: 2, // prefer a resolution of 2\n   *     }\n   * })\n   * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n   * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n   * @param preferOrders - the prefer options\n   */\n  prefer(...preferOrders) {\n    preferOrders.forEach((prefer) => {\n      this._preferredOrder.push(prefer);\n      if (!prefer.priority) {\n        prefer.priority = Object.keys(prefer.params);\n      }\n    });\n    this._resolverHash = {};\n  }\n  /**\n   * Set the base path to prepend to all urls when resolving\n   * @example\n   * resolver.basePath = 'https://home.com/';\n   * resolver.add('foo', 'bar.ong');\n   * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n   * @param basePath - the base path to use\n   */\n  set basePath(basePath) {\n    this._basePath = basePath;\n  }\n  get basePath() {\n    return this._basePath;\n  }\n  /**\n   * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n   * default value for browsers is `window.location.origin`\n   * @example\n   * // Application hosted on https://home.com/some-path/index.html\n   * resolver.basePath = 'https://home.com/some-path/';\n   * resolver.rootPath = 'https://home.com/';\n   * resolver.add('foo', '/bar.png');\n   * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n   * @param rootPath - the root path to use\n   */\n  set rootPath(rootPath) {\n    this._rootPath = rootPath;\n  }\n  get rootPath() {\n    return this._rootPath;\n  }\n  /**\n   * All the active URL parsers that help the parser to extract information and create\n   * an asset object-based on parsing the URL itself.\n   *\n   * Can be added using the extensions API\n   * @example\n   * resolver.add('foo', [\n   *     {\n   *         resolution: 2,\n   *         format: 'png',\n   *         src: 'image@2x.png',\n   *     },\n   *     {\n   *         resolution:1,\n   *         format:'png',\n   *         src: 'image.png',\n   *     },\n   * ]);\n   *\n   * // With a url parser the information such as resolution and file format could extracted from the url itself:\n   * extensions.add({\n   *     extension: ExtensionType.ResolveParser,\n   *     test: loadTextures.test, // test if url ends in an image\n   *     parse: (value: string) =>\n   *     ({\n   *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n   *         format: value.split('.').pop(),\n   *         src: value,\n   *     }),\n   * });\n   *\n   * // Now resolution and format can be extracted from the url\n   * resolver.add('foo', [\n   *     'image@2x.png',\n   *     'image.png',\n   * ]);\n   */\n  get parsers() {\n    return this._parsers;\n  }\n  /** Used for testing, this resets the resolver to its initial state */\n  reset() {\n    this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._resolverHash = {};\n    this._rootPath = null;\n    this._basePath = null;\n    this._manifest = null;\n    this._bundles = {};\n    this._defaultSearchParams = null;\n  }\n  /**\n   * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n   * @param searchParams - the default url parameters to append when resolving urls\n   */\n  setDefaultSearchParams(searchParams) {\n    if (typeof searchParams === \"string\") {\n      this._defaultSearchParams = searchParams;\n    } else {\n      const queryValues = searchParams;\n      this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join(\"&\");\n    }\n  }\n  /**\n   * Returns the aliases for a given asset\n   * @param asset - the asset to get the aliases for\n   */\n  getAlias(asset) {\n    const { alias, src } = asset;\n    const aliasesToUse = convertToList(\n      alias || src,\n      (value) => {\n        if (typeof value === \"string\")\n          return value;\n        if (Array.isArray(value))\n          return value.map((v) => v?.src ?? v);\n        if (value?.src)\n          return value.src;\n        return value;\n      },\n      true\n    );\n    return aliasesToUse;\n  }\n  /**\n   * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n   * generally a manifest would be built using a tool.\n   * @param manifest - the manifest to add to the resolver\n   */\n  addManifest(manifest) {\n    if (this._manifest) {\n      warn(\"[Resolver] Manifest already exists, this will be overwritten\");\n    }\n    this._manifest = manifest;\n    manifest.bundles.forEach((bundle) => {\n      this.addBundle(bundle.name, bundle.assets);\n    });\n  }\n  /**\n   * This adds a bundle of assets in one go so that you can resolve them as a group.\n   * For example you could add a bundle for each screen in you pixi app\n   * @example\n   * resolver.addBundle('animals', [\n   *  { alias: 'bunny', src: 'bunny.png' },\n   *  { alias: 'chicken', src: 'chicken.png' },\n   *  { alias: 'thumper', src: 'thumper.png' },\n   * ]);\n   * // or\n   * resolver.addBundle('animals', {\n   *     bunny: 'bunny.png',\n   *     chicken: 'chicken.png',\n   *     thumper: 'thumper.png',\n   * });\n   *\n   * const resolvedAssets = await resolver.resolveBundle('animals');\n   * @param bundleId - The id of the bundle to add\n   * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n   */\n  addBundle(bundleId, assets) {\n    const assetNames = [];\n    let convertedAssets = assets;\n    if (!Array.isArray(assets)) {\n      convertedAssets = Object.entries(assets).map(([alias, src]) => {\n        if (typeof src === \"string\" || Array.isArray(src)) {\n          return { alias, src };\n        }\n        return { alias, ...src };\n      });\n    }\n    convertedAssets.forEach((asset) => {\n      const srcs = asset.src;\n      const aliases = asset.alias;\n      let ids;\n      if (typeof aliases === \"string\") {\n        const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n        assetNames.push(bundleAssetId);\n        ids = [aliases, bundleAssetId];\n      } else {\n        const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));\n        assetNames.push(...bundleIds);\n        ids = [...aliases, ...bundleIds];\n      }\n      this.add({\n        ...asset,\n        ...{\n          alias: ids,\n          src: srcs\n        }\n      });\n    });\n    this._bundles[bundleId] = assetNames;\n  }\n  /**\n   * Tells the resolver what keys are associated with witch asset.\n   * The most important thing the resolver does\n   * @example\n   * // Single key, single asset:\n   * resolver.add({alias: 'foo', src: 'bar.png');\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   *\n   * // Multiple keys, single asset:\n   * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   * resolver.resolveUrl('boo') // => 'bar.png'\n   *\n   * // Multiple keys, multiple assets:\n   * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   *\n   * // Add custom data attached to the resolver\n   * Resolver.add({\n   *     alias: 'bunnyBooBooSmooth',\n   *     src: 'bunny{png,webp}',\n   *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n   * });\n   *\n   * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n   * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver\n   */\n  add(aliases) {\n    const assets = [];\n    if (Array.isArray(aliases)) {\n      assets.push(...aliases);\n    } else {\n      assets.push(aliases);\n    }\n    let keyCheck;\n    keyCheck = (key) => {\n      if (this.hasKey(key)) {\n        warn(`[Resolver] already has key: ${key} overwriting`);\n      }\n    };\n    const assetArray = convertToList(assets);\n    assetArray.forEach((asset) => {\n      const { src } = asset;\n      let { data, format, loadParser } = asset;\n      const srcsToUse = convertToList(src).map((src2) => {\n        if (typeof src2 === \"string\") {\n          return createStringVariations(src2);\n        }\n        return Array.isArray(src2) ? src2 : [src2];\n      });\n      const aliasesToUse = this.getAlias(asset);\n      Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n      const resolvedAssets = [];\n      srcsToUse.forEach((srcs) => {\n        srcs.forEach((src2) => {\n          let formattedAsset = {};\n          if (typeof src2 !== \"object\") {\n            formattedAsset.src = src2;\n            for (let i = 0; i < this._parsers.length; i++) {\n              const parser = this._parsers[i];\n              if (parser.test(src2)) {\n                formattedAsset = parser.parse(src2);\n                break;\n              }\n            }\n          } else {\n            data = src2.data ?? data;\n            format = src2.format ?? format;\n            loadParser = src2.loadParser ?? loadParser;\n            formattedAsset = {\n              ...formattedAsset,\n              ...src2\n            };\n          }\n          if (!aliasesToUse) {\n            throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);\n          }\n          formattedAsset = this._buildResolvedAsset(formattedAsset, {\n            aliases: aliasesToUse,\n            data,\n            format,\n            loadParser\n          });\n          resolvedAssets.push(formattedAsset);\n        });\n      });\n      aliasesToUse.forEach((alias) => {\n        this._assetMap[alias] = resolvedAssets;\n      });\n    });\n  }\n  // TODO: this needs an overload like load did in Assets\n  /**\n   * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n   * a given bundleId or bundleIds.\n   * @example\n   * // Manifest Example\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: 'load-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'background',\n   *                     src: 'sunset.png',\n   *                 },\n   *                 {\n   *                     alias: 'bar',\n   *                     src: 'load-bar.{png,webp}',\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: 'game-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'character',\n   *                     src: 'robot.png',\n   *                 },\n   *                 {\n   *                     alias: 'enemy',\n   *                     src: 'bad-guy.png',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * resolver.setManifest(manifest);\n   * const resolved = resolver.resolveBundle('load-screen');\n   * @param bundleIds - The bundle ids to resolve\n   * @returns All the bundles assets or a hash of assets for each bundle specified\n   */\n  resolveBundle(bundleIds) {\n    const singleAsset = isSingleItem(bundleIds);\n    bundleIds = convertToList(bundleIds);\n    const out = {};\n    bundleIds.forEach((bundleId) => {\n      const assetNames = this._bundles[bundleId];\n      if (assetNames) {\n        const results = this.resolve(assetNames);\n        const assets = {};\n        for (const key in results) {\n          const asset = results[key];\n          assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n        }\n        out[bundleId] = assets;\n      }\n    });\n    return singleAsset ? out[bundleIds[0]] : out;\n  }\n  /**\n   * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n   * @param key - The key or keys to resolve\n   * @returns - The URLs associated with the key(s)\n   */\n  resolveUrl(key) {\n    const result = this.resolve(key);\n    if (typeof key !== \"string\") {\n      const out = {};\n      for (const i in result) {\n        out[i] = result[i].src;\n      }\n      return out;\n    }\n    return result.src;\n  }\n  resolve(keys) {\n    const singleAsset = isSingleItem(keys);\n    keys = convertToList(keys);\n    const result = {};\n    keys.forEach((key) => {\n      if (!this._resolverHash[key]) {\n        if (this._assetMap[key]) {\n          let assets = this._assetMap[key];\n          const preferredOrder = this._getPreferredOrder(assets);\n          preferredOrder?.priority.forEach((priorityKey) => {\n            preferredOrder.params[priorityKey].forEach((value) => {\n              const filteredAssets = assets.filter((asset) => {\n                if (asset[priorityKey]) {\n                  return asset[priorityKey] === value;\n                }\n                return false;\n              });\n              if (filteredAssets.length) {\n                assets = filteredAssets;\n              }\n            });\n          });\n          this._resolverHash[key] = assets[0];\n        } else {\n          this._resolverHash[key] = this._buildResolvedAsset({\n            alias: [key],\n            src: key\n          }, {});\n        }\n      }\n      result[key] = this._resolverHash[key];\n    });\n    return singleAsset ? result[keys[0]] : result;\n  }\n  /**\n   * Checks if an asset with a given key exists in the resolver\n   * @param key - The key of the asset\n   */\n  hasKey(key) {\n    return !!this._assetMap[key];\n  }\n  /**\n   * Checks if a bundle with the given key exists in the resolver\n   * @param key - The key of the bundle\n   */\n  hasBundle(key) {\n    return !!this._bundles[key];\n  }\n  /**\n   * Internal function for figuring out what prefer criteria an asset should use.\n   * @param assets\n   */\n  _getPreferredOrder(assets) {\n    for (let i = 0; i < assets.length; i++) {\n      const asset = assets[0];\n      const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));\n      if (preferred) {\n        return preferred;\n      }\n    }\n    return this._preferredOrder[0];\n  }\n  /**\n   * Appends the default url parameters to the url\n   * @param url - The url to append the default parameters to\n   * @returns - The url with the default parameters appended\n   */\n  _appendDefaultSearchParams(url) {\n    if (!this._defaultSearchParams)\n      return url;\n    const paramConnector = /\\?/.test(url) ? \"&\" : \"?\";\n    return `${url}${paramConnector}${this._defaultSearchParams}`;\n  }\n  _buildResolvedAsset(formattedAsset, data) {\n    const { aliases, data: assetData, loadParser, format } = data;\n    if (this._basePath || this._rootPath) {\n      formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n    }\n    formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];\n    formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n    formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };\n    formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;\n    formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);\n    return formattedAsset;\n  }\n}\n/**\n * The prefix that denotes a URL is for a retina asset.\n * @static\n * @name RETINA_PREFIX\n * @type {RegExp}\n * @default /@([0-9\\.]+)x/\n * @example `@2x`\n */\nResolver.RETINA_PREFIX = /@([0-9\\.]+)x/;\nfunction getUrlExtension(url) {\n  return url.split(\".\").pop().split(\"?\").shift().split(\"#\").shift();\n}\n\nexport { Resolver, getUrlExtension };\n//# sourceMappingURL=Resolver.mjs.map\n","import { warn } from '../../utils/logging/warn';\nimport { path } from '../../utils/path';\nimport { convertToList } from '../utils/convertToList';\nimport { createStringVariations } from '../utils/createStringVariations';\nimport { isSingleItem } from '../utils/isSingleItem';\n\nimport type {\n    ArrayOr,\n    AssetsBundle,\n    AssetsManifest,\n    AssetSrc,\n    ResolvedAsset,\n    ResolvedSrc,\n    UnresolvedAsset,\n} from '../types';\nimport type { PreferOrder, ResolveURLParser } from './types';\n\n/**\n * Options for how the resolver deals with generating bundle ids\n * @memberof assets\n */\nexport interface BundleIdentifierOptions\n{\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    connector?: string;\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    createBundleAssetId?: (bundleId: string, assetId: string) => string;\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    extractAssetIdFromBundle?: (bundleId: string, assetBundleId: string) => string;\n}\n\n/**\n * A class that is responsible for resolving mapping asset URLs to keys.\n * At its most basic it can be used for Aliases:\n *\n * ```js\n * resolver.add('foo', 'bar');\n * resolver.resolveUrl('foo') // => 'bar'\n * ```\n *\n * It can also be used to resolve the most appropriate asset for a given URL:\n *\n * ```js\n * resolver.prefer({\n *     params: {\n *         format: 'webp',\n *         resolution: 2,\n *     }\n * });\n *\n * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n *\n * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n * ```\n * Other features include:\n * - Ability to process a manifest file to get the correct understanding of how to resolve all assets\n * - Ability to add custom parsers for specific file types\n * - Ability to add custom prefer rules\n *\n * This class only cares about the URL, not the loading of the asset itself.\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the third major system of PixiJS' main Assets class\n * @memberof assets\n */\nexport class Resolver\n{\n    /**\n     * The prefix that denotes a URL is for a retina asset.\n     * @static\n     * @name RETINA_PREFIX\n     * @type {RegExp}\n     * @default /@([0-9\\.]+)x/\n     * @example `@2x`\n     */\n    public static RETINA_PREFIX = /@([0-9\\.]+)x/;\n\n    private readonly _defaultBundleIdentifierOptions: Required<BundleIdentifierOptions> = {\n        connector: '-',\n        createBundleAssetId: (bundleId, assetId) =>\n            `${bundleId}${this._bundleIdConnector}${assetId}`,\n        extractAssetIdFromBundle: (bundleId, assetBundleId) =>\n            assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, ''),\n    };\n\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    private _bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    private _createBundleAssetId: (\n        bundleId: string,\n        assetId: string\n    ) => string = this._defaultBundleIdentifierOptions.createBundleAssetId;\n\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    private _extractAssetIdFromBundle: (\n        bundleId: string,\n        assetBundleId: string\n    ) => string = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n\n    private _assetMap: Record<string, ResolvedAsset[]> = {};\n    private _preferredOrder: PreferOrder[] = [];\n    private readonly _parsers: ResolveURLParser[] = [];\n\n    private _resolverHash: Record<string, ResolvedAsset> = {};\n    private _rootPath: string;\n    private _basePath: string;\n    private _manifest: AssetsManifest;\n    private _bundles: Record<string, string[]> = {};\n    private _defaultSearchParams: string;\n\n    /**\n     * Override how the resolver deals with generating bundle ids.\n     * must be called before any bundles are added\n     * @param bundleIdentifier - the bundle identifier options\n     */\n    public setBundleIdentifier(bundleIdentifier: BundleIdentifierOptions): void\n    {\n        this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n        this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n        this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n\n        if (this._extractAssetIdFromBundle('foo', this._createBundleAssetId('foo', 'bar')) !== 'bar')\n        {\n            throw new Error('[Resolver] GenerateBundleAssetId are not working correctly');\n        }\n    }\n\n    /**\n     * Let the resolver know which assets you prefer to use when resolving assets.\n     * Multiple prefer user defined rules can be added.\n     * @example\n     * resolver.prefer({\n     *     // first look for something with the correct format, and then then correct resolution\n     *     priority: ['format', 'resolution'],\n     *     params:{\n     *         format:'webp', // prefer webp images\n     *         resolution: 2, // prefer a resolution of 2\n     *     }\n     * })\n     * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n     * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n     * @param preferOrders - the prefer options\n     */\n    public prefer(...preferOrders: PreferOrder[]): void\n    {\n        preferOrders.forEach((prefer) =>\n        {\n            this._preferredOrder.push(prefer);\n\n            if (!prefer.priority)\n            {\n                // generate the priority based on the order of the object\n                prefer.priority = Object.keys(prefer.params);\n            }\n        });\n\n        this._resolverHash = {};\n    }\n\n    /**\n     * Set the base path to prepend to all urls when resolving\n     * @example\n     * resolver.basePath = 'https://home.com/';\n     * resolver.add('foo', 'bar.ong');\n     * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n     * @param basePath - the base path to use\n     */\n    public set basePath(basePath: string)\n    {\n        this._basePath = basePath;\n    }\n\n    public get basePath(): string\n    {\n        return this._basePath;\n    }\n\n    /**\n     * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n     * default value for browsers is `window.location.origin`\n     * @example\n     * // Application hosted on https://home.com/some-path/index.html\n     * resolver.basePath = 'https://home.com/some-path/';\n     * resolver.rootPath = 'https://home.com/';\n     * resolver.add('foo', '/bar.png');\n     * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n     * @param rootPath - the root path to use\n     */\n    public set rootPath(rootPath: string)\n    {\n        this._rootPath = rootPath;\n    }\n\n    public get rootPath(): string\n    {\n        return this._rootPath;\n    }\n\n    /**\n     * All the active URL parsers that help the parser to extract information and create\n     * an asset object-based on parsing the URL itself.\n     *\n     * Can be added using the extensions API\n     * @example\n     * resolver.add('foo', [\n     *     {\n     *         resolution: 2,\n     *         format: 'png',\n     *         src: 'image@2x.png',\n     *     },\n     *     {\n     *         resolution:1,\n     *         format:'png',\n     *         src: 'image.png',\n     *     },\n     * ]);\n     *\n     * // With a url parser the information such as resolution and file format could extracted from the url itself:\n     * extensions.add({\n     *     extension: ExtensionType.ResolveParser,\n     *     test: loadTextures.test, // test if url ends in an image\n     *     parse: (value: string) =>\n     *     ({\n     *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n     *         format: value.split('.').pop(),\n     *         src: value,\n     *     }),\n     * });\n     *\n     * // Now resolution and format can be extracted from the url\n     * resolver.add('foo', [\n     *     'image@2x.png',\n     *     'image.png',\n     * ]);\n     */\n    public get parsers(): ResolveURLParser[]\n    {\n        return this._parsers;\n    }\n\n    /** Used for testing, this resets the resolver to its initial state */\n    public reset(): void\n    {\n        this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n\n        this._assetMap = {};\n        this._preferredOrder = [];\n        // Do not reset this._parsers\n\n        this._resolverHash = {};\n        this._rootPath = null;\n        this._basePath = null;\n        this._manifest = null;\n        this._bundles = {};\n        this._defaultSearchParams = null;\n    }\n\n    /**\n     * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n     * @param searchParams - the default url parameters to append when resolving urls\n     */\n    public setDefaultSearchParams(searchParams: string | Record<string, unknown>): void\n    {\n        if (typeof searchParams === 'string')\n        {\n            this._defaultSearchParams = searchParams;\n        }\n        else\n        {\n            const queryValues = searchParams as Record<string, any>;\n\n            this._defaultSearchParams = Object.keys(queryValues)\n                .map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`)\n                .join('&');\n        }\n    }\n\n    /**\n     * Returns the aliases for a given asset\n     * @param asset - the asset to get the aliases for\n     */\n    public getAlias(asset: UnresolvedAsset): string[]\n    {\n        const { alias, src } = asset;\n        const aliasesToUse = convertToList<ArrayOr<string | AssetSrc>>(\n            alias || src, (value: string | AssetSrc) =>\n            {\n                if (typeof value === 'string') return value;\n\n                if (Array.isArray(value)) return value.map((v) => (v as ResolvedSrc)?.src ?? v);\n\n                if (value?.src) return value.src;\n\n                return value;\n            }, true) as string[];\n\n        return aliasesToUse;\n    }\n\n    /**\n     * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n     * generally a manifest would be built using a tool.\n     * @param manifest - the manifest to add to the resolver\n     */\n    public addManifest(manifest: AssetsManifest): void\n    {\n        if (this._manifest)\n        {\n            // #if _DEBUG\n            warn('[Resolver] Manifest already exists, this will be overwritten');\n            // #endif\n        }\n\n        this._manifest = manifest;\n\n        manifest.bundles.forEach((bundle) =>\n        {\n            this.addBundle(bundle.name, bundle.assets);\n        });\n    }\n\n    /**\n     * This adds a bundle of assets in one go so that you can resolve them as a group.\n     * For example you could add a bundle for each screen in you pixi app\n     * @example\n     * resolver.addBundle('animals', [\n     *  { alias: 'bunny', src: 'bunny.png' },\n     *  { alias: 'chicken', src: 'chicken.png' },\n     *  { alias: 'thumper', src: 'thumper.png' },\n     * ]);\n     * // or\n     * resolver.addBundle('animals', {\n     *     bunny: 'bunny.png',\n     *     chicken: 'chicken.png',\n     *     thumper: 'thumper.png',\n     * });\n     *\n     * const resolvedAssets = await resolver.resolveBundle('animals');\n     * @param bundleId - The id of the bundle to add\n     * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n     */\n    public addBundle(bundleId: string, assets: AssetsBundle['assets']): void\n    {\n        const assetNames: string[] = [];\n        let convertedAssets: UnresolvedAsset[] = assets as UnresolvedAsset[];\n\n        if (!Array.isArray(assets))\n        {\n            // convert to array...\n            convertedAssets = Object.entries(assets).map(([alias, src]) =>\n            {\n                if (typeof src === 'string' || Array.isArray(src))\n                {\n                    return { alias, src };\n                }\n\n                return { alias, ...src };\n            });\n        }\n\n        // when storing keys against a bundle we prepend the bundleId to each asset key\n        // and pass it through as an additional alias for the asset\n        // this keeps clashing ids separate on a per-bundle basis\n        // you can also resolve a file using the bundleId-assetId syntax\n\n        convertedAssets.forEach((asset) =>\n        {\n            const srcs = asset.src;\n            const aliases = asset.alias;\n            let ids: string[];\n\n            if (typeof aliases === 'string')\n            {\n                const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n\n                assetNames.push(bundleAssetId);\n                ids = [aliases, bundleAssetId];\n            }\n            else\n            {\n                const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));\n\n                assetNames.push(...bundleIds);\n                ids = [...aliases, ...bundleIds];\n            }\n\n            this.add({\n                ...asset,\n                ...{\n                    alias: ids,\n                    src: srcs,\n                }\n            });\n        });\n\n        this._bundles[bundleId] = assetNames;\n    }\n\n    /**\n     * Tells the resolver what keys are associated with witch asset.\n     * The most important thing the resolver does\n     * @example\n     * // Single key, single asset:\n     * resolver.add({alias: 'foo', src: 'bar.png');\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Multiple keys, single asset:\n     * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     * resolver.resolveUrl('boo') // => 'bar.png'\n     *\n     * // Multiple keys, multiple assets:\n     * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Add custom data attached to the resolver\n     * Resolver.add({\n     *     alias: 'bunnyBooBooSmooth',\n     *     src: 'bunny{png,webp}',\n     *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n     * });\n     *\n     * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n     * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver\n     */\n    public add(\n        aliases: ArrayOr<UnresolvedAsset>,\n    ): void\n    {\n        const assets: UnresolvedAsset[] = [];\n\n        if (Array.isArray(aliases))\n        {\n            assets.push(...(aliases as UnresolvedAsset[]));\n        }\n        else\n        {\n            assets.push(aliases as UnresolvedAsset);\n        }\n\n        let keyCheck: (key: string) => void;\n\n        // #if _DEBUG\n        // eslint-disable-next-line prefer-const\n        keyCheck = (key: string) =>\n        {\n            if (this.hasKey(key))\n            {\n                // #if _DEBUG\n                warn(`[Resolver] already has key: ${key} overwriting`);\n                // #endif\n            }\n        };\n        // #endif\n\n        const assetArray = convertToList(assets);\n\n        // loop through all the assets and generate a resolve asset for each src\n        assetArray.forEach((asset) =>\n        {\n            const { src } = asset;\n            let { data, format, loadParser } = asset;\n\n            // src can contain an unresolved asset itself\n            // so we need to merge that data with the current asset\n            // we dont need to create string variations for the src if it is a ResolvedAsset\n            const srcsToUse: (string | ResolvedSrc)[][] = convertToList<AssetSrc>(src).map((src) =>\n            {\n                if (typeof src === 'string')\n                { return createStringVariations(src); }\n\n                return Array.isArray(src) ? src : [src];\n            });\n\n            const aliasesToUse = this.getAlias(asset);\n\n            // #if _DEBUG\n            Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n            // #endif\n\n            // loop through all the srcs and generate a resolve asset for each src\n            const resolvedAssets: ResolvedAsset[] = [];\n\n            srcsToUse.forEach((srcs) =>\n            {\n                srcs.forEach((src) =>\n                {\n                    let formattedAsset = {} as ResolvedAsset;\n\n                    if (typeof src !== 'object')\n                    {\n                        formattedAsset.src = src;\n                        // first see if it contains any {} tags...\n                        for (let i = 0; i < this._parsers.length; i++)\n                        {\n                            const parser = this._parsers[i];\n\n                            if (parser.test(src))\n                            {\n                                formattedAsset = parser.parse(src);\n                                break;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        data = src.data ?? data;\n                        format = src.format ?? format;\n                        loadParser = src.loadParser ?? loadParser;\n                        formattedAsset = {\n                            ...formattedAsset,\n                            ...src,\n                        };\n                    }\n\n                    // check if aliases is undefined\n                    if (!aliasesToUse)\n                    {\n                        throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);\n                    }\n\n                    formattedAsset = this._buildResolvedAsset(formattedAsset, {\n                        aliases: aliasesToUse,\n                        data,\n                        format,\n                        loadParser,\n                    });\n\n                    resolvedAssets.push(formattedAsset);\n                });\n            });\n\n            aliasesToUse.forEach((alias) =>\n            {\n                this._assetMap[alias] = resolvedAssets;\n            });\n        });\n    }\n\n    // TODO: this needs an overload like load did in Assets\n    /**\n     * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n     * a given bundleId or bundleIds.\n     * @example\n     * // Manifest Example\n     * const manifest = {\n     *     bundles: [\n     *         {\n     *             name: 'load-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'background',\n     *                     src: 'sunset.png',\n     *                 },\n     *                 {\n     *                     alias: 'bar',\n     *                     src: 'load-bar.{png,webp}',\n     *                 },\n     *             ],\n     *         },\n     *         {\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'character',\n     *                     src: 'robot.png',\n     *                 },\n     *                 {\n     *                     alias: 'enemy',\n     *                     src: 'bad-guy.png',\n     *                 },\n     *             ],\n     *         },\n     *     ]\n     * };\n     *\n     * resolver.setManifest(manifest);\n     * const resolved = resolver.resolveBundle('load-screen');\n     * @param bundleIds - The bundle ids to resolve\n     * @returns All the bundles assets or a hash of assets for each bundle specified\n     */\n    public resolveBundle(bundleIds: ArrayOr<string>):\n    Record<string, ResolvedAsset> | Record<string, Record<string, ResolvedAsset>>\n    {\n        const singleAsset = isSingleItem(bundleIds);\n\n        bundleIds = convertToList<string>(bundleIds);\n\n        const out: Record<string, Record<string, ResolvedAsset>> = {};\n\n        bundleIds.forEach((bundleId) =>\n        {\n            const assetNames = this._bundles[bundleId];\n\n            if (assetNames)\n            {\n                const results = this.resolve(assetNames) as Record<string, ResolvedAsset>;\n\n                const assets: Record<string, ResolvedAsset> = {};\n\n                for (const key in results)\n                {\n                    const asset = results[key];\n\n                    assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n                }\n\n                out[bundleId] = assets;\n            }\n        });\n\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n\n    /**\n     * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n     * @param key - The key or keys to resolve\n     * @returns - The URLs associated with the key(s)\n     */\n    public resolveUrl(key: ArrayOr<string>): string | Record<string, string>\n    {\n        const result = this.resolve(key as string) as ResolvedAsset | Record<string, ResolvedAsset>;\n\n        if (typeof key !== 'string')\n        {\n            const out: Record<string, string> = {};\n\n            for (const i in result)\n            {\n                out[i] = (result as Record<string, ResolvedAsset>)[i].src;\n            }\n\n            return out;\n        }\n\n        return (result as ResolvedAsset).src;\n    }\n\n    /**\n     * Resolves each key in the list to an asset object.\n     * Another key function of the resolver! After adding all the various key/asset pairs. this will run the logic\n     * of finding which asset to return based on any preferences set using the `prefer` function\n     * by default the same key passed in will be returned if nothing is matched by the resolver.\n     * @example\n     * resolver.add('boo', 'bunny.png');\n     *\n     * resolver.resolve('boo') // => { src: 'bunny.png' }\n     *\n     * // Will return the same string as no key was added for this value..\n     * resolver.resolve('another-thing.png') // => { src: 'another-thing.png' }\n     * @param keys - key or keys to resolve\n     * @returns - the resolve asset or a hash of resolve assets for each key specified\n     */\n    public resolve(keys: string): ResolvedAsset;\n    public resolve(keys: string[]): Record<string, ResolvedAsset>;\n    public resolve(keys: ArrayOr<string>): ResolvedAsset | Record<string, ResolvedAsset>\n    {\n        const singleAsset = isSingleItem(keys);\n\n        keys = convertToList<string>(keys);\n\n        const result: Record<string, ResolvedAsset> = {};\n\n        keys.forEach((key) =>\n        {\n            if (!this._resolverHash[key])\n            {\n                if (this._assetMap[key])\n                {\n                    let assets = this._assetMap[key];\n                    const preferredOrder = this._getPreferredOrder(assets);\n\n                    preferredOrder?.priority.forEach((priorityKey) =>\n                    {\n                        preferredOrder.params[priorityKey].forEach((value: unknown) =>\n                        {\n                            const filteredAssets = assets.filter((asset) =>\n                            {\n                                if (asset[priorityKey as keyof ResolvedAsset])\n                                {\n                                    return asset[priorityKey as keyof ResolvedAsset] === value;\n                                }\n\n                                return false;\n                            });\n\n                            if (filteredAssets.length)\n                            {\n                                assets = filteredAssets;\n                            }\n                        });\n                    });\n\n                    this._resolverHash[key] = assets[0];\n                }\n                else\n                {\n                    this._resolverHash[key] = this._buildResolvedAsset({\n                        alias: [key],\n                        src: key,\n                    }, {});\n                }\n            }\n\n            result[key] = this._resolverHash[key];\n        });\n\n        return singleAsset ? result[keys[0]] : result;\n    }\n\n    /**\n     * Checks if an asset with a given key exists in the resolver\n     * @param key - The key of the asset\n     */\n    public hasKey(key: string): boolean\n    {\n        return !!this._assetMap[key];\n    }\n\n    /**\n     * Checks if a bundle with the given key exists in the resolver\n     * @param key - The key of the bundle\n     */\n    public hasBundle(key: string): boolean\n    {\n        return !!this._bundles[key];\n    }\n\n    /**\n     * Internal function for figuring out what prefer criteria an asset should use.\n     * @param assets\n     */\n    private _getPreferredOrder(assets: ResolvedAsset[]): PreferOrder\n    {\n        for (let i = 0; i < assets.length; i++)\n        {\n            const asset = assets[0];\n\n            const preferred = this._preferredOrder.find((preference: PreferOrder) =>\n                preference.params.format.includes(asset.format));\n\n            if (preferred)\n            {\n                return preferred;\n            }\n        }\n\n        return this._preferredOrder[0];\n    }\n\n    /**\n     * Appends the default url parameters to the url\n     * @param url - The url to append the default parameters to\n     * @returns - The url with the default parameters appended\n     */\n    private _appendDefaultSearchParams(url: string): string\n    {\n        if (!this._defaultSearchParams) return url;\n\n        const paramConnector = (/\\?/).test(url) ? '&' : '?';\n\n        return `${url}${paramConnector}${this._defaultSearchParams}`;\n    }\n\n    private _buildResolvedAsset(formattedAsset: ResolvedAsset, data?: {\n        aliases?: string[],\n        data?: Record<string, unknown>\n        loadParser?: string,\n        format?: string,\n    }): ResolvedAsset\n    {\n        const { aliases, data: assetData, loadParser, format } = data;\n\n        if (this._basePath || this._rootPath)\n        {\n            formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n        }\n\n        formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];\n        formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n        formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };\n        formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;\n        formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);\n\n        return formattedAsset;\n    }\n}\n\nexport function getUrlExtension(url: string)\n{\n    return url.split('.').pop().split('?').shift()\n        .split('#')\n        .shift();\n}\n","import { DOMAdapter } from '../environment/adapter.mjs';\n\n\"use strict\";\nfunction assertPath(path2) {\n  if (typeof path2 !== \"string\") {\n    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);\n  }\n}\nfunction removeUrlParams(url) {\n  const re = url.split(\"?\")[0];\n  return re.split(\"#\")[0];\n}\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction replaceAll(str, find, replace) {\n  return str.replace(new RegExp(escapeRegExp(find), \"g\"), replace);\n}\nfunction normalizeStringPosix(path2, allowAboveRoot) {\n  let res = \"\";\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = -1;\n  for (let i = 0; i <= path2.length; ++i) {\n    if (i < path2.length) {\n      code = path2.charCodeAt(i);\n    } else if (code === 47) {\n      break;\n    } else {\n      code = 47;\n    }\n    if (code === 47) {\n      if (lastSlash === i - 1 || dots === 1) {\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf(\"/\");\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = \"\";\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf(\"/\");\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = \"\";\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0) {\n            res += \"/..\";\n          } else {\n            res = \"..\";\n          }\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) {\n          res += `/${path2.slice(lastSlash + 1, i)}`;\n        } else {\n          res = path2.slice(lastSlash + 1, i);\n        }\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\nconst path = {\n  /**\n   * Converts a path to posix format.\n   * @param path - The path to convert to posix\n   */\n  toPosix(path2) {\n    return replaceAll(path2, \"\\\\\", \"/\");\n  },\n  /**\n   * Checks if the path is a URL e.g. http://, https://\n   * @param path - The path to check\n   */\n  isUrl(path2) {\n    return /^https?:/.test(this.toPosix(path2));\n  },\n  /**\n   * Checks if the path is a data URL\n   * @param path - The path to check\n   */\n  isDataUrl(path2) {\n    return /^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i.test(path2);\n  },\n  /**\n   * Checks if the path is a blob URL\n   * @param path - The path to check\n   */\n  isBlobUrl(path2) {\n    return path2.startsWith(\"blob:\");\n  },\n  /**\n   * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n   * This will return true for windows file paths\n   * @param path - The path to check\n   */\n  hasProtocol(path2) {\n    return /^[^/:]+:/.test(this.toPosix(path2));\n  },\n  /**\n   * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n   * @param path - The path to get the protocol from\n   */\n  getProtocol(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    const matchFile = /^file:\\/\\/\\//.exec(path2);\n    if (matchFile) {\n      return matchFile[0];\n    }\n    const matchProtocol = /^[^/:]+:\\/{0,2}/.exec(path2);\n    if (matchProtocol) {\n      return matchProtocol[0];\n    }\n    return \"\";\n  },\n  /**\n   * Converts URL to an absolute path.\n   * When loading from a Web Worker, we must use absolute paths.\n   * If the URL is already absolute we return it as is\n   * If it's not, we convert it\n   * @param url - The URL to test\n   * @param customBaseUrl - The base URL to use\n   * @param customRootUrl - The root URL to use\n   */\n  toAbsolute(url, customBaseUrl, customRootUrl) {\n    assertPath(url);\n    if (this.isDataUrl(url) || this.isBlobUrl(url))\n      return url;\n    const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? DOMAdapter.get().getBaseUrl()));\n    const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));\n    url = this.toPosix(url);\n    if (url.startsWith(\"/\")) {\n      return path.join(rootUrl, url.slice(1));\n    }\n    const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);\n    return absolutePath;\n  },\n  /**\n   * Normalizes the given path, resolving '..' and '.' segments\n   * @param path - The path to normalize\n   */\n  normalize(path2) {\n    assertPath(path2);\n    if (path2.length === 0)\n      return \".\";\n    if (this.isDataUrl(path2) || this.isBlobUrl(path2))\n      return path2;\n    path2 = this.toPosix(path2);\n    let protocol = \"\";\n    const isAbsolute = path2.startsWith(\"/\");\n    if (this.hasProtocol(path2)) {\n      protocol = this.rootname(path2);\n      path2 = path2.slice(protocol.length);\n    }\n    const trailingSeparator = path2.endsWith(\"/\");\n    path2 = normalizeStringPosix(path2, false);\n    if (path2.length > 0 && trailingSeparator)\n      path2 += \"/\";\n    if (isAbsolute)\n      return `/${path2}`;\n    return protocol + path2;\n  },\n  /**\n   * Determines if path is an absolute path.\n   * Absolute paths can be urls, data urls, or paths on disk\n   * @param path - The path to test\n   */\n  isAbsolute(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    if (this.hasProtocol(path2))\n      return true;\n    return path2.startsWith(\"/\");\n  },\n  /**\n   * Joins all given path segments together using the platform-specific separator as a delimiter,\n   * then normalizes the resulting path\n   * @param segments - The segments of the path to join\n   */\n  join(...segments) {\n    if (segments.length === 0) {\n      return \".\";\n    }\n    let joined;\n    for (let i = 0; i < segments.length; ++i) {\n      const arg = segments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === void 0)\n          joined = arg;\n        else {\n          const prevArg = segments[i - 1] ?? \"\";\n          if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase())) {\n            joined += `/../${arg}`;\n          } else {\n            joined += `/${arg}`;\n          }\n        }\n      }\n    }\n    if (joined === void 0) {\n      return \".\";\n    }\n    return this.normalize(joined);\n  },\n  /**\n   * Returns the directory name of a path\n   * @param path - The path to parse\n   */\n  dirname(path2) {\n    assertPath(path2);\n    if (path2.length === 0)\n      return \".\";\n    path2 = this.toPosix(path2);\n    let code = path2.charCodeAt(0);\n    const hasRoot = code === 47;\n    let end = -1;\n    let matchedSlash = true;\n    const proto = this.getProtocol(path2);\n    const origpath = path2;\n    path2 = path2.slice(proto.length);\n    for (let i = path2.length - 1; i >= 1; --i) {\n      code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        matchedSlash = false;\n      }\n    }\n    if (end === -1)\n      return hasRoot ? \"/\" : this.isUrl(origpath) ? proto + path2 : proto;\n    if (hasRoot && end === 1)\n      return \"//\";\n    return proto + path2.slice(0, end);\n  },\n  /**\n   * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n   * @param path - The path to parse\n   */\n  rootname(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    let root = \"\";\n    if (path2.startsWith(\"/\"))\n      root = \"/\";\n    else {\n      root = this.getProtocol(path2);\n    }\n    if (this.isUrl(path2)) {\n      const index = path2.indexOf(\"/\", root.length);\n      if (index !== -1) {\n        root = path2.slice(0, index);\n      } else\n        root = path2;\n      if (!root.endsWith(\"/\"))\n        root += \"/\";\n    }\n    return root;\n  },\n  /**\n   * Returns the last portion of a path\n   * @param path - The path to test\n   * @param ext - Optional extension to remove\n   */\n  basename(path2, ext) {\n    assertPath(path2);\n    if (ext)\n      assertPath(ext);\n    path2 = removeUrlParams(this.toPosix(path2));\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i;\n    if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {\n      if (ext.length === path2.length && ext === path2)\n        return \"\";\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (i = path2.length - 1; i >= 0; --i) {\n        const code = path2.charCodeAt(i);\n        if (code === 47) {\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                end = i;\n              }\n            } else {\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path2.length;\n      return path2.slice(start, end);\n    }\n    for (i = path2.length - 1; i >= 0; --i) {\n      if (path2.charCodeAt(i) === 47) {\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n    if (end === -1)\n      return \"\";\n    return path2.slice(start, end);\n  },\n  /**\n   * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n   * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n   * the first character of the basename of path, an empty string is returned.\n   * @param path - The path to parse\n   */\n  extname(path2) {\n    assertPath(path2);\n    path2 = removeUrlParams(this.toPosix(path2));\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let preDotState = 0;\n    for (let i = path2.length - 1; i >= 0; --i) {\n      const code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46) {\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return \"\";\n    }\n    return path2.slice(startDot, end);\n  },\n  /**\n   * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n   * @param path - The path to parse\n   */\n  parse(path2) {\n    assertPath(path2);\n    const ret = { root: \"\", dir: \"\", base: \"\", ext: \"\", name: \"\" };\n    if (path2.length === 0)\n      return ret;\n    path2 = removeUrlParams(this.toPosix(path2));\n    let code = path2.charCodeAt(0);\n    const isAbsolute = this.isAbsolute(path2);\n    let start;\n    const protocol = \"\";\n    ret.root = this.rootname(path2);\n    if (isAbsolute || this.hasProtocol(path2)) {\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path2.length - 1;\n    let preDotState = 0;\n    for (; i >= start; --i) {\n      code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46) {\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute)\n          ret.base = ret.name = path2.slice(1, end);\n        else\n          ret.base = ret.name = path2.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path2.slice(1, startDot);\n        ret.base = path2.slice(1, end);\n      } else {\n        ret.name = path2.slice(startPart, startDot);\n        ret.base = path2.slice(startPart, end);\n      }\n      ret.ext = path2.slice(startDot, end);\n    }\n    ret.dir = this.dirname(path2);\n    if (protocol)\n      ret.dir = protocol + ret.dir;\n    return ret;\n  },\n  sep: \"/\",\n  delimiter: \":\",\n  joinExtensions: [\".html\"]\n};\n\nexport { path };\n//# sourceMappingURL=path.mjs.map\n","import { DOMAdapter } from '../environment/adapter';\n\nfunction assertPath(path: string)\n{\n    if (typeof path !== 'string')\n    {\n        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);\n    }\n}\n\nfunction removeUrlParams(url: string): string\n{\n    const re = url.split('?')[0];\n\n    return re.split('#')[0];\n}\n\nfunction escapeRegExp(string: string)\n{\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\nfunction replaceAll(str: string, find: string, replace: string)\n{\n    return str.replace(new RegExp(escapeRegExp(find), 'g'), replace);\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path: string, allowAboveRoot: boolean)\n{\n    let res = '';\n    let lastSegmentLength = 0;\n    let lastSlash = -1;\n    let dots = 0;\n    let code = -1;\n\n    for (let i = 0; i <= path.length; ++i)\n    {\n        if (i < path.length)\n        {\n            code = path.charCodeAt(i);\n        }\n        else if (code === 47)\n        {\n            break;\n        }\n        else\n        {\n            code = 47;\n        }\n        if (code === 47)\n        {\n            if (lastSlash === i - 1 || dots === 1)\n            {\n                // NOOP\n            }\n            else if (lastSlash !== i - 1 && dots === 2)\n            {\n                if (\n                    res.length < 2\n                    || lastSegmentLength !== 2\n                    || res.charCodeAt(res.length - 1) !== 46\n                    || res.charCodeAt(res.length - 2) !== 46\n                )\n                {\n                    if (res.length > 2)\n                    {\n                        const lastSlashIndex = res.lastIndexOf('/');\n\n                        if (lastSlashIndex !== res.length - 1)\n                        {\n                            if (lastSlashIndex === -1)\n                            {\n                                res = '';\n                                lastSegmentLength = 0;\n                            }\n                            else\n                            {\n                                res = res.slice(0, lastSlashIndex);\n                                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n                            }\n                            lastSlash = i;\n                            dots = 0;\n                            continue;\n                        }\n                    }\n                    else if (res.length === 2 || res.length === 1)\n                    {\n                        res = '';\n                        lastSegmentLength = 0;\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                }\n                if (allowAboveRoot)\n                {\n                    if (res.length > 0)\n                    { res += '/..'; }\n                    else\n                    { res = '..'; }\n                    lastSegmentLength = 2;\n                }\n            }\n            else\n            {\n                if (res.length > 0)\n                {\n                    res += `/${path.slice(lastSlash + 1, i)}`;\n                }\n                else\n                {\n                    res = path.slice(lastSlash + 1, i);\n                }\n                lastSegmentLength = i - lastSlash - 1;\n            }\n            lastSlash = i;\n            dots = 0;\n        }\n        else if (code === 46 && dots !== -1)\n        {\n            ++dots;\n        }\n        else\n        {\n            dots = -1;\n        }\n    }\n\n    return res;\n}\n\n/**\n * Path utilities for working with URLs and file paths in a cross-platform way.\n * All paths that are passed in will become normalized to have posix separators.\n * ```js\n * import { path } from 'pixi.js';\n *\n * path.normalize('http://www.example.com/foo/bar/../baz'); // http://www.example.com/foo/baz\n * ```\n * @memberof utils\n */\nexport interface Path\n{\n    /**\n     * Converts a path to posix format.\n     * @param path - The path to convert to posix\n     */\n    toPosix: (path: string) => string;\n    /**\n     * Checks if the path is a URL e.g. http://, https://\n     * @param path - The path to check\n     */\n    isUrl: (path: string) => boolean;\n    /**\n     * Checks if the path is a data URL\n     * @param path - The path to check\n     */\n    isDataUrl: (path: string) => boolean;\n    /**\n     * Checks if the path is a blob URL\n     * @param path - The path to check\n     */\n    isBlobUrl: (path: string) => boolean;\n    /**\n     * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n     * This will return true for windows file paths\n     * @param path - The path to check\n     */\n    hasProtocol: (path: string) => boolean;\n    /**\n     * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n     * @param path - The path to get the protocol from\n     */\n    getProtocol: (path: string) => string;\n    /**\n     * Converts URL to an absolute path.\n     * When loading from a Web Worker, we must use absolute paths.\n     * If the URL is already absolute we return it as is\n     * If it's not, we convert it\n     * @param url - The URL to test\n     * @param customBaseUrl - The base URL to use\n     * @param customRootUrl - The root URL to use\n     */\n    toAbsolute: (url: string, baseUrl?: string, rootUrl?: string) => string;\n    /**\n     * Normalizes the given path, resolving '..' and '.' segments\n     * @param path - The path to normalize\n     */\n    normalize: (path: string) => string;\n    /**\n     * Determines if path is an absolute path.\n     * Absolute paths can be urls, data urls, or paths on disk\n     * @param path - The path to test\n     */\n    isAbsolute: (path: string) => boolean;\n    /**\n     * Joins all given path segments together using the platform-specific separator as a delimiter,\n     * then normalizes the resulting path\n     * @param segments - The segments of the path to join\n     */\n    join: (...paths: string[]) => string;\n    /**\n     * Returns the directory name of a path\n     * @param path - The path to parse\n     */\n    dirname: (path: string) => string;\n    /**\n     * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n     * @param path - The path to parse\n     */\n    rootname: (path: string) => string;\n    /**\n     * Returns the last portion of a path\n     * @param path - The path to test\n     * @param ext - Optional extension to remove\n     */\n    basename: (path: string, ext?: string) => string;\n    /**\n     * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n     * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n     * the first character of the basename of path, an empty string is returned.\n     * @param path - The path to parse\n     */\n    extname: (path: string) => string;\n    /**\n     * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n     * @param path - The path to parse\n     */\n    parse: (path: string) => { root?: string, dir?: string, base?: string, ext?: string, name?: string };\n    sep: string,\n    delimiter: string,\n    joinExtensions: string[],\n}\n\n/**\n * Path utilities for working with URLs and file paths in a cross-platform way.\n * All paths that are passed in will become normalized to have posix separators.\n * ```js\n * import { path } from 'pixi.js';\n *\n * path.normalize('http://www.example.com/foo/bar/../baz'); // http://www.example.com/foo/baz\n * ```\n * @see {@link utils.Path}\n * @memberof utils\n */\nexport const path: Path = {\n    /**\n     * Converts a path to posix format.\n     * @param path - The path to convert to posix\n     */\n    toPosix(path: string) { return replaceAll(path, '\\\\', '/'); },\n    /**\n     * Checks if the path is a URL e.g. http://, https://\n     * @param path - The path to check\n     */\n    isUrl(path: string) { return (/^https?:/).test(this.toPosix(path)); },\n    /**\n     * Checks if the path is a data URL\n     * @param path - The path to check\n     */\n    isDataUrl(path: string)\n    {\n        // eslint-disable-next-line max-len\n        return (/^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i)\n            .test(path);\n    },\n    /**\n     * Checks if the path is a blob URL\n     * @param path - The path to check\n     */\n    isBlobUrl(path: string)\n    {\n        // Not necessary to have an exact regex to match the blob URLs\n        return path.startsWith('blob:');\n    },\n    /**\n     * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n     * This will return true for windows file paths\n     * @param path - The path to check\n     */\n    hasProtocol(path: string) { return (/^[^/:]+:/).test(this.toPosix(path)); },\n    /**\n     * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n     * @param path - The path to get the protocol from\n     */\n    getProtocol(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        const matchFile = (/^file:\\/\\/\\//).exec(path);\n\n        if (matchFile)\n        {\n            return matchFile[0];\n        }\n\n        const matchProtocol = (/^[^/:]+:\\/{0,2}/).exec(path);\n\n        if (matchProtocol)\n        {\n            return matchProtocol[0];\n        }\n\n        return '';\n    },\n\n    /**\n     * Converts URL to an absolute path.\n     * When loading from a Web Worker, we must use absolute paths.\n     * If the URL is already absolute we return it as is\n     * If it's not, we convert it\n     * @param url - The URL to test\n     * @param customBaseUrl - The base URL to use\n     * @param customRootUrl - The root URL to use\n     */\n    toAbsolute(url: string, customBaseUrl?: string, customRootUrl?: string)\n    {\n        assertPath(url);\n\n        if (this.isDataUrl(url) || this.isBlobUrl(url)) return url;\n\n        const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? DOMAdapter.get().getBaseUrl()));\n        const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));\n\n        url = this.toPosix(url);\n\n        // root relative url\n        if (url.startsWith('/'))\n        {\n            return path.join(rootUrl, url.slice(1));\n        }\n\n        const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);\n\n        return absolutePath;\n    },\n\n    /**\n     * Normalizes the given path, resolving '..' and '.' segments\n     * @param path - The path to normalize\n     */\n    normalize(path: string)\n    {\n        assertPath(path);\n\n        if (path.length === 0) return '.';\n        if (this.isDataUrl(path) || this.isBlobUrl(path)) return path;\n\n        path = this.toPosix(path);\n\n        let protocol = '';\n        const isAbsolute = path.startsWith('/');\n\n        if (this.hasProtocol(path))\n        {\n            protocol = this.rootname(path);\n            path = path.slice(protocol.length);\n        }\n\n        const trailingSeparator = path.endsWith('/');\n\n        // Normalize the path\n        path = normalizeStringPosix(path, false);\n\n        if (path.length > 0 && trailingSeparator) path += '/';\n        if (isAbsolute) return `/${path}`;\n\n        return protocol + path;\n    },\n\n    /**\n     * Determines if path is an absolute path.\n     * Absolute paths can be urls, data urls, or paths on disk\n     * @param path - The path to test\n     */\n    isAbsolute(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        if (this.hasProtocol(path)) return true;\n\n        return path.startsWith('/');\n    },\n\n    /**\n     * Joins all given path segments together using the platform-specific separator as a delimiter,\n     * then normalizes the resulting path\n     * @param segments - The segments of the path to join\n     */\n    join(...segments: string[])\n    {\n        if (segments.length === 0)\n        { return '.'; }\n        let joined;\n\n        for (let i = 0; i < segments.length; ++i)\n        {\n            const arg = segments[i];\n\n            assertPath(arg);\n            if (arg.length > 0)\n            {\n                if (joined === undefined) joined = arg;\n                else\n                {\n                    const prevArg = segments[i - 1] ?? '';\n\n                    if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase()))\n                    {\n                        joined += `/../${arg}`;\n                    }\n                    else\n                    {\n                        joined += `/${arg}`;\n                    }\n                }\n            }\n        }\n        if (joined === undefined) { return '.'; }\n\n        return this.normalize(joined);\n    },\n\n    /**\n     * Returns the directory name of a path\n     * @param path - The path to parse\n     */\n    dirname(path: string)\n    {\n        assertPath(path);\n        if (path.length === 0) return '.';\n        path = this.toPosix(path);\n        let code = path.charCodeAt(0);\n        const hasRoot = code === 47;\n        let end = -1;\n        let matchedSlash = true;\n\n        const proto = this.getProtocol(path);\n        const origpath = path;\n\n        path = path.slice(proto.length);\n\n        for (let i = path.length - 1; i >= 1; --i)\n        {\n            code = path.charCodeAt(i);\n            if (code === 47)\n            {\n                if (!matchedSlash)\n                {\n                    end = i;\n                    break;\n                }\n            }\n            else\n            {\n                // We saw the first non-path separator\n                matchedSlash = false;\n            }\n        }\n\n        // if end is -1 and its a url then we need to add the path back\n        // eslint-disable-next-line no-nested-ternary\n        if (end === -1) return hasRoot ? '/' : this.isUrl(origpath) ? proto + path : proto;\n        if (hasRoot && end === 1) return '//';\n\n        return proto + path.slice(0, end);\n    },\n\n    /**\n     * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n     * @param path - The path to parse\n     */\n    rootname(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        let root = '';\n\n        if (path.startsWith('/')) root = '/';\n        else\n        {\n            root = this.getProtocol(path);\n        }\n\n        if (this.isUrl(path))\n        {\n            // need to find the first path separator\n            const index = path.indexOf('/', root.length);\n\n            if (index !== -1)\n            {\n                root = path.slice(0, index);\n            }\n            else root = path;\n\n            if (!root.endsWith('/')) root += '/';\n        }\n\n        return root;\n    },\n\n    /**\n     * Returns the last portion of a path\n     * @param path - The path to test\n     * @param ext - Optional extension to remove\n     */\n    basename(path: string, ext?: string)\n    {\n        assertPath(path);\n        if (ext) assertPath(ext);\n\n        path = removeUrlParams(this.toPosix(path));\n\n        let start = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i: number;\n\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length)\n        {\n            if (ext.length === path.length && ext === path) return '';\n            let extIdx = ext.length - 1;\n            let firstNonSlashEnd = -1;\n\n            for (i = path.length - 1; i >= 0; --i)\n            {\n                const code = path.charCodeAt(i);\n\n                if (code === 47)\n                {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash)\n                    {\n                        start = i + 1;\n                        break;\n                    }\n                }\n                else\n                {\n                    if (firstNonSlashEnd === -1)\n                    {\n                        // We saw the first non-path separator, remember this index in case\n                        // we need it if the extension ends up not matching\n                        matchedSlash = false;\n                        firstNonSlashEnd = i + 1;\n                    }\n                    if (extIdx >= 0)\n                    {\n                        // Try to match the explicit extension\n                        if (code === ext.charCodeAt(extIdx))\n                        {\n                            if (--extIdx === -1)\n                            {\n                                // We matched the extension, so mark this as the end of our path\n                                // component\n                                end = i;\n                            }\n                        }\n                        else\n                        {\n                            // Extension does not match, so our result is the entire path\n                            // component\n                            extIdx = -1;\n                            end = firstNonSlashEnd;\n                        }\n                    }\n                }\n            }\n\n            if (start === end) end = firstNonSlashEnd; else if (end === -1) end = path.length;\n\n            return path.slice(start, end);\n        }\n        for (i = path.length - 1; i >= 0; --i)\n        {\n            if (path.charCodeAt(i) === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    start = i + 1;\n                    break;\n                }\n            }\n            else if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // path component\n                matchedSlash = false;\n                end = i + 1;\n            }\n        }\n\n        if (end === -1) return '';\n\n        return path.slice(start, end);\n    },\n\n    /**\n     * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n     * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n     * the first character of the basename of path, an empty string is returned.\n     * @param path - The path to parse\n     */\n    extname(path: string)\n    {\n        assertPath(path);\n        path = removeUrlParams(this.toPosix(path));\n\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n\n        for (let i = path.length - 1; i >= 0; --i)\n        {\n            const code = path.charCodeAt(i);\n\n            if (code === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46)\n            {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            }\n            else if (startDot !== -1)\n            {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n\n        if (\n            startDot === -1 || end === -1\n            // We saw a non-dot character immediately before the dot\n            || preDotState === 0\n            // The (right-most) trimmed path component is exactly '..'\n            // eslint-disable-next-line no-mixed-operators, no-mixed-operators/no-mixed-operators\n            || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1\n        )\n        {\n            return '';\n        }\n\n        return path.slice(startDot, end);\n    },\n\n    /**\n     * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n     * @param path - The path to parse\n     */\n    parse(path: string)\n    {\n        assertPath(path);\n\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\n        if (path.length === 0) return ret;\n        path = removeUrlParams(this.toPosix(path));\n\n        let code = path.charCodeAt(0);\n        const isAbsolute = this.isAbsolute(path);\n        let start: number;\n        const protocol = '';\n\n        ret.root = this.rootname(path);\n\n        if (isAbsolute || this.hasProtocol(path))\n        {\n            start = 1;\n        }\n        else\n        {\n            start = 0;\n        }\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i = path.length - 1;\n\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n\n        // Get non-dir info\n        for (; i >= start; --i)\n        {\n            code = path.charCodeAt(i);\n            if (code === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46)\n            {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            }\n            else if (startDot !== -1)\n            {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n\n        if (\n            startDot === -1 || end === -1\n            // We saw a non-dot character immediately before the dot\n            || preDotState === 0\n            // The (right-most) trimmed path component is exactly '..'\n            // eslint-disable-next-line no-mixed-operators, no-mixed-operators/no-mixed-operators\n            || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1\n        )\n        {\n            if (end !== -1)\n            {\n                if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);\n                else ret.base = ret.name = path.slice(startPart, end);\n            }\n        }\n        else\n        {\n            if (startPart === 0 && isAbsolute)\n            {\n                ret.name = path.slice(1, startDot);\n                ret.base = path.slice(1, end);\n            }\n            else\n            {\n                ret.name = path.slice(startPart, startDot);\n                ret.base = path.slice(startPart, end);\n            }\n            ret.ext = path.slice(startDot, end);\n        }\n\n        ret.dir = this.dirname(path);\n        if (protocol) ret.dir = protocol + ret.dir;\n\n        return ret;\n    },\n\n    sep: '/',\n    delimiter: ':',\n    joinExtensions: ['.html'],\n} as Path;\n","\"use strict\";\nconst convertToList = (input, transform, forceTransform = false) => {\n  if (!Array.isArray(input)) {\n    input = [input];\n  }\n  if (!transform) {\n    return input;\n  }\n  return input.map((item) => {\n    if (typeof item === \"string\" || forceTransform) {\n      return transform(item);\n    }\n    return item;\n  });\n};\n\nexport { convertToList };\n//# sourceMappingURL=convertToList.mjs.map\n","export const convertToList = <T>(\n    input: string | T | (string | T)[],\n    transform?: (input: string) => T,\n    forceTransform = false\n): T[] =>\n{\n    if (!Array.isArray(input))\n    {\n        input = [input as T];\n    }\n\n    if (!transform)\n    {\n        return input as T[];\n    }\n\n    return (input as (string | T)[]).map((item): T =>\n    {\n        if (typeof item === 'string' || forceTransform)\n        {\n            return transform(item as string);\n        }\n\n        return item as T;\n    });\n};\n","\"use strict\";\nfunction processX(base, ids, depth, result, tags) {\n  const id = ids[depth];\n  for (let i = 0; i < id.length; i++) {\n    const value = id[i];\n    if (depth < ids.length - 1) {\n      processX(base.replace(result[depth], value), ids, depth + 1, result, tags);\n    } else {\n      tags.push(base.replace(result[depth], value));\n    }\n  }\n}\nfunction createStringVariations(string) {\n  const regex = /\\{(.*?)\\}/g;\n  const result = string.match(regex);\n  const tags = [];\n  if (result) {\n    const ids = [];\n    result.forEach((vars) => {\n      const split = vars.substring(1, vars.length - 1).split(\",\");\n      ids.push(split);\n    });\n    processX(string, ids, 0, result, tags);\n  } else {\n    tags.push(string);\n  }\n  return tags;\n}\n\nexport { createStringVariations };\n//# sourceMappingURL=createStringVariations.mjs.map\n","function processX(base: string, ids: string[][], depth: number, result: string[], tags: string[])\n{\n    const id = ids[depth];\n\n    for (let i = 0; i < id.length; i++)\n    {\n        const value = id[i];\n\n        if (depth < ids.length - 1)\n        {\n            processX(base.replace(result[depth], value), ids, depth + 1, result, tags);\n        }\n        else\n        {\n            tags.push(base.replace(result[depth], value));\n        }\n    }\n}\n\n/**\n * Creates a list of all possible combinations of the given strings.\n * @example\n * const out2 = createStringVariations('name is {chicken,wolf,sheep}');\n * console.log(out2); // [ 'name is chicken', 'name is wolf', 'name is sheep' ]\n * @param string - The string to process\n */\nexport function createStringVariations(string: string): string[]\n{\n    const regex = /\\{(.*?)\\}/g;\n\n    const result = string.match(regex);\n\n    const tags: string[] = [];\n\n    if (result)\n    {\n        const ids: string[][] = [];\n\n        result.forEach((vars) =>\n        {\n            // first remove the brackets...\n            const split = vars.substring(1, vars.length - 1).split(',');\n\n            ids.push(split);\n        });\n\n        processX(string, ids, 0, result, tags);\n    }\n    else\n    {\n        tags.push(string);\n    }\n\n    return tags;\n}\n","\"use strict\";\nconst isSingleItem = (item) => !Array.isArray(item);\n\nexport { isSingleItem };\n//# sourceMappingURL=isSingleItem.mjs.map\n","/**\n * Checks if the given value is an array.\n * @param item - The item to test\n */\nexport const isSingleItem = (item: unknown): boolean => (!Array.isArray(item));\n","\"use strict\";\nconst copySearchParams = (targetUrl, sourceUrl) => {\n  const searchParams = sourceUrl.split(\"?\")[1];\n  if (searchParams) {\n    targetUrl += `?${searchParams}`;\n  }\n  return targetUrl;\n};\n\nexport { copySearchParams };\n//# sourceMappingURL=copySearchParams.mjs.map\n","/**\n * Copies the search params from one url to another\n * @param targetUrl - the url to copy the search params to\n * @param sourceUrl - the url container the search params we want to copy\n * @returns the url with the search params copied\n */\nexport const copySearchParams = (targetUrl: string, sourceUrl: string) =>\n{\n    const searchParams = sourceUrl.split('?')[1];\n\n    if (searchParams)\n    {\n        targetUrl += `?${searchParams}`;\n    }\n\n    return targetUrl;\n};\n","import { Rectangle } from '../maths/shapes/Rectangle.mjs';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture.mjs';\n\n\"use strict\";\nconst _Spritesheet = class _Spritesheet {\n  /**\n   * @param texture - Reference to the source BaseTexture object.\n   * @param {object} data - Spritesheet image data.\n   */\n  constructor(texture, data) {\n    /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */\n    this.linkedSheets = [];\n    this._texture = texture instanceof Texture ? texture : null;\n    this.textureSource = texture.source;\n    this.textures = {};\n    this.animations = {};\n    this.data = data;\n    const metaResolution = parseFloat(data.meta.scale);\n    if (metaResolution) {\n      this.resolution = metaResolution;\n      texture.source.resolution = this.resolution;\n    } else {\n      this.resolution = texture.source._resolution;\n    }\n    this._frames = this.data.frames;\n    this._frameKeys = Object.keys(this._frames);\n    this._batchIndex = 0;\n    this._callback = null;\n  }\n  /**\n   * Parser spritesheet from loaded data. This is done asynchronously\n   * to prevent creating too many Texture within a single process.\n   */\n  parse() {\n    return new Promise((resolve) => {\n      this._callback = resolve;\n      this._batchIndex = 0;\n      if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {\n        this._processFrames(0);\n        this._processAnimations();\n        this._parseComplete();\n      } else {\n        this._nextBatch();\n      }\n    });\n  }\n  /**\n   * Process a batch of frames\n   * @param initialFrameIndex - The index of frame to start.\n   */\n  _processFrames(initialFrameIndex) {\n    let frameIndex = initialFrameIndex;\n    const maxFrames = _Spritesheet.BATCH_SIZE;\n    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {\n      const i = this._frameKeys[frameIndex];\n      const data = this._frames[i];\n      const rect = data.frame;\n      if (rect) {\n        let frame = null;\n        let trim = null;\n        const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;\n        const orig = new Rectangle(\n          0,\n          0,\n          Math.floor(sourceSize.w) / this.resolution,\n          Math.floor(sourceSize.h) / this.resolution\n        );\n        if (data.rotated) {\n          frame = new Rectangle(\n            Math.floor(rect.x) / this.resolution,\n            Math.floor(rect.y) / this.resolution,\n            Math.floor(rect.h) / this.resolution,\n            Math.floor(rect.w) / this.resolution\n          );\n        } else {\n          frame = new Rectangle(\n            Math.floor(rect.x) / this.resolution,\n            Math.floor(rect.y) / this.resolution,\n            Math.floor(rect.w) / this.resolution,\n            Math.floor(rect.h) / this.resolution\n          );\n        }\n        if (data.trimmed !== false && data.spriteSourceSize) {\n          trim = new Rectangle(\n            Math.floor(data.spriteSourceSize.x) / this.resolution,\n            Math.floor(data.spriteSourceSize.y) / this.resolution,\n            Math.floor(rect.w) / this.resolution,\n            Math.floor(rect.h) / this.resolution\n          );\n        }\n        this.textures[i] = new Texture({\n          source: this.textureSource,\n          frame,\n          orig,\n          trim,\n          rotate: data.rotated ? 2 : 0,\n          defaultAnchor: data.anchor,\n          defaultBorders: data.borders,\n          label: i.toString()\n        });\n      }\n      frameIndex++;\n    }\n  }\n  /** Parse animations config. */\n  _processAnimations() {\n    const animations = this.data.animations || {};\n    for (const animName in animations) {\n      this.animations[animName] = [];\n      for (let i = 0; i < animations[animName].length; i++) {\n        const frameName = animations[animName][i];\n        this.animations[animName].push(this.textures[frameName]);\n      }\n    }\n  }\n  /** The parse has completed. */\n  _parseComplete() {\n    const callback = this._callback;\n    this._callback = null;\n    this._batchIndex = 0;\n    callback.call(this, this.textures);\n  }\n  /** Begin the next batch of textures. */\n  _nextBatch() {\n    this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);\n    this._batchIndex++;\n    setTimeout(() => {\n      if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {\n        this._nextBatch();\n      } else {\n        this._processAnimations();\n        this._parseComplete();\n      }\n    }, 0);\n  }\n  /**\n   * Destroy Spritesheet and don't use after this.\n   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n   */\n  destroy(destroyBase = false) {\n    for (const i in this.textures) {\n      this.textures[i].destroy();\n    }\n    this._frames = null;\n    this._frameKeys = null;\n    this.data = null;\n    this.textures = null;\n    if (destroyBase) {\n      this._texture?.destroy();\n      this.textureSource.destroy();\n    }\n    this._texture = null;\n    this.textureSource = null;\n    this.linkedSheets = [];\n  }\n};\n/** The maximum number of Textures to build per process. */\n_Spritesheet.BATCH_SIZE = 1e3;\nlet Spritesheet = _Spritesheet;\n\nexport { Spritesheet };\n//# sourceMappingURL=Spritesheet.mjs.map\n","import { Rectangle } from '../maths/shapes/Rectangle';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\n\nimport type { PointData } from '../maths/point/PointData';\nimport type { TextureSource } from '../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { BindableTexture, TextureBorders } from '../rendering/renderers/shared/texture/Texture';\nimport type { Dict } from '../utils/types';\n\n/**\n * Represents the JSON data for a spritesheet atlas.\n * @memberof assets\n */\nexport interface SpritesheetFrameData\n{\n    /** The frame rectangle of the texture. */\n    frame: {\n        x: number;\n        y: number;\n        w: number;\n        h: number;\n    };\n    /** Whether the texture is trimmed. */\n    trimmed?: boolean;\n    /** Whether the texture is rotated. */\n    rotated?: boolean;\n    /** The source size of the texture. */\n    sourceSize?: {\n        w: number;\n        h: number;\n    };\n    /** The sprite source size. */\n    spriteSourceSize?: {\n        h?: number;\n        w?: number;\n        x: number;\n        y: number;\n    };\n    /** The anchor point of the texture. */\n    anchor?: PointData;\n    /** The 9-slice borders of the texture. */\n    borders?: TextureBorders\n}\n\n/**\n * Atlas format.\n * @memberof assets\n */\nexport interface SpritesheetData\n{\n    /** The frames of the atlas. */\n    frames: Dict<SpritesheetFrameData>;\n    /** The animations of the atlas. */\n    animations?: Dict<string[]>;\n    /** The meta data of the atlas. */\n    meta: {\n        app?: string;\n        format?: string;\n        frameTags?: {\n            from: number;\n            name: string;\n            to: number;\n            direction: string;\n        }[];\n        image?: string;\n        layers?: {\n            blendMode: string;\n            name: string;\n            opacity: number;\n        }[];\n        scale: number | string;\n        size?: {\n            h: number;\n            w: number;\n        };\n        slices?: {\n            color: string;\n            name: string;\n            keys: {\n                frame: number,\n                bounds: {\n                    x: number;\n                    y: number;\n                    w: number;\n                    h: number;\n                };\n            }[];\n        }[];\n        // eslint-disable-next-line camelcase\n        related_multi_packs?: string[];\n        version?: string;\n    };\n}\n\n/**\n * Utility class for maintaining reference to a collection\n * of Textures on a single Spritesheet.\n *\n * To access a sprite sheet from your code you may pass its JSON data file to Pixi's loader:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * const sheet = await Assets.load('images/spritesheet.json');\n * ```\n *\n * Alternately, you may circumvent the loader by instantiating the Spritesheet directly:\n *\n * ```js\n * import { Spritesheet } from 'pixi.js';\n *\n * const sheet = new Spritesheet(texture, spritesheetData);\n * await sheet.parse();\n * console.log('Spritesheet ready to use!');\n * ```\n *\n * With the `sheet.textures` you can create Sprite objects, and `sheet.animations` can be used to create an AnimatedSprite.\n *\n * Here's an example of a sprite sheet JSON data file:\n * ```json\n * {\n *     \"frames\": {\n *         \"enemy1.png\":\n *         {\n *             \"frame\": {\"x\":103,\"y\":1,\"w\":32,\"h\":32},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":32,\"h\":32},\n *             \"sourceSize\": {\"w\":32,\"h\":32},\n *             \"anchor\": {\"x\":16,\"y\":16}\n *         },\n *         \"enemy2.png\":\n *         {\n *             \"frame\": {\"x\":103,\"y\":35,\"w\":32,\"h\":32},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":32,\"h\":32},\n *             \"sourceSize\": {\"w\":32,\"h\":32},\n *             \"anchor\": {\"x\":16,\"y\":16}\n *         },\n *         \"button.png\":\n *         {\n *             \"frame\": {\"x\":1,\"y\":1,\"w\":100,\"h\":100},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":100,\"h\":100},\n *             \"sourceSize\": {\"w\":100,\"h\":100},\n *             \"anchor\": {\"x\":0,\"y\":0},\n *             \"borders\": {\"left\":35,\"top\":35,\"right\":35,\"bottom\":35}\n *         }\n *     },\n *\n *     \"animations\": {\n *         \"enemy\": [\"enemy1.png\",\"enemy2.png\"]\n *     },\n *\n *     \"meta\": {\n *         \"image\": \"sheet.png\",\n *         \"format\": \"RGBA8888\",\n *         \"size\": {\"w\":136,\"h\":102},\n *         \"scale\": \"1\"\n *     }\n * }\n * ```\n * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},\n * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.\n * Default anchor points (see {@link Texture#defaultAnchor}), default 9-slice borders\n * (see {@link Texture#defaultBorders}) and grouping of animation sprites are currently only\n * supported by TexturePacker.\n *\n * Alternative ways for loading spritesheet image if you need more control:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * const sheetTexture = await Assets.load('images/spritesheet.png');\n * Assets.add({\n *     alias: 'atlas',\n *     src: 'images/spritesheet.json'\n *     data: {texture: sheetTexture} // using of preloaded texture\n * });\n * const sheet = await Assets.load('atlas')\n * ```\n *\n * or:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * Assets.add({\n *     alias: 'atlas',\n *     src: 'images/spritesheet.json'\n *     data: {imageFilename: 'my-spritesheet.2x.avif'} // using of custom filename located in \"images/my-spritesheet.2x.avif\"\n * });\n * const sheet = await Assets.load('atlas')\n * ```\n * @memberof assets\n */\nexport class Spritesheet<S extends SpritesheetData = SpritesheetData>\n{\n    /** The maximum number of Textures to build per process. */\n    public static readonly BATCH_SIZE = 1000;\n\n    /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */\n    public linkedSheets: Spritesheet<S>[] = [];\n\n    /** Reference to ths source texture. */\n    public textureSource: TextureSource;\n\n    /**\n     * A map containing all textures of the sprite sheet.\n     * Can be used to create a {@link Sprite|Sprite}:\n     * @example\n     * import { Sprite } from 'pixi.js';\n     *\n     * new Sprite(sheet.textures['image.png']);\n     */\n    public textures: Record<keyof S['frames'], Texture>;\n\n    /**\n     * A map containing the textures for each animation.\n     * Can be used to create an {@link AnimatedSprite|AnimatedSprite}:\n     * @example\n     * import { AnimatedSprite } from 'pixi.js';\n     *\n     * new AnimatedSprite(sheet.animations['anim_name']);\n     */\n    public animations: Record<keyof NonNullable<S['animations']>, Texture[]>;\n\n    /**\n     * Reference to the original JSON data.\n     * @type {object}\n     */\n    public data: S;\n\n    /** The resolution of the spritesheet. */\n    public resolution: number;\n\n    /**\n     * Reference to original source image from the Loader. This reference is retained so we\n     * can destroy the Texture later on. It is never used internally.\n     */\n    private _texture: Texture;\n\n    /**\n     * Map of spritesheet frames.\n     * @type {object}\n     */\n    private _frames: S['frames'];\n\n    /** Collection of frame names. */\n    private _frameKeys: (keyof S['frames'])[];\n\n    /** Current batch index being processed. */\n    private _batchIndex: number;\n\n    /**\n     * Callback when parse is completed.\n     * @type {Function}\n     */\n    private _callback: (textures: Dict<Texture>) => void;\n\n    /**\n     * @param texture - Reference to the source BaseTexture object.\n     * @param {object} data - Spritesheet image data.\n     */\n    constructor(texture: BindableTexture, data: S)\n    {\n        this._texture = texture instanceof Texture ? texture : null;\n        this.textureSource = texture.source;\n        this.textures = {} as Record<keyof S['frames'], Texture>;\n        this.animations = {} as Record<keyof NonNullable<S['animations']>, Texture[]>;\n        this.data = data;\n\n        const metaResolution = parseFloat(data.meta.scale as string);\n\n        if (metaResolution)\n        {\n            this.resolution = metaResolution;\n            texture.source.resolution = this.resolution;\n        }\n        else\n        {\n            this.resolution = texture.source._resolution;\n        }\n\n        this._frames = this.data.frames;\n        this._frameKeys = Object.keys(this._frames);\n        this._batchIndex = 0;\n        this._callback = null;\n    }\n\n    /**\n     * Parser spritesheet from loaded data. This is done asynchronously\n     * to prevent creating too many Texture within a single process.\n     */\n    public parse(): Promise<Record<string, Texture>>\n    {\n        return new Promise((resolve) =>\n        {\n            this._callback = resolve;\n            this._batchIndex = 0;\n\n            if (this._frameKeys.length <= Spritesheet.BATCH_SIZE)\n            {\n                this._processFrames(0);\n                this._processAnimations();\n                this._parseComplete();\n            }\n            else\n            {\n                this._nextBatch();\n            }\n        });\n    }\n\n    /**\n     * Process a batch of frames\n     * @param initialFrameIndex - The index of frame to start.\n     */\n    private _processFrames(initialFrameIndex: number): void\n    {\n        let frameIndex = initialFrameIndex;\n        const maxFrames = Spritesheet.BATCH_SIZE;\n\n        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length)\n        {\n            const i = this._frameKeys[frameIndex];\n            const data = this._frames[i];\n            const rect = data.frame;\n\n            if (rect)\n            {\n                let frame = null;\n                let trim = null;\n                const sourceSize = data.trimmed !== false && data.sourceSize\n                    ? data.sourceSize : data.frame;\n\n                const orig = new Rectangle(\n                    0,\n                    0,\n                    Math.floor(sourceSize.w) / this.resolution,\n                    Math.floor(sourceSize.h) / this.resolution\n                );\n\n                if (data.rotated)\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.h) / this.resolution,\n                        Math.floor(rect.w) / this.resolution\n                    );\n                }\n                else\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                //  Check to see if the sprite is trimmed\n                if (data.trimmed !== false && data.spriteSourceSize)\n                {\n                    trim = new Rectangle(\n                        Math.floor(data.spriteSourceSize.x) / this.resolution,\n                        Math.floor(data.spriteSourceSize.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                this.textures[i] = new Texture({\n                    source: this.textureSource,\n\n                    frame,\n                    orig,\n                    trim,\n                    rotate: data.rotated ? 2 : 0,\n                    defaultAnchor: data.anchor,\n                    defaultBorders: data.borders,\n\n                    label: i.toString(),\n                });\n            }\n\n            frameIndex++;\n        }\n    }\n\n    /** Parse animations config. */\n    private _processAnimations(): void\n    {\n        const animations = this.data.animations || {};\n\n        for (const animName in animations)\n        {\n            this.animations[animName as keyof S['animations']] = [];\n            for (let i = 0; i < animations[animName].length; i++)\n            {\n                const frameName = animations[animName][i];\n\n                this.animations[animName].push(this.textures[frameName]);\n            }\n        }\n    }\n\n    /** The parse has completed. */\n    private _parseComplete(): void\n    {\n        const callback = this._callback;\n\n        this._callback = null;\n        this._batchIndex = 0;\n        callback.call(this, this.textures);\n    }\n\n    /** Begin the next batch of textures. */\n    private _nextBatch(): void\n    {\n        this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);\n        this._batchIndex++;\n        setTimeout(() =>\n        {\n            if (this._batchIndex * Spritesheet.BATCH_SIZE < this._frameKeys.length)\n            {\n                this._nextBatch();\n            }\n            else\n            {\n                this._processAnimations();\n                this._parseComplete();\n            }\n        }, 0);\n    }\n\n    /**\n     * Destroy Spritesheet and don't use after this.\n     * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n     */\n    public destroy(destroyBase = false): void\n    {\n        for (const i in this.textures)\n        {\n            this.textures[i].destroy();\n        }\n        this._frames = null;\n        this._frameKeys = null;\n        this.data = null;\n        this.textures = null;\n        if (destroyBase)\n        {\n            this._texture?.destroy();\n            this.textureSource.destroy();\n        }\n        this._texture = null;\n        this.textureSource = null;\n        this.linkedSheets = [];\n    }\n}\n","import { extensions } from '../extensions/Extensions.mjs';\nimport { AlphaMask } from './mask/alpha/AlphaMask.mjs';\nimport { ColorMask } from './mask/color/ColorMask.mjs';\nimport { StencilMask } from './mask/stencil/StencilMask.mjs';\nimport { BufferImageSource } from './renderers/shared/texture/sources/BufferSource.mjs';\nimport { CanvasSource } from './renderers/shared/texture/sources/CanvasSource.mjs';\nimport { ImageSource } from './renderers/shared/texture/sources/ImageSource.mjs';\nimport { VideoSource } from './renderers/shared/texture/sources/VideoSource.mjs';\nimport './renderers/shared/texture/utils/textureFrom.mjs';\nimport './mask/MaskEffectManager.mjs';\n\n\"use strict\";\nextensions.add(AlphaMask, ColorMask, StencilMask, VideoSource, ImageSource, CanvasSource, BufferImageSource);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../extensions/Extensions';\nimport { AlphaMask } from './mask/alpha/AlphaMask';\nimport { ColorMask } from './mask/color/ColorMask';\nimport { StencilMask } from './mask/stencil/StencilMask';\nimport { BufferImageSource } from './renderers/shared/texture/sources/BufferSource';\nimport { CanvasSource } from './renderers/shared/texture/sources/CanvasSource';\nimport { ImageSource } from './renderers/shared/texture/sources/ImageSource';\nimport { VideoSource } from './renderers/shared/texture/sources/VideoSource';\nimport './renderers/shared/texture/utils/textureFrom';\nimport './mask/MaskEffectManager';\n\n/**\n * The rendering namespace contains all the classes used for core rendering in PixiJS\n * this includes all the lower level resources such as Textures, Shaders, State, Buffers,\n * Geometry and the systems required to use them. This covers WebGL and WebGPU and their shared classes.\n *\n * To automatically create a renderer based on available resources, see the {@link rendering.autoDetectRenderer} function.\n * @namespace rendering\n */\n\nextensions.add(AlphaMask, ColorMask, StencilMask, VideoSource, ImageSource, CanvasSource, BufferImageSource);\n\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Sprite } from '../../../scene/sprite/Sprite.mjs';\nimport { addMaskBounds } from '../utils/addMaskBounds.mjs';\nimport { addMaskLocalBounds } from '../utils/addMaskLocalBounds.mjs';\n\n\"use strict\";\nclass AlphaMask {\n  constructor(options) {\n    this.priority = 0;\n    this.pipe = \"alphaMask\";\n    if (options?.mask) {\n      this.init(options.mask);\n    }\n  }\n  init(mask) {\n    this.mask = mask;\n    this.renderMaskToTexture = !(mask instanceof Sprite);\n    this.mask.renderable = this.renderMaskToTexture;\n    this.mask.includeInBuild = !this.renderMaskToTexture;\n    this.mask.measurable = false;\n  }\n  reset() {\n    this.mask.measurable = true;\n    this.mask = null;\n  }\n  addBounds(bounds, skipUpdateTransform) {\n    addMaskBounds(this.mask, bounds, skipUpdateTransform);\n  }\n  addLocalBounds(bounds, localRoot) {\n    addMaskLocalBounds(this.mask, bounds, localRoot);\n  }\n  containsPoint(point, hitTestFn) {\n    const mask = this.mask;\n    return hitTestFn(mask, point);\n  }\n  destroy() {\n    this.reset();\n  }\n  static test(mask) {\n    return mask instanceof Sprite;\n  }\n}\nAlphaMask.extension = ExtensionType.MaskEffect;\n\nexport { AlphaMask };\n//# sourceMappingURL=AlphaMask.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Sprite } from '../../../scene/sprite/Sprite';\nimport { addMaskBounds } from '../utils/addMaskBounds';\nimport { addMaskLocalBounds } from '../utils/addMaskLocalBounds';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { Point } from '../../../maths/point/Point';\nimport type { Bounds } from '../../../scene/container/bounds/Bounds';\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\n\nexport class AlphaMask implements Effect, PoolItem\n{\n    public static extension: ExtensionMetadata = ExtensionType.MaskEffect;\n\n    public priority = 0;\n    public mask: Container;\n    public pipe = 'alphaMask';\n    public renderMaskToTexture: boolean;\n\n    constructor(options?: {mask: Container})\n    {\n        if (options?.mask)\n        {\n            this.init(options.mask);\n        }\n    }\n\n    public init(mask: Container): void\n    {\n        this.mask = mask;\n\n        // TODO - might want to change this to adjust on the fly\n        // user may add children to the sprite..\n        this.renderMaskToTexture = !(mask instanceof Sprite);\n\n        this.mask.renderable = this.renderMaskToTexture;\n        this.mask.includeInBuild = !this.renderMaskToTexture;\n\n        this.mask.measurable = false;\n    }\n\n    public reset()\n    {\n        this.mask.measurable = true;\n        this.mask = null;\n    }\n\n    public addBounds(bounds: Bounds, skipUpdateTransform?: boolean): void\n    {\n        addMaskBounds(this.mask, bounds, skipUpdateTransform);\n    }\n\n    public addLocalBounds(bounds: Bounds, localRoot: Container): void\n    {\n        addMaskLocalBounds(this.mask, bounds, localRoot);\n    }\n\n    public containsPoint(point: Point, hitTestFn: (container: Container, point: Point) => boolean): boolean\n    {\n        const mask = this.mask as any;\n\n        // if the point is in the mask, yay!\n        return hitTestFn(mask, point);\n    }\n\n    public destroy(): void\n    {\n        this.reset();\n    }\n\n    public static test(mask: any): boolean\n    {\n        return mask instanceof Sprite;\n    }\n}\n","import { Bounds } from '../../../scene/container/bounds/Bounds.mjs';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds.mjs';\n\n\"use strict\";\nconst tempBounds = new Bounds();\nfunction addMaskBounds(mask, bounds, skipUpdateTransform) {\n  const boundsToMask = tempBounds;\n  mask.measurable = true;\n  getGlobalBounds(mask, skipUpdateTransform, boundsToMask);\n  bounds.addBoundsMask(boundsToMask);\n  mask.measurable = false;\n}\n\nexport { addMaskBounds };\n//# sourceMappingURL=addMaskBounds.mjs.map\n","import { Bounds } from '../../../scene/container/bounds/Bounds';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds';\n\nimport type { Container } from '../../../scene/container/Container';\n\nconst tempBounds = new Bounds();\n\nexport function addMaskBounds(mask: Container, bounds: Bounds, skipUpdateTransform: boolean): void\n{\n    const boundsToMask = tempBounds;\n\n    mask.measurable = true;\n\n    getGlobalBounds(mask, skipUpdateTransform, boundsToMask);\n\n    bounds.addBoundsMask(boundsToMask);\n\n    mask.measurable = false;\n}\n\n","import { getLocalBounds } from '../../../scene/container/bounds/getLocalBounds.mjs';\nimport { boundsPool, matrixPool } from '../../../scene/container/bounds/utils/matrixAndBoundsPool.mjs';\nimport { warn } from '../../../utils/logging/warn.mjs';\n\n\"use strict\";\nfunction addMaskLocalBounds(mask, bounds, localRoot) {\n  const boundsToMask = boundsPool.get();\n  mask.measurable = true;\n  const tempMatrix = matrixPool.get().identity();\n  const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix);\n  getLocalBounds(mask, boundsToMask, relativeMask);\n  mask.measurable = false;\n  bounds.addBoundsMask(boundsToMask);\n  matrixPool.return(tempMatrix);\n  boundsPool.return(boundsToMask);\n}\nfunction getMatrixRelativeToParent(target, root, matrix) {\n  if (!target) {\n    warn(\"Mask bounds, renderable is not inside the root container\");\n    return matrix;\n  }\n  if (target !== root) {\n    getMatrixRelativeToParent(target.parent, root, matrix);\n    target.updateLocalTransform();\n    matrix.append(target.localTransform);\n  }\n  return matrix;\n}\n\nexport { addMaskLocalBounds, getMatrixRelativeToParent };\n//# sourceMappingURL=addMaskLocalBounds.mjs.map\n","import { getLocalBounds } from '../../../scene/container/bounds/getLocalBounds';\nimport { boundsPool, matrixPool } from '../../../scene/container/bounds/utils/matrixAndBoundsPool';\nimport { warn } from '../../../utils/logging/warn';\n\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Bounds } from '../../../scene/container/bounds/Bounds';\nimport type { Container } from '../../../scene/container/Container';\n\nexport function addMaskLocalBounds(mask: Container, bounds: Bounds, localRoot: Container): void\n{\n    const boundsToMask = boundsPool.get();\n\n    mask.measurable = true;\n\n    const tempMatrix = matrixPool.get().identity();\n\n    const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix);\n\n    getLocalBounds(mask, boundsToMask, relativeMask);\n\n    mask.measurable = false;\n\n    bounds.addBoundsMask(boundsToMask);\n\n    matrixPool.return(tempMatrix);\n    boundsPool.return(boundsToMask);\n}\n\nexport function getMatrixRelativeToParent(target: Container, root: Container, matrix: Matrix): Matrix\n{\n    if (!target)\n    {\n        // we have reach the top of the tree!\n        // #if _DEBUG\n        warn('Mask bounds, renderable is not inside the root container');\n        // #endif\n\n        return matrix;\n    }\n\n    if (target !== root)\n    {\n        getMatrixRelativeToParent(target.parent, root, matrix);\n\n        target.updateLocalTransform();\n\n        matrix.append(target.localTransform);\n    }\n\n    return matrix;\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass ColorMask {\n  constructor(options) {\n    this.priority = 0;\n    this.pipe = \"colorMask\";\n    if (options?.mask) {\n      this.init(options.mask);\n    }\n  }\n  init(mask) {\n    this.mask = mask;\n  }\n  destroy() {\n  }\n  static test(mask) {\n    return typeof mask === \"number\";\n  }\n}\nColorMask.extension = ExtensionType.MaskEffect;\n\nexport { ColorMask };\n//# sourceMappingURL=ColorMask.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\n\nexport class ColorMask implements Effect, PoolItem\n{\n    public static extension: ExtensionMetadata = ExtensionType.MaskEffect;\n\n    public priority = 0;\n    public mask: number;\n    public pipe = 'colorMask';\n\n    constructor(options: {mask: number})\n    {\n        if (options?.mask)\n        {\n            this.init(options.mask);\n        }\n    }\n\n    public init(mask: number): void\n    {\n        this.mask = mask;\n    }\n\n    public destroy(): void\n    {\n        // nothing to destroy\n    }\n\n    public static test(mask: any): boolean\n    {\n        return typeof mask === 'number';\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Container } from '../../../scene/container/Container.mjs';\nimport { addMaskBounds } from '../utils/addMaskBounds.mjs';\nimport { addMaskLocalBounds } from '../utils/addMaskLocalBounds.mjs';\n\n\"use strict\";\nclass StencilMask {\n  constructor(options) {\n    this.priority = 0;\n    this.pipe = \"stencilMask\";\n    if (options?.mask) {\n      this.init(options.mask);\n    }\n  }\n  init(mask) {\n    this.mask = mask;\n    this.mask.includeInBuild = false;\n    this.mask.measurable = false;\n  }\n  reset() {\n    this.mask.measurable = true;\n    this.mask.includeInBuild = true;\n    this.mask = null;\n  }\n  addBounds(bounds, skipUpdateTransform) {\n    addMaskBounds(this.mask, bounds, skipUpdateTransform);\n  }\n  addLocalBounds(bounds, localRoot) {\n    addMaskLocalBounds(this.mask, bounds, localRoot);\n  }\n  containsPoint(point, hitTestFn) {\n    const mask = this.mask;\n    return hitTestFn(mask, point);\n  }\n  destroy() {\n    this.reset();\n  }\n  static test(mask) {\n    return mask instanceof Container;\n  }\n}\nStencilMask.extension = ExtensionType.MaskEffect;\n\nexport { StencilMask };\n//# sourceMappingURL=StencilMask.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Container } from '../../../scene/container/Container';\nimport { addMaskBounds } from '../utils/addMaskBounds';\nimport { addMaskLocalBounds } from '../utils/addMaskLocalBounds';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { Point } from '../../../maths/point/Point';\nimport type { Bounds } from '../../../scene/container/bounds/Bounds';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\n\nexport class StencilMask implements Effect, PoolItem\n{\n    public static extension: ExtensionMetadata = ExtensionType.MaskEffect;\n\n    public priority = 0;\n    public mask: Container;\n    public pipe = 'stencilMask';\n\n    constructor(options: {mask: Container})\n    {\n        if (options?.mask)\n        {\n            this.init(options.mask);\n        }\n    }\n\n    public init(mask: Container): void\n    {\n        this.mask = mask;\n        this.mask.includeInBuild = false;\n        this.mask.measurable = false;\n    }\n\n    public reset()\n    {\n        this.mask.measurable = true;\n        this.mask.includeInBuild = true;\n        this.mask = null;\n    }\n\n    public addBounds(bounds: Bounds, skipUpdateTransform: boolean): void\n    {\n        addMaskBounds(this.mask, bounds, skipUpdateTransform);\n    }\n\n    public addLocalBounds(bounds: Bounds, localRoot: Container): void\n    {\n        addMaskLocalBounds(this.mask, bounds, localRoot);\n    }\n\n    public containsPoint(point: Point, hitTestFn: (container: Container, point: Point) => boolean): boolean\n    {\n        const mask = this.mask as any;\n\n        // if the point is in the mask, yay!\n        return hitTestFn(mask, point);\n    }\n\n    public destroy(): void\n    {\n        this.reset();\n    }\n\n    public static test(mask: any): boolean\n    {\n        return mask instanceof Container;\n    }\n}\n","import { DOMAdapter } from '../../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../../extensions/Extensions.mjs';\nimport { warn } from '../../../../../utils/logging/warn.mjs';\nimport { TextureSource } from './TextureSource.mjs';\n\n\"use strict\";\nclass ImageSource extends TextureSource {\n  constructor(options) {\n    if (options.resource && (globalThis.HTMLImageElement && options.resource instanceof HTMLImageElement)) {\n      const canvas = DOMAdapter.get().createCanvas(options.resource.width, options.resource.height);\n      const context = canvas.getContext(\"2d\");\n      context.drawImage(options.resource, 0, 0);\n      options.resource = canvas;\n      warn(\"ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.\");\n    }\n    super(options);\n    this.uploadMethodId = \"image\";\n    this.autoGarbageCollect = true;\n  }\n  static test(resource) {\n    return globalThis.HTMLImageElement && resource instanceof HTMLImageElement || typeof ImageBitmap !== \"undefined\" && resource instanceof ImageBitmap;\n  }\n}\nImageSource.extension = ExtensionType.TextureSource;\n\nexport { ImageSource };\n//# sourceMappingURL=ImageSource.mjs.map\n","import { DOMAdapter } from '../../../../../environment/adapter';\nimport { ExtensionType } from '../../../../../extensions/Extensions';\nimport { warn } from '../../../../../utils/logging/warn';\nimport { TextureSource } from './TextureSource';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { TextureSourceOptions } from './TextureSource';\n\nexport type ImageResource =\nImageBitmap\n| HTMLCanvasElement\n| OffscreenCanvas\n| ICanvas\n| VideoFrame\n| HTMLImageElement\n| HTMLVideoElement;\n\nexport class ImageSource extends TextureSource<ImageResource>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n    public uploadMethodId = 'image';\n\n    constructor(options: TextureSourceOptions<ImageResource>)\n    {\n        if (options.resource && (globalThis.HTMLImageElement && options.resource instanceof HTMLImageElement))\n        {\n            const canvas = DOMAdapter.get().createCanvas(options.resource.width, options.resource.height);\n            const context = canvas.getContext('2d');\n\n            context.drawImage(options.resource, 0, 0);\n            options.resource = canvas;\n\n            // #if _DEBUG\n            warn('ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.');\n            // #endif\n        }\n\n        super(options);\n\n        this.autoGarbageCollect = true;\n    }\n\n    public static test(resource: any): resource is ImageResource\n    {\n        return (globalThis.HTMLImageElement && resource instanceof HTMLImageElement)\n        || (typeof ImageBitmap !== 'undefined' && resource instanceof ImageBitmap);\n    }\n}\n","import { ExtensionType } from '../../../../../extensions/Extensions.mjs';\nimport { Ticker } from '../../../../../ticker/Ticker.mjs';\nimport { detectVideoAlphaMode } from '../../../../../utils/browser/detectVideoAlphaMode.mjs';\nimport { TextureSource } from './TextureSource.mjs';\n\n\"use strict\";\nconst _VideoSource = class _VideoSource extends TextureSource {\n  constructor(options) {\n    super(options);\n    // Public\n    /** Whether or not the video is ready to play. */\n    this.isReady = false;\n    /** The upload method for this texture. */\n    this.uploadMethodId = \"video\";\n    options = {\n      ..._VideoSource.defaultOptions,\n      ...options\n    };\n    this._autoUpdate = true;\n    this._isConnectedToTicker = false;\n    this._updateFPS = options.updateFPS || 0;\n    this._msToNextUpdate = 0;\n    this.autoPlay = options.autoPlay !== false;\n    this.alphaMode = options.alphaMode ?? \"premultiply-alpha-on-upload\";\n    this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);\n    this._videoFrameRequestCallbackHandle = null;\n    this._load = null;\n    this._resolve = null;\n    this._reject = null;\n    this._onCanPlay = this._onCanPlay.bind(this);\n    this._onCanPlayThrough = this._onCanPlayThrough.bind(this);\n    this._onError = this._onError.bind(this);\n    this._onPlayStart = this._onPlayStart.bind(this);\n    this._onPlayStop = this._onPlayStop.bind(this);\n    this._onSeeked = this._onSeeked.bind(this);\n    if (options.autoLoad !== false) {\n      void this.load();\n    }\n  }\n  /** Update the video frame if the source is not destroyed and meets certain conditions. */\n  updateFrame() {\n    if (this.destroyed) {\n      return;\n    }\n    if (this._updateFPS) {\n      const elapsedMS = Ticker.shared.elapsedMS * this.resource.playbackRate;\n      this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n    }\n    if (!this._updateFPS || this._msToNextUpdate <= 0) {\n      this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;\n    }\n    if (this.isValid) {\n      this.update();\n    }\n  }\n  /** Callback to update the video frame and potentially request the next frame update. */\n  _videoFrameRequestCallback() {\n    this.updateFrame();\n    if (this.destroyed) {\n      this._videoFrameRequestCallbackHandle = null;\n    } else {\n      this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(\n        this._videoFrameRequestCallback\n      );\n    }\n  }\n  /**\n   * Checks if the resource has valid dimensions.\n   * @returns {boolean} True if width and height are set, otherwise false.\n   */\n  get isValid() {\n    return !!this.resource.videoWidth && !!this.resource.videoHeight;\n  }\n  /**\n   * Start preloading the video resource.\n   * @returns {Promise<this>} Handle the validate event\n   */\n  async load() {\n    if (this._load) {\n      return this._load;\n    }\n    const source = this.resource;\n    const options = this.options;\n    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {\n      source.complete = true;\n    }\n    source.addEventListener(\"play\", this._onPlayStart);\n    source.addEventListener(\"pause\", this._onPlayStop);\n    source.addEventListener(\"seeked\", this._onSeeked);\n    if (!this._isSourceReady()) {\n      if (!options.preload) {\n        source.addEventListener(\"canplay\", this._onCanPlay);\n      }\n      source.addEventListener(\"canplaythrough\", this._onCanPlayThrough);\n      source.addEventListener(\"error\", this._onError, true);\n    } else {\n      this._mediaReady();\n    }\n    this.alphaMode = await detectVideoAlphaMode();\n    this._load = new Promise((resolve, reject) => {\n      if (this.isValid) {\n        resolve(this);\n      } else {\n        this._resolve = resolve;\n        this._reject = reject;\n        if (options.preloadTimeoutMs !== void 0) {\n          this._preloadTimeout = setTimeout(() => {\n            this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));\n          });\n        }\n        source.load();\n      }\n    });\n    return this._load;\n  }\n  /**\n   * Handle video error events.\n   * @param event - The error event\n   */\n  _onError(event) {\n    this.resource.removeEventListener(\"error\", this._onError, true);\n    this.emit(\"error\", event);\n    if (this._reject) {\n      this._reject(event);\n      this._reject = null;\n      this._resolve = null;\n    }\n  }\n  /**\n   * Checks if the underlying source is playing.\n   * @returns True if playing.\n   */\n  _isSourcePlaying() {\n    const source = this.resource;\n    return !source.paused && !source.ended;\n  }\n  /**\n   * Checks if the underlying source is ready for playing.\n   * @returns True if ready.\n   */\n  _isSourceReady() {\n    const source = this.resource;\n    return source.readyState > 2;\n  }\n  /** Runs the update loop when the video is ready to play. */\n  _onPlayStart() {\n    if (!this.isValid) {\n      this._mediaReady();\n    }\n    this._configureAutoUpdate();\n  }\n  /** Stops the update loop when a pause event is triggered. */\n  _onPlayStop() {\n    this._configureAutoUpdate();\n  }\n  /** Handles behavior when the video completes seeking to the current playback position. */\n  _onSeeked() {\n    if (this._autoUpdate && !this._isSourcePlaying()) {\n      this._msToNextUpdate = 0;\n      this.updateFrame();\n      this._msToNextUpdate = 0;\n    }\n  }\n  _onCanPlay() {\n    const source = this.resource;\n    source.removeEventListener(\"canplay\", this._onCanPlay);\n    this._mediaReady();\n  }\n  _onCanPlayThrough() {\n    const source = this.resource;\n    source.removeEventListener(\"canplaythrough\", this._onCanPlay);\n    if (this._preloadTimeout) {\n      clearTimeout(this._preloadTimeout);\n      this._preloadTimeout = void 0;\n    }\n    this._mediaReady();\n  }\n  /** Fired when the video is loaded and ready to play. */\n  _mediaReady() {\n    const source = this.resource;\n    if (this.isValid) {\n      this.isReady = true;\n      this.resize(source.videoWidth, source.videoHeight);\n    }\n    this._msToNextUpdate = 0;\n    this.updateFrame();\n    this._msToNextUpdate = 0;\n    if (this._resolve) {\n      this._resolve(this);\n      this._resolve = null;\n      this._reject = null;\n    }\n    if (this._isSourcePlaying()) {\n      this._onPlayStart();\n    } else if (this.autoPlay) {\n      void this.resource.play();\n    }\n  }\n  /** Cleans up resources and event listeners associated with this texture. */\n  destroy() {\n    this._configureAutoUpdate();\n    const source = this.resource;\n    if (source) {\n      source.removeEventListener(\"play\", this._onPlayStart);\n      source.removeEventListener(\"pause\", this._onPlayStop);\n      source.removeEventListener(\"seeked\", this._onSeeked);\n      source.removeEventListener(\"canplay\", this._onCanPlay);\n      source.removeEventListener(\"canplaythrough\", this._onCanPlayThrough);\n      source.removeEventListener(\"error\", this._onError, true);\n      source.pause();\n      source.src = \"\";\n      source.load();\n    }\n    super.destroy();\n  }\n  /** Should the base texture automatically update itself, set to true by default. */\n  get autoUpdate() {\n    return this._autoUpdate;\n  }\n  set autoUpdate(value) {\n    if (value !== this._autoUpdate) {\n      this._autoUpdate = value;\n      this._configureAutoUpdate();\n    }\n  }\n  /**\n   * How many times a second to update the texture from the video.\n   * Leave at 0 to update at every render.\n   * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n   */\n  get updateFPS() {\n    return this._updateFPS;\n  }\n  set updateFPS(value) {\n    if (value !== this._updateFPS) {\n      this._updateFPS = value;\n      this._configureAutoUpdate();\n    }\n  }\n  /**\n   * Configures the updating mechanism based on the current state and settings.\n   *\n   * This method decides between using the browser's native video frame callback or a custom ticker\n   * for updating the video frame. It ensures optimal performance and responsiveness\n   * based on the video's state, playback status, and the desired frames-per-second setting.\n   *\n   * - If `_autoUpdate` is enabled and the video source is playing:\n   *   - It will prefer the native video frame callback if available and no specific FPS is set.\n   *   - Otherwise, it will use a custom ticker for manual updates.\n   * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.\n   */\n  _configureAutoUpdate() {\n    if (this._autoUpdate && this._isSourcePlaying()) {\n      if (!this._updateFPS && this.source.requestVideoFrameCallback) {\n        if (this._isConnectedToTicker) {\n          Ticker.shared.remove(this.updateFrame, this);\n          this._isConnectedToTicker = false;\n          this._msToNextUpdate = 0;\n        }\n        if (this._videoFrameRequestCallbackHandle === null) {\n          this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(\n            this._videoFrameRequestCallback\n          );\n        }\n      } else {\n        if (this._videoFrameRequestCallbackHandle !== null) {\n          this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n          this._videoFrameRequestCallbackHandle = null;\n        }\n        if (!this._isConnectedToTicker) {\n          Ticker.shared.add(this.updateFrame, this);\n          this._isConnectedToTicker = true;\n          this._msToNextUpdate = 0;\n        }\n      }\n    } else {\n      if (this._videoFrameRequestCallbackHandle !== null) {\n        this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n        this._videoFrameRequestCallbackHandle = null;\n      }\n      if (this._isConnectedToTicker) {\n        Ticker.shared.remove(this.updateFrame, this);\n        this._isConnectedToTicker = false;\n        this._msToNextUpdate = 0;\n      }\n    }\n  }\n  static test(resource) {\n    return globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement || globalThis.VideoFrame && resource instanceof VideoFrame;\n  }\n};\n_VideoSource.extension = ExtensionType.TextureSource;\n/** The default options for video sources. */\n_VideoSource.defaultOptions = {\n  ...TextureSource.defaultOptions,\n  /** If true, the video will start loading immediately. */\n  autoLoad: true,\n  /** If true, the video will start playing as soon as it is loaded. */\n  autoPlay: true,\n  /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n  updateFPS: 0,\n  /** If true, the video will be loaded with the `crossorigin` attribute. */\n  crossorigin: true,\n  /** If true, the video will loop when it ends. */\n  loop: false,\n  /** If true, the video will be muted. */\n  muted: true,\n  /** If true, the video will play inline. */\n  playsinline: true,\n  /** If true, the video will be preloaded. */\n  preload: false\n};\n/**\n * Map of video MIME types that can't be directly derived from file extensions.\n * @readonly\n */\n_VideoSource.MIME_TYPES = {\n  ogv: \"video/ogg\",\n  mov: \"video/quicktime\",\n  m4v: \"video/mp4\"\n};\nlet VideoSource = _VideoSource;\n\nexport { VideoSource };\n//# sourceMappingURL=VideoSource.mjs.map\n","// VideoSource.ts\n\nimport { ExtensionType } from '../../../../../extensions/Extensions';\nimport { Ticker } from '../../../../../ticker/Ticker';\nimport { detectVideoAlphaMode } from '../../../../../utils/browser/detectVideoAlphaMode';\nimport { TextureSource } from './TextureSource';\n\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { Dict } from '../../../../../utils/types';\nimport type { ALPHA_MODES } from '../const';\nimport type { TextureSourceOptions } from './TextureSource';\n\ntype VideoResource = HTMLVideoElement;\n\n/**\n * Options for video sources.\n * @memberof rendering\n */\nexport interface VideoSourceOptions extends TextureSourceOptions<VideoResource>\n{\n    /** If true, the video will start loading immediately. */\n    autoLoad?: boolean;\n    /** If true, the video will start playing as soon as it is loaded. */\n    autoPlay?: boolean;\n    /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n    updateFPS?: number;\n    /** If true, the video will be loaded with the `crossorigin` attribute. */\n    crossorigin?: boolean | string;\n    /** If true, the video will loop when it ends. */\n    loop?: boolean;\n    /** If true, the video will be muted. */\n    muted?: boolean;\n    /** If true, the video will play inline. */\n    playsinline?: boolean;\n    /** If true, the video will be preloaded. */\n    preload?: boolean;\n    /** The time in milliseconds to wait for the video to preload before timing out. */\n    preloadTimeoutMs?: number;\n    /** The alpha mode of the video. */\n    alphaMode?: ALPHA_MODES;\n}\n\nexport interface VideoResourceOptionsElement\n{\n    src: string;\n    mime: string;\n}\n\n/**\n * A source for video-based textures.\n * @memberof rendering\n */\nexport class VideoSource extends TextureSource<VideoResource>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n\n    /** The default options for video sources. */\n    public static defaultOptions: VideoSourceOptions = {\n        ...TextureSource.defaultOptions,\n        /** If true, the video will start loading immediately. */\n        autoLoad: true,\n        /** If true, the video will start playing as soon as it is loaded. */\n        autoPlay: true,\n        /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n        updateFPS: 0,\n        /** If true, the video will be loaded with the `crossorigin` attribute. */\n        crossorigin: true,\n        /** If true, the video will loop when it ends. */\n        loop: false,\n        /** If true, the video will be muted. */\n        muted: true,\n        /** If true, the video will play inline. */\n        playsinline: true,\n        /** If true, the video will be preloaded. */\n        preload: false,\n    };\n\n    // Public\n    /** Whether or not the video is ready to play. */\n    public isReady = false;\n    /** The upload method for this texture. */\n    public uploadMethodId = 'video';\n\n    // Protected\n    /**\n     * When set to true will automatically play videos used by this texture once\n     * they are loaded. If false, it will not modify the playing state.\n     * @default true\n     */\n    protected autoPlay: boolean;\n\n    // Private\n    /**\n     * `true` to use Ticker.shared to auto update the base texture.\n     * @default true\n     */\n    private _autoUpdate: boolean;\n\n    /**\n     * `true` if the instance is currently connected to Ticker.shared to auto update the base texture.\n     * @default false\n     */\n    private _isConnectedToTicker: boolean;\n\n    /**\n     * Promise when loading.\n     * @default null\n     */\n    private _load: Promise<this>;\n\n    private _msToNextUpdate: number;\n    private _preloadTimeout: number;\n\n    /** Callback when completed with load. */\n    private _resolve: (value?: this | PromiseLike<this>) => void;\n    private _reject: (error: ErrorEvent) => void;\n\n    private _updateFPS: number;\n    private _videoFrameRequestCallbackHandle: number | null;\n\n    constructor(\n        options: VideoSourceOptions\n    )\n    {\n        super(options);\n\n        // Merge provided options with default ones\n        options = {\n            ...VideoSource.defaultOptions,\n            ...options\n        };\n\n        this._autoUpdate = true;\n        this._isConnectedToTicker = false;\n        this._updateFPS = options.updateFPS || 0;\n        this._msToNextUpdate = 0;\n        this.autoPlay = options.autoPlay !== false;\n        this.alphaMode = options.alphaMode ?? 'premultiply-alpha-on-upload';\n\n        // Binding for frame updates\n        this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);\n        this._videoFrameRequestCallbackHandle = null;\n\n        this._load = null;\n        this._resolve = null;\n        this._reject = null;\n\n        // Bind for listeners\n        this._onCanPlay = this._onCanPlay.bind(this);\n        this._onCanPlayThrough = this._onCanPlayThrough.bind(this);\n        this._onError = this._onError.bind(this);\n        this._onPlayStart = this._onPlayStart.bind(this);\n        this._onPlayStop = this._onPlayStop.bind(this);\n        this._onSeeked = this._onSeeked.bind(this);\n\n        if (options.autoLoad !== false)\n        {\n            void this.load();\n        }\n    }\n\n    /** Update the video frame if the source is not destroyed and meets certain conditions. */\n    protected updateFrame(): void\n    {\n        if (this.destroyed)\n        {\n            return;\n        }\n\n        if (this._updateFPS)\n        {\n            // Account for if video has had its playbackRate changed\n            const elapsedMS = Ticker.shared.elapsedMS * this.resource.playbackRate;\n\n            this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n        }\n\n        if (!this._updateFPS || this._msToNextUpdate <= 0)\n        {\n            this._msToNextUpdate = this._updateFPS ? Math.floor(1000 / this._updateFPS) : 0;\n        }\n\n        if (this.isValid)\n        {\n            this.update();\n        }\n    }\n\n    /** Callback to update the video frame and potentially request the next frame update. */\n    private _videoFrameRequestCallback(): void\n    {\n        this.updateFrame();\n\n        if (this.destroyed)\n        {\n            this._videoFrameRequestCallbackHandle = null;\n        }\n        else\n        {\n            this._videoFrameRequestCallbackHandle = (this.source as any).requestVideoFrameCallback(\n                this._videoFrameRequestCallback\n            );\n        }\n    }\n\n    /**\n     * Checks if the resource has valid dimensions.\n     * @returns {boolean} True if width and height are set, otherwise false.\n     */\n    public get isValid(): boolean\n    {\n        return !!this.resource.videoWidth && !!this.resource.videoHeight;\n    }\n\n    /**\n     * Start preloading the video resource.\n     * @returns {Promise<this>} Handle the validate event\n     */\n    public async load(): Promise<this>\n    {\n        if (this._load)\n        {\n            return this._load;\n        }\n\n        const source = this.resource;\n        const options = this.options as VideoSourceOptions;\n\n        // Check if source data is enough and set it to complete if needed\n        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA)\n            && source.width && source.height)\n        {\n            (source as any).complete = true;\n        }\n\n        // Add event listeners related to playback and seeking\n        source.addEventListener('play', this._onPlayStart);\n        source.addEventListener('pause', this._onPlayStop);\n        source.addEventListener('seeked', this._onSeeked);\n\n        // Add or handle source readiness event listeners\n        if (!this._isSourceReady())\n        {\n            if (!options.preload)\n            {\n                // since this event fires early, only bind if not waiting for a preload event\n                source.addEventListener('canplay', this._onCanPlay);\n            }\n            source.addEventListener('canplaythrough', this._onCanPlayThrough);\n            source.addEventListener('error', this._onError, true);\n        }\n        else\n        {\n            // Source is already ready, so handle it immediately\n            this._mediaReady();\n        }\n\n        this.alphaMode = await detectVideoAlphaMode();\n\n        // Create and return the loading promise\n        this._load = new Promise((resolve, reject): void =>\n        {\n            if (this.isValid)\n            {\n                resolve(this);\n            }\n            else\n            {\n                this._resolve = resolve;\n                this._reject = reject;\n\n                if (options.preloadTimeoutMs !== undefined)\n                {\n                    this._preloadTimeout = setTimeout(() =>\n                    {\n                        this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));\n                    }) as unknown as number;\n                }\n                source.load();\n            }\n        });\n\n        return this._load;\n    }\n\n    /**\n     * Handle video error events.\n     * @param event - The error event\n     */\n    private _onError(event: ErrorEvent): void\n    {\n        this.resource.removeEventListener('error', this._onError, true);\n        this.emit('error', event);\n\n        if (this._reject)\n        {\n            this._reject(event);\n            this._reject = null;\n            this._resolve = null;\n        }\n    }\n\n    /**\n     * Checks if the underlying source is playing.\n     * @returns True if playing.\n     */\n    private _isSourcePlaying(): boolean\n    {\n        const source = this.resource;\n\n        return (!source.paused && !source.ended);\n    }\n\n    /**\n     * Checks if the underlying source is ready for playing.\n     * @returns True if ready.\n     */\n    private _isSourceReady(): boolean\n    {\n        const source = this.resource;\n\n        return source.readyState > 2;\n    }\n\n    /** Runs the update loop when the video is ready to play. */\n    private _onPlayStart(): void\n    {\n        // Handle edge case where video might not have received its \"can play\" event yet\n        if (!this.isValid)\n        {\n            this._mediaReady();\n        }\n\n        this._configureAutoUpdate();\n    }\n\n    /** Stops the update loop when a pause event is triggered. */\n    private _onPlayStop(): void\n    {\n        this._configureAutoUpdate();\n    }\n\n    /** Handles behavior when the video completes seeking to the current playback position. */\n    private _onSeeked(): void\n    {\n        if (this._autoUpdate && !this._isSourcePlaying())\n        {\n            this._msToNextUpdate = 0;\n            this.updateFrame();\n            this._msToNextUpdate = 0;\n        }\n    }\n\n    private _onCanPlay(): void\n    {\n        const source = this.resource;\n\n        // Remove event listeners\n        source.removeEventListener('canplay', this._onCanPlay);\n\n        this._mediaReady();\n    }\n\n    private _onCanPlayThrough(): void\n    {\n        const source = this.resource;\n\n        // Remove event listeners\n        source.removeEventListener('canplaythrough', this._onCanPlay);\n\n        if (this._preloadTimeout)\n        {\n            clearTimeout(this._preloadTimeout);\n            this._preloadTimeout = undefined;\n        }\n\n        this._mediaReady();\n    }\n\n    /** Fired when the video is loaded and ready to play. */\n    private _mediaReady(): void\n    {\n        const source = this.resource;\n\n        if (this.isValid)\n        {\n            this.isReady = true;\n            this.resize(source.videoWidth, source.videoHeight);\n        }\n\n        // Reset update timers and perform a frame update\n        this._msToNextUpdate = 0;\n        this.updateFrame();\n        this._msToNextUpdate = 0;\n\n        // Resolve the loading promise if it exists\n        if (this._resolve)\n        {\n            this._resolve(this);\n            this._resolve = null;\n            this._reject = null;\n        }\n\n        // Handle play behavior based on current source status\n        if (this._isSourcePlaying())\n        {\n            this._onPlayStart();\n        }\n        else if (this.autoPlay)\n        {\n            void this.resource.play();\n        }\n    }\n\n    /** Cleans up resources and event listeners associated with this texture. */\n    public destroy()\n    {\n        this._configureAutoUpdate();\n\n        const source = this.resource;\n\n        if (source)\n        {\n            // Remove event listeners\n            source.removeEventListener('play', this._onPlayStart);\n            source.removeEventListener('pause', this._onPlayStop);\n            source.removeEventListener('seeked', this._onSeeked);\n            source.removeEventListener('canplay', this._onCanPlay);\n            source.removeEventListener('canplaythrough', this._onCanPlayThrough);\n            source.removeEventListener('error', this._onError, true);\n\n            // Clear the video source and pause\n            source.pause();\n            source.src = '';\n            source.load();\n        }\n\n        super.destroy();\n    }\n\n    /** Should the base texture automatically update itself, set to true by default. */\n    get autoUpdate(): boolean\n    {\n        return this._autoUpdate;\n    }\n\n    set autoUpdate(value: boolean)\n    {\n        if (value !== this._autoUpdate)\n        {\n            this._autoUpdate = value;\n            this._configureAutoUpdate();\n        }\n    }\n\n    /**\n     * How many times a second to update the texture from the video.\n     * Leave at 0 to update at every render.\n     * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n     */\n    get updateFPS(): number\n    {\n        return this._updateFPS;\n    }\n\n    set updateFPS(value: number)\n    {\n        if (value !== this._updateFPS)\n        {\n            this._updateFPS = value;\n            this._configureAutoUpdate();\n        }\n    }\n\n    /**\n     * Configures the updating mechanism based on the current state and settings.\n     *\n     * This method decides between using the browser's native video frame callback or a custom ticker\n     * for updating the video frame. It ensures optimal performance and responsiveness\n     * based on the video's state, playback status, and the desired frames-per-second setting.\n     *\n     * - If `_autoUpdate` is enabled and the video source is playing:\n     *   - It will prefer the native video frame callback if available and no specific FPS is set.\n     *   - Otherwise, it will use a custom ticker for manual updates.\n     * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.\n     */\n    private _configureAutoUpdate(): void\n    {\n        // Check if automatic updating is enabled and if the source is currently playing\n        if (this._autoUpdate && this._isSourcePlaying())\n        {\n            // Determine if we should use the browser's native video frame callback (generally for better performance)\n            if (!this._updateFPS && (this.source as any).requestVideoFrameCallback)\n            {\n                // If connected to a custom ticker, remove the update frame function from it\n                if (this._isConnectedToTicker)\n                {\n                    Ticker.shared.remove(this.updateFrame, this);\n                    this._isConnectedToTicker = false;\n                    // Reset the time until the next update\n                    this._msToNextUpdate = 0;\n                }\n\n                // Check if we haven't already requested a video frame callback, and if not, request one\n                if (this._videoFrameRequestCallbackHandle === null)\n                {\n                    this._videoFrameRequestCallbackHandle = (this.source as any).requestVideoFrameCallback(\n                        this._videoFrameRequestCallback\n                    );\n                }\n            }\n            else\n            {\n                // If a video frame request callback exists, cancel it, as we are switching to manual ticker-based updates\n                if (this._videoFrameRequestCallbackHandle !== null)\n                {\n                    (this.source as any).cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n                    this._videoFrameRequestCallbackHandle = null;\n                }\n\n                // If not connected to the custom ticker, add the update frame function to it\n                if (!this._isConnectedToTicker)\n                {\n                    Ticker.shared.add(this.updateFrame, this);\n                    this._isConnectedToTicker = true;\n                    // Reset the time until the next update\n                    this._msToNextUpdate = 0;\n                }\n            }\n        }\n        else\n        {\n            // If automatic updating is disabled or the source isn't playing, perform cleanup\n\n            // Cancel any existing video frame callback request\n            if (this._videoFrameRequestCallbackHandle !== null)\n            {\n                (this.source as any).cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n                this._videoFrameRequestCallbackHandle = null;\n            }\n\n            // Remove the update frame function from the custom ticker\n            if (this._isConnectedToTicker)\n            {\n                Ticker.shared.remove(this.updateFrame, this);\n                this._isConnectedToTicker = false;\n                // Reset the time until the next update\n                this._msToNextUpdate = 0;\n            }\n        }\n    }\n\n    /**\n     * Map of video MIME types that can't be directly derived from file extensions.\n     * @readonly\n     */\n    public static MIME_TYPES: Dict<string>\n        = {\n            ogv: 'video/ogg',\n            mov: 'video/quicktime',\n            m4v: 'video/mp4',\n        };\n\n    public static test(resource: any): resource is VideoResource\n    {\n        return (globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement)\n            || (globalThis.VideoFrame && resource instanceof VideoFrame);\n    }\n}\n","\"use strict\";\nlet promise;\nasync function detectVideoAlphaMode() {\n  promise ?? (promise = (async () => {\n    const canvas = document.createElement(\"canvas\");\n    const gl = canvas.getContext(\"webgl\");\n    if (!gl) {\n      return \"premultiply-alpha-on-upload\";\n    }\n    const video = await new Promise((resolve) => {\n      const video2 = document.createElement(\"video\");\n      video2.onloadeddata = () => resolve(video2);\n      video2.onerror = () => resolve(null);\n      video2.autoplay = false;\n      video2.crossOrigin = \"anonymous\";\n      video2.preload = \"auto\";\n      video2.src = \"data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=\";\n      video2.load();\n    });\n    if (!video) {\n      return \"premultiply-alpha-on-upload\";\n    }\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    const framebuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n    gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      texture,\n      0\n    );\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);\n    const pixel = new Uint8Array(4);\n    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n    gl.deleteFramebuffer(framebuffer);\n    gl.deleteTexture(texture);\n    gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n    return pixel[0] <= pixel[3] ? \"premultiplied-alpha\" : \"premultiply-alpha-on-upload\";\n  })());\n  return promise;\n}\n\nexport { detectVideoAlphaMode };\n//# sourceMappingURL=detectVideoAlphaMode.mjs.map\n","import type { ALPHA_MODES } from '../../rendering/renderers/shared/texture/const';\n\nlet promise: Promise<ALPHA_MODES> | undefined;\n\n/**\n * Helper for detecting the correct alpha mode for video textures.\n * For some reason, some browsers/devices/WebGL implementations premultiply the alpha\n * of a video before and then a second time if `UNPACK_PREMULTIPLY_ALPHA_WEBGL`\n * is true. So the video is premultiplied twice if the alpha mode is `UNPACK`.\n * In this case we need the alpha mode to be `PMA`. This function detects\n * the upload behavior by uploading a white 2x2 webm with 50% alpha\n * without `UNPACK_PREMULTIPLY_ALPHA_WEBGL` and then checking whether\n * the uploaded pixels are premultiplied.\n * @memberof utils\n * @function detectVideoAlphaMode\n * @returns {Promise<ALPHA_MODES>} The correct alpha mode for video textures.\n */\nexport async function detectVideoAlphaMode(): Promise<ALPHA_MODES>\n{\n    promise ??= (async () =>\n    {\n        const canvas = document.createElement('canvas');\n        const gl = canvas.getContext('webgl');\n\n        if (!gl)\n        {\n            return 'premultiply-alpha-on-upload';\n        }\n\n        const video = await new Promise<HTMLVideoElement | null>((resolve) =>\n        {\n            const video = document.createElement('video');\n\n            video.onloadeddata = () => resolve(video);\n            video.onerror = () => resolve(null);\n            video.autoplay = false;\n            video.crossOrigin = 'anonymous';\n            video.preload = 'auto';\n            // eslint-disable-next-line max-len\n            video.src = 'data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=';\n            video.load();\n        });\n\n        if (!video)\n        {\n            return 'premultiply-alpha-on-upload';\n        }\n\n        const texture = gl.createTexture();\n\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n\n        const framebuffer = gl.createFramebuffer();\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n        gl.framebufferTexture2D(\n            gl.FRAMEBUFFER,\n            gl.COLOR_ATTACHMENT0,\n            gl.TEXTURE_2D,\n            texture,\n            0\n        );\n\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n        gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);\n\n        const pixel = new Uint8Array(4);\n\n        gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n\n        gl.deleteFramebuffer(framebuffer);\n        gl.deleteTexture(texture);\n        gl.getExtension('WEBGL_lose_context')?.loseContext();\n\n        return pixel[0] <= pixel[3] ? 'premultiplied-alpha' : 'premultiply-alpha-on-upload';\n    })();\n\n    return promise;\n}\n","import { Cache } from '../../../../../assets/cache/Cache.mjs';\nimport { extensions, ExtensionType } from '../../../../../extensions/Extensions.mjs';\nimport { TextureSource } from '../sources/TextureSource.mjs';\nimport { Texture } from '../Texture.mjs';\n\n\"use strict\";\nconst sources = [];\nextensions.handleByList(ExtensionType.TextureSource, sources);\nfunction autoDetectSource(options = {}) {\n  const hasResource = options && options.resource;\n  const res = hasResource ? options.resource : options;\n  const opts = hasResource ? options : { resource: options };\n  for (let i = 0; i < sources.length; i++) {\n    const Source = sources[i];\n    if (Source.test(res)) {\n      return new Source(opts);\n    }\n  }\n  throw new Error(`Could not find a source type for resource: ${opts.resource}`);\n}\nfunction resourceToTexture(options = {}, skipCache = false) {\n  const hasResource = options && options.resource;\n  const resource = hasResource ? options.resource : options;\n  const opts = hasResource ? options : { resource: options };\n  if (!skipCache && Cache.has(resource)) {\n    return Cache.get(resource);\n  }\n  const texture = new Texture({ source: autoDetectSource(opts) });\n  texture.on(\"destroy\", () => {\n    if (Cache.has(resource)) {\n      Cache.remove(resource);\n    }\n  });\n  if (!skipCache) {\n    Cache.set(resource, texture);\n  }\n  return texture;\n}\nfunction textureFrom(id, skipCache = false) {\n  if (typeof id === \"string\") {\n    return Cache.get(id);\n  } else if (id instanceof TextureSource) {\n    return new Texture({ source: id });\n  }\n  return resourceToTexture(id, skipCache);\n}\nTexture.from = textureFrom;\n\nexport { autoDetectSource, resourceToTexture, textureFrom };\n//# sourceMappingURL=textureFrom.mjs.map\n","import { Cache } from '../../../../../assets/cache/Cache';\nimport { extensions, ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from '../sources/TextureSource';\nimport { Texture } from '../Texture';\n\nimport type { TypedArray } from '../../buffer/Buffer';\nimport type { BufferSourceOptions } from '../sources/BufferSource';\nimport type { ImageResource } from '../sources/ImageSource';\nimport type { TextureSourceOptions } from '../sources/TextureSource';\nimport type { TextureSourceLike } from '../Texture';\n\ninterface TextureSourceConstructor<T extends TextureSource = TextureSource>\n{\n    new (options: TextureSourceOptions): T;\n    test(options: ImageResource | TypedArray | ArrayBuffer): boolean;\n}\n\nconst sources: TextureSourceConstructor[] = [];\n\nextensions.handleByList(ExtensionType.TextureSource, sources);\n\nexport type TextureResourceOrOptions =\n  ImageResource\n  | TextureSourceOptions<ImageResource>\n  | BufferSourceOptions;\n\nexport function autoDetectSource(options: TextureResourceOrOptions = {}): TextureSource\n{\n    const hasResource = options && (options as TextureSourceOptions).resource;\n    const res = hasResource ? (options as TextureSourceOptions).resource : options;\n    const opts = hasResource ? options as TextureSourceOptions : { resource: options } as TextureSourceOptions;\n\n    for (let i = 0; i < sources.length; i++)\n    {\n        const Source = sources[i];\n\n        if (Source.test(res))\n        {\n            return new Source(opts);\n        }\n    }\n\n    throw new Error(`Could not find a source type for resource: ${opts.resource}`);\n}\n\nexport function resourceToTexture(\n    options: TextureResourceOrOptions = {},\n    skipCache = false\n): Texture\n{\n    const hasResource = options && (options as TextureSourceOptions).resource;\n    const resource = hasResource ? (options as TextureSourceOptions).resource : options;\n    const opts = hasResource ? options as TextureSourceOptions : { resource: options } as TextureSourceOptions;\n\n    if (!skipCache && Cache.has(resource))\n    {\n        return Cache.get(resource);\n    }\n\n    const texture = new Texture({ source: autoDetectSource(opts) });\n\n    texture.on('destroy', () =>\n    {\n        if (Cache.has(resource))\n        {\n            Cache.remove(resource);\n        }\n    });\n\n    if (!skipCache)\n    {\n        Cache.set(resource, texture);\n    }\n\n    return texture;\n}\n\n/**\n * Helper function that creates a returns Texture based on the source you provide.\n * The source should be loaded and ready to go. If not its best to grab the asset using Assets.\n * @param id - String or Source to create texture from\n * @param skipCache - Skip adding the texture to the cache\n * @returns The texture based on the Id provided\n */\nexport function textureFrom(id: TextureSourceLike, skipCache = false): Texture\n{\n    if (typeof id === 'string')\n    {\n        return Cache.get(id);\n    }\n    else if (id instanceof TextureSource)\n    {\n        return new Texture({ source: id });\n    }\n\n    // return a auto generated texture from resource\n    return resourceToTexture(id, skipCache);\n}\n\nTexture.from = textureFrom;\n","import { warn } from '../../utils/logging/warn.mjs';\nimport { convertToList } from '../utils/convertToList.mjs';\n\n\"use strict\";\nclass CacheClass {\n  constructor() {\n    this._parsers = [];\n    this._cache = /* @__PURE__ */ new Map();\n    this._cacheMap = /* @__PURE__ */ new Map();\n  }\n  /** Clear all entries. */\n  reset() {\n    this._cacheMap.clear();\n    this._cache.clear();\n  }\n  /**\n   * Check if the key exists\n   * @param key - The key to check\n   */\n  has(key) {\n    return this._cache.has(key);\n  }\n  /**\n   * Fetch entry by key\n   * @param key - The key of the entry to get\n   */\n  get(key) {\n    const result = this._cache.get(key);\n    if (!result) {\n      warn(`[Assets] Asset id ${key} was not found in the Cache`);\n    }\n    return result;\n  }\n  /**\n   * Set a value by key or keys name\n   * @param key - The key or keys to set\n   * @param value - The value to store in the cache or from which cacheable assets will be derived.\n   */\n  set(key, value) {\n    const keys = convertToList(key);\n    let cacheableAssets;\n    for (let i = 0; i < this.parsers.length; i++) {\n      const parser = this.parsers[i];\n      if (parser.test(value)) {\n        cacheableAssets = parser.getCacheableAssets(keys, value);\n        break;\n      }\n    }\n    const cacheableMap = new Map(Object.entries(cacheableAssets || {}));\n    if (!cacheableAssets) {\n      keys.forEach((key2) => {\n        cacheableMap.set(key2, value);\n      });\n    }\n    const cacheKeys = [...cacheableMap.keys()];\n    const cachedAssets = {\n      cacheKeys,\n      keys\n    };\n    keys.forEach((key2) => {\n      this._cacheMap.set(key2, cachedAssets);\n    });\n    cacheKeys.forEach((key2) => {\n      const val = cacheableAssets ? cacheableAssets[key2] : value;\n      if (this._cache.has(key2) && this._cache.get(key2) !== val) {\n        warn(\"[Cache] already has key:\", key2);\n      }\n      this._cache.set(key2, cacheableMap.get(key2));\n    });\n  }\n  /**\n   * Remove entry by key\n   *\n   * This function will also remove any associated alias from the cache also.\n   * @param key - The key of the entry to remove\n   */\n  remove(key) {\n    if (!this._cacheMap.has(key)) {\n      warn(`[Assets] Asset id ${key} was not found in the Cache`);\n      return;\n    }\n    const cacheMap = this._cacheMap.get(key);\n    const cacheKeys = cacheMap.cacheKeys;\n    cacheKeys.forEach((key2) => {\n      this._cache.delete(key2);\n    });\n    cacheMap.keys.forEach((key2) => {\n      this._cacheMap.delete(key2);\n    });\n  }\n  /** All loader parsers registered */\n  get parsers() {\n    return this._parsers;\n  }\n}\nconst Cache = new CacheClass();\n\nexport { Cache };\n//# sourceMappingURL=Cache.mjs.map\n","import { warn } from '../../utils/logging/warn';\nimport { convertToList } from '../utils/convertToList';\n\nimport type { CacheParser } from './CacheParser';\n\n/**\n * A single Cache for all assets.\n *\n * When assets are added to the cache via set they normally are added to the cache as key-value pairs.\n *\n * With this cache, you can add parsers that will take the object and convert it to a list of assets that can be cached.\n * for example a cacheSpritesheet parser will add all of the textures found within its sprite sheet directly to the cache.\n *\n * This gives devs the flexibility to cache any type of object however we want.\n *\n * It is not intended that this class is created by developers - it is part of the Asset package.\n * This is the first major system of PixiJS' main Assets class.\n * @example\n * import { Cache } from 'pixi.js';\n *\n * Cache.set('bunny', bunnyTexture);\n * @class Cache\n * @memberof assets\n */\nclass CacheClass\n{\n    private readonly _parsers: CacheParser[] = [];\n\n    private readonly _cache: Map<any, any> = new Map();\n    private readonly _cacheMap: Map<string, {\n        keys: string[],\n        cacheKeys: string[],\n    }> = new Map();\n\n    /** Clear all entries. */\n    public reset(): void\n    {\n        this._cacheMap.clear();\n        this._cache.clear();\n    }\n\n    /**\n     * Check if the key exists\n     * @param key - The key to check\n     */\n    public has(key: any): boolean\n    {\n        return this._cache.has(key);\n    }\n\n    /**\n     * Fetch entry by key\n     * @param key - The key of the entry to get\n     */\n    public get<T = any>(key: any): T\n    {\n        const result = this._cache.get(key);\n\n        if (!result)\n        {\n            // #if _DEBUG\n            warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n        }\n\n        return result as T;\n    }\n\n    /**\n     * Set a value by key or keys name\n     * @param key - The key or keys to set\n     * @param value - The value to store in the cache or from which cacheable assets will be derived.\n     */\n    public set(key: any | any[], value: unknown): void\n    {\n        const keys = convertToList<string>(key);\n\n        let cacheableAssets: Record<string, any>;\n\n        for (let i = 0; i < this.parsers.length; i++)\n        {\n            const parser = this.parsers[i];\n\n            if (parser.test(value))\n            {\n                cacheableAssets = parser.getCacheableAssets(keys, value);\n\n                break;\n            }\n        }\n\n        // convert cacheable assets to a map of key-value pairs\n        const cacheableMap = new Map(Object.entries(cacheableAssets || {}));\n\n        if (!cacheableAssets)\n        {\n            keys.forEach((key) =>\n            {\n                cacheableMap.set(key, value);\n            });\n        }\n\n        const cacheKeys = [...cacheableMap.keys()];\n\n        const cachedAssets = {\n            cacheKeys,\n            keys\n        };\n\n        // this is so we can remove them later..\n        keys.forEach((key) =>\n        {\n            this._cacheMap.set(key, cachedAssets as any);\n        });\n\n        cacheKeys.forEach((key) =>\n        {\n            const val = cacheableAssets ? cacheableAssets[key] : value;\n\n            if (this._cache.has(key) && this._cache.get(key) !== val)\n            {\n                // #if _DEBUG\n                warn('[Cache] already has key:', key);\n                // #endif\n            }\n\n            this._cache.set(key, cacheableMap.get(key));\n        });\n    }\n\n    /**\n     * Remove entry by key\n     *\n     * This function will also remove any associated alias from the cache also.\n     * @param key - The key of the entry to remove\n     */\n    public remove(key: any): void\n    {\n        if (!this._cacheMap.has(key))\n        {\n            // #if _DEBUG\n            warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n\n            return;\n        }\n\n        const cacheMap = this._cacheMap.get(key);\n\n        const cacheKeys = cacheMap.cacheKeys;\n\n        cacheKeys.forEach((key) =>\n        {\n            this._cache.delete(key);\n        });\n\n        cacheMap.keys.forEach((key: string) =>\n        {\n            this._cacheMap.delete(key);\n        });\n    }\n\n    /** All loader parsers registered */\n    public get parsers(): CacheParser[]\n    {\n        return this._parsers;\n    }\n}\n\nexport const Cache = new CacheClass();\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { GraphicsContextSystem } from './shared/GraphicsContextSystem.mjs';\nimport { GraphicsPipe } from './shared/GraphicsPipe.mjs';\n\n\"use strict\";\nextensions.add(GraphicsPipe);\nextensions.add(GraphicsContextSystem);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../../extensions/Extensions';\nimport { GraphicsContextSystem } from './shared/GraphicsContextSystem';\nimport { GraphicsPipe } from './shared/GraphicsPipe';\n\nextensions.add(GraphicsPipe);\nextensions.add(GraphicsContextSystem);\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { BatchGeometry } from '../../../rendering/batcher/gpu/BatchGeometry.mjs';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup.mjs';\nimport { Batcher } from '../../../rendering/batcher/shared/Batcher.mjs';\nimport { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { buildContextBatches } from './utils/buildContextBatches.mjs';\n\n\"use strict\";\nclass GpuGraphicsContext {\n  constructor() {\n    this.batches = [];\n    this.geometryData = {\n      vertices: [],\n      uvs: [],\n      indices: []\n    };\n  }\n}\nclass GraphicsContextRenderData {\n  constructor() {\n    this.geometry = new BatchGeometry();\n    this.instructions = new InstructionSet();\n  }\n  init() {\n    this.instructions.reset();\n  }\n}\nconst _GraphicsContextSystem = class _GraphicsContextSystem {\n  constructor() {\n    // the root context batches, used to either make a batch or geometry\n    // all graphics use this as a base\n    this._activeBatchers = [];\n    this._gpuContextHash = {};\n    // used for non-batchable graphics\n    this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null);\n    this._needsContextNeedsRebuild = [];\n  }\n  /**\n   * Runner init called, update the default options\n   * @ignore\n   */\n  init(options) {\n    _GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness ?? _GraphicsContextSystem.defaultOptions.bezierSmoothness;\n  }\n  prerender() {\n    this._returnActiveBatchers();\n  }\n  getContextRenderData(context) {\n    return this._graphicsDataContextHash[context.uid] || this._initContextRenderData(context);\n  }\n  // Context management functions\n  updateGpuContext(context) {\n    let gpuContext = this._gpuContextHash[context.uid] || this._initContext(context);\n    if (context.dirty) {\n      if (gpuContext) {\n        this._cleanGraphicsContextData(context);\n      } else {\n        gpuContext = this._initContext(context);\n      }\n      buildContextBatches(context, gpuContext);\n      const batchMode = context.batchMode;\n      if (context.customShader || batchMode === \"no-batch\") {\n        gpuContext.isBatchable = false;\n      } else if (batchMode === \"auto\") {\n        gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;\n      }\n      context.dirty = false;\n    }\n    return gpuContext;\n  }\n  getGpuContext(context) {\n    return this._gpuContextHash[context.uid] || this._initContext(context);\n  }\n  _returnActiveBatchers() {\n    for (let i = 0; i < this._activeBatchers.length; i++) {\n      BigPool.return(this._activeBatchers[i]);\n    }\n    this._activeBatchers.length = 0;\n  }\n  _initContextRenderData(context) {\n    const graphicsData = BigPool.get(GraphicsContextRenderData);\n    const { batches, geometryData } = this._gpuContextHash[context.uid];\n    const vertexSize = geometryData.vertices.length;\n    const indexSize = geometryData.indices.length;\n    for (let i = 0; i < batches.length; i++) {\n      batches[i].applyTransform = false;\n    }\n    const batcher = BigPool.get(Batcher);\n    this._activeBatchers.push(batcher);\n    batcher.ensureAttributeBuffer(vertexSize);\n    batcher.ensureIndexBuffer(indexSize);\n    batcher.begin();\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batcher.add(batch);\n    }\n    batcher.finish(graphicsData.instructions);\n    const geometry = graphicsData.geometry;\n    geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);\n    geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);\n    const drawBatches = batcher.batches;\n    for (let i = 0; i < drawBatches.length; i++) {\n      const batch = drawBatches[i];\n      batch.bindGroup = getTextureBatchBindGroup(batch.textures.textures, batch.textures.count);\n    }\n    this._graphicsDataContextHash[context.uid] = graphicsData;\n    return graphicsData;\n  }\n  _initContext(context) {\n    const gpuContext = new GpuGraphicsContext();\n    this._gpuContextHash[context.uid] = gpuContext;\n    context.on(\"update\", this.onGraphicsContextUpdate, this);\n    context.on(\"destroy\", this.onGraphicsContextDestroy, this);\n    return this._gpuContextHash[context.uid];\n  }\n  onGraphicsContextUpdate(context) {\n    this._needsContextNeedsRebuild.push(context);\n  }\n  onGraphicsContextDestroy(context) {\n    this._cleanGraphicsContextData(context);\n    context.off(\"update\", this.onGraphicsContextUpdate, this);\n    context.off(\"destroy\", this.onGraphicsContextDestroy, this);\n    this._gpuContextHash[context.uid] = null;\n  }\n  _cleanGraphicsContextData(context) {\n    const gpuContext = this._gpuContextHash[context.uid];\n    if (!gpuContext.isBatchable) {\n      if (this._graphicsDataContextHash[context.uid]) {\n        BigPool.return(this.getContextRenderData(context));\n        this._graphicsDataContextHash[context.uid] = null;\n      }\n    }\n    if (gpuContext.batches) {\n      gpuContext.batches.forEach((batch) => {\n        BigPool.return(batch);\n      });\n    }\n  }\n  destroy() {\n    for (const context of this._needsContextNeedsRebuild) {\n      if (this._gpuContextHash[context.uid]) {\n        this.onGraphicsContextDestroy(context);\n      }\n    }\n    this._needsContextNeedsRebuild.length = 0;\n  }\n};\n/** @ignore */\n_GraphicsContextSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"graphicsContext\"\n};\n/** The default options for the GraphicsContextSystem. */\n_GraphicsContextSystem.defaultOptions = {\n  /**\n   * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n   * @default 0.5\n   */\n  bezierSmoothness: 0.5\n};\nlet GraphicsContextSystem = _GraphicsContextSystem;\n\nexport { GpuGraphicsContext, GraphicsContextRenderData, GraphicsContextSystem };\n//# sourceMappingURL=GraphicsContextSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { BatchGeometry } from '../../../rendering/batcher/gpu/BatchGeometry';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup';\nimport { Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { buildContextBatches } from './utils/buildContextBatches';\n\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { BatchableGraphics } from './BatchableGraphics';\nimport type { GraphicsContext } from './GraphicsContext';\n\ninterface GeometryData\n{\n    vertices: number[];\n    uvs: number[];\n    indices: number[];\n}\n\n/**\n * A class that holds batchable graphics data for a GraphicsContext.\n * @memberof rendering\n * @ignore\n */\nexport class GpuGraphicsContext\n{\n    public isBatchable: boolean;\n    public batches: BatchableGraphics[] = [];\n    public geometryData: GeometryData = {\n        vertices: [],\n        uvs: [],\n        indices: [],\n    };\n    public graphicsData: GraphicsContextRenderData;\n}\n\n/**\n * A class that holds the render data for a GraphicsContext.\n * @memberof rendering\n * @ignore\n */\nexport class GraphicsContextRenderData\n{\n    public geometry = new BatchGeometry();\n    public instructions = new InstructionSet();\n\n    public init()\n    {\n        this.instructions.reset();\n    }\n}\n\n/**\n * Options for the GraphicsContextSystem.\n * @memberof rendering\n */\nexport interface GraphicsContextSystemOptions\n{\n    /** A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother) */\n    bezierSmoothness?: number;\n}\n\n/**\n * A system that manages the rendering of GraphicsContexts.\n * @memberof rendering\n */\nexport class GraphicsContextSystem implements System<GraphicsContextSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'graphicsContext'\n    } as const;\n\n    /** The default options for the GraphicsContextSystem. */\n    public static readonly defaultOptions: GraphicsContextSystemOptions = {\n        /**\n         * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n         * @default 0.5\n         */\n        bezierSmoothness: 0.5,\n    };\n\n    // the root context batches, used to either make a batch or geometry\n    // all graphics use this as a base\n    private readonly _activeBatchers: Batcher[] = [];\n    private _gpuContextHash: Record<number, GpuGraphicsContext> = {};\n    // used for non-batchable graphics\n    private _graphicsDataContextHash: Record<number, GraphicsContextRenderData> = Object.create(null);\n    private readonly _needsContextNeedsRebuild: GraphicsContext[] = [];\n\n    /**\n     * Runner init called, update the default options\n     * @ignore\n     */\n    public init(options?: GraphicsContextSystemOptions)\n    {\n        GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness\n            ?? GraphicsContextSystem.defaultOptions.bezierSmoothness;\n    }\n\n    protected prerender()\n    {\n        this._returnActiveBatchers();\n    }\n\n    public getContextRenderData(context: GraphicsContext): GraphicsContextRenderData\n    {\n        return this._graphicsDataContextHash[context.uid] || this._initContextRenderData(context);\n    }\n\n    // Context management functions\n    public updateGpuContext(context: GraphicsContext)\n    {\n        let gpuContext: GpuGraphicsContext = this._gpuContextHash[context.uid]\n\n            || this._initContext(context);\n\n        if (context.dirty)\n        {\n            if (gpuContext)\n            {\n                this._cleanGraphicsContextData(context);\n            }\n            else\n            {\n                gpuContext = this._initContext(context);\n            }\n\n            buildContextBatches(context, gpuContext);\n\n            const batchMode = context.batchMode;\n\n            if (context.customShader || batchMode === 'no-batch')\n            {\n                gpuContext.isBatchable = false;\n            }\n            else if (batchMode === 'auto')\n            {\n                gpuContext.isBatchable = (gpuContext.geometryData.vertices.length < 400);\n            }\n\n            context.dirty = false;\n        }\n\n        return gpuContext;\n    }\n\n    public getGpuContext(context: GraphicsContext): GpuGraphicsContext\n    {\n        return this._gpuContextHash[context.uid] || this._initContext(context);\n    }\n\n    private _returnActiveBatchers()\n    {\n        for (let i = 0; i < this._activeBatchers.length; i++)\n        {\n            BigPool.return(this._activeBatchers[i] as PoolItem);\n        }\n\n        this._activeBatchers.length = 0;\n    }\n\n    private _initContextRenderData(context: GraphicsContext): GraphicsContextRenderData\n    {\n        const graphicsData: GraphicsContextRenderData = BigPool.get(GraphicsContextRenderData);// ();\n\n        const { batches, geometryData } = this._gpuContextHash[context.uid];\n\n        const vertexSize = geometryData.vertices.length;\n        const indexSize = geometryData.indices.length;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            batches[i].applyTransform = false;\n        }\n\n        const batcher = BigPool.get(Batcher);\n\n        this._activeBatchers.push(batcher);\n\n        batcher.ensureAttributeBuffer(vertexSize);\n        batcher.ensureIndexBuffer(indexSize);\n\n        batcher.begin();\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batcher.add(batch);\n        }\n\n        batcher.finish(graphicsData.instructions);\n\n        const geometry = graphicsData.geometry;\n\n        // not to self - this works as we are assigning the batchers array buffer\n        // once its up loaded - this buffer is then put back in the pool to be reused.\n        // this mean we don't have to creating new Batchers for each graphics items\n        geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);\n        geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);\n\n        const drawBatches = batcher.batches;\n\n        for (let i = 0; i < drawBatches.length; i++)\n        {\n            const batch = drawBatches[i];\n\n            batch.bindGroup = getTextureBatchBindGroup(batch.textures.textures, batch.textures.count);\n        }\n\n        this._graphicsDataContextHash[context.uid] = graphicsData;\n\n        return graphicsData;\n    }\n\n    private _initContext(context: GraphicsContext): GpuGraphicsContext\n    {\n        const gpuContext = new GpuGraphicsContext();\n\n        this._gpuContextHash[context.uid] = gpuContext;\n\n        context.on('update', this.onGraphicsContextUpdate, this);\n        context.on('destroy', this.onGraphicsContextDestroy, this);\n\n        return this._gpuContextHash[context.uid];\n    }\n\n    protected onGraphicsContextUpdate(context: GraphicsContext)\n    {\n        this._needsContextNeedsRebuild.push(context);\n    }\n\n    protected onGraphicsContextDestroy(context: GraphicsContext)\n    {\n        this._cleanGraphicsContextData(context);\n\n        context.off('update', this.onGraphicsContextUpdate, this);\n        context.off('destroy', this.onGraphicsContextDestroy, this);\n\n        this._gpuContextHash[context.uid] = null;\n    }\n\n    private _cleanGraphicsContextData(context: GraphicsContext)\n    {\n        const gpuContext: GpuGraphicsContext = this._gpuContextHash[context.uid];\n\n        if (!gpuContext.isBatchable)\n        {\n            if (this._graphicsDataContextHash[context.uid])\n            {\n                BigPool.return(this.getContextRenderData(context) as PoolItem);\n\n                // we will rebuild this...\n                this._graphicsDataContextHash[context.uid] = null;\n            }\n        }\n\n        if (gpuContext.batches)\n        {\n            gpuContext.batches.forEach((batch) =>\n            {\n                BigPool.return(batch as PoolItem);\n            });\n        }\n    }\n\n    public destroy()\n    {\n        // Clean up all graphics contexts\n        for (const context of this._needsContextNeedsRebuild)\n        {\n            // only clean if it exists\n            if (this._gpuContextHash[context.uid])\n            {\n                this.onGraphicsContextDestroy(context);\n            }\n        }\n\n        this._needsContextNeedsRebuild.length = 0;\n    }\n}\n","import { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { buildUvs, buildSimpleUvs } from '../../../../rendering/renderers/shared/geometry/utils/buildUvs.mjs';\nimport { transformVertices } from '../../../../rendering/renderers/shared/geometry/utils/transformVertices.mjs';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { BigPool } from '../../../../utils/pool/PoolGroup.mjs';\nimport { BatchableGraphics } from '../BatchableGraphics.mjs';\nimport { buildCircle } from '../buildCommands/buildCircle.mjs';\nimport { buildLine } from '../buildCommands/buildLine.mjs';\nimport { buildPolygon } from '../buildCommands/buildPolygon.mjs';\nimport { buildRectangle } from '../buildCommands/buildRectangle.mjs';\nimport { buildTriangle } from '../buildCommands/buildTriangle.mjs';\nimport { triangulateWithHoles } from './triangulateWithHoles.mjs';\n\n\"use strict\";\nconst buildMap = {\n  rectangle: buildRectangle,\n  polygon: buildPolygon,\n  triangle: buildTriangle,\n  circle: buildCircle,\n  ellipse: buildCircle,\n  roundedRectangle: buildCircle\n};\nconst tempRect = new Rectangle();\nfunction buildContextBatches(context, gpuContext) {\n  const { geometryData, batches } = gpuContext;\n  batches.length = 0;\n  geometryData.indices.length = 0;\n  geometryData.vertices.length = 0;\n  geometryData.uvs.length = 0;\n  for (let i = 0; i < context.instructions.length; i++) {\n    const instruction = context.instructions[i];\n    if (instruction.action === \"texture\") {\n      addTextureToGeometryData(instruction.data, batches, geometryData);\n    } else if (instruction.action === \"fill\" || instruction.action === \"stroke\") {\n      const isStroke = instruction.action === \"stroke\";\n      const shapePath = instruction.data.path.shapePath;\n      const style = instruction.data.style;\n      const hole = instruction.data.hole;\n      if (isStroke && hole) {\n        addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);\n      }\n      addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);\n    }\n  }\n}\nfunction addTextureToGeometryData(data, batches, geometryData) {\n  const { vertices, uvs, indices } = geometryData;\n  const indexOffset = indices.length;\n  const vertOffset = vertices.length / 2;\n  const points = [];\n  const build = buildMap.rectangle;\n  const rect = tempRect;\n  const texture = data.image;\n  rect.x = data.dx;\n  rect.y = data.dy;\n  rect.width = data.dw;\n  rect.height = data.dh;\n  const matrix = data.transform;\n  build.build(rect, points);\n  if (matrix) {\n    transformVertices(points, matrix);\n  }\n  build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n  const textureUvs = texture.uvs;\n  uvs.push(\n    textureUvs.x0,\n    textureUvs.y0,\n    textureUvs.x1,\n    textureUvs.y1,\n    textureUvs.x3,\n    textureUvs.y3,\n    textureUvs.x2,\n    textureUvs.y2\n  );\n  const graphicsBatch = BigPool.get(BatchableGraphics);\n  graphicsBatch.indexOffset = indexOffset;\n  graphicsBatch.indexSize = indices.length - indexOffset;\n  graphicsBatch.vertexOffset = vertOffset;\n  graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;\n  graphicsBatch.color = data.style;\n  graphicsBatch.alpha = data.alpha;\n  graphicsBatch.texture = texture;\n  graphicsBatch.geometryData = geometryData;\n  batches.push(graphicsBatch);\n}\nfunction addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData) {\n  const { vertices, uvs, indices } = geometryData;\n  const lastIndex = shapePath.shapePrimitives.length - 1;\n  shapePath.shapePrimitives.forEach(({ shape, transform: matrix }, i) => {\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n    const points = [];\n    const build = buildMap[shape.type];\n    build.build(shape, points);\n    if (matrix) {\n      transformVertices(points, matrix);\n    }\n    if (!isStroke) {\n      if (hole && lastIndex === i) {\n        if (lastIndex !== 0) {\n          console.warn(\"[Pixi Graphics] only the last shape have be cut out\");\n        }\n        const holeIndices = [];\n        const otherPoints = points.slice();\n        const holeArrays = getHoleArrays(hole.shapePath);\n        holeArrays.forEach((holePoints) => {\n          holeIndices.push(otherPoints.length / 2);\n          otherPoints.push(...holePoints);\n        });\n        triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n      } else {\n        build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n      }\n    } else {\n      const close = shape.closePath ?? true;\n      const lineStyle = style;\n      buildLine(points, lineStyle, false, close, vertices, 2, vertOffset, indices, indexOffset);\n    }\n    const uvsOffset = uvs.length / 2;\n    const texture = style.texture;\n    if (texture !== Texture.WHITE) {\n      const textureMatrix = style.matrix;\n      if (matrix) {\n        textureMatrix.append(matrix.clone().invert());\n      }\n      buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);\n    } else {\n      buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);\n    }\n    const graphicsBatch = BigPool.get(BatchableGraphics);\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n    graphicsBatch.vertexOffset = vertOffset;\n    graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;\n    graphicsBatch.color = style.color;\n    graphicsBatch.alpha = style.alpha;\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n    batches.push(graphicsBatch);\n  });\n}\nfunction getHoleArrays(shape) {\n  if (!shape)\n    return [];\n  const holePrimitives = shape.shapePrimitives;\n  const holeArrays = [];\n  for (let k = 0; k < holePrimitives.length; k++) {\n    const holePrimitive = holePrimitives[k].shape;\n    const holePoints = [];\n    const holeBuilder = buildMap[holePrimitive.type];\n    holeBuilder.build(holePrimitive, holePoints);\n    holeArrays.push(holePoints);\n  }\n  return holeArrays;\n}\n\nexport { buildContextBatches };\n//# sourceMappingURL=buildContextBatches.mjs.map\n","import { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { buildSimpleUvs, buildUvs } from '../../../../rendering/renderers/shared/geometry/utils/buildUvs';\nimport { transformVertices } from '../../../../rendering/renderers/shared/geometry/utils/transformVertices';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { BigPool } from '../../../../utils/pool/PoolGroup';\nimport { BatchableGraphics } from '../BatchableGraphics';\nimport { buildCircle } from '../buildCommands/buildCircle';\nimport { buildLine } from '../buildCommands/buildLine';\nimport { buildPolygon } from '../buildCommands/buildPolygon';\nimport { buildRectangle } from '../buildCommands/buildRectangle';\nimport { buildTriangle } from '../buildCommands/buildTriangle';\nimport { triangulateWithHoles } from './triangulateWithHoles';\n\nimport type { Polygon } from '../../../../maths/shapes/Polygon';\nimport type { ShapeBuildCommand } from '../buildCommands/ShapeBuildCommand';\nimport type { ConvertedFillStyle, GraphicsContext, TextureInstruction } from '../GraphicsContext';\nimport type { GpuGraphicsContext } from '../GraphicsContextSystem';\nimport type { GraphicsPath } from '../path/GraphicsPath';\nimport type { ShapePath } from '../path/ShapePath';\n\nconst buildMap: Record<string, ShapeBuildCommand> = {\n    rectangle: buildRectangle,\n    polygon: buildPolygon,\n    triangle: buildTriangle,\n    circle: buildCircle,\n    ellipse: buildCircle,\n    roundedRectangle: buildCircle,\n};\n\nconst tempRect = new Rectangle();\n\nexport function buildContextBatches(context: GraphicsContext, gpuContext: GpuGraphicsContext)\n{\n    const { geometryData, batches } = gpuContext;\n\n    // reset them..\n    batches.length = 0;\n    geometryData.indices.length = 0;\n    geometryData.vertices.length = 0;\n    geometryData.uvs.length = 0;\n\n    for (let i = 0; i < context.instructions.length; i++)\n    {\n        const instruction = context.instructions[i];\n\n        if (instruction.action === 'texture')\n        {\n            // add a quad!\n            addTextureToGeometryData(instruction.data, batches, geometryData);\n        }\n        else if (instruction.action === 'fill' || instruction.action === 'stroke')\n        {\n            const isStroke = instruction.action === 'stroke';\n\n            // build path collection of polys and shapes points..\n            const shapePath = instruction.data.path.shapePath;\n\n            const style = instruction.data.style;\n\n            const hole = instruction.data.hole;\n\n            if (isStroke && hole)\n            {\n                addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);\n            }\n\n            addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);\n        }\n    }\n}\n\nfunction addTextureToGeometryData(\n    data: TextureInstruction['data'],\n    batches: BatchableGraphics[],\n    geometryData: {\n        vertices: number[];\n        uvs: number[];\n        indices: number[];\n    }\n)\n{\n    const { vertices, uvs, indices } = geometryData;\n\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n\n    const points: number[] = [];\n\n    const build = buildMap.rectangle;\n\n    const rect = tempRect;\n\n    const texture = data.image;\n\n    rect.x = data.dx;\n    rect.y = data.dy;\n    rect.width = data.dw;\n    rect.height = data.dh;\n\n    const matrix = data.transform;\n\n    // TODO - this can be cached...\n    build.build(rect, points);\n\n    if (matrix)\n    {\n        transformVertices(points, matrix);\n    }\n\n    build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n\n    const textureUvs = texture.uvs;\n\n    uvs.push(\n        textureUvs.x0, textureUvs.y0,\n        textureUvs.x1, textureUvs.y1,\n        textureUvs.x3, textureUvs.y3,\n        textureUvs.x2, textureUvs.y2,\n    );\n\n    const graphicsBatch = BigPool.get(BatchableGraphics);\n\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n\n    graphicsBatch.vertexOffset = vertOffset;\n    graphicsBatch.vertexSize = (vertices.length / 2) - vertOffset;\n\n    graphicsBatch.color = data.style;\n    graphicsBatch.alpha = data.alpha;\n\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n\n    batches.push(graphicsBatch);\n}\n\nfunction addShapePathToGeometryData(\n    shapePath: ShapePath,\n    style: ConvertedFillStyle,\n    hole: GraphicsPath,\n    isStroke: boolean,\n    batches: BatchableGraphics[],\n    geometryData: {\n        vertices: number[];\n        uvs: number[];\n        indices: number[];\n    }\n)\n{\n    const { vertices, uvs, indices } = geometryData;\n    const lastIndex = shapePath.shapePrimitives.length - 1;\n\n    shapePath.shapePrimitives.forEach(({ shape, transform: matrix }, i) =>\n    {\n        const indexOffset = indices.length;\n        const vertOffset = vertices.length / 2;\n\n        const points: number[] = [];\n\n        const build = buildMap[shape.type];\n\n        // TODO - this can be cached...\n        // TODO - THIS IS DONE TWICE!!!!!!\n        // ONCE FOR STROKE AND ONCE FOR FILL\n        // move to the ShapePath2D class itself?\n        build.build(shape, points);\n\n        if (matrix)\n        {\n            transformVertices(points, matrix);\n        }\n\n        if (!isStroke)\n        {\n            if (hole && lastIndex === i)\n            {\n                if (lastIndex !== 0)\n                {\n                    console.warn('[Pixi Graphics] only the last shape have be cut out');\n                }\n\n                const holeIndices: number[] = [];\n\n                const otherPoints = points.slice();\n\n                const holeArrays = getHoleArrays(hole.shapePath);\n\n                holeArrays.forEach((holePoints) =>\n                {\n                    holeIndices.push(otherPoints.length / 2);\n                    otherPoints.push(...holePoints);\n                });\n\n                triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n            }\n            else\n            {\n                build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n            }\n        }\n        else\n        {\n            const close = (shape as Polygon).closePath ?? true;\n            const lineStyle = style;\n\n            buildLine(points, lineStyle, false, close, vertices, 2, vertOffset, indices, indexOffset);\n        }\n\n        const uvsOffset = uvs.length / 2;\n\n        const texture = style.texture;\n\n        if (texture !== Texture.WHITE)\n        {\n            const textureMatrix = style.matrix;\n\n            if (matrix)\n            {\n                // todo can prolly do this before calculating uvs..\n                textureMatrix.append(matrix.clone().invert());\n            }\n\n            buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset, textureMatrix);\n        }\n        else\n        {\n            buildSimpleUvs(uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset);\n        }\n\n        const graphicsBatch = BigPool.get(BatchableGraphics);\n\n        graphicsBatch.indexOffset = indexOffset;\n        graphicsBatch.indexSize = indices.length - indexOffset;\n\n        graphicsBatch.vertexOffset = vertOffset;\n        graphicsBatch.vertexSize = (vertices.length / 2) - vertOffset;\n\n        graphicsBatch.color = style.color as number;\n        graphicsBatch.alpha = style.alpha;\n\n        graphicsBatch.texture = texture;\n        graphicsBatch.geometryData = geometryData;\n\n        batches.push(graphicsBatch);\n    });\n}\n\nfunction getHoleArrays(shape: ShapePath)\n{\n    if (!shape) return [];\n\n    const holePrimitives = shape.shapePrimitives;\n\n    const holeArrays = [];\n\n    for (let k = 0; k < holePrimitives.length; k++)\n    {\n        const holePrimitive = holePrimitives[k].shape;\n\n        // TODO - need to transform the points via there transform here..\n        const holePoints: number[] = [];\n\n        const holeBuilder = buildMap[holePrimitive.type] as ShapeBuildCommand;\n\n        holeBuilder.build(holePrimitive, holePoints);\n\n        holeArrays.push(holePoints);\n    }\n\n    return holeArrays;\n}\n","\"use strict\";\nfunction buildUvs(vertices, verticesStride, verticesOffset, uvs, uvsOffset, uvsStride, size, matrix = null) {\n  let index = 0;\n  verticesOffset *= verticesStride;\n  uvsOffset *= uvsStride;\n  const a = matrix.a;\n  const b = matrix.b;\n  const c = matrix.c;\n  const d = matrix.d;\n  const tx = matrix.tx;\n  const ty = matrix.ty;\n  while (index < size) {\n    const x = vertices[verticesOffset];\n    const y = vertices[verticesOffset + 1];\n    uvs[uvsOffset] = a * x + c * y + tx;\n    uvs[uvsOffset + 1] = b * x + d * y + ty;\n    uvsOffset += uvsStride;\n    verticesOffset += verticesStride;\n    index++;\n  }\n}\nfunction buildSimpleUvs(uvs, uvsOffset, uvsStride, size) {\n  let index = 0;\n  uvsOffset *= uvsStride;\n  while (index < size) {\n    uvs[uvsOffset] = 0;\n    uvs[uvsOffset + 1] = 0;\n    uvsOffset += uvsStride;\n    index++;\n  }\n}\n\nexport { buildSimpleUvs, buildUvs };\n//# sourceMappingURL=buildUvs.mjs.map\n","import type { Matrix } from '../../../../../maths/matrix/Matrix';\n\n/**\n * Takes a vertices array and a matrix and transforms the vertices based on the matrix.\n * this out put is written to the uvs array\n * @param vertices - the vertices to calculate uvs from\n * @param verticesStride - the stride of the vertice\n * @param verticesOffset - the offset of the vertices\n * @param uvs - the uvs to fill\n * @param uvsOffset - the offset of the uvs\n * @param uvsStride - the stride of the uvs\n * @param size - the size of the vertices\n * @param matrix - the matrix to apply to the uvs\n * @memberof rendering\n */\nexport function buildUvs(\n    vertices: number[],\n    verticesStride: number,\n    verticesOffset: number,\n\n    uvs: number[],\n    uvsOffset: number,\n    uvsStride: number,\n\n    size: number,\n    matrix: Matrix = null\n): void\n{\n    let index = 0;\n\n    verticesOffset *= verticesStride;\n    uvsOffset *= uvsStride;\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    while (index < size)\n    {\n        const x = vertices[verticesOffset];\n        const y = vertices[verticesOffset + 1];\n\n        uvs[uvsOffset] = (a * x) + (c * y) + tx;\n        uvs[uvsOffset + 1] = (b * x) + (d * y) + ty;\n\n        uvsOffset += uvsStride;\n\n        verticesOffset += verticesStride;\n\n        index++;\n    }\n}\n\nexport function buildSimpleUvs(\n    uvs: number[],\n    uvsOffset: number,\n    uvsStride: number,\n    size: number,\n)\n{\n    let index = 0;\n\n    uvsOffset *= uvsStride;\n\n    while (index < size)\n    {\n        uvs[uvsOffset] = 0;\n        uvs[uvsOffset + 1] = 0;\n\n        uvsOffset += uvsStride;\n\n        index++;\n    }\n}\n","\"use strict\";\nfunction transformVertices(vertices, m, offset, stride, size) {\n  const a = m.a;\n  const b = m.b;\n  const c = m.c;\n  const d = m.d;\n  const tx = m.tx;\n  const ty = m.ty;\n  offset = offset || 0;\n  stride = stride || 2;\n  size = size || vertices.length / stride - offset;\n  let index = offset * stride;\n  for (let i = 0; i < size; i++) {\n    const x = vertices[index];\n    const y = vertices[index + 1];\n    vertices[index] = a * x + c * y + tx;\n    vertices[index + 1] = b * x + d * y + ty;\n    index += stride;\n  }\n}\n\nexport { transformVertices };\n//# sourceMappingURL=transformVertices.mjs.map\n","import type { Matrix } from '../../../../../maths/matrix/Matrix';\n\n/**\n * Transforms the vertices in an array with the given matrix.\n * @param vertices - the vertices to transform\n * @param m - the matrix to apply to the vertices\n * @param offset - the offset of the vertices (defaults to 0)\n * @param stride - the stride of the vertices (defaults to 2)\n * @param size - the size of the vertices (defaults to vertices.length / stride - offset)\n * @memberof rendering\n */\nexport function transformVertices(vertices: number[], m: Matrix, offset?: number, stride?: number, size?: number)\n{\n    const a = m.a;\n    const b = m.b;\n    const c = m.c;\n    const d = m.d;\n    const tx = m.tx;\n    const ty = m.ty;\n\n    offset = offset || 0;\n    stride = stride || 2;\n    size = size || (vertices.length / stride) - offset;\n\n    let index = offset * stride;\n\n    for (let i = 0; i < size; i++)\n    {\n        const x = vertices[index];\n        const y = vertices[index + 1];\n\n        vertices[index] = (a * x) + (c * y) + tx;\n        vertices[index + 1] = (b * x) + (d * y) + ty;\n\n        index += stride;\n    }\n}\n","import { mixColors } from '../../container/utils/mixColors.mjs';\n\n\"use strict\";\nclass BatchableGraphics {\n  constructor() {\n    this.batcher = null;\n    this.batch = null;\n    this.applyTransform = true;\n    this.roundPixels = 0;\n  }\n  get blendMode() {\n    if (this.applyTransform) {\n      return this.renderable.groupBlendMode;\n    }\n    return \"normal\";\n  }\n  packIndex(indexBuffer, index, indicesOffset) {\n    const indices = this.geometryData.indices;\n    for (let i = 0; i < this.indexSize; i++) {\n      indexBuffer[index++] = indices[i + this.indexOffset] + indicesOffset - this.vertexOffset;\n    }\n  }\n  packAttributes(float32View, uint32View, index, textureId) {\n    const geometry = this.geometryData;\n    const graphics = this.renderable;\n    const positions = geometry.vertices;\n    const uvs = geometry.uvs;\n    const offset = this.vertexOffset * 2;\n    const vertSize = (this.vertexOffset + this.vertexSize) * 2;\n    const rgb = this.color;\n    const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;\n    if (this.applyTransform) {\n      const argb = mixColors(bgr, graphics.groupColor) + (this.alpha * graphics.groupAlpha * 255 << 24);\n      const wt = graphics.groupTransform;\n      const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;\n      const a = wt.a;\n      const b = wt.b;\n      const c = wt.c;\n      const d = wt.d;\n      const tx = wt.tx;\n      const ty = wt.ty;\n      for (let i = offset; i < vertSize; i += 2) {\n        const x = positions[i];\n        const y = positions[i + 1];\n        float32View[index] = a * x + c * y + tx;\n        float32View[index + 1] = b * x + d * y + ty;\n        float32View[index + 2] = uvs[i];\n        float32View[index + 3] = uvs[i + 1];\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureIdAndRound;\n        index += 6;\n      }\n    } else {\n      const argb = bgr + (this.alpha * 255 << 24);\n      for (let i = offset; i < vertSize; i += 2) {\n        float32View[index] = positions[i];\n        float32View[index + 1] = positions[i + 1];\n        float32View[index + 2] = uvs[i];\n        float32View[index + 3] = uvs[i + 1];\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureId << 16;\n        index += 6;\n      }\n    }\n  }\n  // TODO rename to vertexSize\n  get vertSize() {\n    return this.vertexSize;\n  }\n  copyTo(gpuBuffer) {\n    gpuBuffer.indexOffset = this.indexOffset;\n    gpuBuffer.indexSize = this.indexSize;\n    gpuBuffer.vertexOffset = this.vertexOffset;\n    gpuBuffer.vertexSize = this.vertexSize;\n    gpuBuffer.color = this.color;\n    gpuBuffer.alpha = this.alpha;\n    gpuBuffer.texture = this.texture;\n    gpuBuffer.geometryData = this.geometryData;\n  }\n  reset() {\n    this.applyTransform = true;\n  }\n}\n\nexport { BatchableGraphics };\n//# sourceMappingURL=BatchableGraphics.mjs.map\n","import { mixColors } from '../../container/utils/mixColors';\n\nimport type { Batch, BatchableObject, Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { IndexBufferArray } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Graphics } from './Graphics';\n\n/**\n * A batchable graphics object.\n * @ignore\n */\nexport class BatchableGraphics implements BatchableObject\n{\n    public indexStart: number;\n    public textureId: number;\n    public texture: Texture;\n    public location: number;\n    public batcher: Batcher = null;\n    public batch: Batch = null;\n    public renderable: Graphics;\n    public indexOffset: number;\n    public indexSize: number;\n    public vertexOffset: number;\n    public vertexSize: number;\n    public color: number;\n    public alpha: number;\n    public applyTransform = true;\n    public roundPixels: 0 | 1 = 0;\n\n    public geometryData: { vertices: number[]; uvs: number[]; indices: number[]; };\n\n    get blendMode()\n    {\n        if (this.applyTransform)\n        {\n            return this.renderable.groupBlendMode;\n        }\n\n        return 'normal';\n    }\n\n    public packIndex(indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        const indices = this.geometryData.indices;\n\n        for (let i = 0; i < this.indexSize; i++)\n        {\n            indexBuffer[index++] = indices[i + this.indexOffset] + indicesOffset - this.vertexOffset;\n        }\n    }\n\n    public packAttributes(\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    )\n    {\n        const geometry = this.geometryData;\n        const graphics = this.renderable;\n\n        const positions = geometry.vertices;\n        const uvs = geometry.uvs;\n\n        const offset = this.vertexOffset * 2;\n        const vertSize = (this.vertexOffset + this.vertexSize) * 2;\n\n        const rgb = this.color;\n        const bgr = (rgb >> 16) | (rgb & 0xff00) | ((rgb & 0xff) << 16);\n\n        if (this.applyTransform)\n        {\n            const argb = mixColors(bgr, graphics.groupColor)\n            + ((this.alpha * graphics.groupAlpha * 255) << 24);\n\n            const wt = graphics.groupTransform;\n            const textureIdAndRound = (textureId << 16) | (this.roundPixels & 0xFFFF);\n\n            const a = wt.a;\n            const b = wt.b;\n            const c = wt.c;\n            const d = wt.d;\n            const tx = wt.tx;\n            const ty = wt.ty;\n\n            for (let i = offset; i < vertSize; i += 2)\n            {\n                const x = positions[i];\n                const y = positions[i + 1];\n\n                float32View[index] = (a * x) + (c * y) + tx;\n                float32View[index + 1] = (b * x) + (d * y) + ty;\n\n                float32View[index + 2] = uvs[i];\n                float32View[index + 3] = uvs[i + 1];\n\n                uint32View[index + 4] = argb;\n                uint32View[index + 5] = textureIdAndRound;\n\n                index += 6;\n            }\n        }\n        else\n        {\n            const argb = bgr + ((this.alpha * 255) << 24);\n\n            for (let i = offset; i < vertSize; i += 2)\n            {\n                float32View[index] = positions[i];\n                float32View[index + 1] = positions[i + 1];\n\n                float32View[index + 2] = uvs[i];\n                float32View[index + 3] = uvs[i + 1];\n\n                uint32View[index + 4] = argb;\n                uint32View[index + 5] = textureId << 16;\n\n                index += 6;\n            }\n        }\n    }\n\n    // TODO rename to vertexSize\n    get vertSize()\n    {\n        return this.vertexSize;\n    }\n\n    public copyTo(gpuBuffer: BatchableGraphics)\n    {\n        gpuBuffer.indexOffset = this.indexOffset;\n        gpuBuffer.indexSize = this.indexSize;\n\n        gpuBuffer.vertexOffset = this.vertexOffset;\n        gpuBuffer.vertexSize = this.vertexSize;\n\n        gpuBuffer.color = this.color;\n        gpuBuffer.alpha = this.alpha;\n\n        gpuBuffer.texture = this.texture;\n        gpuBuffer.geometryData = this.geometryData;\n    }\n\n    public reset()\n    {\n        this.applyTransform = true;\n    }\n}\n","\"use strict\";\nconst buildCircle = {\n  build(shape, points) {\n    let x;\n    let y;\n    let dx;\n    let dy;\n    let rx;\n    let ry;\n    if (shape.type === \"circle\") {\n      const circle = shape;\n      x = circle.x;\n      y = circle.y;\n      rx = ry = circle.radius;\n      dx = dy = 0;\n    } else if (shape.type === \"ellipse\") {\n      const ellipse = shape;\n      x = ellipse.x;\n      y = ellipse.y;\n      rx = ellipse.halfWidth;\n      ry = ellipse.halfHeight;\n      dx = dy = 0;\n    } else {\n      const roundedRect = shape;\n      const halfWidth = roundedRect.width / 2;\n      const halfHeight = roundedRect.height / 2;\n      x = roundedRect.x + halfWidth;\n      y = roundedRect.y + halfHeight;\n      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n      dx = halfWidth - rx;\n      dy = halfHeight - ry;\n    }\n    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {\n      return points;\n    }\n    const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n    const m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);\n    if (m === 0) {\n      return points;\n    }\n    if (n === 0) {\n      points[0] = points[6] = x + dx;\n      points[1] = points[3] = y + dy;\n      points[2] = points[4] = x - dx;\n      points[5] = points[7] = y - dy;\n      return points;\n    }\n    let j1 = 0;\n    let j2 = n * 4 + (dx ? 2 : 0) + 2;\n    let j3 = j2;\n    let j4 = m;\n    let x0 = dx + rx;\n    let y0 = dy;\n    let x1 = x + x0;\n    let x2 = x - x0;\n    let y1 = y + y0;\n    points[j1++] = x1;\n    points[j1++] = y1;\n    points[--j2] = y1;\n    points[--j2] = x2;\n    if (dy) {\n      const y22 = y - y0;\n      points[j3++] = x2;\n      points[j3++] = y22;\n      points[--j4] = y22;\n      points[--j4] = x1;\n    }\n    for (let i = 1; i < n; i++) {\n      const a = Math.PI / 2 * (i / n);\n      const x02 = dx + Math.cos(a) * rx;\n      const y02 = dy + Math.sin(a) * ry;\n      const x12 = x + x02;\n      const x22 = x - x02;\n      const y12 = y + y02;\n      const y22 = y - y02;\n      points[j1++] = x12;\n      points[j1++] = y12;\n      points[--j2] = y12;\n      points[--j2] = x22;\n      points[j3++] = x22;\n      points[j3++] = y22;\n      points[--j4] = y22;\n      points[--j4] = x12;\n    }\n    x0 = dx;\n    y0 = dy + ry;\n    x1 = x + x0;\n    x2 = x - x0;\n    y1 = y + y0;\n    const y2 = y - y0;\n    points[j1++] = x1;\n    points[j1++] = y1;\n    points[--j4] = y2;\n    points[--j4] = x1;\n    if (dx) {\n      points[j1++] = x2;\n      points[j1++] = y1;\n      points[--j4] = y2;\n      points[--j4] = x2;\n    }\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    if (points.length === 0) {\n      return;\n    }\n    let centerX = 0;\n    let centerY = 0;\n    for (let i = 0; i < points.length; i += 2) {\n      centerX += points[i];\n      centerY += points[i + 1];\n    }\n    centerX /= points.length / 2;\n    centerY /= points.length / 2;\n    let count = verticesOffset;\n    vertices[count * verticesStride] = centerX;\n    vertices[count * verticesStride + 1] = centerY;\n    const centerIndex = count++;\n    for (let i = 0; i < points.length; i += 2) {\n      vertices[count * verticesStride] = points[i];\n      vertices[count * verticesStride + 1] = points[i + 1];\n      if (i > 0) {\n        indices[indicesOffset++] = count;\n        indices[indicesOffset++] = centerIndex;\n        indices[indicesOffset++] = count - 1;\n      }\n      count++;\n    }\n    indices[indicesOffset++] = centerIndex + 1;\n    indices[indicesOffset++] = centerIndex;\n    indices[indicesOffset++] = count - 1;\n  }\n};\n\nexport { buildCircle };\n//# sourceMappingURL=buildCircle.mjs.map\n","import type { Circle } from '../../../../maths/shapes/Circle';\nimport type { Ellipse } from '../../../../maths/shapes/Ellipse';\nimport type { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\ntype RoundedShape = Circle | Ellipse | RoundedRectangle;\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildCircle: ShapeBuildCommand<RoundedShape> = {\n\n    build(shape: RoundedShape, points: number[])\n    {\n        let x;\n        let y;\n        let dx;\n        let dy;\n\n        let rx;\n        let ry;\n\n        if (shape.type === 'circle')\n        {\n            const circle = shape as Circle;\n\n            x = circle.x;\n            y = circle.y;\n            rx = ry = circle.radius;\n            dx = dy = 0;\n        }\n\n        else if (shape.type === 'ellipse')\n        {\n            const ellipse = shape as Ellipse;\n\n            x = ellipse.x;\n            y = ellipse.y;\n            rx = ellipse.halfWidth;\n            ry = ellipse.halfHeight;\n            dx = dy = 0;\n        }\n        else\n        {\n            const roundedRect = shape as RoundedRectangle;\n            const halfWidth = roundedRect.width / 2;\n            const halfHeight = roundedRect.height / 2;\n\n            x = roundedRect.x + halfWidth;\n            y = roundedRect.y + halfHeight;\n            rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n            dx = halfWidth - rx;\n            dy = halfHeight - ry;\n        }\n\n        if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0))\n        {\n            return points;\n        }\n\n        // Choose a number of segments such that the maximum absolute deviation from the circle is approximately 0.029\n        const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n        const m = (n * 8) + (dx ? 4 : 0) + (dy ? 4 : 0);\n\n        if (m === 0)\n        {\n            return points;\n        }\n\n        if (n === 0)\n        {\n            points[0] = points[6] = x + dx;\n            points[1] = points[3] = y + dy;\n            points[2] = points[4] = x - dx;\n            points[5] = points[7] = y - dy;\n\n            return points;\n        }\n\n        let j1 = 0;\n        let j2 = (n * 4) + (dx ? 2 : 0) + 2;\n        let j3 = j2;\n        let j4 = m;\n\n        let x0 = dx + rx;\n        let y0 = dy;\n        let x1 = x + x0;\n        let x2 = x - x0;\n        let y1 = y + y0;\n\n        points[j1++] = x1;\n        points[j1++] = y1;\n        points[--j2] = y1;\n        points[--j2] = x2;\n\n        if (dy)\n        {\n            const y2 = y - y0;\n\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        for (let i = 1; i < n; i++)\n        {\n            const a = Math.PI / 2 * (i / n);\n            const x0 = dx + (Math.cos(a) * rx);\n            const y0 = dy + (Math.sin(a) * ry);\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n            const y2 = y - y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j2] = y1;\n            points[--j2] = x2;\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        x0 = dx;\n        y0 = dy + ry;\n        x1 = x + x0;\n        x2 = x - x0;\n        y1 = y + y0;\n        const y2 = y - y0;\n\n        points[j1++] = x1;\n        points[j1++] = y1;\n        points[--j4] = y2;\n        points[--j4] = x1;\n\n        if (dx)\n        {\n            points[j1++] = x2;\n            points[j1++] = y1;\n            points[--j4] = y2;\n            points[--j4] = x2;\n        }\n\n        return points;\n    },\n\n    triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset)\n    {\n        if (points.length === 0)\n        {\n            return;\n        }\n\n        // Compute center (average of all points)\n        let centerX = 0; let\n            centerY = 0;\n\n        for (let i = 0; i < points.length; i += 2)\n        {\n            centerX += points[i];\n            centerY += points[i + 1];\n        }\n        centerX /= (points.length / 2);\n        centerY /= (points.length / 2);\n\n        // Set center vertex\n        let count = verticesOffset;\n\n        vertices[count * verticesStride] = centerX;\n        vertices[(count * verticesStride) + 1] = centerY;\n        const centerIndex = count++;\n\n        // Set edge vertices and indices\n        for (let i = 0; i < points.length; i += 2)\n        {\n            vertices[count * verticesStride] = points[i];\n            vertices[(count * verticesStride) + 1] = points[i + 1];\n\n            if (i > 0)\n            { // Skip first point for indices\n                indices[indicesOffset++] = count;\n                indices[indicesOffset++] = centerIndex;\n                indices[indicesOffset++] = count - 1;\n            }\n            count++;\n        }\n\n        // Connect last point to the first edge point\n        indices[indicesOffset++] = centerIndex + 1;\n        indices[indicesOffset++] = centerIndex;\n        indices[indicesOffset++] = count - 1;\n    }\n\n};\n","import { Point } from '../../../../maths/point/Point.mjs';\nimport { closePointEps, curveEps } from '../const.mjs';\nimport { getOrientationOfPoints } from '../utils/getOrientationOfPoints.mjs';\n\n\"use strict\";\nfunction square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {\n  const ix = x - nx * innerWeight;\n  const iy = y - ny * innerWeight;\n  const ox = x + nx * outerWeight;\n  const oy = y + ny * outerWeight;\n  let exx;\n  let eyy;\n  if (clockwise) {\n    exx = ny;\n    eyy = -nx;\n  } else {\n    exx = -ny;\n    eyy = nx;\n  }\n  const eix = ix + exx;\n  const eiy = iy + eyy;\n  const eox = ox + exx;\n  const eoy = oy + eyy;\n  verts.push(eix, eiy);\n  verts.push(eox, eoy);\n  return 2;\n}\nfunction round(cx, cy, sx, sy, ex, ey, verts, clockwise) {\n  const cx2p0x = sx - cx;\n  const cy2p0y = sy - cy;\n  let angle0 = Math.atan2(cx2p0x, cy2p0y);\n  let angle1 = Math.atan2(ex - cx, ey - cy);\n  if (clockwise && angle0 < angle1) {\n    angle0 += Math.PI * 2;\n  } else if (!clockwise && angle0 > angle1) {\n    angle1 += Math.PI * 2;\n  }\n  let startAngle = angle0;\n  const angleDiff = angle1 - angle0;\n  const absAngleDiff = Math.abs(angleDiff);\n  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);\n  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;\n  const angleInc = angleDiff / segCount;\n  startAngle += angleInc;\n  if (clockwise) {\n    verts.push(cx, cy);\n    verts.push(sx, sy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(cx, cy);\n      verts.push(\n        cx + Math.sin(angle) * radius,\n        cy + Math.cos(angle) * radius\n      );\n    }\n    verts.push(cx, cy);\n    verts.push(ex, ey);\n  } else {\n    verts.push(sx, sy);\n    verts.push(cx, cy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(\n        cx + Math.sin(angle) * radius,\n        cy + Math.cos(angle) * radius\n      );\n      verts.push(cx, cy);\n    }\n    verts.push(ex, ey);\n    verts.push(cx, cy);\n  }\n  return segCount * 2;\n}\nfunction buildLine(points, lineStyle, flipAlignment, closed, vertices, _verticesStride, _verticesOffset, indices, _indicesOffset) {\n  const eps = closePointEps;\n  if (points.length === 0) {\n    return;\n  }\n  const style = lineStyle;\n  let alignment = style.alignment;\n  if (lineStyle.alignment !== 0.5) {\n    let orientation = getOrientationOfPoints(points);\n    if (flipAlignment)\n      orientation *= -1;\n    alignment = (alignment - 0.5) * orientation + 0.5;\n  }\n  const firstPoint = new Point(points[0], points[1]);\n  const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n  const closedShape = closed;\n  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;\n  if (closedShape) {\n    points = points.slice();\n    if (closedPath) {\n      points.pop();\n      points.pop();\n      lastPoint.set(points[points.length - 2], points[points.length - 1]);\n    }\n    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n    points.unshift(midPointX, midPointY);\n    points.push(midPointX, midPointY);\n  }\n  const verts = vertices;\n  const length = points.length / 2;\n  let indexCount = points.length;\n  const indexStart = verts.length / 2;\n  const width = style.width / 2;\n  const widthSquared = width * width;\n  const miterLimitSquared = style.miterLimit * style.miterLimit;\n  let x0 = points[0];\n  let y0 = points[1];\n  let x1 = points[2];\n  let y1 = points[3];\n  let x2 = 0;\n  let y2 = 0;\n  let perpX = -(y0 - y1);\n  let perpY = x0 - x1;\n  let perp1x = 0;\n  let perp1y = 0;\n  let dist = Math.sqrt(perpX * perpX + perpY * perpY);\n  perpX /= dist;\n  perpY /= dist;\n  perpX *= width;\n  perpY *= width;\n  const ratio = alignment;\n  const innerWeight = (1 - ratio) * 2;\n  const outerWeight = ratio * 2;\n  if (!closedShape) {\n    if (style.cap === \"round\") {\n      indexCount += round(\n        x0 - perpX * (innerWeight - outerWeight) * 0.5,\n        y0 - perpY * (innerWeight - outerWeight) * 0.5,\n        x0 - perpX * innerWeight,\n        y0 - perpY * innerWeight,\n        x0 + perpX * outerWeight,\n        y0 + perpY * outerWeight,\n        verts,\n        true\n      ) + 2;\n    } else if (style.cap === \"square\") {\n      indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);\n    }\n  }\n  verts.push(\n    x0 - perpX * innerWeight,\n    y0 - perpY * innerWeight\n  );\n  verts.push(\n    x0 + perpX * outerWeight,\n    y0 + perpY * outerWeight\n  );\n  for (let i = 1; i < length - 1; ++i) {\n    x0 = points[(i - 1) * 2];\n    y0 = points[(i - 1) * 2 + 1];\n    x1 = points[i * 2];\n    y1 = points[i * 2 + 1];\n    x2 = points[(i + 1) * 2];\n    y2 = points[(i + 1) * 2 + 1];\n    perpX = -(y0 - y1);\n    perpY = x0 - x1;\n    dist = Math.sqrt(perpX * perpX + perpY * perpY);\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n    perp1x = -(y1 - y2);\n    perp1y = x1 - x2;\n    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);\n    perp1x /= dist;\n    perp1y /= dist;\n    perp1x *= width;\n    perp1y *= width;\n    const dx0 = x1 - x0;\n    const dy0 = y0 - y1;\n    const dx1 = x1 - x2;\n    const dy1 = y2 - y1;\n    const dot = dx0 * dx1 + dy0 * dy1;\n    const cross = dy0 * dx1 - dy1 * dx0;\n    const clockwise = cross < 0;\n    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {\n      verts.push(\n        x1 - perpX * innerWeight,\n        y1 - perpY * innerWeight\n      );\n      verts.push(\n        x1 + perpX * outerWeight,\n        y1 + perpY * outerWeight\n      );\n      if (dot >= 0) {\n        if (style.join === \"round\") {\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 4;\n        } else {\n          indexCount += 2;\n        }\n        verts.push(\n          x1 - perp1x * outerWeight,\n          y1 - perp1y * outerWeight\n        );\n        verts.push(\n          x1 + perp1x * innerWeight,\n          y1 + perp1y * innerWeight\n        );\n      }\n      continue;\n    }\n    const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);\n    const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);\n    const px = (dx0 * c2 - dx1 * c1) / cross;\n    const py = (dy1 * c1 - dy0 * c2) / cross;\n    const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);\n    const imx = x1 + (px - x1) * innerWeight;\n    const imy = y1 + (py - y1) * innerWeight;\n    const omx = x1 - (px - x1) * outerWeight;\n    const omy = y1 - (py - y1) * outerWeight;\n    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);\n    const insideWeight = clockwise ? innerWeight : outerWeight;\n    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;\n    const insideMiterOk = pDist <= smallerInsideDiagonalSq;\n    if (insideMiterOk) {\n      if (style.join === \"bevel\" || pDist / widthSquared > miterLimitSquared) {\n        if (clockwise) {\n          verts.push(imx, imy);\n          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else {\n          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n          verts.push(omx, omy);\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n        indexCount += 2;\n      } else if (style.join === \"round\") {\n        if (clockwise) {\n          verts.push(imx, imy);\n          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n          indexCount += round(\n            x1,\n            y1,\n            x1 + perpX * outerWeight,\n            y1 + perpY * outerWeight,\n            x1 + perp1x * outerWeight,\n            y1 + perp1y * outerWeight,\n            verts,\n            true\n          ) + 4;\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else {\n          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n          verts.push(omx, omy);\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 4;\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n      } else {\n        verts.push(imx, imy);\n        verts.push(omx, omy);\n      }\n    } else {\n      verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n      verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n      if (style.join === \"round\") {\n        if (clockwise) {\n          indexCount += round(\n            x1,\n            y1,\n            x1 + perpX * outerWeight,\n            y1 + perpY * outerWeight,\n            x1 + perp1x * outerWeight,\n            y1 + perp1y * outerWeight,\n            verts,\n            true\n          ) + 2;\n        } else {\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 2;\n        }\n      } else if (style.join === \"miter\" && pDist / widthSquared <= miterLimitSquared) {\n        if (clockwise) {\n          verts.push(omx, omy);\n          verts.push(omx, omy);\n        } else {\n          verts.push(imx, imy);\n          verts.push(imx, imy);\n        }\n        indexCount += 2;\n      }\n      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n      verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n      indexCount += 2;\n    }\n  }\n  x0 = points[(length - 2) * 2];\n  y0 = points[(length - 2) * 2 + 1];\n  x1 = points[(length - 1) * 2];\n  y1 = points[(length - 1) * 2 + 1];\n  perpX = -(y0 - y1);\n  perpY = x0 - x1;\n  dist = Math.sqrt(perpX * perpX + perpY * perpY);\n  perpX /= dist;\n  perpY /= dist;\n  perpX *= width;\n  perpY *= width;\n  verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n  verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n  if (!closedShape) {\n    if (style.cap === \"round\") {\n      indexCount += round(\n        x1 - perpX * (innerWeight - outerWeight) * 0.5,\n        y1 - perpY * (innerWeight - outerWeight) * 0.5,\n        x1 - perpX * innerWeight,\n        y1 - perpY * innerWeight,\n        x1 + perpX * outerWeight,\n        y1 + perpY * outerWeight,\n        verts,\n        false\n      ) + 2;\n    } else if (style.cap === \"square\") {\n      indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);\n    }\n  }\n  const eps2 = curveEps * curveEps;\n  for (let i = indexStart; i < indexCount + indexStart - 2; ++i) {\n    x0 = verts[i * 2];\n    y0 = verts[i * 2 + 1];\n    x1 = verts[(i + 1) * 2];\n    y1 = verts[(i + 1) * 2 + 1];\n    x2 = verts[(i + 2) * 2];\n    y2 = verts[(i + 2) * 2 + 1];\n    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {\n      continue;\n    }\n    indices.push(i, i + 1, i + 2);\n  }\n}\n\nexport { buildLine };\n//# sourceMappingURL=buildLine.mjs.map\n","import { Point } from '../../../../maths/point/Point';\nimport { closePointEps, curveEps } from '../const';\nimport { getOrientationOfPoints } from '../utils/getOrientationOfPoints';\n\nimport type { StrokeStyle } from '../GraphicsContext';\n\n/**\n * Buffers vertices to draw a square cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} x - X-coord of end point\n * @param {number} y - Y-coord of end point\n * @param {number} nx - X-coord of line normal pointing inside\n * @param {number} ny - Y-coord of line normal pointing inside\n * @param {number} innerWeight - Weight of inner points\n * @param {number} outerWeight - Weight of outer points\n * @param {boolean} clockwise - Whether the cap is drawn clockwise\n * @param {Array<number>} verts - vertex buffer\n * @returns {number} - no. of vertices pushed\n */\nfunction square(\n    x: number,\n    y: number,\n    nx: number,\n    ny: number,\n    innerWeight: number,\n    outerWeight: number,\n    clockwise: boolean, /* rotation for square (true at left end, false at right end) */\n    verts: Array<number>\n): number\n{\n    const ix = x - (nx * innerWeight);\n    const iy = y - (ny * innerWeight);\n    const ox = x + (nx * outerWeight);\n    const oy = y + (ny * outerWeight);\n\n    /* Rotate nx,ny for extension vector */\n    let exx; let\n        eyy;\n\n    if (clockwise)\n    {\n        exx = ny;\n        eyy = -nx;\n    }\n    else\n    {\n        exx = -ny;\n        eyy = nx;\n    }\n\n    /* [i|0]x,y extended at cap */\n    const eix = ix + exx;\n    const eiy = iy + eyy;\n    const eox = ox + exx;\n    const eoy = oy + eyy;\n\n    /* Square itself must be inserted clockwise*/\n    verts.push(eix, eiy);\n    verts.push(eox, eoy);\n\n    return 2;\n}\n\n/**\n * Buffers vertices to draw an arc at the line joint or cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} cx - X-coord of center\n * @param {number} cy - Y-coord of center\n * @param {number} sx - X-coord of arc start\n * @param {number} sy - Y-coord of arc start\n * @param {number} ex - X-coord of arc end\n * @param {number} ey - Y-coord of arc end\n * @param {Array[]} verts - buffer of vertices\n * @param {boolean} clockwise - orientation of vertices\n * @returns {number} - no. of vertices pushed\n */\nfunction round(\n    cx: number,\n    cy: number,\n    sx: number,\n    sy: number,\n    ex: number,\n    ey: number,\n    verts: number[],\n    clockwise: boolean, /* if not cap, then clockwise is turn of joint, otherwise rotation from angle0 to angle1 */\n): number\n{\n    const cx2p0x = sx - cx;\n    const cy2p0y = sy - cy;\n\n    let angle0 = Math.atan2(cx2p0x, cy2p0y);\n    let angle1 = Math.atan2(ex - cx, ey - cy);\n\n    if (clockwise && angle0 < angle1)\n    {\n        angle0 += Math.PI * 2;\n    }\n    else if (!clockwise && angle0 > angle1)\n    {\n        angle1 += Math.PI * 2;\n    }\n\n    let startAngle = angle0;\n    const angleDiff = angle1 - angle0;\n    const absAngleDiff = Math.abs(angleDiff);\n\n    const radius = Math.sqrt((cx2p0x * cx2p0x) + (cy2p0y * cy2p0y));\n    const segCount = ((15 * absAngleDiff * Math.sqrt(radius) / Math.PI) >> 0) + 1;\n    const angleInc = angleDiff / segCount;\n\n    startAngle += angleInc;\n\n    if (clockwise)\n    {\n        verts.push(cx, cy);\n        verts.push(sx, sy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx, cy);\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n        }\n\n        verts.push(cx, cy);\n        verts.push(ex, ey);\n    }\n    else\n    {\n        verts.push(sx, sy);\n        verts.push(cx, cy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n            verts.push(cx, cy);\n        }\n\n        verts.push(ex, ey);\n        verts.push(cx, cy);\n    }\n\n    return segCount * 2;\n}\n\n/**\n * Builds a line to draw using the polygon method.\n * @param points\n * @param lineStyle\n * @param flipAlignment\n * @param closed\n * @param vertices\n * @param _verticesStride\n * @param _verticesOffset\n * @param indices\n * @param _indicesOffset\n */\nexport function buildLine(\n    points: number[],\n    lineStyle: StrokeStyle,\n    flipAlignment: boolean,\n    closed: boolean,\n    // alignment:number,\n\n    vertices: number[],\n    _verticesStride: number,\n    _verticesOffset: number,\n\n    indices: number[],\n    _indicesOffset: number,\n\n): void\n{\n    // const shape = graphicsData.shape as Polygon;\n    //   let points = graphicsData.points || shape.points.slice();\n    const eps = closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n\n    const style = lineStyle;\n\n    let alignment = style.alignment;\n\n    if (lineStyle.alignment !== 0.5)\n    {\n        // rotate the points!\n        let orientation = getOrientationOfPoints(points);\n\n        if (flipAlignment)orientation *= -1;\n\n        alignment = ((alignment - 0.5) * orientation) + 0.5;\n    }\n\n    // get first and last point.. figure out the middle!\n    const firstPoint = new Point(points[0], points[1]);\n    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n    const closedShape = closed;\n    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\n        && Math.abs(firstPoint.y - lastPoint.y) < eps;\n\n    // if the first point is the last point - gonna have issues :)\n    if (closedShape)\n    {\n        // need to clone as we are going to slightly modify the shape..\n        points = points.slice();\n\n        if (closedPath)\n        {\n            points.pop();\n            points.pop();\n            lastPoint.set(points[points.length - 2], points[points.length - 1]);\n        }\n\n        const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n        const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    const verts = vertices;\n\n    const length = points.length / 2;\n    let indexCount = points.length;\n    const indexStart = verts.length / 2;\n\n    // Max. inner and outer width\n    const width = style.width / 2;\n    const widthSquared = width * width;\n    const miterLimitSquared = style.miterLimit * style.miterLimit;\n\n    /* Line segments of interest where (x1,y1) forms the corner. */\n    let x0 = points[0];\n    let y0 = points[1];\n    let x1 = points[2];\n    let y1 = points[3];\n    let x2 = 0;\n    let y2 = 0;\n\n    /* perp[?](x|y) = the line normal with magnitude lineWidth. */\n    let perpX = -(y0 - y1);\n    let perpY = x0 - x1;\n    let perp1x = 0;\n    let perp1y = 0;\n\n    let dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n\n    const ratio = alignment;// 0.5;\n    const innerWeight = (1 - ratio) * 2;\n    const outerWeight = ratio * 2;\n\n    if (!closedShape)\n    {\n        if (style.cap === 'round')\n        {\n            indexCount += round(\n                x0 - (perpX * (innerWeight - outerWeight) * 0.5),\n                y0 - (perpY * (innerWeight - outerWeight) * 0.5),\n                x0 - (perpX * innerWeight),\n                y0 - (perpY * innerWeight),\n                x0 + (perpX * outerWeight),\n                y0 + (perpY * outerWeight),\n                verts,\n                true,\n            ) + 2;\n        }\n        else if (style.cap === 'square')\n        {\n            indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);\n        }\n    }\n\n    // Push first point (below & above vertices)\n    verts.push(\n        x0 - (perpX * innerWeight),\n        y0 - (perpY * innerWeight));\n    verts.push(\n        x0 + (perpX * outerWeight),\n        y0 + (perpY * outerWeight));\n\n    for (let i = 1; i < length - 1; ++i)\n    {\n        x0 = points[(i - 1) * 2];\n        y0 = points[((i - 1) * 2) + 1];\n\n        x1 = points[i * 2];\n        y1 = points[(i * 2) + 1];\n\n        x2 = points[(i + 1) * 2];\n        y2 = points[((i + 1) * 2) + 1];\n\n        perpX = -(y0 - y1);\n        perpY = x0 - x1;\n\n        dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n        perpX /= dist;\n        perpY /= dist;\n        perpX *= width;\n        perpY *= width;\n\n        perp1x = -(y1 - y2);\n        perp1y = x1 - x2;\n\n        dist = Math.sqrt((perp1x * perp1x) + (perp1y * perp1y));\n        perp1x /= dist;\n        perp1y /= dist;\n        perp1x *= width;\n        perp1y *= width;\n\n        /* d[x|y](0|1) = the component displacement between points p(0,1|1,2) */\n        const dx0 = x1 - x0;\n        const dy0 = y0 - y1;\n        const dx1 = x1 - x2;\n        const dy1 = y2 - y1;\n\n        /* +ve if internal angle < 90 degree, -ve if internal angle > 90 degree. */\n        const dot = (dx0 * dx1) + (dy0 * dy1);\n        /* +ve if internal angle counterclockwise, -ve if internal angle clockwise. */\n        const cross = (dy0 * dx1) - (dy1 * dx0);\n        const clockwise = (cross < 0);\n\n        /* Going nearly parallel? */\n        /* atan(0.001) ~= 0.001 rad ~= 0.057 degree */\n        if (Math.abs(cross) < 0.001 * Math.abs(dot))\n        {\n            verts.push(\n                x1 - (perpX * innerWeight),\n                y1 - (perpY * innerWeight));\n            verts.push(\n                x1 + (perpX * outerWeight),\n                y1 + (perpY * outerWeight));\n\n            /* 180 degree corner? */\n            if (dot >= 0)\n            {\n                if (style.join === 'round')\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false) + 4;\n                }\n                else\n                {\n                    indexCount += 2;\n                }\n\n                verts.push(\n                    x1 - (perp1x * outerWeight),\n                    y1 - (perp1y * outerWeight));\n                verts.push(\n                    x1 + (perp1x * innerWeight),\n                    y1 + (perp1y * innerWeight));\n            }\n\n            continue;\n        }\n\n        /* p[x|y] is the miter point. pDist is the distance between miter point and p1. */\n        const c1 = ((-perpX + x0) * (-perpY + y1)) - ((-perpX + x1) * (-perpY + y0));\n        const c2 = ((-perp1x + x2) * (-perp1y + y1)) - ((-perp1x + x1) * (-perp1y + y2));\n        const px = ((dx0 * c2) - (dx1 * c1)) / cross;\n        const py = ((dy1 * c1) - (dy0 * c2)) / cross;\n        const pDist = ((px - x1) * (px - x1)) + ((py - y1) * (py - y1));\n\n        /* Inner miter point */\n        const imx = x1 + ((px - x1) * innerWeight);\n        const imy = y1 + ((py - y1) * innerWeight);\n        /* Outer miter point */\n        const omx = x1 - ((px - x1) * outerWeight);\n        const omy = y1 - ((py - y1) * outerWeight);\n\n        /* Is the inside miter point too far away, creating a spike? */\n        const smallerInsideSegmentSq = Math.min((dx0 * dx0) + (dy0 * dy0), (dx1 * dx1) + (dy1 * dy1));\n        const insideWeight = clockwise ? innerWeight : outerWeight;\n        const smallerInsideDiagonalSq = smallerInsideSegmentSq + (insideWeight * insideWeight * widthSquared);\n        const insideMiterOk = pDist <= smallerInsideDiagonalSq;\n\n        if (insideMiterOk)\n        {\n            if (style.join === 'bevel' || pDist / widthSquared > miterLimitSquared)\n            {\n                if (clockwise) /* rotating at inner angle */\n                {\n                    verts.push(imx, imy); // inner miter point\n                    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight)); // first segment's outer vertex\n                    verts.push(imx, imy); // inner miter point\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n                }\n                else /* rotating at outer angle */\n                {\n                    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight)); // first segment's inner vertex\n                    verts.push(omx, omy); // outer miter point\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's outer vertex\n                    verts.push(omx, omy); // outer miter point\n                }\n\n                indexCount += 2;\n            }\n            else if (style.join === 'round')\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight));\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpX * outerWeight), y1 + (perpY * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 4;\n\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight));\n                }\n                else /* arc is inside */\n                {\n                    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight));\n                    verts.push(omx, omy);\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 4;\n\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight));\n                    verts.push(omx, omy);\n                }\n            }\n            else\n            {\n                verts.push(imx, imy);\n                verts.push(omx, omy);\n            }\n        }\n        else // inside miter is NOT ok\n        {\n            verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight)); // first segment's inner vertex\n            verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight)); // first segment's outer vertex\n            if (style.join === 'round')\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpX * outerWeight), y1 + (perpY * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 2;\n                }\n                else /* arc is inside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 2;\n                }\n            }\n            else if (style.join === 'miter' && pDist / widthSquared <= miterLimitSquared)\n            {\n                if (clockwise)\n                {\n                    verts.push(omx, omy); // inner miter point\n                    verts.push(omx, omy); // inner miter point\n                }\n                else\n                {\n                    verts.push(imx, imy); // outer miter point\n                    verts.push(imx, imy); // outer miter point\n                }\n                indexCount += 2;\n            }\n            verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's inner vertex\n            verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n            indexCount += 2;\n        }\n    }\n\n    x0 = points[(length - 2) * 2];\n    y0 = points[((length - 2) * 2) + 1];\n\n    x1 = points[(length - 1) * 2];\n    y1 = points[((length - 1) * 2) + 1];\n\n    perpX = -(y0 - y1);\n    perpY = x0 - x1;\n\n    dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n\n    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight));\n    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight));\n\n    if (!closedShape)\n    {\n        if (style.cap === 'round')\n        {\n            indexCount += round(\n                x1 - (perpX * (innerWeight - outerWeight) * 0.5),\n                y1 - (perpY * (innerWeight - outerWeight) * 0.5),\n                x1 - (perpX * innerWeight),\n                y1 - (perpY * innerWeight),\n                x1 + (perpX * outerWeight),\n                y1 + (perpY * outerWeight),\n                verts,\n                false\n            ) + 2;\n        }\n        else if (style.cap === 'square')\n        {\n            indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);\n        }\n    }\n\n    // const indices = graphicsGeometry.indices;\n    const eps2 = curveEps * curveEps;\n\n    // indices.push(indexStart);\n    for (let i = indexStart; i < indexCount + indexStart - 2; ++i)\n    {\n        x0 = verts[(i * 2)];\n        y0 = verts[(i * 2) + 1];\n\n        x1 = verts[(i + 1) * 2];\n        y1 = verts[((i + 1) * 2) + 1];\n\n        x2 = verts[(i + 2) * 2];\n        y2 = verts[((i + 2) * 2) + 1];\n\n        /* Skip zero area triangles */\n        if (Math.abs((x0 * (y1 - y2)) + (x1 * (y2 - y0)) + (x2 * (y0 - y1))) < eps2)\n        {\n            continue;\n        }\n\n        indices.push(i, i + 1, i + 2);\n    }\n}\n\n","\"use strict\";\nconst closePointEps = 1e-4;\nconst curveEps = 1e-4;\n\nexport { closePointEps, curveEps };\n//# sourceMappingURL=const.mjs.map\n","export type LineCap = 'butt' | 'round' | 'square';\nexport type LineJoin = 'round' | 'bevel' | 'miter';\n\nexport const closePointEps = 1e-4;\nexport const curveEps = 0.0001;\n","\"use strict\";\nfunction getOrientationOfPoints(points) {\n  const m = points.length;\n  if (m < 6) {\n    return 1;\n  }\n  let area = 0;\n  for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2) {\n    const x2 = points[i];\n    const y2 = points[i + 1];\n    area += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n  if (area < 0) {\n    return -1;\n  }\n  return 1;\n}\n\nexport { getOrientationOfPoints };\n//# sourceMappingURL=getOrientationOfPoints.mjs.map\n","export function getOrientationOfPoints(points: number[]): number\n{\n    const m = points.length;\n\n    if (m < 6)\n    {\n        return 1;\n    }\n\n    let area = 0;\n\n    for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2)\n    {\n        const x2 = points[i];\n        const y2 = points[i + 1];\n\n        area += (x2 - x1) * (y2 + y1);\n\n        x1 = x2;\n        y1 = y2;\n    }\n\n    if (area < 0)\n    {\n        return -1;\n    }\n\n    return 1;\n}\n","import { triangulateWithHoles } from '../utils/triangulateWithHoles.mjs';\n\n\"use strict\";\nconst emptyArray = [];\nconst buildPolygon = {\n  build(shape, points) {\n    for (let i = 0; i < shape.points.length; i++) {\n      points[i] = shape.points[i];\n    }\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);\n  }\n};\n\nexport { buildPolygon };\n//# sourceMappingURL=buildPolygon.mjs.map\n","import { triangulateWithHoles } from '../utils/triangulateWithHoles';\n\nimport type { Polygon } from '../../../../maths/shapes/Polygon';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\nconst emptyArray: number[] = [];\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildPolygon: ShapeBuildCommand<Polygon> = {\n\n    build(shape: Polygon, points: number[]): number[]\n    {\n        for (let i = 0; i < shape.points.length; i++)\n        {\n            points[i] = shape.points[i];\n        }\n\n        return points;\n    },\n\n    triangulate(\n        points: number[],\n        //  holes: number[],\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);\n    },\n\n};\n","import earcut from 'earcut';\n\n\"use strict\";\nfunction triangulateWithHoles(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n  const triangles = earcut(points, holes, 2);\n  if (!triangles) {\n    return;\n  }\n  for (let i = 0; i < triangles.length; i += 3) {\n    indices[indicesOffset++] = triangles[i] + verticesOffset;\n    indices[indicesOffset++] = triangles[i + 1] + verticesOffset;\n    indices[indicesOffset++] = triangles[i + 2] + verticesOffset;\n  }\n  let index = verticesOffset * verticesStride;\n  for (let i = 0; i < points.length; i += 2) {\n    vertices[index] = points[i];\n    vertices[index + 1] = points[i + 1];\n    index += verticesStride;\n  }\n}\n\nexport { triangulateWithHoles };\n//# sourceMappingURL=triangulateWithHoles.mjs.map\n","import { default as earcut } from 'earcut';\n\nexport function triangulateWithHoles(\n    points: number[],\n    holes: number[],\n    vertices: number[],\n    verticesStride: number,\n    verticesOffset: number,\n\n    indices: number[],\n    indicesOffset: number\n)\n{\n    const triangles = earcut(points, holes, 2);\n\n    if (!triangles)\n    {\n        return;\n    }\n\n    for (let i = 0; i < triangles.length; i += 3)\n    {\n        indices[indicesOffset++] = (triangles[i] + verticesOffset);\n        indices[indicesOffset++] = (triangles[i + 1] + verticesOffset);\n        indices[indicesOffset++] = (triangles[i + 2] + verticesOffset);\n    }\n\n    let index = verticesOffset * verticesStride;\n\n    for (let i = 0; i < points.length; i += 2)\n    {\n        vertices[index] = points[i];\n        vertices[index + 1] = points[i + 1];\n\n        index += verticesStride;\n    }\n}\n\n","'use strict';\n\nmodule.exports = earcut;\nmodule.exports.default = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim | 0);\n            triangles.push(ear.i / dim | 0);\n            triangles.push(next.i / dim | 0);\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    var p = c.next;\n    while (p !== a) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(x0, y0, minX, minY, invSize),\n        maxZ = zOrder(x1, y1, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim | 0);\n            triangles.push(p.i / dim | 0);\n            triangles.push(b.i / dim | 0);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        outerNode = eliminateHole(queue[i], outerNode);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    var bridge = findHoleBridge(hole, outerNode);\n    if (!bridge) {\n        return outerNode;\n    }\n\n    var bridgeReverse = splitPolygon(bridge, hole);\n\n    // filter collinear points around the cuts\n    filterPoints(bridgeReverse, bridgeReverse.next);\n    return filterPoints(bridge, bridge.next);\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&\n           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&\n           (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = 0;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n","\"use strict\";\nconst buildRectangle = {\n  build(shape, points) {\n    const rectData = shape;\n    const x = rectData.x;\n    const y = rectData.y;\n    const width = rectData.width;\n    const height = rectData.height;\n    if (!(width >= 0 && height >= 0)) {\n      return points;\n    }\n    points[0] = x;\n    points[1] = y;\n    points[2] = x + width;\n    points[3] = y;\n    points[4] = x + width;\n    points[5] = y + height;\n    points[6] = x;\n    points[7] = y + height;\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    let count = 0;\n    verticesOffset *= verticesStride;\n    vertices[verticesOffset + count] = points[0];\n    vertices[verticesOffset + count + 1] = points[1];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[2];\n    vertices[verticesOffset + count + 1] = points[3];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[6];\n    vertices[verticesOffset + count + 1] = points[7];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[4];\n    vertices[verticesOffset + count + 1] = points[5];\n    count += verticesStride;\n    const verticesIndex = verticesOffset / verticesStride;\n    indices[indicesOffset++] = verticesIndex;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 2;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 3;\n    indices[indicesOffset++] = verticesIndex + 2;\n  }\n};\n\nexport { buildRectangle };\n//# sourceMappingURL=buildRectangle.mjs.map\n","import type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildRectangle: ShapeBuildCommand<Rectangle> = {\n\n    build(shape: Rectangle, points: number[]): number[]\n    {\n        const rectData = shape;\n        const x = rectData.x;\n        const y = rectData.y;\n        const width = rectData.width;\n        const height = rectData.height;\n\n        if (!(width >= 0 && height >= 0))\n        {\n            return points;\n        }\n\n        points[0] = x;\n        points[1] = y;\n        points[2] = x + width;\n        points[3] = y;\n        points[4] = x + width;\n        points[5] = y + height;\n        points[6] = x;\n        points[7] = y + height;\n\n        return points;\n    },\n\n    triangulate(\n        points: number[],\n\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        let count = 0;\n\n        verticesOffset *= verticesStride;\n\n        vertices[verticesOffset + count] = points[0];\n        vertices[verticesOffset + count + 1] = points[1];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[2];\n        vertices[verticesOffset + count + 1] = points[3];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[6];\n        vertices[verticesOffset + count + 1] = points[7];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[4];\n        vertices[verticesOffset + count + 1] = points[5];\n\n        count += verticesStride;\n\n        const verticesIndex = verticesOffset / verticesStride;\n\n        // triangle 1\n        indices[indicesOffset++] = verticesIndex;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 2;\n\n        // triangle 2\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 3;\n        indices[indicesOffset++] = verticesIndex + 2;\n    },\n};\n","\"use strict\";\nconst buildTriangle = {\n  build(shape, points) {\n    points[0] = shape.x;\n    points[1] = shape.y;\n    points[2] = shape.x2;\n    points[3] = shape.y2;\n    points[4] = shape.x3;\n    points[5] = shape.y3;\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    let count = 0;\n    verticesOffset *= verticesStride;\n    vertices[verticesOffset + count] = points[0];\n    vertices[verticesOffset + count + 1] = points[1];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[2];\n    vertices[verticesOffset + count + 1] = points[3];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[4];\n    vertices[verticesOffset + count + 1] = points[5];\n    const verticesIndex = verticesOffset / verticesStride;\n    indices[indicesOffset++] = verticesIndex;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 2;\n  }\n};\n\nexport { buildTriangle };\n//# sourceMappingURL=buildTriangle.mjs.map\n","import type { Triangle } from '../../../../maths/shapes/Triangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\n/**\n * Builds a triangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildTriangle: ShapeBuildCommand<Triangle> = {\n\n    build(shape: Triangle, points: number[]): number[]\n    {\n        points[0] = shape.x;\n        points[1] = shape.y;\n        points[2] = shape.x2;\n        points[3] = shape.y2;\n        points[4] = shape.x3;\n        points[5] = shape.y3;\n\n        return points;\n    },\n\n    triangulate(\n        points: number[],\n\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        let count = 0;\n\n        verticesOffset *= verticesStride;\n\n        vertices[verticesOffset + count] = points[0];\n        vertices[verticesOffset + count + 1] = points[1];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[2];\n        vertices[verticesOffset + count + 1] = points[3];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[4];\n        vertices[verticesOffset + count + 1] = points[5];\n\n        const verticesIndex = verticesOffset / verticesStride;\n\n        // triangle 1\n        indices[indicesOffset++] = verticesIndex;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 2;\n    },\n};\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { State } from '../../../rendering/renderers/shared/state/State.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { color32BitToUniform } from '../gpu/colorToUniform.mjs';\nimport { BatchableGraphics } from './BatchableGraphics.mjs';\n\n\"use strict\";\nclass GraphicsPipe {\n  constructor(renderer, adaptor) {\n    this.state = State.for2d();\n    // batchable graphics list, used to render batches\n    this._graphicsBatchesHash = /* @__PURE__ */ Object.create(null);\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init();\n  }\n  validateRenderable(graphics) {\n    const context = graphics.context;\n    const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n    if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {\n      return true;\n    }\n    return false;\n  }\n  addRenderable(graphics, instructionSet) {\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n    if (graphics._didGraphicsUpdate) {\n      graphics._didGraphicsUpdate = false;\n      this._rebuild(graphics);\n    }\n    if (gpuContext.isBatchable) {\n      this._addToBatcher(graphics, instructionSet);\n    } else {\n      this.renderer.renderPipes.batch.break(instructionSet);\n      instructionSet.add(graphics);\n    }\n  }\n  updateRenderable(graphics) {\n    const batches = this._graphicsBatchesHash[graphics.uid];\n    if (batches) {\n      for (let i = 0; i < batches.length; i++) {\n        const batch = batches[i];\n        batch.batcher.updateElement(batch);\n      }\n    }\n  }\n  destroyRenderable(graphics) {\n    if (this._graphicsBatchesHash[graphics.uid]) {\n      this._removeBatchForRenderable(graphics.uid);\n    }\n  }\n  execute(graphics) {\n    if (!graphics.isRenderable)\n      return;\n    const renderer = this.renderer;\n    const context = graphics.context;\n    const contextSystem = renderer.graphicsContext;\n    if (!contextSystem.getGpuContext(context).batches.length) {\n      return;\n    }\n    const shader = context.customShader || this._adaptor.shader;\n    this.state.blendMode = graphics.groupBlendMode;\n    const localUniforms = shader.resources.localUniforms.uniforms;\n    localUniforms.uTransformMatrix = graphics.groupTransform;\n    localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n    color32BitToUniform(\n      graphics.groupColorAlpha,\n      localUniforms.uColor,\n      0\n    );\n    this._adaptor.execute(this, graphics);\n  }\n  _rebuild(graphics) {\n    const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n    if (wasBatched) {\n      this._removeBatchForRenderable(graphics.uid);\n    }\n    if (gpuContext.isBatchable) {\n      this._initBatchesForRenderable(graphics);\n    }\n    graphics.batched = gpuContext.isBatchable;\n  }\n  _addToBatcher(graphics, instructionSet) {\n    const batchPipe = this.renderer.renderPipes.batch;\n    const batches = this._getBatchesForRenderable(graphics);\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batchPipe.addToBatch(batch, instructionSet);\n    }\n  }\n  _getBatchesForRenderable(graphics) {\n    return this._graphicsBatchesHash[graphics.uid] || this._initBatchesForRenderable(graphics);\n  }\n  _initBatchesForRenderable(graphics) {\n    const context = graphics.context;\n    const gpuContext = this.renderer.graphicsContext.getGpuContext(context);\n    const roundPixels = this.renderer._roundPixels | graphics._roundPixels;\n    const batches = gpuContext.batches.map((batch) => {\n      const batchClone = BigPool.get(BatchableGraphics);\n      batch.copyTo(batchClone);\n      batchClone.renderable = graphics;\n      batchClone.roundPixels = roundPixels;\n      return batchClone;\n    });\n    this._graphicsBatchesHash[graphics.uid] = batches;\n    graphics.on(\"destroyed\", () => {\n      this.destroyRenderable(graphics);\n    });\n    return batches;\n  }\n  _removeBatchForRenderable(graphicsUid) {\n    this._graphicsBatchesHash[graphicsUid].forEach((batch) => {\n      BigPool.return(batch);\n    });\n    this._graphicsBatchesHash[graphicsUid] = null;\n  }\n  destroy() {\n    this.renderer = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    this.state = null;\n    for (const i in this._graphicsBatchesHash) {\n      this._removeBatchForRenderable(i);\n    }\n    this._graphicsBatchesHash = null;\n  }\n}\n/** @ignore */\nGraphicsPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"graphics\"\n};\n\nexport { GraphicsPipe };\n//# sourceMappingURL=GraphicsPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../gpu/colorToUniform';\nimport { BatchableGraphics } from './BatchableGraphics';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { BatchPipe, RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Graphics } from './Graphics';\nimport type { GpuGraphicsContext, GraphicsContextSystem } from './GraphicsContextSystem';\n\nexport interface GraphicsAdaptor\n{\n    shader: Shader;\n    init(): void;\n    execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void;\n    destroy(): void;\n}\nexport interface GraphicsSystem\n{\n    graphicsContext: GraphicsContextSystem;\n    renderPipes: {\n        batch: BatchPipe\n    }\n    _roundPixels: 0 | 1;\n}\n\nexport class GraphicsPipe implements RenderPipe<Graphics>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public renderer: GraphicsSystem;\n    public state: State = State.for2d();\n\n    // batchable graphics list, used to render batches\n    private _graphicsBatchesHash: Record<number, BatchableGraphics[]> = Object.create(null);\n    private _adaptor: GraphicsAdaptor;\n\n    constructor(renderer: GraphicsSystem, adaptor: GraphicsAdaptor)\n    {\n        this.renderer = renderer;\n\n        this._adaptor = adaptor;\n        this._adaptor.init();\n    }\n\n    public validateRenderable(graphics: Graphics): boolean\n    {\n        // assume context is dirty..\n\n        const context = graphics.context;\n\n        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n\n        if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable)\n        {\n            // TODO what if they are the same size??\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // need to get batches here.. as we need to know if we can batch or not..\n        // this also overrides the current batches..\n\n        if (graphics._didGraphicsUpdate)\n        {\n            graphics._didGraphicsUpdate = false;\n\n            this._rebuild(graphics);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._addToBatcher(graphics, instructionSet);\n        }\n        else\n        {\n            this.renderer.renderPipes.batch.break(instructionSet);\n            instructionSet.add(graphics);\n        }\n    }\n\n    public updateRenderable(graphics: Graphics)\n    {\n        const batches = this._graphicsBatchesHash[graphics.uid];\n\n        if (batches)\n        {\n            for (let i = 0; i < batches.length; i++)\n            {\n                const batch = batches[i];\n\n                batch.batcher.updateElement(batch);\n            }\n        }\n    }\n\n    public destroyRenderable(graphics: Graphics)\n    {\n        if (this._graphicsBatchesHash[graphics.uid])\n        {\n            this._removeBatchForRenderable(graphics.uid);\n        }\n    }\n\n    public execute(graphics: Graphics)\n    {\n        if (!graphics.isRenderable) return;\n\n        const renderer = this.renderer;\n        const context = graphics.context;\n        const contextSystem = renderer.graphicsContext;\n\n        // early out if there is no actual visual stuff...\n        if (!contextSystem.getGpuContext(context).batches.length)\n        { return; }\n\n        const shader = context.customShader || this._adaptor.shader;\n\n        this.state.blendMode = graphics.groupBlendMode;\n\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = graphics.groupTransform;\n        localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n\n        color32BitToUniform(\n            graphics.groupColorAlpha,\n            localUniforms.uColor,\n            0,\n        );\n\n        this._adaptor.execute(this, graphics);\n    }\n\n    private _rebuild(graphics: Graphics)\n    {\n        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // TODO POOL the old batches!\n\n        if (wasBatched)\n        {\n            this._removeBatchForRenderable(graphics.uid);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._initBatchesForRenderable(graphics);\n        }\n\n        graphics.batched = gpuContext.isBatchable;\n    }\n\n    private _addToBatcher(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const batchPipe = this.renderer.renderPipes.batch;\n\n        const batches = this._getBatchesForRenderable(graphics);\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batchPipe.addToBatch(batch, instructionSet);\n        }\n    }\n\n    private _getBatchesForRenderable(graphics: Graphics): BatchableGraphics[]\n    {\n        return this._graphicsBatchesHash[graphics.uid] || this._initBatchesForRenderable(graphics);\n    }\n\n    private _initBatchesForRenderable(graphics: Graphics): BatchableGraphics[]\n    {\n        const context = graphics.context;\n\n        const gpuContext: GpuGraphicsContext = this.renderer.graphicsContext.getGpuContext(context);\n\n        const roundPixels = (this.renderer._roundPixels | graphics._roundPixels) as 0 | 1;\n\n        const batches = gpuContext.batches.map((batch) =>\n        {\n            // TODO pool this!!\n            const batchClone = BigPool.get(BatchableGraphics);\n\n            batch.copyTo(batchClone);\n\n            batchClone.renderable = graphics;\n\n            batchClone.roundPixels = roundPixels;\n\n            return batchClone;\n        });\n\n        this._graphicsBatchesHash[graphics.uid] = batches;\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        graphics.on('destroyed', () =>\n        {\n            this.destroyRenderable(graphics);\n        });\n\n        return batches;\n    }\n\n    private _removeBatchForRenderable(graphicsUid: number)\n    {\n        this._graphicsBatchesHash[graphicsUid].forEach((batch) =>\n        {\n            BigPool.return(batch as PoolItem);\n        });\n\n        this._graphicsBatchesHash[graphicsUid] = null;\n    }\n\n    public destroy()\n    {\n        this.renderer = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n        this.state = null;\n\n        for (const i in this._graphicsBatchesHash)\n        {\n            this._removeBatchForRenderable(i as unknown as number);\n        }\n\n        this._graphicsBatchesHash = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { MeshPipe } from './shared/MeshPipe.mjs';\n\n\"use strict\";\nextensions.add(MeshPipe);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../../extensions/Extensions';\nimport { MeshPipe } from './shared/MeshPipe';\n\nextensions.add(MeshPipe);\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform.mjs';\nimport { BatchableMesh } from './BatchableMesh.mjs';\n\n\"use strict\";\nclass MeshPipe {\n  constructor(renderer, adaptor) {\n    this.localUniforms = new UniformGroup({\n      uTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n      uRound: { value: 0, type: \"f32\" }\n    });\n    this.localUniformsBindGroup = new BindGroup({\n      0: this.localUniforms\n    });\n    this._meshDataHash = /* @__PURE__ */ Object.create(null);\n    this._gpuBatchableMeshHash = /* @__PURE__ */ Object.create(null);\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init();\n  }\n  validateRenderable(mesh) {\n    const meshData = this._getMeshData(mesh);\n    const wasBatched = meshData.batched;\n    const isBatched = mesh.batched;\n    meshData.batched = isBatched;\n    if (wasBatched !== isBatched) {\n      return true;\n    } else if (isBatched) {\n      const geometry = mesh._geometry;\n      if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {\n        meshData.indexSize = geometry.indices.length;\n        meshData.vertexSize = geometry.positions.length;\n        return true;\n      }\n      const batchableMesh = this._getBatchableMesh(mesh);\n      const texture = mesh.texture;\n      if (batchableMesh.texture._source !== texture._source) {\n        if (batchableMesh.texture._source !== texture._source) {\n          return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, texture);\n        }\n      }\n    }\n    return false;\n  }\n  addRenderable(mesh, instructionSet) {\n    const batcher = this.renderer.renderPipes.batch;\n    const { batched } = this._getMeshData(mesh);\n    if (batched) {\n      const gpuBatchableMesh = this._getBatchableMesh(mesh);\n      gpuBatchableMesh.texture = mesh._texture;\n      gpuBatchableMesh.geometry = mesh._geometry;\n      batcher.addToBatch(gpuBatchableMesh);\n    } else {\n      batcher.break(instructionSet);\n      instructionSet.add({\n        renderPipeId: \"mesh\",\n        mesh\n      });\n    }\n  }\n  updateRenderable(mesh) {\n    if (mesh.batched) {\n      const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];\n      gpuBatchableMesh.texture = mesh._texture;\n      gpuBatchableMesh.geometry = mesh._geometry;\n      gpuBatchableMesh.batcher.updateElement(gpuBatchableMesh);\n    }\n  }\n  destroyRenderable(mesh) {\n    this._meshDataHash[mesh.uid] = null;\n    const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];\n    if (gpuMesh) {\n      BigPool.return(gpuMesh);\n      this._gpuBatchableMeshHash[mesh.uid] = null;\n    }\n  }\n  execute({ mesh }) {\n    if (!mesh.isRenderable)\n      return;\n    mesh.state.blendMode = mesh.groupBlendMode;\n    const localUniforms = this.localUniforms;\n    localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n    localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n    localUniforms.update();\n    color32BitToUniform(\n      mesh.groupColorAlpha,\n      localUniforms.uniforms.uColor,\n      0\n    );\n    this._adaptor.execute(this, mesh);\n  }\n  _getMeshData(mesh) {\n    return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);\n  }\n  _initMeshData(mesh) {\n    this._meshDataHash[mesh.uid] = {\n      batched: mesh.batched,\n      indexSize: mesh._geometry.indices?.length,\n      vertexSize: mesh._geometry.positions?.length\n    };\n    mesh.on(\"destroyed\", () => {\n      this.destroyRenderable(mesh);\n    });\n    return this._meshDataHash[mesh.uid];\n  }\n  _getBatchableMesh(mesh) {\n    return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);\n  }\n  _initBatchableMesh(mesh) {\n    const gpuMesh = BigPool.get(BatchableMesh);\n    gpuMesh.mesh = mesh;\n    gpuMesh.texture = mesh._texture;\n    gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;\n    this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;\n    gpuMesh.mesh = mesh;\n    return gpuMesh;\n  }\n  destroy() {\n    for (const i in this._gpuBatchableMeshHash) {\n      if (this._gpuBatchableMeshHash[i]) {\n        BigPool.return(this._gpuBatchableMeshHash[i]);\n      }\n    }\n    this._gpuBatchableMeshHash = null;\n    this._meshDataHash = null;\n    this.localUniforms = null;\n    this.localUniformsBindGroup = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    this.renderer = null;\n  }\n}\n/** @ignore */\nMeshPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"mesh\"\n};\n\nexport { MeshPipe };\n//# sourceMappingURL=MeshPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from './BatchableMesh';\n\nimport type { Instruction } from '../../../rendering/renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type {\n    InstructionPipe,\n    RenderPipe\n} from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Mesh } from './Mesh';\n\n// TODO Record mode is a P2, will get back to this as it's not a priority\n// const recordMode = true;\n\ninterface MeshData\n{\n    batched: boolean;\n    indexSize: number;\n    vertexSize: number;\n}\n\nexport interface MeshAdaptor\n{\n    init(): void;\n    execute(meshPipe: MeshPipe, mesh: Mesh): void;\n    destroy(): void;\n}\n\nexport interface MeshInstruction extends Instruction\n{\n    renderPipeId: 'mesh';\n    mesh: Mesh;\n}\n\n// eslint-disable-next-line max-len\nexport class MeshPipe implements RenderPipe<Mesh>, InstructionPipe<MeshInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'mesh',\n    } as const;\n\n    public localUniforms = new UniformGroup({\n        uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n        uRound: { value: 0, type: 'f32' },\n    });\n\n    public localUniformsBindGroup = new BindGroup({\n        0: this.localUniforms,\n    });\n\n    public renderer: Renderer;\n\n    private _meshDataHash: Record<number, MeshData> = Object.create(null);\n    private _gpuBatchableMeshHash: Record<number, BatchableMesh> = Object.create(null);\n    private _adaptor: MeshAdaptor;\n\n    constructor(renderer: Renderer, adaptor: MeshAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init();\n    }\n\n    public validateRenderable(mesh: Mesh): boolean\n    {\n        const meshData = this._getMeshData(mesh);\n\n        const wasBatched = meshData.batched;\n\n        const isBatched = mesh.batched;\n\n        meshData.batched = isBatched;\n\n        if (wasBatched !== isBatched)\n        {\n            return true;\n        }\n        else if (isBatched)\n        {\n            const geometry = mesh._geometry;\n\n            // no need to break the batch if it's the same size\n            if (geometry.indices.length !== meshData.indexSize\n                    || geometry.positions.length !== meshData.vertexSize)\n            {\n                meshData.indexSize = geometry.indices.length;\n                meshData.vertexSize = geometry.positions.length;\n\n                return true;\n            }\n\n            const batchableMesh = this._getBatchableMesh(mesh);\n\n            const texture = mesh.texture;\n\n            if (batchableMesh.texture._source !== texture._source)\n            {\n                if (batchableMesh.texture._source !== texture._source)\n                {\n                    return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, texture);\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public addRenderable(mesh: Mesh, instructionSet: InstructionSet)\n    {\n        const batcher = this.renderer.renderPipes.batch;\n\n        const { batched } = this._getMeshData(mesh);\n\n        if (batched)\n        {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n\n            gpuBatchableMesh.texture = mesh._texture;\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            batcher.addToBatch(gpuBatchableMesh);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            instructionSet.add({\n                renderPipeId: 'mesh',\n                mesh\n            } as MeshInstruction);\n        }\n    }\n\n    public updateRenderable(mesh: Mesh)\n    {\n        if (mesh.batched)\n        {\n            const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];\n\n            gpuBatchableMesh.texture = mesh._texture;\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            gpuBatchableMesh.batcher.updateElement(gpuBatchableMesh);\n        }\n    }\n\n    public destroyRenderable(mesh: Mesh)\n    {\n        this._meshDataHash[mesh.uid] = null;\n\n        const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];\n\n        if (gpuMesh)\n        {\n            BigPool.return(gpuMesh as PoolItem);\n            this._gpuBatchableMeshHash[mesh.uid] = null;\n        }\n    }\n\n    public execute({ mesh }: MeshInstruction)\n    {\n        if (!mesh.isRenderable) return;\n\n        mesh.state.blendMode = mesh.groupBlendMode;\n\n        const localUniforms = this.localUniforms;\n\n        localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n        localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n        localUniforms.update();\n\n        color32BitToUniform(\n            mesh.groupColorAlpha,\n            localUniforms.uniforms.uColor,\n            0\n        );\n\n        this._adaptor.execute(this, mesh);\n    }\n\n    private _getMeshData(mesh: Mesh): MeshData\n    {\n        return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);\n    }\n\n    private _initMeshData(mesh: Mesh): MeshData\n    {\n        this._meshDataHash[mesh.uid] = {\n            batched: mesh.batched,\n            indexSize: mesh._geometry.indices?.length,\n            vertexSize: mesh._geometry.positions?.length,\n        };\n\n        mesh.on('destroyed', () =>\n        {\n            this.destroyRenderable(mesh);\n        });\n\n        return this._meshDataHash[mesh.uid];\n    }\n\n    private _getBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);\n    }\n\n    private _initBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        // TODO - make this batchable graphics??\n        const gpuMesh: BatchableMesh = BigPool.get(BatchableMesh);\n\n        gpuMesh.mesh = mesh;\n        gpuMesh.texture = mesh._texture;\n        gpuMesh.roundPixels = (this.renderer._roundPixels | mesh._roundPixels) as 0 | 1;\n\n        this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;\n\n        gpuMesh.mesh = mesh;\n\n        return gpuMesh;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuBatchableMeshHash)\n        {\n            if (this._gpuBatchableMeshHash[i])\n            {\n                BigPool.return(this._gpuBatchableMeshHash[i] as PoolItem);\n            }\n        }\n\n        this._gpuBatchableMeshHash = null;\n        this._meshDataHash = null;\n\n        this.localUniforms = null;\n        this.localUniformsBindGroup = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n\n        this.renderer = null;\n    }\n}\n","\"use strict\";\nclass BatchableMesh {\n  constructor() {\n    this.batcher = null;\n    this.batch = null;\n    this.roundPixels = 0;\n    this._uvUpdateId = -1;\n    this._textureMatrixUpdateId = -1;\n  }\n  get blendMode() {\n    return this.mesh.groupBlendMode;\n  }\n  reset() {\n    this.mesh = null;\n    this.texture = null;\n    this.batcher = null;\n    this.batch = null;\n  }\n  packIndex(indexBuffer, index, indicesOffset) {\n    const indices = this.geometry.indices;\n    for (let i = 0; i < indices.length; i++) {\n      indexBuffer[index++] = indices[i] + indicesOffset;\n    }\n  }\n  packAttributes(float32View, uint32View, index, textureId) {\n    const mesh = this.mesh;\n    const geometry = this.geometry;\n    const wt = mesh.groupTransform;\n    const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const positions = geometry.positions;\n    const uvBuffer = geometry.getBuffer(\"aUV\");\n    const uvs = uvBuffer.data;\n    let transformedUvs = uvs;\n    const textureMatrix = this.texture.textureMatrix;\n    if (!textureMatrix.isSimple) {\n      transformedUvs = this._transformedUvs;\n      if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID) {\n        if (!transformedUvs || transformedUvs.length < uvs.length) {\n          transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n        }\n        this._textureMatrixUpdateId = textureMatrix._updateID;\n        this._uvUpdateId = uvBuffer._updateID;\n        textureMatrix.multiplyUvs(uvs, transformedUvs);\n      }\n    }\n    const abgr = mesh.groupColorAlpha;\n    for (let i = 0; i < positions.length; i += 2) {\n      const x = positions[i];\n      const y = positions[i + 1];\n      float32View[index] = a * x + c * y + tx;\n      float32View[index + 1] = b * x + d * y + ty;\n      float32View[index + 2] = transformedUvs[i];\n      float32View[index + 3] = transformedUvs[i + 1];\n      uint32View[index + 4] = abgr;\n      uint32View[index + 5] = textureIdAndRound;\n      index += 6;\n    }\n  }\n  get vertexSize() {\n    return this.geometry.positions.length / 2;\n  }\n  get indexSize() {\n    return this.geometry.indices.length;\n  }\n}\n\nexport { BatchableMesh };\n//# sourceMappingURL=BatchableMesh.mjs.map\n","import type { Batch, BatchableObject, Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { IndexBufferArray } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Container } from '../../container/Container';\nimport type { MeshGeometry } from './MeshGeometry';\n\n/**\n * A batchable mesh object.\n * @ignore\n */\nexport class BatchableMesh implements BatchableObject\n{\n    public indexStart: number;\n    public textureId: number;\n    public texture: Texture;\n    public location: number;\n    public batcher: Batcher = null;\n    public batch: Batch = null;\n    public mesh: Container;\n    public geometry: MeshGeometry;\n\n    public roundPixels: 0 | 1 = 0;\n\n    private _transformedUvs: Float32Array;\n    private _uvUpdateId: number = -1;\n    private _textureMatrixUpdateId: number = -1;\n\n    get blendMode() { return this.mesh.groupBlendMode; }\n\n    public reset()\n    {\n        this.mesh = null;\n        this.texture = null;\n        this.batcher = null;\n        this.batch = null;\n    }\n\n    public packIndex(indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        const indices = this.geometry.indices;\n\n        for (let i = 0; i < indices.length; i++)\n        {\n            indexBuffer[index++] = indices[i] + indicesOffset;\n        }\n    }\n\n    public packAttributes(\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    )\n    {\n        const mesh = this.mesh;\n\n        const geometry = this.geometry;\n        const wt = mesh.groupTransform;\n\n        const textureIdAndRound = (textureId << 16) | (this.roundPixels & 0xFFFF);\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        // const trim = texture.trim;\n        const positions = geometry.positions;\n        const uvBuffer = geometry.getBuffer('aUV');\n\n        const uvs = uvBuffer.data;\n\n        let transformedUvs = uvs;\n        const textureMatrix = this.texture.textureMatrix;\n\n        if (!textureMatrix.isSimple)\n        {\n            transformedUvs = this._transformedUvs;\n\n            if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID)\n            {\n                if (!transformedUvs || transformedUvs.length < uvs.length)\n                {\n                    transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n                }\n\n                this._textureMatrixUpdateId = textureMatrix._updateID;\n                this._uvUpdateId = uvBuffer._updateID;\n\n                textureMatrix.multiplyUvs(uvs as Float32Array, transformedUvs);\n            }\n        }\n\n        const abgr = mesh.groupColorAlpha;\n\n        for (let i = 0; i < positions.length; i += 2)\n        {\n            const x = positions[i];\n            const y = positions[i + 1];\n\n            float32View[index] = (a * x) + (c * y) + tx;\n            float32View[index + 1] = (b * x) + (d * y) + ty;\n\n            // TODO implement texture matrix?\n            float32View[index + 2] = transformedUvs[i];\n            float32View[index + 3] = transformedUvs[i + 1];\n\n            uint32View[index + 4] = abgr;\n            uint32View[index + 5] = textureIdAndRound;\n\n            index += 6;\n        }\n    }\n\n    get vertexSize()\n    {\n        return this.geometry.positions.length / 2;\n    }\n\n    get indexSize()\n    {\n        return this.geometry.indices.length;\n    }\n}\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { CanvasTextPipe } from './canvas/CanvasTextPipe.mjs';\nimport { CanvasTextSystem } from './canvas/CanvasTextSystem.mjs';\n\n\"use strict\";\nextensions.add(CanvasTextSystem);\nextensions.add(CanvasTextPipe);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../../extensions/Extensions';\nimport { CanvasTextPipe } from './canvas/CanvasTextPipe';\nimport { CanvasTextSystem } from './canvas/CanvasTextSystem';\n\nextensions.add(CanvasTextSystem);\nextensions.add(CanvasTextPipe);\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { updateQuadBounds } from '../../../utils/data/updateQuadBounds.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { BatchableSprite } from '../../sprite/BatchableSprite.mjs';\n\n\"use strict\";\nclass CanvasTextPipe {\n  constructor(renderer) {\n    this._gpuText = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  validateRenderable(text) {\n    const gpuText = this._getGpuText(text);\n    const newKey = text._getKey();\n    if (gpuText.currentKey !== newKey) {\n      const resolution = text.resolution ?? this._renderer.resolution;\n      const { width, height } = this._renderer.canvasText.getTextureSize(\n        text.text,\n        resolution,\n        text._style\n      );\n      if (\n        // is only being used by this text:\n        this._renderer.canvasText.getReferenceCount(gpuText.currentKey) === 1 && width === gpuText.texture._source.width && height === gpuText.texture._source.height\n      ) {\n        return false;\n      }\n      return true;\n    }\n    return false;\n  }\n  addRenderable(text, _instructionSet) {\n    const gpuText = this._getGpuText(text);\n    const batchableSprite = gpuText.batchableSprite;\n    if (text._didTextUpdate) {\n      this._updateText(text);\n    }\n    this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n  }\n  updateRenderable(text) {\n    const gpuText = this._getGpuText(text);\n    const batchableSprite = gpuText.batchableSprite;\n    if (text._didTextUpdate) {\n      this._updateText(text);\n    }\n    batchableSprite.batcher.updateElement(batchableSprite);\n  }\n  destroyRenderable(text) {\n    this._destroyRenderableById(text.uid);\n  }\n  _destroyRenderableById(textUid) {\n    const gpuText = this._gpuText[textUid];\n    this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n    BigPool.return(gpuText.batchableSprite);\n    this._gpuText[textUid] = null;\n  }\n  _updateText(text) {\n    const newKey = text._getKey();\n    const gpuText = this._getGpuText(text);\n    const batchableSprite = gpuText.batchableSprite;\n    if (gpuText.currentKey !== newKey) {\n      this._updateGpuText(text);\n    }\n    text._didTextUpdate = false;\n    const padding = text._style.padding;\n    updateQuadBounds(batchableSprite.bounds, text._anchor, batchableSprite.texture, padding);\n  }\n  _updateGpuText(text) {\n    const gpuText = this._getGpuText(text);\n    const batchableSprite = gpuText.batchableSprite;\n    if (gpuText.texture) {\n      this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n    }\n    const resolution = text.resolution ?? this._renderer.resolution;\n    gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getTexture(\n      text.text,\n      resolution,\n      text._style,\n      text._getKey()\n    );\n    gpuText.currentKey = text._getKey();\n    batchableSprite.texture = gpuText.texture;\n  }\n  _getGpuText(text) {\n    return this._gpuText[text.uid] || this.initGpuText(text);\n  }\n  initGpuText(text) {\n    const gpuTextData = {\n      texture: null,\n      currentKey: \"--\",\n      batchableSprite: BigPool.get(BatchableSprite)\n    };\n    gpuTextData.batchableSprite.renderable = text;\n    gpuTextData.batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    gpuTextData.batchableSprite.roundPixels = this._renderer._roundPixels | text._roundPixels;\n    this._gpuText[text.uid] = gpuTextData;\n    this._updateText(text);\n    text.on(\"destroyed\", () => {\n      this.destroyRenderable(text);\n    });\n    return gpuTextData;\n  }\n  destroy() {\n    for (const i in this._gpuText) {\n      this._destroyRenderableById(i);\n    }\n    this._gpuText = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nCanvasTextPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"text\"\n};\n\nexport { CanvasTextPipe };\n//# sourceMappingURL=CanvasTextPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { updateQuadBounds } from '../../../utils/data/updateQuadBounds';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../../sprite/BatchableSprite';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Text } from '../Text';\n\nexport class CanvasTextPipe implements RenderPipe<Text>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'text',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _gpuText: Record<number, {\n        texture: Texture,\n        currentKey: string,\n        batchableSprite: BatchableSprite,\n    }> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(text: Text): boolean\n    {\n        const gpuText = this._getGpuText(text);\n\n        const newKey = text._getKey();\n\n        if (gpuText.currentKey !== newKey)\n        {\n            const resolution = text.resolution ?? this._renderer.resolution;\n\n            const { width, height } = this._renderer.canvasText.getTextureSize(\n                text.text,\n                resolution,\n                text._style,\n            );\n\n            if (\n                // is only being used by this text:\n                this._renderer.canvasText.getReferenceCount(gpuText.currentKey) === 1\n                // check the size of the text is the same po2\n                && width === gpuText.texture._source.width\n                && height === gpuText.texture._source.height\n            )\n            {\n                return false;\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(text: Text, _instructionSet: InstructionSet)\n    {\n        const gpuText = this._getGpuText(text);\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (text._didTextUpdate)\n        {\n            this._updateText(text);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n    }\n\n    public updateRenderable(text: Text)\n    {\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (text._didTextUpdate)\n        {\n            this._updateText(text);\n        }\n\n        batchableSprite.batcher.updateElement(batchableSprite);\n    }\n\n    public destroyRenderable(text: Text)\n    {\n        this._destroyRenderableById(text.uid);\n    }\n\n    private _destroyRenderableById(textUid: number)\n    {\n        const gpuText = this._gpuText[textUid];\n\n        this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n\n        BigPool.return(gpuText.batchableSprite);\n\n        this._gpuText[textUid] = null;\n    }\n\n    private _updateText(text: Text)\n    {\n        const newKey = text._getKey();\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            this._updateGpuText(text);\n        }\n\n        text._didTextUpdate = false;\n\n        const padding = text._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, text._anchor, batchableSprite.texture, padding);\n    }\n\n    private _updateGpuText(text: Text)\n    {\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.texture)\n        {\n            this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n        }\n\n        const resolution = text.resolution ?? this._renderer.resolution;\n\n        gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getTexture(\n            text.text,\n            resolution,\n            text._style,\n            text._getKey()\n        );\n\n        gpuText.currentKey = text._getKey();\n        batchableSprite.texture = gpuText.texture;\n    }\n\n    private _getGpuText(text: Text)\n    {\n        return this._gpuText[text.uid] || this.initGpuText(text);\n    }\n\n    public initGpuText(text: Text)\n    {\n        const gpuTextData: CanvasTextPipe['_gpuText'][number] = {\n            texture: null,\n            currentKey: '--',\n            batchableSprite: BigPool.get(BatchableSprite),\n        };\n\n        gpuTextData.batchableSprite.renderable = text;\n        gpuTextData.batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        gpuTextData.batchableSprite.roundPixels = (this._renderer._roundPixels | text._roundPixels) as 0 | 1;\n\n        this._gpuText[text.uid] = gpuTextData;\n\n        this._updateText(text);\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        text.on('destroyed', () =>\n        {\n            this.destroyRenderable(text);\n        });\n\n        return gpuTextData;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuText)\n        {\n            this._destroyRenderableById(i as unknown as number);\n        }\n\n        this._gpuText = null;\n        this._renderer = null;\n    }\n}\n","import { Color } from '../../../color/Color.mjs';\nimport { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { nextPow2 } from '../../../maths/misc/pow2.mjs';\nimport { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool.mjs';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { getCanvasBoundingBox } from '../../../utils/canvas/getCanvasBoundingBox.mjs';\nimport { getPo2TextureFromSource } from '../utils/getPo2TextureFromSource.mjs';\nimport { CanvasTextMetrics } from './CanvasTextMetrics.mjs';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle.mjs';\nimport { getCanvasFillStyle } from './utils/getCanvasFillStyle.mjs';\n\n\"use strict\";\nclass CanvasTextSystem {\n  constructor() {\n    this._activeTextures = {};\n  }\n  getTextureSize(text, resolution, style) {\n    const measured = CanvasTextMetrics.measureText(text || \" \", style);\n    let width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    let height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    width = Math.ceil(width - 1e-6);\n    height = Math.ceil(height - 1e-6);\n    width = nextPow2(width);\n    height = nextPow2(height);\n    return { width, height };\n  }\n  getTexture(text, resolution, style, textKey) {\n    if (this._activeTextures[textKey]) {\n      this._increaseReferenceCount(textKey);\n      return this._activeTextures[textKey].texture;\n    }\n    const measured = CanvasTextMetrics.measureText(text || \" \", style);\n    const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);\n    const { canvas } = canvasAndContext;\n    this.renderTextToCanvas(text, style, resolution, canvasAndContext);\n    const texture = getPo2TextureFromSource(canvas, width, height, resolution);\n    if (style.trim) {\n      const trimmed = getCanvasBoundingBox(canvas, resolution);\n      texture.frame.copyFrom(trimmed);\n      texture.updateUvs();\n    }\n    this._activeTextures[textKey] = {\n      canvasAndContext,\n      texture,\n      usageCount: 1\n    };\n    return texture;\n  }\n  _increaseReferenceCount(textKey) {\n    this._activeTextures[textKey].usageCount++;\n  }\n  decreaseReferenceCount(textKey) {\n    const activeTexture = this._activeTextures[textKey];\n    activeTexture.usageCount--;\n    if (activeTexture.usageCount === 0) {\n      CanvasPool.returnCanvasAndContext(activeTexture.canvasAndContext);\n      TexturePool.returnTexture(activeTexture.texture);\n      const source = activeTexture.texture.source;\n      source.resource = null;\n      source.uploadMethodId = \"unknown\";\n      source.alphaMode = \"no-premultiply-alpha\";\n      this._activeTextures[textKey] = null;\n    }\n  }\n  getReferenceCount(textKey) {\n    return this._activeTextures[textKey].usageCount;\n  }\n  /**\n   * Renders text to its canvas, and updates its texture.\n   *\n   * By default this is used internally to ensure the texture is correct before rendering,\n   * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,\n   * and then shared across multiple Sprites.\n   * @param text\n   * @param style\n   * @param resolution\n   * @param canvasAndContext\n   */\n  renderTextToCanvas(text, style, resolution, canvasAndContext) {\n    const { canvas, context } = canvasAndContext;\n    const font = fontStringFromTextStyle(style);\n    const measured = CanvasTextMetrics.measureText(text || \" \", style);\n    const lines = measured.lines;\n    const lineHeight = measured.lineHeight;\n    const lineWidths = measured.lineWidths;\n    const maxLineWidth = measured.maxLineWidth;\n    const fontProperties = measured.fontProperties;\n    const height = canvas.height;\n    context.resetTransform();\n    context.scale(resolution, resolution);\n    context.clearRect(0, 0, measured.width + 4, measured.height + 4);\n    if (style._stroke?.width) {\n      const strokeStyle = style._stroke;\n      context.lineWidth = strokeStyle.width;\n      context.miterLimit = strokeStyle.miterLimit;\n      context.lineJoin = strokeStyle.join;\n      context.lineCap = strokeStyle.cap;\n    }\n    context.font = font;\n    let linePositionX;\n    let linePositionY;\n    const passesCount = style.dropShadow ? 2 : 1;\n    for (let i = 0; i < passesCount; ++i) {\n      const isShadowPass = style.dropShadow && i === 0;\n      const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;\n      const dsOffsetShadow = dsOffsetText * resolution;\n      if (isShadowPass) {\n        context.fillStyle = \"black\";\n        context.strokeStyle = \"black\";\n        const shadowOptions = style.dropShadow;\n        const dropShadowColor = shadowOptions.color;\n        const dropShadowAlpha = shadowOptions.alpha;\n        context.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();\n        const dropShadowBlur = shadowOptions.blur * resolution;\n        const dropShadowDistance = shadowOptions.distance * resolution;\n        context.shadowBlur = dropShadowBlur;\n        context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n        context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance + dsOffsetShadow;\n      } else {\n        context.globalAlpha = style._fill?.alpha ?? 1;\n        context.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context) : null;\n        if (style._stroke?.width) {\n          context.strokeStyle = getCanvasFillStyle(style._stroke, context);\n        }\n        context.shadowColor = \"black\";\n      }\n      let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n      if (lineHeight - fontProperties.fontSize < 0) {\n        linePositionYShift = 0;\n      }\n      const strokeWidth = style._stroke?.width ?? 0;\n      for (let i2 = 0; i2 < lines.length; i2++) {\n        linePositionX = strokeWidth / 2;\n        linePositionY = strokeWidth / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift;\n        if (style.align === \"right\") {\n          linePositionX += maxLineWidth - lineWidths[i2];\n        } else if (style.align === \"center\") {\n          linePositionX += (maxLineWidth - lineWidths[i2]) / 2;\n        }\n        if (style._stroke) {\n          this._drawLetterSpacing(\n            lines[i2],\n            style,\n            canvasAndContext,\n            linePositionX + style.padding,\n            linePositionY + style.padding - dsOffsetText,\n            true\n          );\n        }\n        if (style._fill !== void 0) {\n          this._drawLetterSpacing(\n            lines[i2],\n            style,\n            canvasAndContext,\n            linePositionX + style.padding,\n            linePositionY + style.padding - dsOffsetText\n          );\n        }\n      }\n    }\n  }\n  /**\n   * Render the text with letter-spacing.\n   * @param text - The text to draw\n   * @param style\n   * @param canvasAndContext\n   * @param x - Horizontal position to draw the text\n   * @param y - Vertical position to draw the text\n   * @param isStroke - Is this drawing for the outside stroke of the\n   *  text? If not, it's for the inside fill\n   */\n  _drawLetterSpacing(text, style, canvasAndContext, x, y, isStroke = false) {\n    const { context } = canvasAndContext;\n    const letterSpacing = style.letterSpacing;\n    let useExperimentalLetterSpacing = false;\n    if (CanvasTextMetrics.experimentalLetterSpacingSupported) {\n      if (CanvasTextMetrics.experimentalLetterSpacing) {\n        context.letterSpacing = `${letterSpacing}px`;\n        context.textLetterSpacing = `${letterSpacing}px`;\n        useExperimentalLetterSpacing = true;\n      } else {\n        context.letterSpacing = \"0px\";\n        context.textLetterSpacing = \"0px\";\n      }\n    }\n    if (letterSpacing === 0 || useExperimentalLetterSpacing) {\n      if (isStroke) {\n        context.strokeText(text, x, y);\n      } else {\n        context.fillText(text, x, y);\n      }\n      return;\n    }\n    let currentPosition = x;\n    const stringArray = CanvasTextMetrics.graphemeSegmenter(text);\n    let previousWidth = context.measureText(text).width;\n    let currentWidth = 0;\n    for (let i = 0; i < stringArray.length; ++i) {\n      const currentChar = stringArray[i];\n      if (isStroke) {\n        context.strokeText(currentChar, currentPosition, y);\n      } else {\n        context.fillText(currentChar, currentPosition, y);\n      }\n      let textStr = \"\";\n      for (let j = i + 1; j < stringArray.length; ++j) {\n        textStr += stringArray[j];\n      }\n      currentWidth = context.measureText(textStr).width;\n      currentPosition += previousWidth - currentWidth + letterSpacing;\n      previousWidth = currentWidth;\n    }\n  }\n  destroy() {\n    this._activeTextures = null;\n  }\n}\n/** @ignore */\nCanvasTextSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"canvasText\"\n};\n\nexport { CanvasTextSystem };\n//# sourceMappingURL=CanvasTextSystem.mjs.map\n","import { Color } from '../../../color/Color';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { nextPow2 } from '../../../maths/misc/pow2';\nimport { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { getCanvasBoundingBox } from '../../../utils/canvas/getCanvasBoundingBox';\nimport { getPo2TextureFromSource } from '../utils/getPo2TextureFromSource';\nimport { CanvasTextMetrics } from './CanvasTextMetrics';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from './utils/getCanvasFillStyle';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { TextStyle } from '../TextStyle';\n\ninterface CanvasAndContext\n{\n    canvas: ICanvas;\n    context: ICanvasRenderingContext2D;\n}\n\n/**\n * System plugin to the renderer to manage canvas text.\n * @memberof rendering\n */\nexport class CanvasTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'canvasText',\n    } as const;\n\n    private _activeTextures: Record<string, {\n        canvasAndContext: CanvasAndContext,\n        texture: Texture,\n        usageCount: number,\n    }> = {};\n\n    public getTextureSize(text: string, resolution: number, style: TextStyle): { width: number, height: number }\n    {\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        let width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        let height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        width = Math.ceil((width) - 1e-6);\n        height = Math.ceil((height) - 1e-6);\n        width = nextPow2(width);\n        height = nextPow2(height);\n\n        return { width, height };\n    }\n\n    public getTexture(text: string, resolution: number, style: TextStyle, textKey: string)\n    {\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].texture;\n        }\n\n        // create a canvas with the word hello on it\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);\n\n        // create a texture from the canvas\n        const { canvas } = canvasAndContext;\n\n        this.renderTextToCanvas(text, style, resolution, canvasAndContext);\n\n        const texture = getPo2TextureFromSource(canvas, width, height, resolution);\n\n        if (style.trim)\n        {\n            const trimmed = getCanvasBoundingBox(canvas, resolution);\n\n            texture.frame.copyFrom(trimmed);\n\n            texture.updateUvs();\n        }\n\n        this._activeTextures[textKey] = {\n            canvasAndContext,\n            texture,\n            usageCount: 1,\n        };\n\n        return texture;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            CanvasPool.returnCanvasAndContext(activeTexture.canvasAndContext);\n            TexturePool.returnTexture(activeTexture.texture);\n\n            const source = activeTexture.texture.source;\n\n            source.resource = null;\n            source.uploadMethodId = 'unknown';\n            source.alphaMode = 'no-premultiply-alpha';\n\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey].usageCount;\n    }\n\n    /**\n     * Renders text to its canvas, and updates its texture.\n     *\n     * By default this is used internally to ensure the texture is correct before rendering,\n     * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,\n     * and then shared across multiple Sprites.\n     * @param text\n     * @param style\n     * @param resolution\n     * @param canvasAndContext\n     */\n    public renderTextToCanvas(text: string, style: TextStyle, resolution: number, canvasAndContext: CanvasAndContext): void\n    {\n        const { canvas, context } = canvasAndContext;\n\n        const font = fontStringFromTextStyle(style);\n\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);// , canvas);\n        const lines = measured.lines;\n        const lineHeight = measured.lineHeight;\n        const lineWidths = measured.lineWidths;\n        const maxLineWidth = measured.maxLineWidth;\n        const fontProperties = measured.fontProperties;\n\n        const height = canvas.height;\n\n        context.resetTransform();\n\n        context.scale(resolution, resolution);\n\n        context.clearRect(0, 0, measured.width + 4, measured.height + 4);\n\n        // set stroke styles..\n\n        if (style._stroke?.width)\n        {\n            const strokeStyle = style._stroke;\n\n            context.lineWidth = strokeStyle.width;\n\n            context.miterLimit = strokeStyle.miterLimit;\n            context.lineJoin = strokeStyle.join;\n            context.lineCap = strokeStyle.cap;\n        }\n\n        // return;\n        context.font = font;\n\n        let linePositionX: number;\n        let linePositionY: number;\n\n        // require 2 passes if a shadow; the first to draw the drop shadow, the second to draw the text\n        const passesCount = style.dropShadow ? 2 : 1;\n\n        // For v4, we drew text at the colours of the drop shadow underneath the normal text. This gave the correct zIndex,\n        // but features such as alpha and shadowblur did not look right at all, since we were using actual text as a shadow.\n        //\n        // For v5.0.0, we moved over to just use the canvas API for drop shadows, which made them look much nicer and more\n        // visually please, but now because the stroke is drawn and then the fill, drop shadows would appear on both the fill\n        // and the stroke; and fill drop shadows would appear over the top of the stroke.\n        //\n        // For v5.1.1, the new route is to revert to v4 style of drawing text first to get the drop shadows underneath normal\n        // text, but instead drawing text in the correct location, we'll draw it off screen (-paddingY), and then adjust the\n        // drop shadow so only that appears on screen (+paddingY). Now we'll have the correct draw order of the shadow\n        // beneath the text, whilst also having the proper text shadow styling.\n        for (let i = 0; i < passesCount; ++i)\n        {\n            const isShadowPass = style.dropShadow && i === 0;\n            // we only want the drop shadow, so put text way off-screen\n            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + (style.padding * 2)) : 0;\n            const dsOffsetShadow = dsOffsetText * resolution;\n\n            if (isShadowPass)\n            {\n                // On Safari, text with gradient and drop shadows together do not position correctly\n                // if the scale of the canvas is not 1: https://bugs.webkit.org/show_bug.cgi?id=197689\n                // Therefore we'll set the styles to be a plain black whilst generating this drop shadow\n                context.fillStyle = 'black';\n                context.strokeStyle = 'black';\n\n                const shadowOptions = style.dropShadow;\n\n                const dropShadowColor = shadowOptions.color;\n                const dropShadowAlpha = shadowOptions.alpha;\n\n                context.shadowColor = Color.shared\n                    .setValue(dropShadowColor)\n                    .setAlpha(dropShadowAlpha)\n                    .toRgbaString();\n\n                const dropShadowBlur = shadowOptions.blur * resolution;\n                const dropShadowDistance = shadowOptions.distance * resolution;\n\n                context.shadowBlur = dropShadowBlur;\n                context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n                context.shadowOffsetY = (Math.sin(shadowOptions.angle) * dropShadowDistance) + dsOffsetShadow;\n            }\n            else\n            {\n                context.globalAlpha = style._fill?.alpha ?? 1;\n                context.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context) : null;\n\n                if (style._stroke?.width)\n                {\n                    context.strokeStyle = getCanvasFillStyle(style._stroke, context);\n                }\n\n                context.shadowColor = 'black';\n            }\n\n            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n\n            if (lineHeight - fontProperties.fontSize < 0)\n            {\n                linePositionYShift = 0;\n            }\n\n            const strokeWidth = style._stroke?.width ?? 0;\n\n            // draw lines line by line\n            for (let i = 0; i < lines.length; i++)\n            {\n                linePositionX = strokeWidth / 2;\n                linePositionY = ((strokeWidth / 2) + (i * lineHeight)) + fontProperties.ascent + linePositionYShift;\n\n                if (style.align === 'right')\n                {\n                    linePositionX += maxLineWidth - lineWidths[i];\n                }\n                else if (style.align === 'center')\n                {\n                    linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n                }\n\n                if (style._stroke)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText,\n                        true\n                    );\n                }\n\n                if (style._fill !== undefined)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Render the text with letter-spacing.\n     * @param text - The text to draw\n     * @param style\n     * @param canvasAndContext\n     * @param x - Horizontal position to draw the text\n     * @param y - Vertical position to draw the text\n     * @param isStroke - Is this drawing for the outside stroke of the\n     *  text? If not, it's for the inside fill\n     */\n    private _drawLetterSpacing(\n        text: string,\n        style: TextStyle,\n        canvasAndContext: CanvasAndContext,\n        x: number, y: number,\n        isStroke = false\n    ): void\n    {\n        const { context } = canvasAndContext;\n\n        // letterSpacing of 0 means normal\n        const letterSpacing = style.letterSpacing;\n\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        if (letterSpacing === 0 || useExperimentalLetterSpacing)\n        {\n            if (isStroke)\n            {\n                context.strokeText(text, x, y);\n            }\n            else\n            {\n                context.fillText(text, x, y);\n            }\n\n            return;\n        }\n\n        let currentPosition = x;\n\n        const stringArray = CanvasTextMetrics.graphemeSegmenter(text);\n        let previousWidth = context.measureText(text).width;\n        let currentWidth = 0;\n\n        for (let i = 0; i < stringArray.length; ++i)\n        {\n            const currentChar = stringArray[i];\n\n            if (isStroke)\n            {\n                context.strokeText(currentChar, currentPosition, y);\n            }\n            else\n            {\n                context.fillText(currentChar, currentPosition, y);\n            }\n            let textStr = '';\n\n            for (let j = i + 1; j < stringArray.length; ++j)\n            {\n                textStr += stringArray[j];\n            }\n            currentWidth = context.measureText(textStr).width;\n            currentPosition += previousWidth - currentWidth + letterSpacing;\n            previousWidth = currentWidth;\n        }\n    }\n\n    public destroy(): void\n    {\n        this._activeTextures = null;\n    }\n}\n","import { Rectangle } from '../../maths/shapes/Rectangle.mjs';\n\n\"use strict\";\nfunction checkRow(data, width, y) {\n  for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4) {\n    if (data[index + 3] !== 0)\n      return false;\n  }\n  return true;\n}\nfunction checkColumn(data, width, x, top, bottom) {\n  const stride = 4 * width;\n  for (let y = top, index = top * stride + 4 * x; y <= bottom; ++y, index += stride) {\n    if (data[index + 3] !== 0)\n      return false;\n  }\n  return true;\n}\nfunction getCanvasBoundingBox(canvas, resolution = 1) {\n  const { width, height } = canvas;\n  const context = canvas.getContext(\"2d\", {\n    willReadFrequently: true\n  });\n  if (context === null) {\n    throw new TypeError(\"Failed to get canvas 2D context\");\n  }\n  const imageData = context.getImageData(0, 0, width, height);\n  const data = imageData.data;\n  let left = 0;\n  let top = 0;\n  let right = width - 1;\n  let bottom = height - 1;\n  while (top < height && checkRow(data, width, top))\n    ++top;\n  if (top === height)\n    return Rectangle.EMPTY;\n  while (checkRow(data, width, bottom))\n    --bottom;\n  while (checkColumn(data, width, left, top, bottom))\n    ++left;\n  while (checkColumn(data, width, right, top, bottom))\n    --right;\n  ++right;\n  ++bottom;\n  return new Rectangle(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);\n}\n\nexport { getCanvasBoundingBox };\n//# sourceMappingURL=getCanvasBoundingBox.mjs.map\n","import { Rectangle } from '../../maths/shapes/Rectangle';\n\nimport type { ICanvas } from '../../environment/canvas/ICanvas';\n\nfunction checkRow(data: Uint8ClampedArray, width: number, y: number)\n{\n    for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\nfunction checkColumn(data: Uint8ClampedArray, width: number, x: number, top: number, bottom: number)\n{\n    const stride = 4 * width;\n\n    for (let y = top, index = (top * stride) + (4 * x); y <= bottom; ++y, index += stride)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\n/**\n * Measuring the bounds of a canvas' visible (non-transparent) pixels.\n * @param canvas - The canvas to measure.\n * @param resolution - The resolution of the canvas.\n * @returns The bounding box of the canvas' visible pixels.\n * @since 7.1.0\n * @memberof utils\n */\nexport function getCanvasBoundingBox(canvas: ICanvas, resolution = 1): Rectangle\n{\n    // https://gist.github.com/timdown/021d9c8f2aabc7092df564996f5afbbf\n\n    const { width, height } = canvas;\n\n    const context = canvas.getContext('2d', {\n        willReadFrequently: true,\n    });\n\n    if (context === null)\n    {\n        throw new TypeError('Failed to get canvas 2D context');\n    }\n\n    const imageData = context.getImageData(0, 0, width, height);\n    const data = imageData.data;\n\n    let left = 0;\n    let top = 0;\n    let right = width - 1;\n    let bottom = height - 1;\n\n    while (top < height && checkRow(data, width, top)) ++top;\n    if (top === height) return Rectangle.EMPTY;\n    while (checkRow(data, width, bottom)) --bottom;\n    while (checkColumn(data, width, left, top, bottom)) ++left;\n    while (checkColumn(data, width, right, top, bottom)) --right;\n\n    ++right;\n    ++bottom;\n\n    return new Rectangle(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);\n}\n","import { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { Bounds } from '../../container/bounds/Bounds.mjs';\n\n\"use strict\";\nconst tempBounds = new Bounds();\nfunction getPo2TextureFromSource(image, width, height, resolution) {\n  const bounds = tempBounds;\n  bounds.minX = 0;\n  bounds.minY = 0;\n  bounds.maxX = image.width / resolution | 0;\n  bounds.maxY = image.height / resolution | 0;\n  const texture = TexturePool.getOptimalTexture(\n    bounds.width,\n    bounds.height,\n    resolution,\n    false\n  );\n  texture.source.uploadMethodId = \"image\";\n  texture.source.resource = image;\n  texture.source.alphaMode = \"premultiply-alpha-on-upload\";\n  texture.frame.width = width / resolution;\n  texture.frame.height = height / resolution;\n  texture.source.emit(\"update\", texture.source);\n  texture.updateUvs();\n  return texture;\n}\n\nexport { getPo2TextureFromSource };\n//# sourceMappingURL=getPo2TextureFromSource.mjs.map\n","import { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { Bounds } from '../../container/bounds/Bounds';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nconst tempBounds = new Bounds();\n\n/**\n * Takes an image and creates a texture from it, using a power of 2 texture from the texture pool.\n * Remember to return the texture when you don't need it any more!\n * @param image - The image to create a texture from\n * @param width - the frame width of the texture\n * @param height - the frame height of the texture\n * @param resolution - The resolution of the texture\n * @returns - The texture\n */\nexport function getPo2TextureFromSource(\n    image: HTMLImageElement | HTMLCanvasElement | ICanvas,\n    width: number,\n    height: number,\n    resolution: number\n): Texture\n{\n    const bounds = tempBounds;\n\n    bounds.minX = 0;\n    bounds.minY = 0;\n\n    bounds.maxX = (image.width / resolution) | 0;\n    bounds.maxY = (image.height / resolution) | 0;\n\n    const texture = TexturePool.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        resolution,\n        false\n    );\n\n    texture.source.uploadMethodId = 'image';\n    texture.source.resource = image;\n    texture.source.alphaMode = 'premultiply-alpha-on-upload';\n\n    texture.frame.width = width / resolution;\n    texture.frame.height = height / resolution;\n\n    // We want to update the resource on the GPU,\n    // but we do not want to resize the texture.\n    // calling `texture.source.update` will fit the resource to the texture\n    // causing a resize of the texture on the GPU.\n    // which is not what we want!\n    texture.source.emit('update', texture.source);\n\n    texture.updateUvs();\n\n    return texture;\n}\n","import { DOMAdapter } from '../../../environment/adapter.mjs';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle.mjs';\n\n\"use strict\";\nconst contextSettings = {\n  // TextMetrics requires getImageData readback for measuring fonts.\n  willReadFrequently: true\n};\nconst _CanvasTextMetrics = class _CanvasTextMetrics {\n  /**\n   * Checking that we can use modern canvas 2D API.\n   *\n   * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n   * @see TextMetrics.experimentalLetterSpacing\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing\n   * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n   */\n  static get experimentalLetterSpacingSupported() {\n    let result = _CanvasTextMetrics._experimentalLetterSpacingSupported;\n    if (result !== void 0) {\n      const proto = DOMAdapter.get().getCanvasRenderingContext2D().prototype;\n      result = _CanvasTextMetrics._experimentalLetterSpacingSupported = \"letterSpacing\" in proto || \"textLetterSpacing\" in proto;\n    }\n    return result;\n  }\n  /**\n   * @param text - the text that was measured\n   * @param style - the style that was measured\n   * @param width - the measured width of the text\n   * @param height - the measured height of the text\n   * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n   * @param lineWidths - an array of the line widths for each line matched to `lines`\n   * @param lineHeight - the measured line height for this style\n   * @param maxLineWidth - the maximum line width for all measured lines\n   * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n   */\n  constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {\n    this.text = text;\n    this.style = style;\n    this.width = width;\n    this.height = height;\n    this.lines = lines;\n    this.lineWidths = lineWidths;\n    this.lineHeight = lineHeight;\n    this.maxLineWidth = maxLineWidth;\n    this.fontProperties = fontProperties;\n  }\n  /**\n   * Measures the supplied string of text and returns a Rectangle.\n   * @param text - The text to measure.\n   * @param style - The text style to use for measuring\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @param wordWrap\n   * @returns Measured width and height of the text.\n   */\n  static measureText(text = \" \", style, canvas = _CanvasTextMetrics._canvas, wordWrap = style.wordWrap) {\n    const textKey = `${text}:${style.styleKey}`;\n    if (_CanvasTextMetrics._measurementCache[textKey])\n      return _CanvasTextMetrics._measurementCache[textKey];\n    const font = fontStringFromTextStyle(style);\n    const fontProperties = _CanvasTextMetrics.measureFont(font);\n    if (fontProperties.fontSize === 0) {\n      fontProperties.fontSize = style.fontSize;\n      fontProperties.ascent = style.fontSize;\n    }\n    const context = _CanvasTextMetrics.__context;\n    context.font = font;\n    const outputText = wordWrap ? _CanvasTextMetrics._wordWrap(text, style, canvas) : text;\n    const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n    const lineWidths = new Array(lines.length);\n    let maxLineWidth = 0;\n    for (let i = 0; i < lines.length; i++) {\n      const lineWidth = _CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);\n      lineWidths[i] = lineWidth;\n      maxLineWidth = Math.max(maxLineWidth, lineWidth);\n    }\n    const strokeWidth = style._stroke?.width || 0;\n    let width = maxLineWidth + strokeWidth;\n    if (style.dropShadow) {\n      width += style.dropShadow.distance;\n    }\n    const lineHeight = style.lineHeight || fontProperties.fontSize + strokeWidth;\n    let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth * 2) + (lines.length - 1) * (lineHeight + style.leading);\n    if (style.dropShadow) {\n      height += style.dropShadow.distance;\n    }\n    const measurements = new _CanvasTextMetrics(\n      text,\n      style,\n      width,\n      height,\n      lines,\n      lineWidths,\n      lineHeight + style.leading,\n      maxLineWidth,\n      fontProperties\n    );\n    return measurements;\n  }\n  static _measureText(text, letterSpacing, context) {\n    let useExperimentalLetterSpacing = false;\n    if (_CanvasTextMetrics.experimentalLetterSpacingSupported) {\n      if (_CanvasTextMetrics.experimentalLetterSpacing) {\n        context.letterSpacing = `${letterSpacing}px`;\n        context.textLetterSpacing = `${letterSpacing}px`;\n        useExperimentalLetterSpacing = true;\n      } else {\n        context.letterSpacing = \"0px\";\n        context.textLetterSpacing = \"0px\";\n      }\n    }\n    let width = context.measureText(text).width;\n    if (width > 0) {\n      if (useExperimentalLetterSpacing) {\n        width -= letterSpacing;\n      } else {\n        width += (_CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n      }\n    }\n    return width;\n  }\n  /**\n   * Applies newlines to a string to have it optimally fit into the horizontal\n   * bounds set by the Text object's wordWrapWidth property.\n   * @param text - String to apply word wrapping to\n   * @param style - the style to use when wrapping\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @returns New string with new lines applied where required\n   */\n  static _wordWrap(text, style, canvas = _CanvasTextMetrics._canvas) {\n    const context = canvas.getContext(\"2d\", contextSettings);\n    let width = 0;\n    let line = \"\";\n    let lines = \"\";\n    const cache = /* @__PURE__ */ Object.create(null);\n    const { letterSpacing, whiteSpace } = style;\n    const collapseSpaces = _CanvasTextMetrics._collapseSpaces(whiteSpace);\n    const collapseNewlines = _CanvasTextMetrics._collapseNewlines(whiteSpace);\n    let canPrependSpaces = !collapseSpaces;\n    const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n    const tokens = _CanvasTextMetrics._tokenize(text);\n    for (let i = 0; i < tokens.length; i++) {\n      let token = tokens[i];\n      if (_CanvasTextMetrics._isNewline(token)) {\n        if (!collapseNewlines) {\n          lines += _CanvasTextMetrics._addLine(line);\n          canPrependSpaces = !collapseSpaces;\n          line = \"\";\n          width = 0;\n          continue;\n        }\n        token = \" \";\n      }\n      if (collapseSpaces) {\n        const currIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(token);\n        const lastIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);\n        if (currIsBreakingSpace && lastIsBreakingSpace) {\n          continue;\n        }\n      }\n      const tokenWidth = _CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context);\n      if (tokenWidth > wordWrapWidth) {\n        if (line !== \"\") {\n          lines += _CanvasTextMetrics._addLine(line);\n          line = \"\";\n          width = 0;\n        }\n        if (_CanvasTextMetrics.canBreakWords(token, style.breakWords)) {\n          const characters = _CanvasTextMetrics.wordWrapSplit(token);\n          for (let j = 0; j < characters.length; j++) {\n            let char = characters[j];\n            let lastChar = char;\n            let k = 1;\n            while (characters[j + k]) {\n              const nextChar = characters[j + k];\n              if (!_CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {\n                char += nextChar;\n              } else {\n                break;\n              }\n              lastChar = nextChar;\n              k++;\n            }\n            j += k - 1;\n            const characterWidth = _CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context);\n            if (characterWidth + width > wordWrapWidth) {\n              lines += _CanvasTextMetrics._addLine(line);\n              canPrependSpaces = false;\n              line = \"\";\n              width = 0;\n            }\n            line += char;\n            width += characterWidth;\n          }\n        } else {\n          if (line.length > 0) {\n            lines += _CanvasTextMetrics._addLine(line);\n            line = \"\";\n            width = 0;\n          }\n          const isLastToken = i === tokens.length - 1;\n          lines += _CanvasTextMetrics._addLine(token, !isLastToken);\n          canPrependSpaces = false;\n          line = \"\";\n          width = 0;\n        }\n      } else {\n        if (tokenWidth + width > wordWrapWidth) {\n          canPrependSpaces = false;\n          lines += _CanvasTextMetrics._addLine(line);\n          line = \"\";\n          width = 0;\n        }\n        if (line.length > 0 || !_CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces) {\n          line += token;\n          width += tokenWidth;\n        }\n      }\n    }\n    lines += _CanvasTextMetrics._addLine(line, false);\n    return lines;\n  }\n  /**\n   * Convienience function for logging each line added during the wordWrap method.\n   * @param line    - The line of text to add\n   * @param newLine - Add new line character to end\n   * @returns A formatted line\n   */\n  static _addLine(line, newLine = true) {\n    line = _CanvasTextMetrics._trimRight(line);\n    line = newLine ? `${line}\n` : line;\n    return line;\n  }\n  /**\n   * Gets & sets the widths of calculated characters in a cache object\n   * @param key            - The key\n   * @param letterSpacing  - The letter spacing\n   * @param cache          - The cache\n   * @param context        - The canvas context\n   * @returns The from cache.\n   */\n  static _getFromCache(key, letterSpacing, cache, context) {\n    let width = cache[key];\n    if (typeof width !== \"number\") {\n      width = _CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n      cache[key] = width;\n    }\n    return width;\n  }\n  /**\n   * Determines whether we should collapse breaking spaces.\n   * @param whiteSpace - The TextStyle property whiteSpace\n   * @returns Should collapse\n   */\n  static _collapseSpaces(whiteSpace) {\n    return whiteSpace === \"normal\" || whiteSpace === \"pre-line\";\n  }\n  /**\n   * Determines whether we should collapse newLine chars.\n   * @param whiteSpace - The white space\n   * @returns should collapse\n   */\n  static _collapseNewlines(whiteSpace) {\n    return whiteSpace === \"normal\";\n  }\n  /**\n   * Trims breaking whitespaces from string.\n   * @param text - The text\n   * @returns Trimmed string\n   */\n  static _trimRight(text) {\n    if (typeof text !== \"string\") {\n      return \"\";\n    }\n    for (let i = text.length - 1; i >= 0; i--) {\n      const char = text[i];\n      if (!_CanvasTextMetrics.isBreakingSpace(char)) {\n        break;\n      }\n      text = text.slice(0, -1);\n    }\n    return text;\n  }\n  /**\n   * Determines if char is a newline.\n   * @param char - The character\n   * @returns True if newline, False otherwise.\n   */\n  static _isNewline(char) {\n    if (typeof char !== \"string\") {\n      return false;\n    }\n    return _CanvasTextMetrics._newlines.includes(char.charCodeAt(0));\n  }\n  /**\n   * Determines if char is a breaking whitespace.\n   *\n   * It allows one to determine whether char should be a breaking whitespace\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param char - The character\n   * @param [_nextChar] - The next character\n   * @returns True if whitespace, False otherwise.\n   */\n  static isBreakingSpace(char, _nextChar) {\n    if (typeof char !== \"string\") {\n      return false;\n    }\n    return _CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n  }\n  /**\n   * Splits a string into words, breaking-spaces and newLine characters\n   * @param text - The text\n   * @returns A tokenized array\n   */\n  static _tokenize(text) {\n    const tokens = [];\n    let token = \"\";\n    if (typeof text !== \"string\") {\n      return tokens;\n    }\n    for (let i = 0; i < text.length; i++) {\n      const char = text[i];\n      const nextChar = text[i + 1];\n      if (_CanvasTextMetrics.isBreakingSpace(char, nextChar) || _CanvasTextMetrics._isNewline(char)) {\n        if (token !== \"\") {\n          tokens.push(token);\n          token = \"\";\n        }\n        tokens.push(char);\n        continue;\n      }\n      token += char;\n    }\n    if (token !== \"\") {\n      tokens.push(token);\n    }\n    return tokens;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It allows one to customise which words should break\n   * Examples are if the token is CJK or numbers.\n   * It must return a boolean.\n   * @param _token - The token\n   * @param breakWords - The style attr break words\n   * @returns Whether to break word or not\n   */\n  static canBreakWords(_token, breakWords) {\n    return breakWords;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It allows one to determine whether a pair of characters\n   * should be broken by newlines\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param _char - The character\n   * @param _nextChar - The next character\n   * @param _token - The token/word the characters are from\n   * @param _index - The index in the token of the char\n   * @param _breakWords - The style attr break words\n   * @returns whether to break word or not\n   */\n  static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {\n    return true;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It is called when a token (usually a word) has to be split into separate pieces\n   * in order to determine the point to break a word.\n   * It must return an array of characters.\n   * @param token - The token to split\n   * @returns The characters of the token\n   * @see CanvasTextMetrics.graphemeSegmenter\n   */\n  static wordWrapSplit(token) {\n    return _CanvasTextMetrics.graphemeSegmenter(token);\n  }\n  /**\n   * Calculates the ascent, descent and fontSize of a given font-style\n   * @param font - String representing the style of the font\n   * @returns Font properties object\n   */\n  static measureFont(font) {\n    if (_CanvasTextMetrics._fonts[font]) {\n      return _CanvasTextMetrics._fonts[font];\n    }\n    const context = _CanvasTextMetrics._context;\n    context.font = font;\n    const metrics = context.measureText(_CanvasTextMetrics.METRICS_STRING + _CanvasTextMetrics.BASELINE_SYMBOL);\n    const properties = {\n      ascent: metrics.actualBoundingBoxAscent,\n      descent: metrics.actualBoundingBoxDescent,\n      fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n    };\n    _CanvasTextMetrics._fonts[font] = properties;\n    return properties;\n  }\n  /**\n   * Clear font metrics in metrics cache.\n   * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n   */\n  static clearMetrics(font = \"\") {\n    if (font) {\n      delete _CanvasTextMetrics._fonts[font];\n    } else {\n      _CanvasTextMetrics._fonts = {};\n    }\n  }\n  /**\n   * Cached canvas element for measuring text\n   * TODO: this should be private, but isn't because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _canvas() {\n    if (!_CanvasTextMetrics.__canvas) {\n      let canvas;\n      try {\n        const c = new OffscreenCanvas(0, 0);\n        const context = c.getContext(\"2d\", contextSettings);\n        if (context?.measureText) {\n          _CanvasTextMetrics.__canvas = c;\n          return c;\n        }\n        canvas = DOMAdapter.get().createCanvas();\n      } catch (ex) {\n        canvas = DOMAdapter.get().createCanvas();\n      }\n      canvas.width = canvas.height = 10;\n      _CanvasTextMetrics.__canvas = canvas;\n    }\n    return _CanvasTextMetrics.__canvas;\n  }\n  /**\n   * TODO: this should be private, but isn't because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _context() {\n    if (!_CanvasTextMetrics.__context) {\n      _CanvasTextMetrics.__context = _CanvasTextMetrics._canvas.getContext(\"2d\", contextSettings);\n    }\n    return _CanvasTextMetrics.__context;\n  }\n};\n/**\n * String used for calculate font metrics.\n * These characters are all tall to help calculate the height required for text.\n */\n_CanvasTextMetrics.METRICS_STRING = \"|\\xC9q\\xC5\";\n/** Baseline symbol for calculate font metrics. */\n_CanvasTextMetrics.BASELINE_SYMBOL = \"M\";\n/** Baseline multiplier for calculate font metrics. */\n_CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;\n/** Height multiplier for setting height of canvas to calculate font metrics. */\n_CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;\n/**\n * A Unicode \"character\", or \"grapheme cluster\", can be composed of multiple Unicode code points,\n * such as letters with diacritical marks (e.g. `'\\u0065\\u0301'`, letter e with acute)\n * or emojis with modifiers (e.g. `'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB'`, technologist).\n * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n * If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),\n * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.\n */\n_CanvasTextMetrics.graphemeSegmenter = (() => {\n  if (typeof Intl?.Segmenter === \"function\") {\n    const segmenter = new Intl.Segmenter();\n    return (s) => [...segmenter.segment(s)].map((x) => x.segment);\n  }\n  return (s) => [...s];\n})();\n/**\n * New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n * lead to more accurate letter-spacing results because it does not try to manually draw\n * each character. However, this Chrome API is experimental and may not serve all cases yet.\n * @see TextMetrics.experimentalLetterSpacingSupported\n */\n_CanvasTextMetrics.experimentalLetterSpacing = false;\n/** Cache of {@see TextMetrics.FontMetrics} objects. */\n_CanvasTextMetrics._fonts = {};\n/** Cache of new line chars. */\n_CanvasTextMetrics._newlines = [\n  10,\n  // line feed\n  13\n  // carriage return\n];\n/** Cache of breaking spaces. */\n_CanvasTextMetrics._breakingSpaces = [\n  9,\n  // character tabulation\n  32,\n  // space\n  8192,\n  // en quad\n  8193,\n  // em quad\n  8194,\n  // en space\n  8195,\n  // em space\n  8196,\n  // three-per-em space\n  8197,\n  // four-per-em space\n  8198,\n  // six-per-em space\n  8200,\n  // punctuation space\n  8201,\n  // thin space\n  8202,\n  // hair space\n  8287,\n  // medium mathematical space\n  12288\n  // ideographic space\n];\n_CanvasTextMetrics._measurementCache = {};\nlet CanvasTextMetrics = _CanvasTextMetrics;\n\nexport { CanvasTextMetrics };\n//# sourceMappingURL=CanvasTextMetrics.mjs.map\n","import { DOMAdapter } from '../../../environment/adapter';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle';\n\nimport type { ICanvas, ICanvasRenderingContext2DSettings } from '../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { TextStyle, TextStyleWhiteSpace } from '../TextStyle';\n\n// The type for Intl.Segmenter is only available since TypeScript 4.7.2, so let's make a polyfill for it.\ninterface ISegmentData\n{\n    segment: string;\n}\ninterface ISegments\n{\n    [Symbol.iterator](): IterableIterator<ISegmentData>;\n}\ninterface ISegmenter\n{\n    segment(input: string): ISegments;\n}\ninterface IIntl\n{\n    Segmenter?: {\n        prototype: ISegmenter;\n        new(): ISegmenter;\n    };\n}\n\n/**\n * A number, or a string containing a number.\n * @memberof text\n * @typedef {object} FontMetrics\n * @property {number} ascent - Font ascent\n * @property {number} descent - Font descent\n * @property {number} fontSize - Font size\n */\nexport interface FontMetrics\n{\n    ascent: number;\n    descent: number;\n    fontSize: number;\n}\n\ntype CharacterWidthCache = Record<string, number>;\n\n// Default settings used for all getContext calls\nconst contextSettings: ICanvasRenderingContext2DSettings = {\n    // TextMetrics requires getImageData readback for measuring fonts.\n    willReadFrequently: true,\n};\n\n/**\n * The TextMetrics object represents the measurement of a block of text with a specified style.\n * @example\n * import { TextMetrics, TextStyle } from 'pixi.js';\n *\n * const style = new TextStyle({\n *     fontFamily: 'Arial',\n *     fontSize: 24,\n *     fill: 0xff1010,\n *     align: 'center',\n * });\n * const textMetrics = TextMetrics.measureText('Your text', style);\n * @memberof text\n */\nexport class CanvasTextMetrics\n{\n    /** The text that was measured. */\n    public text: string;\n\n    /** The style that was measured. */\n    public style: TextStyle;\n\n    /** The measured width of the text. */\n    public width: number;\n\n    /** The measured height of the text. */\n    public height: number;\n\n    /** An array of lines of the text broken by new lines and wrapping is specified in style. */\n    public lines: string[];\n\n    /** An array of the line widths for each line matched to `lines`. */\n    public lineWidths: number[];\n\n    /** The measured line height for this style. */\n    public lineHeight: number;\n\n    /** The maximum line width for all measured lines. */\n    public maxLineWidth: number;\n\n    /** The font properties object from TextMetrics.measureFont. */\n    public fontProperties: FontMetrics;\n\n    /**\n     * String used for calculate font metrics.\n     * These characters are all tall to help calculate the height required for text.\n     */\n    public static METRICS_STRING = '|q';\n\n    /** Baseline symbol for calculate font metrics. */\n    public static BASELINE_SYMBOL = 'M';\n\n    /** Baseline multiplier for calculate font metrics. */\n    public static BASELINE_MULTIPLIER = 1.4;\n\n    /** Height multiplier for setting height of canvas to calculate font metrics. */\n    public static HEIGHT_MULTIPLIER = 2.0;\n\n    /**\n     * A Unicode \"character\", or \"grapheme cluster\", can be composed of multiple Unicode code points,\n     * such as letters with diacritical marks (e.g. `'\\u0065\\u0301'`, letter e with acute)\n     * or emojis with modifiers (e.g. `'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB'`, technologist).\n     * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n     * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n     * If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),\n     * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n     * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n     * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.\n     */\n    public static graphemeSegmenter: (s: string) => string[] = (() =>\n    {\n        if (typeof (Intl as IIntl)?.Segmenter === 'function')\n        {\n            const segmenter = new (Intl as IIntl).Segmenter();\n\n            return (s: string) => [...segmenter.segment(s)].map((x) => x.segment);\n        }\n\n        return (s: string) => [...s];\n    })();\n\n    public static _experimentalLetterSpacingSupported?: boolean;\n\n    /**\n     * Checking that we can use modern canvas 2D API.\n     *\n     * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n     * @see TextMetrics.experimentalLetterSpacing\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing\n     * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n     */\n    public static get experimentalLetterSpacingSupported(): boolean\n    {\n        let result = CanvasTextMetrics._experimentalLetterSpacingSupported;\n\n        if (result !== undefined)\n        {\n            const proto = DOMAdapter.get().getCanvasRenderingContext2D().prototype;\n\n            result\n                = CanvasTextMetrics._experimentalLetterSpacingSupported\n                = 'letterSpacing' in proto || 'textLetterSpacing' in proto;\n        }\n\n        return result;\n    }\n\n    /**\n     * New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n     * lead to more accurate letter-spacing results because it does not try to manually draw\n     * each character. However, this Chrome API is experimental and may not serve all cases yet.\n     * @see TextMetrics.experimentalLetterSpacingSupported\n     */\n    public static experimentalLetterSpacing = false;\n\n    /** Cache of {@see TextMetrics.FontMetrics} objects. */\n    private static _fonts: Record<string, FontMetrics> = {};\n\n    /** Cache of new line chars. */\n    private static readonly _newlines: number[] = [\n        0x000A, // line feed\n        0x000D, // carriage return\n    ];\n\n    /** Cache of breaking spaces. */\n    private static readonly _breakingSpaces: number[] = [\n        0x0009, // character tabulation\n        0x0020, // space\n        0x2000, // en quad\n        0x2001, // em quad\n        0x2002, // en space\n        0x2003, // em space\n        0x2004, // three-per-em space\n        0x2005, // four-per-em space\n        0x2006, // six-per-em space\n        0x2008, // punctuation space\n        0x2009, // thin space\n        0x200A, // hair space\n        0x205F, // medium mathematical space\n        0x3000, // ideographic space\n    ];\n\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static __canvas: ICanvas;\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static __context: ICanvasRenderingContext2D;\n\n    private static readonly _measurementCache: Record<string, CanvasTextMetrics> = {};\n\n    /**\n     * @param text - the text that was measured\n     * @param style - the style that was measured\n     * @param width - the measured width of the text\n     * @param height - the measured height of the text\n     * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n     * @param lineWidths - an array of the line widths for each line matched to `lines`\n     * @param lineHeight - the measured line height for this style\n     * @param maxLineWidth - the maximum line width for all measured lines\n     * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n     */\n    constructor(text: string, style: TextStyle, width: number, height: number, lines: string[], lineWidths: number[],\n        lineHeight: number, maxLineWidth: number, fontProperties: FontMetrics)\n    {\n        this.text = text;\n        this.style = style;\n        this.width = width;\n        this.height = height;\n        this.lines = lines;\n        this.lineWidths = lineWidths;\n        this.lineHeight = lineHeight;\n        this.maxLineWidth = maxLineWidth;\n        this.fontProperties = fontProperties;\n    }\n\n    /**\n     * Measures the supplied string of text and returns a Rectangle.\n     * @param text - The text to measure.\n     * @param style - The text style to use for measuring\n     * @param canvas - optional specification of the canvas to use for measuring.\n     * @param wordWrap\n     * @returns Measured width and height of the text.\n     */\n    public static measureText(\n        text = ' ',\n        style: TextStyle,\n        canvas: ICanvas = CanvasTextMetrics._canvas,\n        wordWrap: boolean = style.wordWrap,\n    ): CanvasTextMetrics\n    {\n        const textKey = `${text}:${style.styleKey}`;\n\n        // TODO - if we find this starts to go nuts with memory, we can remove the cache\n        // or instead just stick a usage tick that we increment each time we return it.\n        // if some are not used, we can just tidy them up!\n        if (CanvasTextMetrics._measurementCache[textKey]) return CanvasTextMetrics._measurementCache[textKey];\n\n        const font = fontStringFromTextStyle(style);\n        const fontProperties = CanvasTextMetrics.measureFont(font);\n\n        // fallback in case UA disallow canvas data extraction\n        if (fontProperties.fontSize === 0)\n        {\n            fontProperties.fontSize = style.fontSize as number;\n            fontProperties.ascent = style.fontSize as number;\n        }\n\n        const context = CanvasTextMetrics.__context; // canvas.getContext('2d', contextSettings);\n\n        context.font = font;\n\n        const outputText = wordWrap ? CanvasTextMetrics._wordWrap(text, style, canvas) : text;\n        const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n        const lineWidths = new Array<number>(lines.length);\n        let maxLineWidth = 0;\n\n        for (let i = 0; i < lines.length; i++)\n        {\n            const lineWidth = CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);\n\n            lineWidths[i] = lineWidth;\n            maxLineWidth = Math.max(maxLineWidth, lineWidth);\n        }\n\n        const strokeWidth = style._stroke?.width || 0;\n\n        let width = maxLineWidth + strokeWidth;\n\n        if (style.dropShadow)\n        {\n            width += style.dropShadow.distance;\n        }\n\n        const lineHeight = style.lineHeight || fontProperties.fontSize + strokeWidth;\n\n        let height = Math.max(lineHeight, fontProperties.fontSize + (strokeWidth * 2))\n            + ((lines.length - 1) * (lineHeight + style.leading));\n\n        if (style.dropShadow)\n        {\n            height += style.dropShadow.distance;\n        }\n\n        const measurements = new CanvasTextMetrics(\n            text,\n            style,\n            width,\n            height,\n            lines,\n            lineWidths,\n            lineHeight + style.leading,\n            maxLineWidth,\n            fontProperties\n        );\n\n        // CanvasTextMetrics._measurementCache[textKey] = measurements;\n\n        return measurements;\n    }\n\n    private static _measureText(\n        text: string,\n        letterSpacing: number,\n        context: ICanvasRenderingContext2D\n    )\n    {\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        let width = context.measureText(text).width;\n\n        if (width > 0)\n        {\n            if (useExperimentalLetterSpacing)\n            {\n                width -= letterSpacing;\n            }\n            else\n            {\n                width += (CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n            }\n        }\n\n        return width;\n    }\n\n    /**\n     * Applies newlines to a string to have it optimally fit into the horizontal\n     * bounds set by the Text object's wordWrapWidth property.\n     * @param text - String to apply word wrapping to\n     * @param style - the style to use when wrapping\n     * @param canvas - optional specification of the canvas to use for measuring.\n     * @returns New string with new lines applied where required\n     */\n    private static _wordWrap(\n        text: string,\n        style: TextStyle,\n        canvas: ICanvas = CanvasTextMetrics._canvas\n    ): string\n    {\n        const context = canvas.getContext('2d', contextSettings);\n\n        let width = 0;\n        let line = '';\n        let lines = '';\n\n        const cache: CharacterWidthCache = Object.create(null);\n        const { letterSpacing, whiteSpace } = style;\n\n        // How to handle whitespaces\n        const collapseSpaces = CanvasTextMetrics._collapseSpaces(whiteSpace);\n        const collapseNewlines = CanvasTextMetrics._collapseNewlines(whiteSpace);\n\n        // whether or not spaces may be added to the beginning of lines\n        let canPrependSpaces = !collapseSpaces;\n\n        // There is letterSpacing after every char except the last one\n        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!\n        // so for convenience the above needs to be compared to width + 1 extra letterSpace\n        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!_\n        // ________________________________________________\n        // And then the final space is simply no appended to each line\n        const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n\n        // break text into words, spaces and newline chars\n        const tokens = CanvasTextMetrics._tokenize(text);\n\n        for (let i = 0; i < tokens.length; i++)\n        {\n            // get the word, space or newlineChar\n            let token = tokens[i];\n\n            // if word is a new line\n            if (CanvasTextMetrics._isNewline(token))\n            {\n                // keep the new line\n                if (!collapseNewlines)\n                {\n                    lines += CanvasTextMetrics._addLine(line);\n                    canPrependSpaces = !collapseSpaces;\n                    line = '';\n                    width = 0;\n                    continue;\n                }\n\n                // if we should collapse new lines\n                // we simply convert it into a space\n                token = ' ';\n            }\n\n            // if we should collapse repeated whitespaces\n            if (collapseSpaces)\n            {\n                // check both this and the last tokens for spaces\n                const currIsBreakingSpace = CanvasTextMetrics.isBreakingSpace(token);\n                const lastIsBreakingSpace = CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);\n\n                if (currIsBreakingSpace && lastIsBreakingSpace)\n                {\n                    continue;\n                }\n            }\n\n            // get word width from cache if possible\n            const tokenWidth = CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context);\n\n            // word is longer than desired bounds\n            if (tokenWidth > wordWrapWidth)\n            {\n                // if we are not already at the beginning of a line\n                if (line !== '')\n                {\n                    // start newlines for overflow words\n                    lines += CanvasTextMetrics._addLine(line);\n                    line = '';\n                    width = 0;\n                }\n\n                // break large word over multiple lines\n                if (CanvasTextMetrics.canBreakWords(token, style.breakWords))\n                {\n                    // break word into characters\n                    const characters = CanvasTextMetrics.wordWrapSplit(token);\n\n                    // loop the characters\n                    for (let j = 0; j < characters.length; j++)\n                    {\n                        let char = characters[j];\n                        let lastChar = char;\n\n                        let k = 1;\n\n                        // we are not at the end of the token\n                        while (characters[j + k])\n                        {\n                            const nextChar = characters[j + k];\n\n                            // should not split chars\n                            if (!CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords))\n                            {\n                                // combine chars & move forward one\n                                char += nextChar;\n                            }\n                            else\n                            {\n                                break;\n                            }\n\n                            lastChar = nextChar;\n                            k++;\n                        }\n\n                        j += k - 1;\n\n                        const characterWidth = CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context);\n\n                        if (characterWidth + width > wordWrapWidth)\n                        {\n                            lines += CanvasTextMetrics._addLine(line);\n                            canPrependSpaces = false;\n                            line = '';\n                            width = 0;\n                        }\n\n                        line += char;\n                        width += characterWidth;\n                    }\n                }\n\n                // run word out of the bounds\n                else\n                {\n                    // if there are words in this line already\n                    // finish that line and start a new one\n                    if (line.length > 0)\n                    {\n                        lines += CanvasTextMetrics._addLine(line);\n                        line = '';\n                        width = 0;\n                    }\n\n                    const isLastToken = i === tokens.length - 1;\n\n                    // give it its own line if it's not the end\n                    lines += CanvasTextMetrics._addLine(token, !isLastToken);\n                    canPrependSpaces = false;\n                    line = '';\n                    width = 0;\n                }\n            }\n\n            // word could fit\n            else\n            {\n                // word won't fit because of existing words\n                // start a new line\n                if (tokenWidth + width > wordWrapWidth)\n                {\n                    // if its a space we don't want it\n                    canPrependSpaces = false;\n\n                    // add a new line\n                    lines += CanvasTextMetrics._addLine(line);\n\n                    // start a new line\n                    line = '';\n                    width = 0;\n                }\n\n                // don't add spaces to the beginning of lines\n                if (line.length > 0 || !CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces)\n                {\n                    // add the word to the current line\n                    line += token;\n\n                    // update width counter\n                    width += tokenWidth;\n                }\n            }\n        }\n\n        lines += CanvasTextMetrics._addLine(line, false);\n\n        return lines;\n    }\n\n    /**\n     * Convienience function for logging each line added during the wordWrap method.\n     * @param line    - The line of text to add\n     * @param newLine - Add new line character to end\n     * @returns A formatted line\n     */\n    private static _addLine(line: string, newLine = true): string\n    {\n        line = CanvasTextMetrics._trimRight(line);\n\n        line = (newLine) ? `${line}\\n` : line;\n\n        return line;\n    }\n\n    /**\n     * Gets & sets the widths of calculated characters in a cache object\n     * @param key            - The key\n     * @param letterSpacing  - The letter spacing\n     * @param cache          - The cache\n     * @param context        - The canvas context\n     * @returns The from cache.\n     */\n    private static _getFromCache(key: string, letterSpacing: number, cache: CharacterWidthCache,\n        context: ICanvasRenderingContext2D): number\n    {\n        let width = cache[key];\n\n        if (typeof width !== 'number')\n        {\n            width = CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n            cache[key] = width;\n        }\n\n        return width;\n    }\n\n    /**\n     * Determines whether we should collapse breaking spaces.\n     * @param whiteSpace - The TextStyle property whiteSpace\n     * @returns Should collapse\n     */\n    private static _collapseSpaces(whiteSpace: TextStyleWhiteSpace): boolean\n    {\n        return (whiteSpace === 'normal' || whiteSpace === 'pre-line');\n    }\n\n    /**\n     * Determines whether we should collapse newLine chars.\n     * @param whiteSpace - The white space\n     * @returns should collapse\n     */\n    private static _collapseNewlines(whiteSpace: TextStyleWhiteSpace): boolean\n    {\n        return (whiteSpace === 'normal');\n    }\n\n    /**\n     * Trims breaking whitespaces from string.\n     * @param text - The text\n     * @returns Trimmed string\n     */\n    private static _trimRight(text: string): string\n    {\n        if (typeof text !== 'string')\n        {\n            return '';\n        }\n\n        for (let i = text.length - 1; i >= 0; i--)\n        {\n            const char = text[i];\n\n            if (!CanvasTextMetrics.isBreakingSpace(char))\n            {\n                break;\n            }\n\n            text = text.slice(0, -1);\n        }\n\n        return text;\n    }\n\n    /**\n     * Determines if char is a newline.\n     * @param char - The character\n     * @returns True if newline, False otherwise.\n     */\n    private static _isNewline(char: string): boolean\n    {\n        if (typeof char !== 'string')\n        {\n            return false;\n        }\n\n        return CanvasTextMetrics._newlines.includes(char.charCodeAt(0));\n    }\n\n    /**\n     * Determines if char is a breaking whitespace.\n     *\n     * It allows one to determine whether char should be a breaking whitespace\n     * For example certain characters in CJK langs or numbers.\n     * It must return a boolean.\n     * @param char - The character\n     * @param [_nextChar] - The next character\n     * @returns True if whitespace, False otherwise.\n     */\n    public static isBreakingSpace(char: string, _nextChar?: string): boolean\n    {\n        if (typeof char !== 'string')\n        {\n            return false;\n        }\n\n        return CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n    }\n\n    /**\n     * Splits a string into words, breaking-spaces and newLine characters\n     * @param text - The text\n     * @returns A tokenized array\n     */\n    private static _tokenize(text: string): string[]\n    {\n        const tokens: string[] = [];\n        let token = '';\n\n        if (typeof text !== 'string')\n        {\n            return tokens;\n        }\n\n        for (let i = 0; i < text.length; i++)\n        {\n            const char = text[i];\n            const nextChar = text[i + 1];\n\n            if (CanvasTextMetrics.isBreakingSpace(char, nextChar) || CanvasTextMetrics._isNewline(char))\n            {\n                if (token !== '')\n                {\n                    tokens.push(token);\n                    token = '';\n                }\n\n                tokens.push(char);\n\n                continue;\n            }\n\n            token += char;\n        }\n\n        if (token !== '')\n        {\n            tokens.push(token);\n        }\n\n        return tokens;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It allows one to customise which words should break\n     * Examples are if the token is CJK or numbers.\n     * It must return a boolean.\n     * @param _token - The token\n     * @param breakWords - The style attr break words\n     * @returns Whether to break word or not\n     */\n    public static canBreakWords(_token: string, breakWords: boolean): boolean\n    {\n        return breakWords;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It allows one to determine whether a pair of characters\n     * should be broken by newlines\n     * For example certain characters in CJK langs or numbers.\n     * It must return a boolean.\n     * @param _char - The character\n     * @param _nextChar - The next character\n     * @param _token - The token/word the characters are from\n     * @param _index - The index in the token of the char\n     * @param _breakWords - The style attr break words\n     * @returns whether to break word or not\n     */\n    public static canBreakChars(_char: string, _nextChar: string, _token: string, _index: number,\n        _breakWords: boolean): boolean\n    {\n        return true;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It is called when a token (usually a word) has to be split into separate pieces\n     * in order to determine the point to break a word.\n     * It must return an array of characters.\n     * @param token - The token to split\n     * @returns The characters of the token\n     * @see CanvasTextMetrics.graphemeSegmenter\n     */\n    public static wordWrapSplit(token: string): string[]\n    {\n        return CanvasTextMetrics.graphemeSegmenter(token);\n    }\n\n    /**\n     * Calculates the ascent, descent and fontSize of a given font-style\n     * @param font - String representing the style of the font\n     * @returns Font properties object\n     */\n    public static measureFont(font: string): FontMetrics\n    {\n        // as this method is used for preparing assets, don't recalculate things if we don't need to\n        if (CanvasTextMetrics._fonts[font])\n        {\n            return CanvasTextMetrics._fonts[font];\n        }\n\n        const context = CanvasTextMetrics._context;\n\n        context.font = font;\n        const metrics = context.measureText(CanvasTextMetrics.METRICS_STRING + CanvasTextMetrics.BASELINE_SYMBOL);\n\n        const properties = {\n            ascent: metrics.actualBoundingBoxAscent,\n            descent: metrics.actualBoundingBoxDescent,\n            fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n        };\n\n        CanvasTextMetrics._fonts[font] = properties;\n\n        return properties;\n    }\n\n    /**\n     * Clear font metrics in metrics cache.\n     * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n     */\n    public static clearMetrics(font = ''): void\n    {\n        if (font)\n        {\n            delete CanvasTextMetrics._fonts[font];\n        }\n        else\n        {\n            CanvasTextMetrics._fonts = {};\n        }\n    }\n\n    /**\n     * Cached canvas element for measuring text\n     * TODO: this should be private, but isn't because of backward compat, will fix later.\n     * @ignore\n     */\n    public static get _canvas(): ICanvas\n    {\n        if (!CanvasTextMetrics.__canvas)\n        {\n            let canvas: ICanvas;\n\n            try\n            {\n                // OffscreenCanvas2D measureText can be up to 40% faster.\n                const c = new OffscreenCanvas(0, 0);\n                const context = c.getContext('2d', contextSettings);\n\n                if (context?.measureText)\n                {\n                    CanvasTextMetrics.__canvas = c as ICanvas;\n\n                    return c as ICanvas;\n                }\n\n                canvas = DOMAdapter.get().createCanvas();\n            }\n            catch (ex)\n            {\n                canvas = DOMAdapter.get().createCanvas();\n            }\n            canvas.width = canvas.height = 10;\n            CanvasTextMetrics.__canvas = canvas;\n        }\n\n        return CanvasTextMetrics.__canvas;\n    }\n\n    /**\n     * TODO: this should be private, but isn't because of backward compat, will fix later.\n     * @ignore\n     */\n    public static get _context(): ICanvasRenderingContext2D\n    {\n        if (!CanvasTextMetrics.__context)\n        {\n            CanvasTextMetrics.__context = CanvasTextMetrics._canvas.getContext('2d', contextSettings);\n        }\n\n        return CanvasTextMetrics.__context;\n    }\n}\n","\"use strict\";\nconst genericFontFamilies = [\n  \"serif\",\n  \"sans-serif\",\n  \"monospace\",\n  \"cursive\",\n  \"fantasy\",\n  \"system-ui\"\n];\nfunction fontStringFromTextStyle(style) {\n  const fontSizeString = typeof style.fontSize === \"number\" ? `${style.fontSize}px` : style.fontSize;\n  let fontFamilies = style.fontFamily;\n  if (!Array.isArray(style.fontFamily)) {\n    fontFamilies = style.fontFamily.split(\",\");\n  }\n  for (let i = fontFamilies.length - 1; i >= 0; i--) {\n    let fontFamily = fontFamilies[i].trim();\n    if (!/([\\\"\\'])[^\\'\\\"]+\\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {\n      fontFamily = `\"${fontFamily}\"`;\n    }\n    fontFamilies[i] = fontFamily;\n  }\n  return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(\",\")}`;\n}\n\nexport { fontStringFromTextStyle };\n//# sourceMappingURL=fontStringFromTextStyle.mjs.map\n","import type { TextStyle } from '../../TextStyle';\n\nconst genericFontFamilies = [\n    'serif',\n    'sans-serif',\n    'monospace',\n    'cursive',\n    'fantasy',\n    'system-ui',\n];\n\n/**\n * Generates a font style string to use for `TextMetrics.measureFont()`.\n * @param style\n * @returns Font style string, for passing to `TextMetrics.measureFont()`\n */\nexport function fontStringFromTextStyle(style: TextStyle): string\n{\n    // build canvas api font setting from individual components. Convert a numeric style.fontSize to px\n    const fontSizeString = (typeof style.fontSize === 'number') ? `${style.fontSize}px` : style.fontSize;\n\n    // Clean-up fontFamily property by quoting each font name\n    // this will support font names with spaces\n    let fontFamilies: string | string[] = style.fontFamily;\n\n    if (!Array.isArray(style.fontFamily))\n    {\n        fontFamilies = style.fontFamily.split(',');\n    }\n\n    for (let i = fontFamilies.length - 1; i >= 0; i--)\n    {\n        // Trim any extra white-space\n        let fontFamily = fontFamilies[i].trim();\n\n        // Check if font already contains strings\n        if (!(/([\\\"\\'])[^\\'\\\"]+\\1/).test(fontFamily) && !genericFontFamilies.includes(fontFamily))\n        {\n            fontFamily = `\"${fontFamily}\"`;\n        }\n        (fontFamilies as string[])[i] = fontFamily;\n    }\n\n    // eslint-disable-next-line max-len\n    return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${(fontFamilies as string[]).join(',')}`;\n}\n","import { Color } from '../../../../color/Color.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\nimport { FillGradient } from '../../../graphics/shared/fill/FillGradient.mjs';\nimport { FillPattern } from '../../../graphics/shared/fill/FillPattern.mjs';\n\n\"use strict\";\nfunction getCanvasFillStyle(fillStyle, context) {\n  if (fillStyle.texture === Texture.WHITE && !fillStyle.fill) {\n    return Color.shared.setValue(fillStyle.color).toHex();\n  } else if (!fillStyle.fill) {\n    const pattern = context.createPattern(fillStyle.texture.source.resource, \"repeat\");\n    const tempMatrix = fillStyle.matrix.copyTo(Matrix.shared);\n    tempMatrix.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);\n    pattern.setTransform(tempMatrix);\n    return pattern;\n  } else if (fillStyle.fill instanceof FillPattern) {\n    const fillPattern = fillStyle.fill;\n    const pattern = context.createPattern(fillPattern.texture.source.resource, \"repeat\");\n    const tempMatrix = fillPattern.transform.copyTo(Matrix.shared);\n    tempMatrix.scale(\n      fillPattern.texture.frame.width,\n      fillPattern.texture.frame.height\n    );\n    pattern.setTransform(tempMatrix);\n    return pattern;\n  } else if (fillStyle.fill instanceof FillGradient) {\n    const fillGradient = fillStyle.fill;\n    if (fillGradient.type === \"linear\") {\n      const gradient = context.createLinearGradient(\n        fillGradient.x0,\n        fillGradient.y0,\n        fillGradient.x1,\n        fillGradient.y1\n      );\n      fillGradient.gradientStops.forEach((stop) => {\n        gradient.addColorStop(stop.offset, Color.shared.setValue(stop.color).toHex());\n      });\n      return gradient;\n    }\n  }\n  warn(\"FillStyle not recognised\", fillStyle);\n  return \"red\";\n}\n\nexport { getCanvasFillStyle };\n//# sourceMappingURL=getCanvasFillStyle.mjs.map\n","import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../../utils/logging/warn';\nimport { FillGradient } from '../../../graphics/shared/fill/FillGradient';\nimport { FillPattern } from '../../../graphics/shared/fill/FillPattern';\n\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { ConvertedFillStyle } from '../../../graphics/shared/GraphicsContext';\n\nexport function getCanvasFillStyle(\n    fillStyle: ConvertedFillStyle,\n    context: ICanvasRenderingContext2D): string | CanvasGradient | CanvasPattern\n{\n    if (fillStyle.texture === Texture.WHITE && !fillStyle.fill)\n    {\n        return Color.shared.setValue(fillStyle.color).toHex();\n    }\n    else if (!fillStyle.fill)\n    {\n        // fancy set up...\n        const pattern = context.createPattern(fillStyle.texture.source.resource, 'repeat');\n\n        // create an inverted scale matrix..\n        const tempMatrix = fillStyle.matrix.copyTo(Matrix.shared);\n\n        tempMatrix.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);\n\n        pattern.setTransform(tempMatrix);\n\n        return pattern;\n    }\n    else if (fillStyle.fill instanceof FillPattern)\n    {\n        const fillPattern = fillStyle.fill as FillPattern;\n\n        const pattern = context.createPattern(fillPattern.texture.source.resource, 'repeat');\n\n        const tempMatrix = fillPattern.transform.copyTo(Matrix.shared);\n\n        tempMatrix.scale(\n            fillPattern.texture.frame.width,\n            fillPattern.texture.frame.height\n        );\n\n        pattern.setTransform(tempMatrix);\n\n        return pattern;\n    }\n    else if (fillStyle.fill instanceof FillGradient)\n    {\n        const fillGradient = fillStyle.fill as FillGradient;\n\n        if (fillGradient.type === 'linear')\n        {\n            const gradient = context.createLinearGradient(\n                fillGradient.x0,\n                fillGradient.y0,\n                fillGradient.x1,\n                fillGradient.y1\n            );\n\n            fillGradient.gradientStops.forEach((stop) =>\n            {\n                gradient.addColorStop(stop.offset, Color.shared.setValue(stop.color).toHex());\n            });\n\n            return gradient;\n        }\n    }\n\n    // #if _DEBUG\n    warn('FillStyle not recognised', fillStyle);\n    // #endif\n\n    return 'red';\n}\n","import { Color } from '../../../../color/Color.mjs';\nimport { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource.mjs';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\n\n\"use strict\";\nconst _FillGradient = class _FillGradient {\n  constructor(x0, y0, x1, y1) {\n    this.uid = uid(\"fillGradient\");\n    this.type = \"linear\";\n    this.gradientStops = [];\n    this.x0 = x0;\n    this.y0 = y0;\n    this.x1 = x1;\n    this.y1 = y1;\n  }\n  addColorStop(offset, color) {\n    this.gradientStops.push({ offset, color: Color.shared.setValue(color).toHex() });\n    return this;\n  }\n  // TODO move to the system!\n  buildLinearGradient() {\n    const defaultSize = _FillGradient.defaultTextureSize;\n    const { gradientStops } = this;\n    const canvas = DOMAdapter.get().createCanvas();\n    canvas.width = defaultSize;\n    canvas.height = defaultSize;\n    const ctx = canvas.getContext(\"2d\");\n    const gradient = ctx.createLinearGradient(0, 0, _FillGradient.defaultTextureSize, 1);\n    for (let i = 0; i < gradientStops.length; i++) {\n      const stop = gradientStops[i];\n      gradient.addColorStop(stop.offset, stop.color);\n    }\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, defaultSize, defaultSize);\n    this.texture = new Texture({\n      source: new ImageSource({\n        resource: canvas,\n        addressModeU: \"clamp-to-edge\",\n        addressModeV: \"repeat\"\n      })\n    });\n    const { x0, y0, x1, y1 } = this;\n    const m = new Matrix();\n    const dx = x1 - x0;\n    const dy = y1 - y0;\n    const dist = Math.sqrt(dx * dx + dy * dy);\n    const angle = Math.atan2(dy, dx);\n    m.translate(-x0, -y0);\n    m.scale(1 / defaultSize, 1 / defaultSize);\n    m.rotate(-angle);\n    m.scale(256 / dist, 1);\n    this.transform = m;\n  }\n};\n_FillGradient.defaultTextureSize = 256;\nlet FillGradient = _FillGradient;\n\nexport { FillGradient };\n//# sourceMappingURL=FillGradient.mjs.map\n","import { Color } from '../../../../color/Color';\nimport { DOMAdapter } from '../../../../environment/adapter';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { uid } from '../../../../utils/data/uid';\n\nimport type { ColorSource } from '../../../../color/Color';\n\nexport type GradientType = 'linear' | 'radial';\n\n// export type GradientSource =\n//     string // CSS gradient string: 'linear-gradient(...)'\n//     | IGradientOptions // Gradient options: { x0, y0, x1, y1, ...}\n//     | Gradient; // class Gradient itself\n\nexport interface LinearGradientFillStyle\n{\n    x0: number;\n    y0: number;\n    x1: number;\n    y1: number;\n    colors: number[];\n    stops: number[];\n}\n\nexport class FillGradient implements CanvasGradient\n{\n    public static defaultTextureSize = 256;\n\n    public readonly uid = uid('fillGradient');\n    public readonly type: GradientType = 'linear';\n\n    public x0: number;\n    public y0: number;\n    public x1: number;\n    public y1: number;\n\n    public texture: Texture;\n    public transform: Matrix;\n    public gradientStops: Array<{ offset: number, color: string }> = [];\n\n    constructor(x0: number, y0: number, x1: number, y1: number)\n    {\n        this.x0 = x0;\n        this.y0 = y0;\n\n        this.x1 = x1;\n        this.y1 = y1;\n    }\n\n    public addColorStop(offset: number, color: ColorSource): this\n    {\n        this.gradientStops.push({ offset, color: Color.shared.setValue(color).toHex() });\n\n        return this;\n    }\n\n    // TODO move to the system!\n    public buildLinearGradient(): void\n    {\n        const defaultSize = FillGradient.defaultTextureSize;\n\n        const { gradientStops } = this;\n\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = defaultSize;\n        canvas.height = defaultSize;\n\n        const ctx = canvas.getContext('2d');\n\n        const gradient = ctx.createLinearGradient(0, 0, FillGradient.defaultTextureSize, 1);\n\n        for (let i = 0; i < gradientStops.length; i++)\n        {\n            const stop = gradientStops[i];\n\n            gradient.addColorStop(stop.offset, stop.color);\n        }\n\n        ctx.fillStyle = gradient;\n        ctx.fillRect(0, 0, defaultSize, defaultSize);\n\n        this.texture = new Texture({\n            source: new ImageSource({\n                resource: canvas,\n                addressModeU: 'clamp-to-edge',\n                addressModeV: 'repeat',\n            }),\n        });\n\n        // generate some UVS based on the gradient direction sent\n\n        const { x0, y0, x1, y1 } = this;\n\n        const m = new Matrix();\n\n        // get angle\n        const dx = x1 - x0;\n        const dy = y1 - y0;\n\n        const dist = Math.sqrt((dx * dx) + (dy * dy));\n\n        const angle = Math.atan2(dy, dx);\n\n        m.translate(-x0, -y0);\n        m.scale(1 / defaultSize, 1 / defaultSize);\n        m.rotate(-angle);\n        m.scale(256 / dist, 1);\n\n        this.transform = m;\n    }\n}\n","import { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\n\n\"use strict\";\nconst repetitionMap = {\n  repeat: {\n    addressModeU: \"repeat\",\n    addressModeV: \"repeat\"\n  },\n  \"repeat-x\": {\n    addressModeU: \"repeat\",\n    addressModeV: \"clamp-to-edge\"\n  },\n  \"repeat-y\": {\n    addressModeU: \"clamp-to-edge\",\n    addressModeV: \"repeat\"\n  },\n  \"no-repeat\": {\n    addressModeU: \"clamp-to-edge\",\n    addressModeV: \"clamp-to-edge\"\n  }\n};\nclass FillPattern {\n  constructor(texture, repetition) {\n    this.uid = uid(\"fillPattern\");\n    this.transform = new Matrix();\n    this.texture = texture;\n    this.transform.scale(\n      1 / texture.frame.width,\n      1 / texture.frame.height\n    );\n    if (repetition) {\n      texture.source.style.addressModeU = repetitionMap[repetition].addressModeU;\n      texture.source.style.addressModeV = repetitionMap[repetition].addressModeV;\n    }\n  }\n  setTransform(transform) {\n    const texture = this.texture;\n    this.transform.copyFrom(transform);\n    this.transform.invert();\n    this.transform.scale(\n      1 / texture.frame.width,\n      1 / texture.frame.height\n    );\n  }\n}\n\nexport { FillPattern };\n//# sourceMappingURL=FillPattern.mjs.map\n","import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { uid } from '../../../../utils/data/uid';\n\nimport type { WRAP_MODE } from '../../../../rendering/renderers/shared/texture/const';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\n\nexport type PatternRepetition = 'repeat' | 'repeat-x' | 'repeat-y' | 'no-repeat';\n\nconst repetitionMap = {\n    repeat: {\n        addressModeU: 'repeat',\n        addressModeV: 'repeat',\n    },\n    'repeat-x': {\n        addressModeU: 'repeat',\n        addressModeV: 'clamp-to-edge',\n    },\n    'repeat-y': {\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'repeat',\n    },\n    'no-repeat': {\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'clamp-to-edge',\n    },\n};\n\nexport class FillPattern implements CanvasPattern\n{\n    public readonly uid = uid('fillPattern');\n    public texture: Texture;\n    public transform = new Matrix();\n\n    constructor(texture: Texture, repetition?: PatternRepetition)\n    {\n        this.texture = texture;\n\n        this.transform.scale(\n            1 / texture.frame.width,\n            1 / texture.frame.height\n        );\n\n        if (repetition)\n        {\n            texture.source.style.addressModeU = repetitionMap[repetition].addressModeU as WRAP_MODE;\n            texture.source.style.addressModeV = repetitionMap[repetition].addressModeV as WRAP_MODE;\n        }\n    }\n\n    public setTransform(transform?: Matrix): void\n    {\n        const texture = this.texture;\n\n        this.transform.copyFrom(transform);\n        this.transform.invert();\n        //  transform.scale\n        this.transform.scale(\n            1 / texture.frame.width,\n            1 / texture.frame.height\n        );\n    }\n}\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { loadBitmapFont, bitmapFontCachePlugin } from './asset/loadBitmapFont.mjs';\nimport { BitmapTextPipe } from './BitmapTextPipe.mjs';\n\n\"use strict\";\nextensions.add(BitmapTextPipe, loadBitmapFont, bitmapFontCachePlugin);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../../extensions/Extensions';\nimport { bitmapFontCachePlugin, loadBitmapFont } from './asset/loadBitmapFont';\nimport { BitmapTextPipe } from './BitmapTextPipe';\n\nextensions.add(BitmapTextPipe, loadBitmapFont, bitmapFontCachePlugin);\n","import { LoaderParserPriority } from '../../../assets/loader/parsers/LoaderParser.mjs';\nimport { copySearchParams } from '../../../assets/utils/copySearchParams.mjs';\nimport { DOMAdapter } from '../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { path } from '../../../utils/path.mjs';\nimport { BitmapFont } from '../BitmapFont.mjs';\nimport { bitmapFontTextParser } from './bitmapFontTextParser.mjs';\nimport { bitmapFontXMLStringParser } from './bitmapFontXMLStringParser.mjs';\n\n\"use strict\";\nconst validExtensions = [\".xml\", \".fnt\"];\nconst bitmapFontCachePlugin = {\n  extension: ExtensionType.CacheParser,\n  test: (asset) => asset instanceof BitmapFont,\n  getCacheableAssets(keys, asset) {\n    const out = {};\n    keys.forEach((key) => {\n      out[key] = asset;\n    });\n    out[`${asset.fontFamily}-bitmap`] = asset;\n    return out;\n  }\n};\nconst loadBitmapFont = {\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.Normal\n  },\n  test(url) {\n    return validExtensions.includes(path.extname(url).toLowerCase());\n  },\n  async testParse(data) {\n    return bitmapFontTextParser.test(data) || bitmapFontXMLStringParser.test(data);\n  },\n  async parse(asset, data, loader) {\n    const bitmapFontData = bitmapFontTextParser.test(asset) ? bitmapFontTextParser.parse(asset) : bitmapFontXMLStringParser.parse(asset);\n    const { src } = data;\n    const { pages } = bitmapFontData;\n    const textureUrls = [];\n    for (let i = 0; i < pages.length; ++i) {\n      const pageFile = pages[i].file;\n      let imagePath = path.join(path.dirname(src), pageFile);\n      imagePath = copySearchParams(imagePath, src);\n      textureUrls.push(imagePath);\n    }\n    const loadedTextures = await loader.load(textureUrls);\n    const textures = textureUrls.map((url) => loadedTextures[url]);\n    const bitmapFont = new BitmapFont({\n      data: bitmapFontData,\n      textures\n    }, src);\n    return bitmapFont;\n  },\n  async load(url, _options) {\n    const response = await DOMAdapter.get().fetch(url);\n    return await response.text();\n  },\n  async unload(bitmapFont, _resolvedAsset, loader) {\n    await Promise.all(bitmapFont.pages.map((page) => loader.unload(page.texture.source._sourceOrigin)));\n    bitmapFont.destroy();\n  }\n};\n\nexport { bitmapFontCachePlugin, loadBitmapFont };\n//# sourceMappingURL=loadBitmapFont.mjs.map\n","import { LoaderParserPriority } from '../../../assets/loader/parsers/LoaderParser';\nimport { copySearchParams } from '../../../assets/utils/copySearchParams';\nimport { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { path } from '../../../utils/path';\nimport { BitmapFont } from '../BitmapFont';\nimport { bitmapFontTextParser } from './bitmapFontTextParser';\nimport { bitmapFontXMLStringParser } from './bitmapFontXMLStringParser';\n\nimport type { Loader } from '../../../assets/loader/Loader';\nimport type { LoaderParser } from '../../../assets/loader/parsers/LoaderParser';\nimport type { ResolvedAsset } from '../../../assets/types';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nconst validExtensions = ['.xml', '.fnt'];\n\n/** simple loader plugin for loading in bitmap fonts! */\nexport const bitmapFontCachePlugin = {\n    extension: ExtensionType.CacheParser,\n    test: (asset: BitmapFont) => asset instanceof BitmapFont,\n    getCacheableAssets(keys: string[], asset: BitmapFont)\n    {\n        const out: Record<string, BitmapFont> = {};\n\n        keys.forEach((key) =>\n        {\n            out[key] = asset;\n        });\n\n        out[`${asset.fontFamily}-bitmap`] = asset;\n\n        return out;\n    }\n};\n\nexport const loadBitmapFont = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Normal,\n    },\n\n    test(url: string): boolean\n    {\n        return validExtensions.includes(path.extname(url).toLowerCase());\n    },\n\n    async testParse(data: string): Promise<boolean>\n    {\n        return bitmapFontTextParser.test(data) || bitmapFontXMLStringParser.test(data);\n    },\n\n    async parse(asset: string, data: ResolvedAsset, loader: Loader): Promise<BitmapFont>\n    {\n        const bitmapFontData = bitmapFontTextParser.test(asset)\n            ? bitmapFontTextParser.parse(asset)\n            : bitmapFontXMLStringParser.parse(asset);\n\n        const { src } = data;\n        const { pages } = bitmapFontData;\n        const textureUrls = [];\n\n        for (let i = 0; i < pages.length; ++i)\n        {\n            const pageFile = pages[i].file;\n            let imagePath = path.join(path.dirname(src), pageFile);\n\n            imagePath = copySearchParams(imagePath, src);\n\n            textureUrls.push(imagePath);\n        }\n\n        const loadedTextures = await loader.load<Texture>(textureUrls);\n        const textures = textureUrls.map((url) => loadedTextures[url]);\n\n        const bitmapFont = new BitmapFont({\n            data: bitmapFontData,\n            textures\n        }, src);\n\n        return bitmapFont;\n    },\n\n    async load(url: string, _options: ResolvedAsset): Promise<string>\n    {\n        const response = await DOMAdapter.get().fetch(url);\n\n        return await response.text();\n    },\n\n    async unload(bitmapFont: BitmapFont, _resolvedAsset, loader): Promise<void>\n    {\n        await Promise.all(bitmapFont.pages.map((page) => loader.unload(page.texture.source._sourceOrigin)));\n\n        bitmapFont.destroy();\n    }\n} as LoaderParser;\n","import { Rectangle } from '../../maths/shapes/Rectangle.mjs';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { AbstractBitmapFont } from './AbstractBitmapFont.mjs';\nimport { BitmapFontManager } from './BitmapFontManager.mjs';\n\n\"use strict\";\nclass BitmapFont extends AbstractBitmapFont {\n  constructor(options, url) {\n    super();\n    const { textures, data } = options;\n    Object.keys(data.pages).forEach((key) => {\n      const pageData = data.pages[parseInt(key, 10)];\n      const texture = textures[pageData.id];\n      this.pages.push({ texture });\n    });\n    Object.keys(data.chars).forEach((key) => {\n      const charData = data.chars[key];\n      const textureSource = textures[charData.page].source;\n      const frameReal = new Rectangle(\n        charData.x,\n        charData.y,\n        charData.width,\n        charData.height\n      );\n      const texture = new Texture({\n        source: textureSource,\n        frame: frameReal\n      });\n      this.chars[key] = {\n        id: key.codePointAt(0),\n        xOffset: charData.xOffset,\n        yOffset: charData.yOffset,\n        xAdvance: charData.xAdvance,\n        kerning: charData.kerning ?? {},\n        texture\n      };\n    });\n    this.baseRenderedFontSize = data.fontSize;\n    this.baseMeasurementFontSize = data.fontSize;\n    this.fontMetrics = {\n      ascent: 0,\n      descent: 0,\n      fontSize: data.fontSize\n    };\n    this.baseLineOffset = data.baseLineOffset;\n    this.lineHeight = data.lineHeight;\n    this.fontFamily = data.fontFamily;\n    this.distanceField = data.distanceField ?? {\n      type: \"none\",\n      range: 0\n    };\n    this.url = url;\n  }\n  /** Destroys the BitmapFont object. */\n  destroy() {\n    super.destroy();\n    for (let i = 0; i < this.pages.length; i++) {\n      const { texture } = this.pages[i];\n      texture.destroy(true);\n    }\n    this.pages = null;\n  }\n  /**\n   * Generates a bitmap-font for the given style and character set\n   * @param options - Setup options for font generation.\n   * @returns Font generated by style options.\n   * @example\n   * import { BitmapFont, BitmapText } from 'pixi.js';\n   *\n   * BitmapFont.install('TitleFont', {\n   *     fontFamily: 'Arial',\n   *     fontSize: 12,\n   *     strokeThickness: 2,\n   *     fill: 'purple',\n   * });\n   *\n   * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });\n   */\n  static install(options) {\n    BitmapFontManager.install(options);\n  }\n  /**\n   * Uninstalls a bitmap font from the cache.\n   * @param {string} name - The name of the bitmap font to uninstall.\n   */\n  static uninstall(name) {\n    BitmapFontManager.uninstall(name);\n  }\n}\n\nexport { BitmapFont };\n//# sourceMappingURL=BitmapFont.mjs.map\n","import { Rectangle } from '../../maths/shapes/Rectangle';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { AbstractBitmapFont } from './AbstractBitmapFont';\nimport { BitmapFontManager } from './BitmapFontManager';\n\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\nimport type { BitmapFontData } from './AbstractBitmapFont';\nimport type { BitmapFontInstallOptions } from './BitmapFontManager';\n\n/**\n * Options for creating a BitmapFont.\n * @memberof text\n */\nexport interface BitmapFontOptions\n{\n    data: BitmapFontData\n    textures: Texture[]\n}\n\n/**\n * A BitmapFont object represents a particular font face, size, and style.\n * @memberof text\n */\nexport class BitmapFont extends AbstractBitmapFont<BitmapFont>\n{\n    /** the url of the font */\n    public url?: string;\n\n    constructor(options: BitmapFontOptions, url?: string)\n    {\n        super();\n\n        const { textures, data } = options;\n\n        Object.keys(data.pages).forEach((key: string) =>\n        {\n            const pageData = data.pages[parseInt(key, 10)];\n\n            const texture = textures[pageData.id];\n\n            this.pages.push({ texture });\n        });\n\n        Object.keys(data.chars).forEach((key: string) =>\n        {\n            const charData = data.chars[key];\n            const textureSource = textures[charData.page].source;\n\n            const frameReal = new Rectangle(\n                charData.x,\n                charData.y,\n                charData.width,\n                charData.height,\n            );\n\n            const texture = new Texture({\n                source: textureSource,\n                frame: frameReal\n            });\n\n            this.chars[key] = {\n                id: key.codePointAt(0),\n                xOffset: charData.xOffset,\n                yOffset: charData.yOffset,\n                xAdvance: charData.xAdvance,\n                kerning: charData.kerning ?? {},\n                texture,\n            };\n        });\n\n        this.baseRenderedFontSize = data.fontSize;\n\n        (this.baseMeasurementFontSize as number) = data.fontSize;\n        (this.fontMetrics as FontMetrics) = {\n            ascent: 0,\n            descent: 0,\n            fontSize: data.fontSize,\n        };\n        (this.baseLineOffset as number) = data.baseLineOffset;\n        (this.lineHeight as number) = data.lineHeight;\n        (this.fontFamily as string) = data.fontFamily;\n        (this.distanceField as { type: string, range: number }) = data.distanceField ?? {\n            type: 'none',\n            range: 0,\n        };\n\n        this.url = url;\n    }\n\n    /** Destroys the BitmapFont object. */\n    public override destroy(): void\n    {\n        super.destroy();\n\n        for (let i = 0; i < this.pages.length; i++)\n        {\n            const { texture } = this.pages[i];\n\n            texture.destroy(true);\n        }\n\n        (this.pages as null) = null;\n    }\n\n    /**\n     * Generates a bitmap-font for the given style and character set\n     * @param options - Setup options for font generation.\n     * @returns Font generated by style options.\n     * @example\n     * import { BitmapFont, BitmapText } from 'pixi.js';\n     *\n     * BitmapFont.install('TitleFont', {\n     *     fontFamily: 'Arial',\n     *     fontSize: 12,\n     *     strokeThickness: 2,\n     *     fill: 'purple',\n     * });\n     *\n     * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });\n     */\n    public static install(options: BitmapFontInstallOptions)\n    {\n        BitmapFontManager.install(options);\n    }\n    /**\n     * Uninstalls a bitmap font from the cache.\n     * @param {string} name - The name of the bitmap font to uninstall.\n     */\n    public static uninstall(name: string)\n    {\n        BitmapFontManager.uninstall(name);\n    }\n}\n","import EventEmitter from 'eventemitter3';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nclass AbstractBitmapFont extends EventEmitter {\n  constructor() {\n    super(...arguments);\n    /** The map of characters by character code. */\n    this.chars = /* @__PURE__ */ Object.create(null);\n    /**\n     * The line-height of the font face in pixels.\n     * @type {number}\n     */\n    this.lineHeight = 0;\n    /**\n     * The name of the font face\n     * @type {string}\n     */\n    this.fontFamily = \"\";\n    /** The metrics of the font face. */\n    this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 };\n    /**\n     * The offset of the font face from the baseline.\n     * @type {number}\n     */\n    this.baseLineOffset = 0;\n    /** The range and type of the distance field for this font. */\n    this.distanceField = { type: \"none\", range: 0 };\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    this.pages = [];\n    /** The size of the font face in pixels. */\n    this.baseMeasurementFontSize = 100;\n    this.baseRenderedFontSize = 100;\n  }\n  /**\n   * The name of the font face.\n   * @deprecated since 8.0.0 Use `fontFamily` instead.\n   */\n  get font() {\n    deprecation(v8_0_0, \"BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.\");\n    return this.fontFamily;\n  }\n  /**\n   * The map of base page textures (i.e., sheets of glyphs).\n   * @deprecated since 8.0.0 Use `pages` instead.\n   */\n  get pageTextures() {\n    deprecation(v8_0_0, \"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.\");\n    return this.pages;\n  }\n  /**\n   * The size of the font face in pixels.\n   * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.\n   */\n  get size() {\n    deprecation(v8_0_0, \"BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.\");\n    return this.fontMetrics.fontSize;\n  }\n  /**\n   * The kind of distance field for this font or \"none\".\n   * @deprecated since 8.0.0 Use `distanceField.type` instead.\n   */\n  get distanceFieldRange() {\n    deprecation(v8_0_0, \"BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.\");\n    return this.distanceField.range;\n  }\n  /**\n   * The range of the distance field in pixels.\n   * @deprecated since 8.0.0 Use `distanceField.range` instead.\n   */\n  get distanceFieldType() {\n    deprecation(v8_0_0, \"BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.\");\n    return this.distanceField.type;\n  }\n  destroy(destroyTextures = false) {\n    this.emit(\"destroy\", this);\n    this.removeAllListeners();\n    for (const i in this.chars) {\n      this.chars[i].texture.destroy();\n    }\n    this.chars = null;\n    if (destroyTextures) {\n      this.pages.forEach((page) => page.texture.destroy(true));\n      this.pages = null;\n    }\n  }\n}\n\nexport { AbstractBitmapFont };\n//# sourceMappingURL=AbstractBitmapFont.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\n\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\n\n/** @memberof text */\nexport interface CharData\n{\n    /** Unique id of character */\n    id: number;\n    /** x-offset to apply when rendering character */\n    xOffset: number;\n    /** y-offset to apply when rendering character. */\n    yOffset: number;\n    /** Advancement to apply to next character. */\n    xAdvance: number;\n    /** The kerning values for this character. */\n    kerning: Record<string, number>;\n    /** The texture of the character. */\n    texture?: Texture;\n}\n\n/**\n * The raw data of a character in a bitmap font.\n * @memberof text\n */\nexport interface RawCharData extends Omit<CharData, 'texture'>\n{\n    /** The page of the font texture that the character is on. */\n    page: number;\n    /** The x position of the character in the page. */\n    x: number;\n    /** The y position of the character in the page. */\n    y: number;\n    /** The width of the character in the page. */\n    width: number;\n    /** The height of the character in the page. */\n    height: number;\n    /** The letter of the character. */\n    letter: string;\n}\n\n/**\n * The raw data of a bitmap font.\n * @memberof text\n */\nexport interface BitmapFontData\n{\n    /** The offset of the font face from the baseline. */\n    baseLineOffset: number;\n    /** The map of characters by character code. */\n    chars: Record<string, RawCharData>;\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    pages: {\n        /** Unique id for bitmap texture */\n        id: number;\n        /** File name */\n        file: string\n    }[];\n    /** The line-height of the font face in pixels. */\n    lineHeight: number;\n    /** The size of the font face in pixels. */\n    fontSize: number;\n    /** The name of the font face. */\n    fontFamily: string;\n    /** The range and type of the distance field for this font. */\n    distanceField?: {\n        /** Type of distance field */\n        type: 'sdf' | 'msdf' | 'none';\n        /** Range of the distance field in pixels */\n        range: number;\n    };\n}\n\ninterface BitmapFontEvents<Type>\n{\n    destroy: [Type];\n}\n\n/**\n * An abstract representation of a bitmap font.\n * @memberof text\n */\nexport abstract class AbstractBitmapFont<FontType>\n    extends EventEmitter<BitmapFontEvents<FontType>>\n    implements Omit<BitmapFontData, 'chars' | 'pages' | 'fontSize'>\n{\n    /** The map of characters by character code. */\n    public readonly chars: Record<string, CharData> = Object.create(null);\n\n    /**\n     * The line-height of the font face in pixels.\n     * @type {number}\n     */\n    public readonly lineHeight: BitmapFontData['lineHeight'] = 0;\n\n    /**\n     * The name of the font face\n     * @type {string}\n     */\n    public readonly fontFamily: BitmapFontData['fontFamily'] = '';\n    /** The metrics of the font face. */\n    public readonly fontMetrics: FontMetrics = { fontSize: 0, ascent: 0, descent: 0 };\n    /**\n     * The offset of the font face from the baseline.\n     * @type {number}\n     */\n    public readonly baseLineOffset: BitmapFontData['baseLineOffset'] = 0;\n    /** The range and type of the distance field for this font. */\n    public readonly distanceField: BitmapFontData['distanceField'] = { type: 'none', range: 0 };\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    public readonly pages: { texture: Texture }[] = [];\n\n    /** The size of the font face in pixels. */\n    public readonly baseMeasurementFontSize: number = 100;\n    protected baseRenderedFontSize = 100;\n\n    /**\n     * The name of the font face.\n     * @deprecated since 8.0.0 Use `fontFamily` instead.\n     */\n    public get font(): BitmapFontData['fontFamily']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.');\n        // #endif\n\n        return this.fontFamily;\n    }\n\n    /**\n     * The map of base page textures (i.e., sheets of glyphs).\n     * @deprecated since 8.0.0 Use `pages` instead.\n     */\n    public get pageTextures(): AbstractBitmapFont<FontType>['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    /**\n     * The size of the font face in pixels.\n     * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.\n     */\n    public get size(): BitmapFontData['fontSize']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.');\n        // #endif\n\n        return this.fontMetrics.fontSize;\n    }\n\n    /**\n     * The kind of distance field for this font or \"none\".\n     * @deprecated since 8.0.0 Use `distanceField.type` instead.\n     */\n    public get distanceFieldRange(): NonNullable<BitmapFontData['distanceField']>['range']\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.');\n        // #endif\n\n        return this.distanceField.range;\n    }\n\n    /**\n     * The range of the distance field in pixels.\n     * @deprecated since 8.0.0 Use `distanceField.range` instead.\n     */\n    public get distanceFieldType(): NonNullable<BitmapFontData['distanceField']>['type']\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.');\n        // #endif\n\n        return this.distanceField.type;\n    }\n\n    public destroy(destroyTextures = false): void\n    {\n        this.emit('destroy', this as unknown as FontType);\n\n        this.removeAllListeners();\n\n        for (const i in this.chars)\n        {\n            this.chars[i].texture.destroy();\n        }\n\n        (this.chars as null) = null;\n\n        if (destroyTextures)\n        {\n            this.pages.forEach((page) => page.texture.destroy(true));\n            (this.pages as any) = null;\n        }\n    }\n}\n","import { Cache } from '../../assets/cache/Cache.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { TextStyle } from '../text/TextStyle.mjs';\nimport { DynamicBitmapFont } from './DynamicBitmapFont.mjs';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout.mjs';\nimport { resolveCharacters } from './utils/resolveCharacters.mjs';\n\n\"use strict\";\nclass BitmapFontManagerClass {\n  constructor() {\n    /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.ALPHA })\n     */\n    this.ALPHA = [[\"a\", \"z\"], [\"A\", \"Z\"], \" \"];\n    /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })\n     */\n    this.NUMERIC = [[\"0\", \"9\"]];\n    /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */\n    this.ALPHANUMERIC = [[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"], \" \"];\n    /**\n     * This character set consists of all the ASCII table.\n     * @member {string[][]}\n     * @see http://www.asciitable.com/\n     */\n    this.ASCII = [[\" \", \"~\"]];\n    /** Default options for installing a new BitmapFont. */\n    this.defaultOptions = {\n      chars: this.ALPHANUMERIC,\n      resolution: 1,\n      padding: 4,\n      skipKerning: false\n    };\n  }\n  /**\n   * Get a font for the specified text and style.\n   * @param text - The text to get the font for\n   * @param style - The style to use\n   */\n  getFont(text, style) {\n    let fontFamilyKey = `${style.fontFamily}-bitmap`;\n    let overrideFill = true;\n    if (style._fill.fill) {\n      fontFamilyKey += style._fill.fill.uid;\n      overrideFill = false;\n    }\n    if (!Cache.has(fontFamilyKey)) {\n      const fnt = new DynamicBitmapFont({\n        style,\n        overrideFill,\n        overrideSize: true,\n        ...this.defaultOptions\n      });\n      fnt.once(\"destroy\", () => Cache.remove(fontFamilyKey));\n      Cache.set(\n        fontFamilyKey,\n        fnt\n      );\n    }\n    const dynamicFont = Cache.get(fontFamilyKey);\n    dynamicFont.ensureCharacters?.(text);\n    return dynamicFont;\n  }\n  /**\n   * Get the layout of a text for the specified style.\n   * @param text - The text to get the layout for\n   * @param style - The style to use\n   */\n  getLayout(text, style) {\n    const bitmapFont = this.getFont(text, style);\n    return getBitmapTextLayout(text.split(\"\"), style, bitmapFont);\n  }\n  /**\n   * Measure the text using the specified style.\n   * @param text - The text to measure\n   * @param style - The style to use\n   */\n  measureText(text, style) {\n    return this.getLayout(text, style);\n  }\n  // eslint-disable-next-line max-len\n  install(...args) {\n    let options = args[0];\n    if (typeof options === \"string\") {\n      options = {\n        name: options,\n        style: args[1],\n        chars: args[2]?.chars,\n        resolution: args[2]?.resolution,\n        padding: args[2]?.padding,\n        skipKerning: args[2]?.skipKerning\n      };\n      deprecation(v8_0_0, \"BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})\");\n    }\n    const name = options?.name;\n    if (!name) {\n      throw new Error(\"[BitmapFontManager] Property `name` is required.\");\n    }\n    options = { ...this.defaultOptions, ...options };\n    const textStyle = options.style;\n    const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);\n    const overrideFill = style._fill.fill !== null && style._fill.fill !== void 0;\n    const font = new DynamicBitmapFont({\n      style,\n      overrideFill,\n      skipKerning: options.skipKerning,\n      padding: options.padding,\n      resolution: options.resolution,\n      overrideSize: false\n    });\n    const flatChars = resolveCharacters(options.chars);\n    font.ensureCharacters(flatChars.join(\"\"));\n    Cache.set(`${name}-bitmap`, font);\n    font.once(\"destroy\", () => Cache.remove(`${name}-bitmap`));\n    return font;\n  }\n  /**\n   * Uninstalls a bitmap font from the cache.\n   * @param {string} name - The name of the bitmap font to uninstall.\n   */\n  uninstall(name) {\n    const cacheKey = `${name}-bitmap`;\n    const font = Cache.get(cacheKey);\n    if (font) {\n      Cache.remove(cacheKey);\n      font.destroy();\n    }\n  }\n}\nconst BitmapFontManager = new BitmapFontManagerClass();\n\nexport { BitmapFontManager };\n//# sourceMappingURL=BitmapFontManager.mjs.map\n","import { Cache } from '../../assets/cache/Cache';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { TextStyle } from '../text/TextStyle';\nimport { DynamicBitmapFont } from './DynamicBitmapFont';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\nimport { resolveCharacters } from './utils/resolveCharacters';\n\nimport type { TextStyleOptions } from '../text/TextStyle';\nimport type { BitmapFont } from './BitmapFont';\nimport type { BitmapTextLayoutData } from './utils/getBitmapTextLayout';\n\n/**\n *\n * The options for installing a new BitmapFont. Once installed the font will be available for use in the BitmapText.\n * It can be accessed by the `fontFamily` property of the TextStyle.\n *\n * Install a new BitmapFont will create the characters provided for the font and store them in the cache.\n * But don't worry, if a character is requested that hasn't been generated yet, it will be created on the fly.\n * @memberof text\n */\nexport interface BitmapFontInstallOptions\n{\n    /** the name of the font, this will be the name you use in the fontFamily of text style to access this font */\n    name?: string;\n    /**\n     * Characters included in the font set. You can also use ranges.\n     * For example, `[['a', 'z'], ['A', 'Z'], \"!@#$%^&*()~{}[] \"]`.\n     * Don't forget to include spaces ' ' in your character set!\n     * @default BitmapFont.ALPHANUMERIC\n     */\n    chars?: string | (string | string[])[];\n    /**\n     * Render resolution for glyphs.\n     * @default 1\n     */\n    resolution?: number;\n    /**\n     * Padding between glyphs on texture atlas. Lower values could mean more visual artifacts\n     * and bleeding from other glyphs, larger values increase the space required on the texture.\n     * @default 4\n     */\n    padding?: number;\n    /**\n     * Skip generation of kerning information for the BitmapFont.\n     * If true, this could potentially increase the performance, but may impact the rendered text appearance.\n     * @default false\n     */\n    skipKerning?: boolean;\n    /** Style options to render with BitmapFont. */\n    style?: TextStyle | TextStyleOptions;\n}\n\n/**\n * The BitmapFontManager is a helper that exists to install and uninstall fonts\n * into the cache for BitmapText objects.\n * @memberof text\n * @name BitmapFontManager\n * @example\n * import { BitmapFontManager, BitmapText } from 'pixi.js';\n *\n * BitmapFontManager.install({\n *   name: 'TitleFont',\n *   style: {}\n * });\n *\n * const title = new BitmapText({ text: 'This is the title', style: { fontFamily: 'TitleFont' }});\n */\nclass BitmapFontManagerClass\n{\n    /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.ALPHA })\n     */\n    public readonly ALPHA = [['a', 'z'], ['A', 'Z'], ' '];\n\n    /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })\n     */\n    public readonly NUMERIC = [['0', '9']];\n\n    /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */\n    public readonly ALPHANUMERIC = [['a', 'z'], ['A', 'Z'], ['0', '9'], ' '];\n\n    /**\n     * This character set consists of all the ASCII table.\n     * @member {string[][]}\n     * @see http://www.asciitable.com/\n     */\n    public readonly ASCII = [[' ', '~']];\n\n    /** Default options for installing a new BitmapFont. */\n    public defaultOptions: Omit<BitmapFontInstallOptions, 'style'> = {\n        chars: this.ALPHANUMERIC,\n        resolution: 1,\n        padding: 4,\n        skipKerning: false,\n    };\n\n    /**\n     * Get a font for the specified text and style.\n     * @param text - The text to get the font for\n     * @param style - The style to use\n     */\n    public getFont(text: string, style: TextStyle): BitmapFont\n    {\n        let fontFamilyKey = `${style.fontFamily as string}-bitmap`;\n        let overrideFill = true;\n\n        // assuming there is no texture we can use a tint!\n        if (style._fill.fill)\n        {\n            fontFamilyKey += style._fill.fill.uid;\n            overrideFill = false;\n        }\n\n        // first get us the the right font...\n        if (!Cache.has(fontFamilyKey))\n        {\n            const fnt = new DynamicBitmapFont({\n                style,\n                overrideFill,\n                overrideSize: true,\n                ...this.defaultOptions,\n            });\n\n            fnt.once('destroy', () => Cache.remove(fontFamilyKey));\n\n            Cache.set(\n                fontFamilyKey as string,\n                fnt\n            );\n        }\n\n        const dynamicFont = Cache.get(fontFamilyKey);\n\n        (dynamicFont as DynamicBitmapFont).ensureCharacters?.(text);\n\n        return dynamicFont;\n    }\n\n    /**\n     * Get the layout of a text for the specified style.\n     * @param text - The text to get the layout for\n     * @param style - The style to use\n     */\n    public getLayout(text: string, style: TextStyle): BitmapTextLayoutData\n    {\n        const bitmapFont = this.getFont(text, style);\n\n        return getBitmapTextLayout(text.split(''), style, bitmapFont);\n    }\n\n    /**\n     * Measure the text using the specified style.\n     * @param text - The text to measure\n     * @param style - The style to use\n     */\n    public measureText(text: string, style: TextStyle): { width: number; height: number; scale: number; offsetY: number }\n    {\n        return this.getLayout(text, style);\n    }\n\n    /**\n     * Generates a bitmap-font for the given style and character set\n     * @param options - Setup options for font generation.\n     * @returns Font generated by style options.\n     * @example\n     * import { BitmapFontManager, BitmapText } from 'pixi.js';\n     *\n     * BitmapFontManager.install('TitleFont', {\n     *     fontFamily: 'Arial',\n     *     fontSize: 12,\n     *     strokeThickness: 2,\n     *     fill: 'purple',\n     * });\n     *\n     * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });\n     */\n    public install(options: BitmapFontInstallOptions): BitmapFont;\n    /** @deprecated since 7.0.0 */\n    public install(name: string, style?: TextStyle | TextStyleOptions, options?: BitmapFontInstallOptions): BitmapFont;\n    // eslint-disable-next-line max-len\n    public install(...args: [string | BitmapFontInstallOptions, (TextStyle | TextStyleOptions)?, BitmapFontInstallOptions?]): BitmapFont\n    {\n        let options = args[0] as BitmapFontInstallOptions;\n\n        if (typeof options === 'string')\n        {\n            options = {\n                name: options,\n                style: args[1],\n                chars: args[2]?.chars,\n                resolution: args[2]?.resolution,\n                padding: args[2]?.padding,\n                skipKerning: args[2]?.skipKerning,\n            } as BitmapFontInstallOptions;\n\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})');\n            // #endif\n        }\n\n        const name = options?.name;\n\n        if (!name)\n        {\n            throw new Error('[BitmapFontManager] Property `name` is required.');\n        }\n\n        options = { ...this.defaultOptions, ...options };\n\n        const textStyle = options.style;\n\n        const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);\n        const overrideFill = style._fill.fill !== null && style._fill.fill !== undefined;\n        const font = new DynamicBitmapFont({\n            style,\n            overrideFill,\n            skipKerning: options.skipKerning,\n            padding: options.padding,\n            resolution: options.resolution,\n            overrideSize: false\n        });\n\n        const flatChars = resolveCharacters(options.chars);\n\n        font.ensureCharacters(flatChars.join(''));\n\n        Cache.set(`${name}-bitmap`, font);\n\n        font.once('destroy', () => Cache.remove(`${name}-bitmap`));\n\n        return font;\n    }\n\n    /**\n     * Uninstalls a bitmap font from the cache.\n     * @param {string} name - The name of the bitmap font to uninstall.\n     */\n    public uninstall(name: string)\n    {\n        const cacheKey = `${name}-bitmap`;\n        const font = Cache.get<BitmapFont>(cacheKey);\n\n        if (font)\n        {\n            Cache.remove(cacheKey);\n            font.destroy();\n        }\n    }\n}\n\nexport const BitmapFontManager = new BitmapFontManagerClass();\n","import EventEmitter from 'eventemitter3';\nimport { Color } from '../../color/Color.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { FillGradient } from '../graphics/shared/fill/FillGradient.mjs';\nimport { GraphicsContext } from '../graphics/shared/GraphicsContext.mjs';\nimport { convertFillInputToFillStyle } from '../graphics/shared/utils/convertFillInputToFillStyle.mjs';\nimport { generateTextStyleKey } from './utils/generateTextStyleKey.mjs';\n\n\"use strict\";\nconst _TextStyle = class _TextStyle extends EventEmitter {\n  constructor(style = {}) {\n    super();\n    convertV7Tov8Style(style);\n    const fullStyle = { ..._TextStyle.defaultTextStyle, ...style };\n    for (const key in fullStyle) {\n      const thisKey = key;\n      this[thisKey] = fullStyle[key];\n    }\n    this.update();\n  }\n  /**\n   * Alignment for multiline text, does not affect single line text.\n   * @member {'left'|'center'|'right'|'justify'}\n   */\n  get align() {\n    return this._align;\n  }\n  set align(value) {\n    this._align = value;\n    this.update();\n  }\n  /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */\n  get breakWords() {\n    return this._breakWords;\n  }\n  set breakWords(value) {\n    this._breakWords = value;\n    this.update();\n  }\n  /** Set a drop shadow for the text. */\n  get dropShadow() {\n    return this._dropShadow;\n  }\n  set dropShadow(value) {\n    if (value !== null && typeof value === \"object\") {\n      this._dropShadow = {\n        ..._TextStyle.defaultDropShadow,\n        ...value\n      };\n    } else {\n      this._dropShadow = value ? {\n        ..._TextStyle.defaultDropShadow\n      } : null;\n    }\n    this.update();\n  }\n  /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n  get fontFamily() {\n    return this._fontFamily;\n  }\n  set fontFamily(value) {\n    this._fontFamily = value;\n    this.update();\n  }\n  /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n  get fontSize() {\n    return this._fontSize;\n  }\n  set fontSize(value) {\n    if (typeof value === \"string\") {\n      this._fontSize = parseInt(value, 10);\n    } else {\n      this._fontSize = value;\n    }\n    this.update();\n  }\n  /**\n   * The font style.\n   * @member {'normal'|'italic'|'oblique'}\n   */\n  get fontStyle() {\n    return this._fontStyle;\n  }\n  set fontStyle(value) {\n    this._fontStyle = value;\n    this.update();\n  }\n  /**\n   * The font variant.\n   * @member {'normal'|'small-caps'}\n   */\n  get fontVariant() {\n    return this._fontVariant;\n  }\n  set fontVariant(value) {\n    this._fontVariant = value;\n    this.update();\n  }\n  /**\n   * The font weight.\n   * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n   */\n  get fontWeight() {\n    return this._fontWeight;\n  }\n  set fontWeight(value) {\n    this._fontWeight = value;\n    this.update();\n  }\n  /** The space between lines. */\n  get leading() {\n    return this._leading;\n  }\n  set leading(value) {\n    this._leading = value;\n    this.update();\n  }\n  /** The amount of spacing between letters, default is 0. */\n  get letterSpacing() {\n    return this._letterSpacing;\n  }\n  set letterSpacing(value) {\n    this._letterSpacing = value;\n    this.update();\n  }\n  /** The line height, a number that represents the vertical space that a letter uses. */\n  get lineHeight() {\n    return this._lineHeight;\n  }\n  set lineHeight(value) {\n    this._lineHeight = value;\n    this.update();\n  }\n  /**\n   * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n   * by adding padding to all sides of the text.\n   */\n  get padding() {\n    return this._padding;\n  }\n  set padding(value) {\n    this._padding = value;\n    this.update();\n  }\n  /** Trim transparent borders. This is an expensive operation so only use this if you have to! */\n  get trim() {\n    return this._trim;\n  }\n  set trim(value) {\n    this._trim = value;\n    this.update();\n  }\n  /**\n   * The baseline of the text that is rendered.\n   * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n   */\n  get textBaseline() {\n    return this._textBaseline;\n  }\n  set textBaseline(value) {\n    this._textBaseline = value;\n    this.update();\n  }\n  /**\n   * How newlines and spaces should be handled.\n   * Default is 'pre' (preserve, preserve).\n   *\n   *  value       | New lines     |   Spaces\n   *  ---         | ---           |   ---\n   * 'normal'     | Collapse      |   Collapse\n   * 'pre'        | Preserve      |   Preserve\n   * 'pre-line'   | Preserve      |   Collapse\n   * @member {'normal'|'pre'|'pre-line'}\n   */\n  get whiteSpace() {\n    return this._whiteSpace;\n  }\n  set whiteSpace(value) {\n    this._whiteSpace = value;\n    this.update();\n  }\n  /** Indicates if word wrap should be used. */\n  get wordWrap() {\n    return this._wordWrap;\n  }\n  set wordWrap(value) {\n    this._wordWrap = value;\n    this.update();\n  }\n  /** The width at which text will wrap, it needs wordWrap to be set to true. */\n  get wordWrapWidth() {\n    return this._wordWrapWidth;\n  }\n  set wordWrapWidth(value) {\n    this._wordWrapWidth = value;\n    this.update();\n  }\n  /** A fillstyle that will be used on the text e.g., 'red', '#00FF00'. */\n  get fill() {\n    return this._originalFill;\n  }\n  set fill(value) {\n    if (value === this._originalFill)\n      return;\n    this._originalFill = value;\n    this._fill = convertFillInputToFillStyle(\n      value === 0 ? \"black\" : value,\n      GraphicsContext.defaultFillStyle\n    );\n    this.update();\n  }\n  /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */\n  get stroke() {\n    return this._originalStroke;\n  }\n  set stroke(value) {\n    if (value === this._originalStroke)\n      return;\n    this._originalStroke = value;\n    this._stroke = convertFillInputToFillStyle(value, GraphicsContext.defaultStrokeStyle);\n    this.update();\n  }\n  _generateKey() {\n    this._styleKey = generateTextStyleKey(this);\n    return this._styleKey;\n  }\n  update() {\n    this._styleKey = null;\n    this.emit(\"update\", this);\n  }\n  /** Resets all properties to the default values */\n  reset() {\n    const defaultStyle = _TextStyle.defaultTextStyle;\n    for (const key in defaultStyle) {\n      this[key] = defaultStyle[key];\n    }\n  }\n  get styleKey() {\n    return this._styleKey || this._generateKey();\n  }\n  /**\n   * Creates a new TextStyle object with the same values as this one.\n   * @returns New cloned TextStyle object\n   */\n  clone() {\n    return new _TextStyle({\n      align: this.align,\n      breakWords: this.breakWords,\n      dropShadow: this.dropShadow,\n      fill: this._fill,\n      fontFamily: this.fontFamily,\n      fontSize: this.fontSize,\n      fontStyle: this.fontStyle,\n      fontVariant: this.fontVariant,\n      fontWeight: this.fontWeight,\n      leading: this.leading,\n      letterSpacing: this.letterSpacing,\n      lineHeight: this.lineHeight,\n      padding: this.padding,\n      stroke: this._stroke,\n      textBaseline: this.textBaseline,\n      whiteSpace: this.whiteSpace,\n      wordWrap: this.wordWrap,\n      wordWrapWidth: this.wordWrapWidth\n    });\n  }\n  /**\n   * Destroys this text style.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style\n   */\n  destroy(options = false) {\n    this.removeAllListeners();\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      if (this._fill?.texture) {\n        this._fill.texture.destroy(destroyTextureSource);\n      }\n      if (this._originalFill?.texture) {\n        this._originalFill.texture.destroy(destroyTextureSource);\n      }\n      if (this._stroke?.texture) {\n        this._stroke.texture.destroy(destroyTextureSource);\n      }\n      if (this._originalStroke?.texture) {\n        this._originalStroke.texture.destroy(destroyTextureSource);\n      }\n    }\n    this._fill = null;\n    this._stroke = null;\n    this.dropShadow = null;\n    this._originalStroke = null;\n    this._originalFill = null;\n  }\n};\n/** The default drop shadow settings */\n_TextStyle.defaultDropShadow = {\n  /** Set alpha for the drop shadow */\n  alpha: 1,\n  /** Set a angle of the drop shadow */\n  angle: Math.PI / 6,\n  /** Set a shadow blur radius */\n  blur: 0,\n  /** A fill style to be used on the  e.g., 'red', '#00FF00' */\n  color: \"black\",\n  /** Set a distance of the drop shadow */\n  distance: 5\n};\n/** The default text style settings */\n_TextStyle.defaultTextStyle = {\n  /**\n   * See {@link TextStyle.align}\n   * @type {'left'|'center'|'right'|'justify'}\n   */\n  align: \"left\",\n  /** See {@link TextStyle.breakWords} */\n  breakWords: false,\n  /** See {@link TextStyle.dropShadow} */\n  dropShadow: null,\n  /**\n   * See {@link TextStyle.fill}\n   * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n   */\n  fill: \"black\",\n  /**\n   * See {@link TextStyle.fontFamily}\n   * @type {string|string[]}\n   */\n  fontFamily: \"Arial\",\n  /**\n   * See {@link TextStyle.fontSize}\n   * @type {number|string}\n   */\n  fontSize: 26,\n  /**\n   * See {@link TextStyle.fontStyle}\n   * @type {'normal'|'italic'|'oblique'}\n   */\n  fontStyle: \"normal\",\n  /**\n   * See {@link TextStyle.fontVariant}\n   * @type {'normal'|'small-caps'}\n   */\n  fontVariant: \"normal\",\n  /**\n   * See {@link TextStyle.fontWeight}\n   * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n   */\n  fontWeight: \"normal\",\n  /** See {@link TextStyle.leading} */\n  leading: 0,\n  /** See {@link TextStyle.letterSpacing} */\n  letterSpacing: 0,\n  /** See {@link TextStyle.lineHeight} */\n  lineHeight: 0,\n  /** See {@link TextStyle.padding} */\n  padding: 0,\n  /**\n   * See {@link TextStyle.stroke}\n   * @type {string|number}\n   */\n  stroke: null,\n  /**\n   * See {@link TextStyle.textBaseline}\n   * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n   */\n  textBaseline: \"alphabetic\",\n  /** See {@link TextStyle.trim} */\n  trim: false,\n  /**\n   * See {@link TextStyle.whiteSpace}\n   * @type {'normal'|'pre'|'pre-line'}\n   */\n  whiteSpace: \"pre\",\n  /** See {@link TextStyle.wordWrap} */\n  wordWrap: false,\n  /** See {@link TextStyle.wordWrapWidth} */\n  wordWrapWidth: 100\n};\nlet TextStyle = _TextStyle;\nfunction convertV7Tov8Style(style) {\n  const oldStyle = style;\n  if (typeof oldStyle.dropShadow === \"boolean\" && oldStyle.dropShadow) {\n    const defaults = TextStyle.defaultDropShadow;\n    style.dropShadow = {\n      alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,\n      angle: oldStyle.dropShadowAngle ?? defaults.angle,\n      blur: oldStyle.dropShadowBlur ?? defaults.blur,\n      color: oldStyle.dropShadowColor ?? defaults.color,\n      distance: oldStyle.dropShadowDistance ?? defaults.distance\n    };\n  }\n  if (oldStyle.strokeThickness) {\n    deprecation(v8_0_0, \"strokeThickness is now a part of stroke\");\n    const color = oldStyle.stroke;\n    style.stroke = {\n      color,\n      width: oldStyle.strokeThickness\n    };\n  }\n  if (Array.isArray(oldStyle.fill)) {\n    deprecation(v8_0_0, \"gradient fill is now a fill pattern: `new FillGradient(...)`\");\n    const gradientFill = new FillGradient(0, 0, 0, style.fontSize * 1.7);\n    const fills = oldStyle.fill.map((color) => Color.shared.setValue(color).toNumber());\n    fills.forEach((number, index) => {\n      const ratio = oldStyle.fillGradientStops[index] ?? index / fills.length;\n      gradientFill.addColorStop(ratio, number);\n    });\n    style.fill = {\n      fill: gradientFill\n    };\n  }\n}\n\nexport { TextStyle };\n//# sourceMappingURL=TextStyle.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../color/Color';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { FillGradient } from '../graphics/shared/fill/FillGradient';\nimport { GraphicsContext } from '../graphics/shared/GraphicsContext';\nimport { convertFillInputToFillStyle } from '../graphics/shared/utils/convertFillInputToFillStyle';\nimport { generateTextStyleKey } from './utils/generateTextStyleKey';\n\nimport type { TextureDestroyOptions, TypeOrBool } from '../container/destroyTypes';\nimport type {\n    ConvertedFillStyle,\n    ConvertedStrokeStyle,\n    FillStyle,\n    FillStyleInputs\n} from '../graphics/shared/GraphicsContext';\n\nexport type TextStyleAlign = 'left' | 'center' | 'right' | 'justify';\nexport type TextStyleFill = string | string[] | number | number[] | CanvasGradient | CanvasPattern;\nexport type TextStyleFontStyle = 'normal' | 'italic' | 'oblique';\nexport type TextStyleFontVariant = 'normal' | 'small-caps';\n// eslint-disable-next-line max-len\nexport type TextStyleFontWeight = 'normal' | 'bold' | 'bolder' | 'lighter' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900';\nexport type TextStyleLineJoin = 'miter' | 'round' | 'bevel';\nexport type TextStyleTextBaseline = 'alphabetic' | 'top' | 'hanging' | 'middle' | 'ideographic' | 'bottom';\nexport type TextStyleWhiteSpace = 'normal' | 'pre' | 'pre-line';\n\n/**\n * A collection of text related classes.\n * @namespace text\n */\n\n/**\n * A drop shadow effect.\n * @memberof text\n */\nexport type TextDropShadow = {\n    /** Set alpha for the drop shadow  */\n    alpha: number;\n    /** Set a angle of the drop shadow */\n    angle: number;\n    /** Set a shadow blur radius */\n    blur: number;\n    /** A fill style to be used on the  e.g., 'red', '#00FF00' */\n    color: ColorSource;\n    /** Set a distance of the drop shadow */\n    distance: number;\n};\n\n/**\n * Constructor options used for `TextStyle` instances.\n * ```js\n * const textStyle = new TextStyle({\n *    fontSize: 12,\n *    fill: 'black',\n * });\n * ```\n * @see {@link text.TextStyle}\n * @memberof text\n */\nexport interface TextStyleOptions\n{\n    /**\n     * Alignment for multiline text, does not affect single line text\n     * @type {'left'|'center'|'right'|'justify'}\n     */\n    align?: TextStyleAlign;\n    /** Indicates if lines can be wrapped within words, it needs `wordWrap` to be set to `true` */\n    breakWords?: boolean;\n    /** Set a drop shadow for the text */\n    dropShadow?: boolean | Partial<TextDropShadow>;\n    /**\n     * A canvas fillstyle that will be used on the text e.g., 'red', '#00FF00'.\n     * Can be an array to create a gradient, e.g., `['#000000','#FFFFFF']`\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}\n     * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n     */\n    fill?: FillStyleInputs;\n    /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n    fontFamily?: string | string[];\n    /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n    fontSize?: number | string;\n    /**\n     * The font style.\n     * @type {'normal'|'italic'|'oblique'}\n     */\n    fontStyle?: TextStyleFontStyle;\n    /**\n     * The font variant.\n     * @type {'normal'|'small-caps'}\n     */\n    fontVariant?: TextStyleFontVariant;\n    /**\n     * The font weight.\n     * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n     */\n    fontWeight?: TextStyleFontWeight;\n    /** The height of the line, a number that represents the vertical space that a letter uses. */\n    leading?: number;\n    /** The amount of spacing between letters, default is 0 */\n    letterSpacing?: number;\n    /** The line height, a number that represents the vertical space that a letter uses */\n    lineHeight?: number;\n    /**\n     * Occasionally some fonts are cropped. Adding some padding will prevent this from\n     * happening by adding padding to all sides of the text.\n     */\n    padding?: number;\n    /** A canvas fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00' */\n    stroke?: FillStyleInputs;\n    /**\n     * The baseline of the text that is rendered.\n     * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n     */\n    textBaseline?: TextStyleTextBaseline;\n    trim?: boolean,\n    /**\n     * Determines whether newlines & spaces are collapsed or preserved \"normal\"\n     * (collapse, collapse), \"pre\" (preserve, preserve) | \"pre-line\" (preserve,\n     * collapse). It needs wordWrap to be set to true.\n     * @type {'normal'|'pre'|'pre-line'}\n     */\n    whiteSpace?: TextStyleWhiteSpace;\n    /** Indicates if word wrap should be used */\n    wordWrap?: boolean;\n    /** The width at which text will wrap, it needs wordWrap to be set to true */\n    wordWrapWidth?: number;\n}\n\n/**\n * A TextStyle Object contains information to decorate a Text objects.\n *\n * An instance can be shared between multiple Text objects; then changing the style will update all text objects using it.\n * @memberof text\n * @example\n * import { TextStyle } from 'pixi.js';\n * const style = new TextStyle({\n *   fontFamily: ['Helvetica', 'Arial', 'sans-serif'],\n *   fontSize: 36,\n * });\n */\nexport class TextStyle extends EventEmitter<{\n    update: TextDropShadow\n}>\n{\n    /** The default drop shadow settings */\n    public static defaultDropShadow: TextDropShadow = {\n        /** Set alpha for the drop shadow */\n        alpha: 1,\n        /** Set a angle of the drop shadow */\n        angle: Math.PI / 6,\n        /** Set a shadow blur radius */\n        blur: 0,\n        /** A fill style to be used on the  e.g., 'red', '#00FF00' */\n        color: 'black',\n        /** Set a distance of the drop shadow */\n        distance: 5,\n    };\n\n    /** The default text style settings */\n    public static defaultTextStyle: TextStyleOptions = {\n        /**\n         * See {@link TextStyle.align}\n         * @type {'left'|'center'|'right'|'justify'}\n         */\n        align: 'left',\n        /** See {@link TextStyle.breakWords} */\n        breakWords: false,\n        /** See {@link TextStyle.dropShadow} */\n        dropShadow:  null,\n        /**\n         * See {@link TextStyle.fill}\n         * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n         */\n        fill: 'black',\n        /**\n         * See {@link TextStyle.fontFamily}\n         * @type {string|string[]}\n         */\n        fontFamily: 'Arial',\n        /**\n         * See {@link TextStyle.fontSize}\n         * @type {number|string}\n         */\n        fontSize: 26,\n        /**\n         * See {@link TextStyle.fontStyle}\n         * @type {'normal'|'italic'|'oblique'}\n         */\n        fontStyle: 'normal',\n        /**\n         * See {@link TextStyle.fontVariant}\n         * @type {'normal'|'small-caps'}\n         */\n        fontVariant: 'normal',\n        /**\n         * See {@link TextStyle.fontWeight}\n         * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n         */\n        fontWeight: 'normal',\n        /** See {@link TextStyle.leading} */\n        leading: 0,\n        /** See {@link TextStyle.letterSpacing} */\n        letterSpacing: 0,\n        /** See {@link TextStyle.lineHeight} */\n        lineHeight: 0,\n        /** See {@link TextStyle.padding} */\n        padding: 0,\n        /**\n         * See {@link TextStyle.stroke}\n         * @type {string|number}\n         */\n        stroke: null,\n        /**\n         * See {@link TextStyle.textBaseline}\n         * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n         */\n        textBaseline: 'alphabetic',\n        /** See {@link TextStyle.trim} */\n        trim: false,\n        /**\n         * See {@link TextStyle.whiteSpace}\n         * @type {'normal'|'pre'|'pre-line'}\n         */\n        whiteSpace: 'pre',\n        /** See {@link TextStyle.wordWrap} */\n        wordWrap: false,\n        /** See {@link TextStyle.wordWrapWidth} */\n        wordWrapWidth: 100,\n    };\n\n    // colors!!\n    public _fill: ConvertedFillStyle;\n    private _originalFill: FillStyleInputs;\n\n    public _stroke: ConvertedStrokeStyle;\n    private _originalStroke: FillStyleInputs;\n\n    private _dropShadow: TextDropShadow;\n\n    private _fontFamily: string | string[];\n    private _fontSize: number;\n    private _fontStyle: TextStyleFontStyle;\n    private _fontVariant: TextStyleFontVariant;\n    private _fontWeight: TextStyleFontWeight;\n\n    private _breakWords: boolean;\n    private _align: TextStyleAlign;\n    private _leading: number;\n    private _letterSpacing: number;\n    private _lineHeight: number;\n\n    private _textBaseline: TextStyleTextBaseline;\n    private _whiteSpace: TextStyleWhiteSpace;\n    private _wordWrap: boolean;\n    private _wordWrapWidth: number;\n\n    private _padding: number;\n\n    protected _styleKey: string;\n    private _trim: boolean;\n\n    constructor(style: Partial<TextStyleOptions> = {})\n    {\n        super();\n\n        convertV7Tov8Style(style);\n\n        const fullStyle = { ...TextStyle.defaultTextStyle, ...style };\n\n        for (const key in fullStyle)\n        {\n            const thisKey = key as keyof typeof this;\n\n            this[thisKey] = fullStyle[key as keyof TextStyleOptions] as any;\n        }\n\n        this.update();\n    }\n\n    /**\n     * Alignment for multiline text, does not affect single line text.\n     * @member {'left'|'center'|'right'|'justify'}\n     */\n    get align(): TextStyleAlign { return this._align; }\n    set align(value: TextStyleAlign) { this._align = value; this.update(); }\n    /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */\n    get breakWords(): boolean { return this._breakWords; }\n    set breakWords(value: boolean) { this._breakWords = value; this.update(); }\n    /** Set a drop shadow for the text. */\n    get dropShadow(): TextDropShadow { return this._dropShadow; }\n    set dropShadow(value: boolean | TextDropShadow)\n    {\n        if (value !== null && typeof value === 'object')\n        {\n            this._dropShadow = {\n                ...TextStyle.defaultDropShadow as TextDropShadow,\n                ...value as TextDropShadow\n            };\n        }\n        else\n        {\n            this._dropShadow = value ? {\n                ...TextStyle.defaultDropShadow as TextDropShadow\n            } : null;\n        }\n\n        this.update();\n    }\n    /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n    get fontFamily(): string | string[] { return this._fontFamily; }\n    set fontFamily(value: string | string[]) { this._fontFamily = value; this.update(); }\n    /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n    get fontSize(): number { return this._fontSize; }\n    set fontSize(value: string | number)\n    {\n        if (typeof value === 'string')\n        {\n            // eg '34px' to number\n            this._fontSize = parseInt(value as string, 10);\n        }\n        else\n        {\n            this._fontSize = value as number;\n        }\n        this.update();\n    }\n    /**\n     * The font style.\n     * @member {'normal'|'italic'|'oblique'}\n     */\n    get fontStyle(): TextStyleFontStyle { return this._fontStyle; }\n    set fontStyle(value: TextStyleFontStyle) { this._fontStyle = value; this.update(); }\n    /**\n     * The font variant.\n     * @member {'normal'|'small-caps'}\n     */\n    get fontVariant(): TextStyleFontVariant { return this._fontVariant; }\n    set fontVariant(value: TextStyleFontVariant) { this._fontVariant = value; this.update(); }\n    /**\n     * The font weight.\n     * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n     */\n    get fontWeight(): TextStyleFontWeight { return this._fontWeight; }\n    set fontWeight(value: TextStyleFontWeight) { this._fontWeight = value; this.update(); }\n    /** The space between lines. */\n    get leading(): number { return this._leading; }\n    set leading(value: number) { this._leading = value; this.update(); }\n    /** The amount of spacing between letters, default is 0. */\n    get letterSpacing(): number { return this._letterSpacing; }\n    set letterSpacing(value: number) { this._letterSpacing = value; this.update(); }\n    /** The line height, a number that represents the vertical space that a letter uses. */\n    get lineHeight(): number { return this._lineHeight; }\n    set lineHeight(value: number) { this._lineHeight = value; this.update(); }\n    /**\n     * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n     * by adding padding to all sides of the text.\n     */\n    get padding(): number { return this._padding; }\n    set padding(value: number) { this._padding = value; this.update(); }\n\n    /** Trim transparent borders. This is an expensive operation so only use this if you have to! */\n    get trim(): boolean { return this._trim; }\n    set trim(value: boolean) { this._trim = value; this.update(); }\n    /**\n     * The baseline of the text that is rendered.\n     * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n     */\n    get textBaseline(): TextStyleTextBaseline { return this._textBaseline; }\n    set textBaseline(value: TextStyleTextBaseline) { this._textBaseline = value; this.update(); }\n    /**\n     * How newlines and spaces should be handled.\n     * Default is 'pre' (preserve, preserve).\n     *\n     *  value       | New lines     |   Spaces\n     *  ---         | ---           |   ---\n     * 'normal'     | Collapse      |   Collapse\n     * 'pre'        | Preserve      |   Preserve\n     * 'pre-line'   | Preserve      |   Collapse\n     * @member {'normal'|'pre'|'pre-line'}\n     */\n    get whiteSpace(): TextStyleWhiteSpace { return this._whiteSpace; }\n    set whiteSpace(value: TextStyleWhiteSpace) { this._whiteSpace = value; this.update(); }\n    /** Indicates if word wrap should be used. */\n    get wordWrap(): boolean { return this._wordWrap; }\n    set wordWrap(value: boolean) { this._wordWrap = value; this.update(); }\n    /** The width at which text will wrap, it needs wordWrap to be set to true. */\n    get wordWrapWidth(): number { return this._wordWrapWidth; }\n    set wordWrapWidth(value: number) { this._wordWrapWidth = value; this.update(); }\n\n    /** A fillstyle that will be used on the text e.g., 'red', '#00FF00'. */\n    get fill(): FillStyleInputs\n    {\n        return this._originalFill;\n    }\n\n    set fill(value: FillStyleInputs)\n    {\n        if (value === this._originalFill) return;\n\n        this._originalFill = value;\n        this._fill = convertFillInputToFillStyle(\n            value === 0x0 ? 'black' : value,\n            GraphicsContext.defaultFillStyle\n        );\n        this.update();\n    }\n\n    /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */\n    get stroke(): FillStyleInputs\n    {\n        return this._originalStroke;\n    }\n\n    set stroke(value: FillStyleInputs)\n    {\n        if (value === this._originalStroke) return;\n\n        this._originalStroke = value;\n        this._stroke = convertFillInputToFillStyle(value, GraphicsContext.defaultStrokeStyle);\n        this.update();\n    }\n\n    protected _generateKey(): string\n    {\n        this._styleKey = generateTextStyleKey(this);\n\n        return this._styleKey;\n    }\n\n    public update()\n    {\n        this._styleKey = null;\n        this.emit('update', this);\n    }\n\n    /** Resets all properties to the default values */\n    public reset()\n    {\n        const defaultStyle = TextStyle.defaultTextStyle;\n\n        for (const key in defaultStyle)\n        {\n            this[key as keyof typeof this] = defaultStyle[key as keyof TextStyleOptions] as any;\n        }\n    }\n\n    get styleKey()\n    {\n        return this._styleKey || this._generateKey();\n    }\n\n    /**\n     * Creates a new TextStyle object with the same values as this one.\n     * @returns New cloned TextStyle object\n     */\n    public clone(): TextStyle\n    {\n        return new TextStyle({\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this.dropShadow,\n            fill: this._fill,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            leading: this.leading,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke,\n            textBaseline: this.textBaseline,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth,\n        });\n    }\n\n    /**\n     * Destroys this text style.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style\n     */\n    public destroy(options: TypeOrBool<TextureDestroyOptions> = false)\n    {\n        this.removeAllListeners();\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            if (this._fill?.texture)\n            {\n                this._fill.texture.destroy(destroyTextureSource);\n            }\n\n            if ((this._originalFill as FillStyle)?.texture)\n            {\n                (this._originalFill as FillStyle).texture.destroy(destroyTextureSource);\n            }\n\n            if (this._stroke?.texture)\n            {\n                this._stroke.texture.destroy(destroyTextureSource);\n            }\n\n            if ((this._originalStroke as FillStyle)?.texture)\n            {\n                (this._originalStroke as FillStyle).texture.destroy(destroyTextureSource);\n            }\n        }\n\n        this._fill = null;\n        this._stroke = null;\n        this.dropShadow = null;\n        this._originalStroke = null;\n        this._originalFill = null;\n    }\n}\n\nfunction convertV7Tov8Style(style: TextStyleOptions)\n{\n    const oldStyle = style as any;\n\n    if (typeof oldStyle.dropShadow === 'boolean' && oldStyle.dropShadow)\n    {\n        const defaults = TextStyle.defaultDropShadow;\n\n        style.dropShadow = {\n            alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,\n            angle: oldStyle.dropShadowAngle ?? defaults.angle,\n            blur: oldStyle.dropShadowBlur ?? defaults.blur,\n            color: oldStyle.dropShadowColor ?? defaults.color,\n            distance:   oldStyle.dropShadowDistance ?? defaults.distance,\n        };\n    }\n\n    if (oldStyle.strokeThickness)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'strokeThickness is now a part of stroke');\n        // #endif\n\n        const color = oldStyle.stroke;\n\n        style.stroke = {\n            color,\n            width: oldStyle.strokeThickness\n        };\n    }\n\n    if (Array.isArray(oldStyle.fill))\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'gradient fill is now a fill pattern: `new FillGradient(...)`');\n        // #endif\n\n        const gradientFill = new FillGradient(0, 0, 0, (style.fontSize as number) * 1.7);\n\n        const fills: number[] = oldStyle.fill.map((color: ColorSource) => Color.shared.setValue(color).toNumber());\n\n        fills.forEach((number, index) =>\n        {\n            const ratio = oldStyle.fillGradientStops[index] ?? index / fills.length;\n\n            gradientFill.addColorStop(ratio, number);\n        });\n\n        style.fill = {\n            fill: gradientFill\n        };\n    }\n}\n","import EventEmitter from 'eventemitter3';\nimport { Color } from '../../../color/Color.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { Point } from '../../../maths/point/Point.mjs';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { uid } from '../../../utils/data/uid.mjs';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\nimport { Bounds } from '../../container/bounds/Bounds.mjs';\nimport { GraphicsPath } from './path/GraphicsPath.mjs';\nimport { SVGParser } from './svg/SVGParser.mjs';\nimport { convertFillInputToFillStyle } from './utils/convertFillInputToFillStyle.mjs';\n\n\"use strict\";\nconst tmpPoint = new Point();\nconst tempMatrix = new Matrix();\nconst _GraphicsContext = class _GraphicsContext extends EventEmitter {\n  constructor() {\n    super(...arguments);\n    this.uid = uid(\"graphicsContext\");\n    this.dirty = true;\n    this.batchMode = \"auto\";\n    this.instructions = [];\n    this._activePath = new GraphicsPath();\n    this._transform = new Matrix();\n    this._fillStyle = { ..._GraphicsContext.defaultFillStyle };\n    this._strokeStyle = { ..._GraphicsContext.defaultStrokeStyle };\n    this._stateStack = [];\n    this._tick = 0;\n    this._bounds = new Bounds();\n    this._boundsDirty = true;\n  }\n  /**\n   * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,\n   * including the current drawing state, transformations, styles, and instructions.\n   * @returns A new GraphicsContext instance with the same properties and state as this one.\n   */\n  clone() {\n    const clone = new _GraphicsContext();\n    clone.batchMode = this.batchMode;\n    clone.instructions = this.instructions.slice();\n    clone._activePath = this._activePath.clone();\n    clone._transform = this._transform.clone();\n    clone._fillStyle = { ...this._fillStyle };\n    clone._strokeStyle = { ...this._strokeStyle };\n    clone._stateStack = this._stateStack.slice();\n    clone._bounds = this._bounds.clone();\n    clone._boundsDirty = true;\n    return clone;\n  }\n  /**\n   * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.\n   */\n  get fillStyle() {\n    return this._fillStyle;\n  }\n  set fillStyle(value) {\n    this._fillStyle = convertFillInputToFillStyle(value, _GraphicsContext.defaultFillStyle);\n  }\n  /**\n   * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   */\n  get strokeStyle() {\n    return this._strokeStyle;\n  }\n  set strokeStyle(value) {\n    this._strokeStyle = convertFillInputToFillStyle(value, _GraphicsContext.defaultStrokeStyle);\n  }\n  /**\n   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n   * pattern, or a more complex style defined by a FillStyle object.\n   * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,\n   *                or a FillStyle or ConvertedFillStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setFillStyle(style) {\n    this._fillStyle = convertFillInputToFillStyle(style, _GraphicsContext.defaultFillStyle);\n    return this;\n  }\n  /**\n   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n   *                or a StrokeStyle or ConvertedStrokeStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setStrokeStyle(style) {\n    this._strokeStyle = convertFillInputToFillStyle(style, _GraphicsContext.defaultStrokeStyle);\n    return this;\n  }\n  texture(texture, tint, dx, dy, dw, dh) {\n    this.instructions.push({\n      action: \"texture\",\n      data: {\n        image: texture,\n        dx: dx || 0,\n        dy: dy || 0,\n        dw: dw || texture.frame.width,\n        dh: dh || texture.frame.height,\n        transform: this._transform.clone(),\n        alpha: this._fillStyle.alpha,\n        style: tint ? Color.shared.setValue(tint).toNumber() : 16777215\n      }\n    });\n    this.onUpdate();\n    return this;\n  }\n  /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  beginPath() {\n    this._activePath = new GraphicsPath();\n    return this;\n  }\n  fill(style, alpha) {\n    let path;\n    const lastInstruction = this.instructions[this.instructions.length - 1];\n    if (this._tick === 0 && lastInstruction && lastInstruction.action === \"stroke\") {\n      path = lastInstruction.data.path;\n    } else {\n      path = this._activePath.clone();\n    }\n    if (!path)\n      return this;\n    if (style != null) {\n      if (alpha !== void 0 && typeof style === \"number\") {\n        deprecation(v8_0_0, \"GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead\");\n        style = { color: style, alpha };\n      }\n      this._fillStyle = convertFillInputToFillStyle(style, _GraphicsContext.defaultFillStyle);\n    }\n    this.instructions.push({\n      action: \"fill\",\n      // TODO copy fill style!\n      data: { style: this.fillStyle, path }\n    });\n    this.onUpdate();\n    this._initNextPathLocation();\n    this._tick = 0;\n    return this;\n  }\n  _initNextPathLocation() {\n    const { x, y } = this._activePath.getLastPoint(Point.shared);\n    this._activePath.clear();\n    this._activePath.moveTo(x, y);\n  }\n  /**\n   * Strokes the current path with the current stroke style. This method can take an optional\n   * FillStyleInputs parameter to define the stroke's appearance, including its color, width, and other properties.\n   * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  stroke(style) {\n    let path;\n    const lastInstruction = this.instructions[this.instructions.length - 1];\n    if (this._tick === 0 && lastInstruction && lastInstruction.action === \"fill\") {\n      path = lastInstruction.data.path;\n    } else {\n      path = this._activePath.clone();\n    }\n    if (!path)\n      return this;\n    if (style != null) {\n      this._strokeStyle = convertFillInputToFillStyle(style, _GraphicsContext.defaultStrokeStyle);\n    }\n    this.instructions.push({\n      action: \"stroke\",\n      // TODO copy fill style!\n      data: { style: this.strokeStyle, path }\n    });\n    this.onUpdate();\n    this._initNextPathLocation();\n    this._tick = 0;\n    return this;\n  }\n  /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n   * fail to cut correctly!\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  cut() {\n    for (let i = 0; i < 2; i++) {\n      const lastInstruction = this.instructions[this.instructions.length - 1 - i];\n      const holePath = this._activePath.clone();\n      if (lastInstruction) {\n        if (lastInstruction.action === \"stroke\" || lastInstruction.action === \"fill\") {\n          if (lastInstruction.data.hole) {\n            lastInstruction.data.hole.addPath(holePath);\n          } else {\n            lastInstruction.data.hole = holePath;\n            break;\n          }\n        }\n      }\n    }\n    this._initNextPathLocation();\n    return this;\n  }\n  /**\n   * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n   * starting and ending angles, and direction.\n   * @param x - The x-coordinate of the arc's center.\n   * @param y - The y-coordinate of the arc's center.\n   * @param radius - The arc's radius.\n   * @param startAngle - The starting angle, in radians.\n   * @param endAngle - The ending angle, in radians.\n   * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arc(\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      radius,\n      startAngle,\n      endAngle,\n      counterclockwise\n    );\n    return this;\n  }\n  /**\n   * Adds an arc to the current path with the given control points and radius, connected to the previous point\n   * by a straight line if necessary.\n   * @param x1 - The x-coordinate of the first control point.\n   * @param y1 - The y-coordinate of the first control point.\n   * @param x2 - The x-coordinate of the second control point.\n   * @param y2 - The y-coordinate of the second control point.\n   * @param radius - The arc's radius.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  arcTo(x1, y1, x2, y2, radius) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arcTo(\n      t.a * x1 + t.c * y1 + t.tx,\n      t.b * x1 + t.d * y1 + t.ty,\n      t.a * x2 + t.c * y2 + t.tx,\n      t.b * x2 + t.d * y2 + t.ty,\n      radius\n    );\n    return this;\n  }\n  /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc's end point.\n   * @param y - The y-coordinate of the arc's end point.\n   * @returns The instance of the current object for chaining.\n   */\n  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arcToSvg(\n      rx,\n      ry,\n      xAxisRotation,\n      // should we rotate this with transform??\n      largeArcFlag,\n      sweepFlag,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty\n    );\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.bezierCurveTo(\n      t.a * cp1x + t.c * cp1y + t.tx,\n      t.b * cp1x + t.d * cp1y + t.ty,\n      t.a * cp2x + t.c * cp2y + t.tx,\n      t.b * cp2x + t.d * cp2y + t.ty,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this._tick++;\n    this._activePath?.closePath();\n    return this;\n  }\n  /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @returns The instance of the current object for chaining.\n   */\n  ellipse(x, y, radiusX, radiusY) {\n    this._tick++;\n    this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius) {\n    this._tick++;\n    this._activePath.circle(x, y, radius, this._transform.clone());\n    return this;\n  }\n  /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @returns The instance of the current object for chaining.\n   */\n  path(path) {\n    this._tick++;\n    this._activePath.addPath(path, this._transform.clone());\n    return this;\n  }\n  /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */\n  lineTo(x, y) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.lineTo(\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty\n    );\n    return this;\n  }\n  /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */\n  moveTo(x, y) {\n    this._tick++;\n    const t = this._transform;\n    const instructions = this._activePath.instructions;\n    const transformedX = t.a * x + t.c * y + t.tx;\n    const transformedY = t.b * x + t.d * y + t.ty;\n    if (instructions.length === 1 && instructions[0].action === \"moveTo\") {\n      instructions[0].data[0] = transformedX;\n      instructions[0].data[1] = transformedY;\n      return this;\n    }\n    this._activePath.moveTo(\n      transformedX,\n      transformedY\n    );\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cpx - The x-coordinate of the control point.\n   * @param cpy - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveTo(cpx, cpy, x, y, smoothness) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.quadraticCurveTo(\n      t.a * cpx + t.c * cpy + t.tx,\n      t.b * cpx + t.d * cpy + t.ty,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h) {\n    this._tick++;\n    this._activePath.rect(x, y, w, h, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n   * @returns The instance of the current object for chaining.\n   */\n  roundRect(x, y, w, h, radius) {\n    this._tick++;\n    this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n   * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n   * rotated, or translated as needed.\n   * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates, of the polygon's vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   */\n  poly(points, close) {\n    this._tick++;\n    this._activePath.poly(points, close, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  regularPoly(x, y, radius, sides, rotation = 0, transform) {\n    this._tick++;\n    this._activePath.regularPoly(x, y, radius, sides, rotation, transform);\n    return this;\n  }\n  /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @returns The instance of the current object for chaining.\n   */\n  roundPoly(x, y, radius, sides, corner, rotation) {\n    this._tick++;\n    this._activePath.roundPoly(x, y, radius, sides, corner, rotation);\n    return this;\n  }\n  /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */\n  roundShape(points, radius, useQuadratic, smoothness) {\n    this._tick++;\n    this._activePath.roundShape(points, radius, useQuadratic, smoothness);\n    return this;\n  }\n  /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */\n  filletRect(x, y, width, height, fillet) {\n    this._tick++;\n    this._activePath.filletRect(x, y, width, height, fillet);\n    return this;\n  }\n  /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */\n  chamferRect(x, y, width, height, chamfer, transform) {\n    this._tick++;\n    this._activePath.chamferRect(x, y, width, height, chamfer, transform);\n    return this;\n  }\n  /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */\n  star(x, y, points, radius, innerRadius = 0, rotation = 0) {\n    this._tick++;\n    this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());\n    return this;\n  }\n  /**\n   * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n   * defined in SVG format to be drawn within the graphics context.\n   * @param svg - The SVG string to be parsed and rendered.\n   */\n  svg(svg) {\n    this._tick++;\n    SVGParser(svg, this);\n    return this;\n  }\n  /**\n   * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n   * This includes transformations, fill styles, and stroke styles.\n   */\n  restore() {\n    const state = this._stateStack.pop();\n    if (state) {\n      this._transform = state.transform;\n      this._fillStyle = state.fillStyle;\n      this._strokeStyle = state.strokeStyle;\n    }\n    return this;\n  }\n  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n  save() {\n    this._stateStack.push({\n      transform: this._transform.clone(),\n      fillStyle: { ...this._fillStyle },\n      strokeStyle: { ...this._strokeStyle }\n    });\n    return this;\n  }\n  /**\n   * Returns the current transformation matrix of the graphics context.\n   * @returns The current transformation matrix.\n   */\n  getTransform() {\n    return this._transform;\n  }\n  /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  resetTransform() {\n    this._transform.identity();\n    return this;\n  }\n  /**\n   * Applies a rotation transformation to the graphics context around the current origin.\n   * @param angle - The angle of rotation in radians.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  rotate(angle) {\n    this._transform.rotate(angle);\n    return this;\n  }\n  /**\n   * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n   * @param x - The scale factor in the horizontal direction.\n   * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  scale(x, y = x) {\n    this._transform.scale(x, y);\n    return this;\n  }\n  setTransform(a, b, c, d, dx, dy) {\n    if (a instanceof Matrix) {\n      this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);\n      return this;\n    }\n    this._transform.set(a, b, c, d, dx, dy);\n    return this;\n  }\n  transform(a, b, c, d, dx, dy) {\n    if (a instanceof Matrix) {\n      this._transform.append(a);\n      return this;\n    }\n    tempMatrix.set(a, b, c, d, dx, dy);\n    this._transform.append(tempMatrix);\n    return this;\n  }\n  /**\n   * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n   * @param x - The amount to translate in the horizontal direction.\n   * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  translate(x, y = x) {\n    this._transform.translate(x, y);\n    return this;\n  }\n  /**\n   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n   * and optionally resetting transformations to the identity matrix.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  clear() {\n    this.instructions.length = 0;\n    this.resetTransform();\n    this.onUpdate();\n    return this;\n  }\n  onUpdate() {\n    if (this.dirty)\n      return;\n    this.emit(\"update\", this, 16);\n    this.dirty = true;\n    this._boundsDirty = true;\n  }\n  /** The bounds of the graphic shape. */\n  get bounds() {\n    if (!this._boundsDirty)\n      return this._bounds;\n    const bounds = this._bounds;\n    bounds.clear();\n    for (let i = 0; i < this.instructions.length; i++) {\n      const instruction = this.instructions[i];\n      const action = instruction.action;\n      if (action === \"fill\") {\n        const data = instruction.data;\n        bounds.addBounds(data.path.bounds);\n      } else if (action === \"texture\") {\n        const data = instruction.data;\n        bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);\n      }\n      if (action === \"stroke\") {\n        const data = instruction.data;\n        const padding = data.style.width / 2;\n        const _bounds = data.path.bounds;\n        bounds.addFrame(\n          _bounds.minX - padding,\n          _bounds.minY - padding,\n          _bounds.maxX + padding,\n          _bounds.maxY + padding\n        );\n      }\n    }\n    return bounds;\n  }\n  /**\n   * Check to see if a point is contained within this geometry.\n   * @param point - Point to check if it's contained.\n   * @returns {boolean} `true` if the point is contained within geometry.\n   */\n  containsPoint(point) {\n    if (!this.bounds.containsPoint(point.x, point.y))\n      return false;\n    const instructions = this.instructions;\n    let hasHit = false;\n    for (let k = 0; k < instructions.length; k++) {\n      const instruction = instructions[k];\n      const data = instruction.data;\n      const path = data.path;\n      if (!instruction.action || !path)\n        continue;\n      const style = data.style;\n      const shapes = path.shapePath.shapePrimitives;\n      for (let i = 0; i < shapes.length; i++) {\n        const shape = shapes[i].shape;\n        if (!style || !shape)\n          continue;\n        const transform = shapes[i].transform;\n        const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;\n        if (instruction.action === \"fill\") {\n          hasHit = shape.contains(transformedPoint.x, transformedPoint.y);\n        } else {\n          hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, style.width);\n        }\n        const holes = data.hole;\n        if (holes) {\n          const holeShapes = holes.shapePath?.shapePrimitives;\n          if (holeShapes) {\n            for (let j = 0; j < holeShapes.length; j++) {\n              if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y)) {\n                hasHit = false;\n              }\n            }\n          }\n        }\n        if (hasHit) {\n          return true;\n        }\n      }\n    }\n    return hasHit;\n  }\n  /**\n   * Destroys the GraphicsData object.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?\n   * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?\n   */\n  destroy(options = false) {\n    this._stateStack.length = 0;\n    this._transform = null;\n    this.emit(\"destroy\", this);\n    this.removeAllListeners();\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      if (this._fillStyle.texture) {\n        this._fillStyle.texture.destroy(destroyTextureSource);\n      }\n      if (this._strokeStyle.texture) {\n        this._strokeStyle.texture.destroy(destroyTextureSource);\n      }\n    }\n    this._fillStyle = null;\n    this._strokeStyle = null;\n    this.instructions = null;\n    this._activePath = null;\n    this._bounds = null;\n    this._stateStack = null;\n    this.customShader = null;\n    this._transform = null;\n  }\n};\n/** The default fill style to use when none is provided. */\n_GraphicsContext.defaultFillStyle = {\n  /** The color to use for the fill. */\n  color: 16777215,\n  /** The alpha value to use for the fill. */\n  alpha: 1,\n  /** The texture to use for the fill. */\n  texture: Texture.WHITE,\n  /** The matrix to apply. */\n  matrix: null,\n  /** The fill pattern to use. */\n  fill: null\n};\n/** The default stroke style to use when none is provided. */\n_GraphicsContext.defaultStrokeStyle = {\n  /** The width of the stroke. */\n  width: 1,\n  /** The color to use for the stroke. */\n  color: 16777215,\n  /** The alpha value to use for the stroke. */\n  alpha: 1,\n  /** The alignment of the stroke. */\n  alignment: 0.5,\n  /** The miter limit to use. */\n  miterLimit: 10,\n  /** The line cap style to use. */\n  cap: \"butt\",\n  /** The line join style to use. */\n  join: \"miter\",\n  /** The texture to use for the fill. */\n  texture: Texture.WHITE,\n  /** The matrix to apply. */\n  matrix: null,\n  /** The fill pattern to use. */\n  fill: null\n};\nlet GraphicsContext = _GraphicsContext;\n\nexport { GraphicsContext };\n//# sourceMappingURL=GraphicsContext.mjs.map\n","/* eslint-disable max-len */\nimport EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../../color/Color';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { Point } from '../../../maths/point/Point';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { uid } from '../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { Bounds } from '../../container/bounds/Bounds';\nimport { GraphicsPath } from './path/GraphicsPath';\nimport { SVGParser } from './svg/SVGParser';\nimport { convertFillInputToFillStyle } from './utils/convertFillInputToFillStyle';\n\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { TextureDestroyOptions, TypeOrBool } from '../../container/destroyTypes';\nimport type { LineCap, LineJoin } from './const';\nimport type { FillGradient } from './fill/FillGradient';\nimport type { FillPattern } from './fill/FillPattern';\nimport type { RoundedPoint } from './path/roundShape';\n\n/**\n * A fill style object.\n * @memberof scene\n */\nexport interface FillStyle\n{\n    /** The color to use for the fill. */\n    color?: ColorSource;\n    /** The alpha value to use for the fill. */\n    alpha?: number;\n    /** The texture to use for the fill. */\n    texture?: Texture | null;\n    /** The matrix to apply. */\n    matrix?: Matrix | null;\n    /** The fill pattern to use. */\n    fill?: FillPattern | FillGradient | null;\n}\n\nexport type ConvertedFillStyle = Omit<Required<FillStyle>, 'color'> & { color: number };\n\nexport interface PatternFillStyle\n{\n    fill?: FillPattern | FillGradient;\n    color?: number;\n    alpha?: number;\n}\n\n/**\n * A stroke style object.\n * @memberof scene\n */\nexport interface StrokeStyle extends FillStyle\n{\n    /** The width of the stroke. */\n    width?: number;\n    /** The alignment of the stroke. */\n    alignment?: number;\n    // native?: boolean;\n    /** The line cap style to use. */\n    cap?: LineCap;\n    /** The line join style to use. */\n    join?: LineJoin;\n    /** The miter limit to use. */\n    miterLimit?: number;\n}\n\nexport type ConvertedStrokeStyle = Omit<StrokeStyle, 'color'> & ConvertedFillStyle;\n\nconst tmpPoint = new Point();\n\nexport type BatchMode = 'auto' | 'batch' | 'no-batch';\n\nexport type FillStyleInputs = ColorSource | FillGradient | CanvasPattern | PatternFillStyle | FillStyle | ConvertedFillStyle | StrokeStyle | ConvertedStrokeStyle;\n\nexport interface FillInstruction\n{\n    action: 'fill' | 'cut'\n    data: { style: ConvertedFillStyle, path: GraphicsPath, hole?: GraphicsPath }\n}\n\nexport interface StrokeInstruction\n{\n    action: 'stroke'\n    data: { style: ConvertedStrokeStyle, path: GraphicsPath, hole?: GraphicsPath }\n}\n\nexport interface TextureInstruction\n{\n    action: 'texture'\n    data: {\n        image: Texture,\n\n        dx: number\n        dy: number\n\n        dw: number\n        dh: number\n\n        transform: Matrix\n        alpha: number\n        style: number,\n    }\n}\n\nexport type GraphicsInstructions = FillInstruction | StrokeInstruction | TextureInstruction;\n\nconst tempMatrix = new Matrix();\n\n/**\n * The GraphicsContext class allows for the creation of lightweight objects that contain instructions for drawing shapes and paths.\n * It is used internally by the Graphics class to draw shapes and paths, and can be used directly and shared between Graphics objects,\n *\n * This sharing of a `GraphicsContext` means that the intensive task of converting graphics instructions into GPU-ready geometry is done once, and the results are reused,\n * much like sprites reusing textures.\n * @memberof scene\n */\nexport class GraphicsContext extends EventEmitter<{\n    update: GraphicsContext\n    destroy: GraphicsContext\n}>\n{\n    /** The default fill style to use when none is provided. */\n    public static defaultFillStyle: ConvertedFillStyle = {\n        /** The color to use for the fill. */\n        color: 0xffffff,\n        /** The alpha value to use for the fill. */\n        alpha: 1,\n        /** The texture to use for the fill. */\n        texture: Texture.WHITE,\n        /** The matrix to apply. */\n        matrix: null,\n        /** The fill pattern to use. */\n        fill: null,\n    };\n\n    /** The default stroke style to use when none is provided. */\n    public static defaultStrokeStyle: ConvertedStrokeStyle = {\n        /** The width of the stroke. */\n        width: 1,\n        /** The color to use for the stroke. */\n        color: 0xffffff,\n        /** The alpha value to use for the stroke. */\n        alpha: 1,\n        /** The alignment of the stroke. */\n        alignment: 0.5,\n        /** The miter limit to use. */\n        miterLimit: 10,\n        /** The line cap style to use. */\n        cap: 'butt',\n        /** The line join style to use. */\n        join: 'miter',\n        /** The texture to use for the fill. */\n        texture: Texture.WHITE,\n        /** The matrix to apply. */\n        matrix: null,\n        /** The fill pattern to use. */\n        fill: null,\n    };\n\n    public uid = uid('graphicsContext');\n    public dirty = true;\n    public batchMode: BatchMode = 'auto';\n    public instructions: GraphicsInstructions[] = [];\n    public customShader?: Shader;\n\n    private _activePath: GraphicsPath = new GraphicsPath();\n    private _transform: Matrix = new Matrix();\n\n    private _fillStyle: ConvertedFillStyle = { ...GraphicsContext.defaultFillStyle };\n    private _strokeStyle: ConvertedStrokeStyle = { ...GraphicsContext.defaultStrokeStyle };\n    private _stateStack: { fillStyle: ConvertedFillStyle; strokeStyle: ConvertedStrokeStyle, transform: Matrix }[] = [];\n\n    private _tick = 0;\n\n    private _bounds = new Bounds();\n    private _boundsDirty = true;\n\n    /**\n     * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,\n     * including the current drawing state, transformations, styles, and instructions.\n     * @returns A new GraphicsContext instance with the same properties and state as this one.\n     */\n    public clone(): GraphicsContext\n    {\n        const clone = new GraphicsContext();\n\n        clone.batchMode = this.batchMode;\n        clone.instructions = this.instructions.slice();\n        clone._activePath = this._activePath.clone();\n        clone._transform = this._transform.clone();\n        clone._fillStyle = { ...this._fillStyle };\n        clone._strokeStyle = { ...this._strokeStyle };\n        clone._stateStack = this._stateStack.slice();\n        clone._bounds = this._bounds.clone();\n        clone._boundsDirty = true;\n\n        return clone;\n    }\n\n    /**\n     * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.\n     */\n    get fillStyle(): ConvertedFillStyle\n    {\n        return this._fillStyle;\n    }\n\n    set fillStyle(value: FillStyleInputs)\n    {\n        this._fillStyle = convertFillInputToFillStyle(value, GraphicsContext.defaultFillStyle);\n    }\n\n    /**\n     * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     */\n    get strokeStyle(): ConvertedStrokeStyle\n    {\n        return this._strokeStyle;\n    }\n\n    set strokeStyle(value: FillStyleInputs)\n    {\n        this._strokeStyle = convertFillInputToFillStyle(value, GraphicsContext.defaultStrokeStyle) as ConvertedStrokeStyle;\n    }\n\n    /**\n     * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n     * pattern, or a more complex style defined by a FillStyle object.\n     * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,\n     *                or a FillStyle or ConvertedFillStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setFillStyle(style: FillStyleInputs): this\n    {\n        this._fillStyle = convertFillInputToFillStyle(style, GraphicsContext.defaultFillStyle);\n\n        return this;\n    }\n\n    /**\n     * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n     * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n     *                or a StrokeStyle or ConvertedStrokeStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setStrokeStyle(style: FillStyleInputs): this\n    {\n        this._strokeStyle = convertFillInputToFillStyle(style, GraphicsContext.defaultStrokeStyle) as ConvertedStrokeStyle;\n\n        return this;\n    }\n\n    /**\n     * Adds a texture to the graphics context. This method supports multiple overloads for specifying the texture, tint, and dimensions.\n     * If only a texture is provided, it uses the texture's width and height for drawing. Additional parameters allow for specifying\n     * a tint color, and custom dimensions for the texture drawing area.\n     * @param texture - The Texture object to use.\n     * @param tint - (Optional) A ColorSource to tint the texture. If not provided, defaults to white (0xFFFFFF).\n     * @param dx - (Optional) The x-coordinate in the destination canvas at which to place the top-left corner of the source image.\n     * @param dy - (Optional) The y-coordinate in the destination canvas at which to place the top-left corner of the source image.\n     * @param dw - (Optional) The width of the rectangle within the source image to draw onto the destination canvas. If not provided, uses the texture's frame width.\n     * @param dh - (Optional) The height of the rectangle within the source image to draw onto the destination canvas. If not provided, uses the texture's frame height.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public texture(texture: Texture): this;\n    public texture(texture: Texture, tint: ColorSource): this;\n    public texture(texture: Texture, tint: ColorSource, dx: number, dy: number): this;\n    public texture(texture: Texture, tint: ColorSource, dx: number, dy: number, dw: number, dh: number): this;\n    public texture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this\n    {\n        this.instructions.push({\n            action: 'texture',\n            data: {\n                image: texture,\n\n                dx: dx || 0,\n                dy: dy || 0,\n\n                dw: dw || texture.frame.width,\n                dh: dh || texture.frame.height,\n\n                transform: this._transform.clone(),\n                alpha: this._fillStyle.alpha,\n                style: tint ? Color.shared.setValue(tint).toNumber() : 0xFFFFFF,\n            }\n        });\n\n        this.onUpdate();\n\n        return this;\n    }\n\n    /**\n     * Resets the current path. Any previous path and its commands are discarded and a new path is\n     * started. This is typically called before beginning a new shape or series of drawing commands.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public beginPath(): this\n    {\n        this._activePath = new GraphicsPath();\n\n        return this;\n    }\n\n    /**\n     * Fills the current or given path with the current fill style. This method can optionally take\n     * a color and alpha for a simple fill, or a more complex FillStyleInputs object for advanced fills.\n     * @param style - (Optional) The style to fill the path with. Can be a color, gradient, pattern, or a complex style object. If omitted, uses the current fill style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public fill(style?: FillStyleInputs): this;\n    /** @deprecated 8.0.0 */\n    public fill(color: ColorSource, alpha: number): this;\n    public fill(style?: FillStyleInputs, alpha?: number): this\n    {\n        let path: GraphicsPath;\n\n        const lastInstruction = this.instructions[this.instructions.length - 1];\n\n        if (this._tick === 0 && lastInstruction && lastInstruction.action === 'stroke')\n        {\n            path = lastInstruction.data.path;\n        }\n        else\n        {\n            path = this._activePath.clone();\n        }\n\n        if (!path) return this;\n\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (style != null)\n        {\n            if (alpha !== undefined && typeof style === 'number')\n            {\n                // #if _DEBUG\n                deprecation(v8_0_0, 'GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead');\n                // #endif\n\n                style = { color: style, alpha };\n            }\n            this._fillStyle = convertFillInputToFillStyle(style, GraphicsContext.defaultFillStyle);\n        }\n\n        // TODO not a fan of the clone!!\n        this.instructions.push({\n            action: 'fill',\n            // TODO copy fill style!\n            data: { style: this.fillStyle, path }\n        });\n\n        this.onUpdate();\n\n        this._initNextPathLocation();\n        this._tick = 0;\n\n        return this;\n    }\n\n    private _initNextPathLocation()\n    {\n        // Reset the _activePath with the last point of the current path\n        const { x, y } = this._activePath.getLastPoint(Point.shared);\n\n        this._activePath.clear();\n        this._activePath.moveTo(x, y);\n    }\n\n    /**\n     * Strokes the current path with the current stroke style. This method can take an optional\n     * FillStyleInputs parameter to define the stroke's appearance, including its color, width, and other properties.\n     * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public stroke(style?: FillStyleInputs): this\n    {\n        let path: GraphicsPath;\n\n        const lastInstruction = this.instructions[this.instructions.length - 1];\n\n        if (this._tick === 0 && lastInstruction && lastInstruction.action === 'fill')\n        {\n            path = lastInstruction.data.path;\n        }\n        else\n        {\n            path = this._activePath.clone();\n        }\n\n        if (!path) return this;\n\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (style != null)\n        {\n            this._strokeStyle = convertFillInputToFillStyle(style, GraphicsContext.defaultStrokeStyle);\n        }\n\n        // TODO not a fan of the clone!!\n        this.instructions.push({\n            action: 'stroke',\n            // TODO copy fill style!\n            data: { style: this.strokeStyle, path }\n        });\n\n        this.onUpdate();\n\n        this._initNextPathLocation();\n        this._tick = 0;\n\n        return this;\n    }\n\n    /**\n     * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n     * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n     * fail to cut correctly!\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public cut(): this\n    {\n        for (let i = 0; i < 2; i++)\n        {\n            const lastInstruction = this.instructions[this.instructions.length - 1 - i];\n\n            const holePath = this._activePath.clone();\n\n            if (lastInstruction)\n            {\n                if (lastInstruction.action === 'stroke' || lastInstruction.action === 'fill')\n                {\n                    if (lastInstruction.data.hole)\n                    {\n                        lastInstruction.data.hole.addPath(holePath);\n                    }\n                    else\n                    {\n                        lastInstruction.data.hole = holePath;\n                        break;\n                    }\n                }\n            }\n        }\n\n        this._initNextPathLocation();\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n     * starting and ending angles, and direction.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The arc's radius.\n     * @param startAngle - The starting angle, in radians.\n     * @param endAngle - The ending angle, in radians.\n     * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arc(\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            radius,\n            startAngle,\n            endAngle,\n            counterclockwise,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the current path with the given control points and radius, connected to the previous point\n     * by a straight line if necessary.\n     * @param x1 - The x-coordinate of the first control point.\n     * @param y1 - The y-coordinate of the first control point.\n     * @param x2 - The x-coordinate of the second control point.\n     * @param y2 - The y-coordinate of the second control point.\n     * @param radius - The arc's radius.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arcTo(\n            (t.a * x1) + (t.c * y1) + t.tx,\n            (t.b * x1) + (t.d * y1) + t.ty,\n            (t.a * x2) + (t.c * y2) + t.tx,\n            (t.b * x2) + (t.d * y2) + t.ty,\n            radius,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number,\n        xAxisRotation: number,\n        largeArcFlag: number,\n        sweepFlag: number,\n        x: number, y: number\n    ): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arcToSvg(\n            rx, ry,\n            xAxisRotation, // should we rotate this with transform??\n            largeArcFlag,\n            sweepFlag,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this\n    {\n        this._tick++;\n\n        // TODO optimize for no transform\n        const t = this._transform;\n\n        this._activePath.bezierCurveTo(\n            (t.a * cp1x) + (t.c * cp1y) + t.tx,\n            (t.b * cp1x) + (t.d * cp1y) + t.ty,\n            (t.a * cp2x) + (t.c * cp2y) + t.tx,\n            (t.b * cp2x) + (t.d * cp2y) + t.ty,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this._tick++;\n\n        this._activePath?.closePath();\n\n        return this;\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number): this\n    {\n        this._tick++;\n\n        this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number): this\n    {\n        this._tick++;\n\n        this._activePath.circle(x, y, radius, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @returns The instance of the current object for chaining.\n     */\n    public path(path: GraphicsPath): this\n    {\n        this._tick++;\n\n        this._activePath.addPath(path, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.lineTo(\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty\n        );\n\n        return this;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        const instructions = this._activePath.instructions;\n\n        const transformedX = (t.a * x) + (t.c * y) + t.tx;\n        const transformedY = (t.b * x) + (t.d * y) + t.ty;\n\n        if (instructions.length === 1 && instructions[0].action === 'moveTo')\n        {\n            instructions[0].data[0] = transformedX;\n            instructions[0].data[1] = transformedY;\n\n            return this;\n        }\n        this._activePath.moveTo(\n            transformedX,\n            transformedY\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cpx - The x-coordinate of the control point.\n     * @param cpy - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.quadraticCurveTo(\n            (t.a * cpx) + (t.c * cpy) + t.tx,\n            (t.b * cpx) + (t.d * cpy) + t.ty,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number): this\n    {\n        this._tick++;\n\n        this._activePath.rect(x, y, w, h, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number): this\n    {\n        this._tick++;\n\n        this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates, of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     */\n    public poly(points: number[] | PointData[], close?: boolean): this\n    {\n        this._tick++;\n\n        this._activePath.poly(points, close, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation = 0, transform?: Matrix): this\n    {\n        this._tick++;\n        this._activePath.regularPoly(x, y, radius, sides, rotation, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this\n    {\n        this._tick++;\n        this._activePath.roundPoly(x, y, radius, sides, corner, rotation);\n\n        return this;\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this\n    {\n        this._tick++;\n        this._activePath.roundShape(points, radius, useQuadratic, smoothness);\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this\n    {\n        this._tick++;\n        this._activePath.filletRect(x, y, width, height, fillet);\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this\n    {\n        this._tick++;\n        this._activePath.chamferRect(x, y, width, height, chamfer, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public star(x: number, y: number, points: number, radius: number, innerRadius = 0, rotation = 0): this\n    {\n        this._tick++;\n\n        this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n     * defined in SVG format to be drawn within the graphics context.\n     * @param svg - The SVG string to be parsed and rendered.\n     */\n    public svg(svg: string): this\n    {\n        this._tick++;\n\n        SVGParser(svg, this);\n\n        return this;\n    }\n\n    /**\n     * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n     * This includes transformations, fill styles, and stroke styles.\n     */\n    public restore(): this\n    {\n        const state = this._stateStack.pop();\n\n        if (state)\n        {\n            this._transform = state.transform;\n            this._fillStyle = state.fillStyle;\n            this._strokeStyle = state.strokeStyle;\n        }\n\n        return this;\n    }\n\n    /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n    public save(): this\n    {\n        this._stateStack.push({\n            transform: this._transform.clone(),\n            fillStyle: { ...this._fillStyle },\n            strokeStyle: { ...this._strokeStyle },\n        });\n\n        return this;\n    }\n\n    /**\n     * Returns the current transformation matrix of the graphics context.\n     * @returns The current transformation matrix.\n     */\n    public getTransform(): Matrix\n    {\n        return this._transform;\n    }\n\n    /**\n     * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public resetTransform(): this\n    {\n        this._transform.identity();\n\n        return this;\n    }\n\n    /**\n     * Applies a rotation transformation to the graphics context around the current origin.\n     * @param angle - The angle of rotation in radians.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public rotate(angle: number): this\n    {\n        this._transform.rotate(angle);\n\n        return this;\n    }\n\n    /**\n     * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n     * @param x - The scale factor in the horizontal direction.\n     * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public scale(x: number, y: number = x): this\n    {\n        this._transform.scale(x, y);\n\n        return this;\n    }\n\n    /**\n     * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n     * This replaces the current transformation matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(transform: Matrix): this;\n    public setTransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public setTransform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this\n    {\n        if (a instanceof Matrix)\n        {\n            this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);\n\n            return this;\n        }\n\n        this._transform.set(a, b, c, d, dx, dy);\n\n        return this;\n    }\n\n    /**\n     * Applies the specified transformation matrix to the current graphics context by multiplying the current matrix with the specified matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(transform: Matrix): this;\n    public transform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public transform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this\n    {\n        if (a instanceof Matrix)\n        {\n            this._transform.append(a);\n\n            return this;\n        }\n\n        tempMatrix.set(a, b, c, d, dx, dy);\n        this._transform.append(tempMatrix);\n\n        return this;\n    }\n\n    /**\n     * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n     * @param x - The amount to translate in the horizontal direction.\n     * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public translate(x: number, y: number = x): this\n    {\n        this._transform.translate(x, y);\n\n        return this;\n    }\n\n    /**\n     * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n     * and optionally resetting transformations to the identity matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public clear(): this\n    {\n        this.instructions.length = 0;\n        this.resetTransform();\n\n        this.onUpdate();\n\n        return this;\n    }\n\n    protected onUpdate(): void\n    {\n        if (this.dirty) return;\n\n        this.emit('update', this, 0x10);\n        this.dirty = true;\n        this._boundsDirty = true;\n    }\n\n    /** The bounds of the graphic shape. */\n    get bounds(): Bounds\n    {\n        if (!this._boundsDirty) return this._bounds;\n\n        // TODO switch to idy dirty with tick..\n        const bounds = this._bounds;\n\n        bounds.clear();\n\n        for (let i = 0; i < this.instructions.length; i++)\n        {\n            const instruction = this.instructions[i];\n            const action = instruction.action;\n\n            if (action === 'fill')\n            {\n                const data = instruction.data as FillInstruction['data'];\n\n                bounds.addBounds(data.path.bounds);\n            }\n            else if (action === 'texture')\n            {\n                const data = instruction.data as TextureInstruction['data'];\n\n                bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);\n            }\n            if (action === 'stroke')\n            {\n                const data = instruction.data as StrokeInstruction['data'];\n\n                const padding = data.style.width / 2;\n\n                const _bounds = data.path.bounds;\n\n                bounds.addFrame(\n                    _bounds.minX - padding,\n                    _bounds.minY - padding,\n                    _bounds.maxX + padding,\n                    _bounds.maxY + padding\n                );\n            }\n        }\n\n        return bounds;\n    }\n\n    /**\n     * Check to see if a point is contained within this geometry.\n     * @param point - Point to check if it's contained.\n     * @returns {boolean} `true` if the point is contained within geometry.\n     */\n    public containsPoint(point: PointData): boolean\n    {\n        // early out if the bounding box is not hit\n        if (!this.bounds.containsPoint(point.x, point.y)) return false;\n\n        const instructions = this.instructions;\n        let hasHit = false;\n\n        for (let k = 0; k < instructions.length; k++)\n        {\n            const instruction = instructions[k];\n\n            const data = instruction.data as FillInstruction['data'];\n            const path = data.path;\n\n            if (!instruction.action || !path) continue;\n\n            const style = data.style;\n            const shapes = path.shapePath.shapePrimitives;\n\n            for (let i = 0; i < shapes.length; i++)\n            {\n                const shape = shapes[i].shape;\n\n                if (!style || !shape) continue;\n\n                const transform = shapes[i].transform;\n\n                const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;\n\n                if (instruction.action === 'fill')\n                {\n                    hasHit = shape.contains(transformedPoint.x, transformedPoint.y);\n                }\n                else\n                {\n                    hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, (style as ConvertedStrokeStyle).width);\n                }\n\n                const holes = data.hole;\n\n                if (holes)\n                {\n                    const holeShapes = holes.shapePath?.shapePrimitives;\n\n                    if (holeShapes)\n                    {\n                        for (let j = 0; j < holeShapes.length; j++)\n                        {\n                            if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y))\n                            {\n                                hasHit = false;\n                            }\n                        }\n                    }\n                }\n\n                if (hasHit)\n                {\n                    return true;\n                }\n            }\n        }\n\n        return hasHit;\n    }\n\n    /**\n     * Destroys the GraphicsData object.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?\n     * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?\n     */\n    public destroy(options: TypeOrBool<TextureDestroyOptions> = false): void\n    {\n        this._stateStack.length = 0;\n        this._transform = null;\n\n        this.emit('destroy', this);\n        this.removeAllListeners();\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            if (this._fillStyle.texture)\n            {\n                this._fillStyle.texture.destroy(destroyTextureSource);\n            }\n\n            if (this._strokeStyle.texture)\n            {\n                this._strokeStyle.texture.destroy(destroyTextureSource);\n            }\n        }\n\n        this._fillStyle = null;\n        this._strokeStyle = null;\n\n        this.instructions = null;\n        this._activePath = null;\n        this._bounds = null;\n        this._stateStack = null;\n        this.customShader = null;\n        this._transform = null;\n    }\n}\n","import { Point } from '../../../../maths/point/Point.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\nimport { SVGToGraphicsPath } from '../svg/SVGToGraphicsPath.mjs';\nimport { ShapePath } from './ShapePath.mjs';\n\n\"use strict\";\nclass GraphicsPath {\n  /**\n   * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n   * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n   */\n  constructor(instructions) {\n    this.instructions = [];\n    this.uid = uid(\"graphicsPath\");\n    this._dirty = true;\n    if (typeof instructions === \"string\") {\n      SVGToGraphicsPath(instructions, this);\n    } else {\n      this.instructions = instructions?.slice() ?? [];\n    }\n  }\n  /**\n   * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n   * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n   */\n  get shapePath() {\n    if (!this._shapePath) {\n      this._shapePath = new ShapePath(this);\n    }\n    if (this._dirty) {\n      this._dirty = false;\n      this._shapePath.buildPath();\n    }\n    return this._shapePath;\n  }\n  /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @param transform - An optional transformation to apply to the added path.\n   * @returns The instance of the current object for chaining.\n   */\n  addPath(path, transform) {\n    path = path.clone();\n    this.instructions.push({ action: \"addPath\", data: [path, transform] });\n    this._dirty = true;\n    return this;\n  }\n  arc(...args) {\n    this.instructions.push({ action: \"arc\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  arcTo(...args) {\n    this.instructions.push({ action: \"arcTo\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  arcToSvg(...args) {\n    this.instructions.push({ action: \"arcToSvg\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  bezierCurveTo(...args) {\n    this.instructions.push({ action: \"bezierCurveTo\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires two points: the second control point and the end point. The first control point is assumed to be\n   * The starting point is the last point in the current path.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveToShort(cp2x, cp2y, x, y, smoothness) {\n    const last = this.instructions[this.instructions.length - 1];\n    const lastPoint = this.getLastPoint(Point.shared);\n    let cp1x = 0;\n    let cp1y = 0;\n    if (!last || last.action !== \"bezierCurveTo\") {\n      cp1x = lastPoint.x;\n      cp1y = lastPoint.y;\n    } else {\n      cp1x = last.data[2];\n      cp1y = last.data[3];\n      const currentX = lastPoint.x;\n      const currentY = lastPoint.y;\n      cp1x = currentX + (currentX - cp1x);\n      cp1y = currentY + (currentY - cp1y);\n    }\n    this.instructions.push({ action: \"bezierCurveTo\", data: [cp1x, cp1y, cp2x, cp2y, x, y, smoothness] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this.instructions.push({ action: \"closePath\", data: [] });\n    this._dirty = true;\n    return this;\n  }\n  ellipse(...args) {\n    this.instructions.push({ action: \"ellipse\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  lineTo(...args) {\n    this.instructions.push({ action: \"lineTo\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  moveTo(...args) {\n    this.instructions.push({ action: \"moveTo\", data: args });\n    return this;\n  }\n  quadraticCurveTo(...args) {\n    this.instructions.push({ action: \"quadraticCurveTo\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It uses the previous point as the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveToShort(x, y, smoothness) {\n    const last = this.instructions[this.instructions.length - 1];\n    const lastPoint = this.getLastPoint(Point.shared);\n    let cpx1 = 0;\n    let cpy1 = 0;\n    if (!last || last.action !== \"quadraticCurveTo\") {\n      cpx1 = lastPoint.x;\n      cpy1 = lastPoint.y;\n    } else {\n      cpx1 = last.data[0];\n      cpy1 = last.data[1];\n      const currentX = lastPoint.x;\n      const currentY = lastPoint.y;\n      cpx1 = currentX + (currentX - cpx1);\n      cpy1 = currentY + (currentY - cpy1);\n    }\n    this.instructions.push({ action: \"quadraticCurveTo\", data: [cpx1, cpy1, x, y, smoothness] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h, transform) {\n    this.instructions.push({ action: \"rect\", data: [x, y, w, h, transform] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius, transform) {\n    this.instructions.push({ action: \"circle\", data: [x, y, radius, transform] });\n    this._dirty = true;\n    return this;\n  }\n  roundRect(...args) {\n    this.instructions.push({ action: \"roundRect\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  poly(...args) {\n    this.instructions.push({ action: \"poly\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  regularPoly(...args) {\n    this.instructions.push({ action: \"regularPoly\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  roundPoly(...args) {\n    this.instructions.push({ action: \"roundPoly\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  roundShape(...args) {\n    this.instructions.push({ action: \"roundShape\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  filletRect(...args) {\n    this.instructions.push({ action: \"filletRect\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  chamferRect(...args) {\n    this.instructions.push({ action: \"chamferRect\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @param transform - An optional `Matrix` object to apply a transformation to the star.\n   * This can include rotations, scaling, and translations.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */\n  // eslint-disable-next-line max-len\n  star(x, y, points, radius, innerRadius, rotation, transform) {\n    innerRadius = innerRadius || radius / 2;\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const len = points * 2;\n    const delta = Math.PI * 2 / len;\n    const polygon = [];\n    for (let i = 0; i < len; i++) {\n      const r = i % 2 ? innerRadius : radius;\n      const angle = i * delta + startAngle;\n      polygon.push(\n        x + r * Math.cos(angle),\n        y + r * Math.sin(angle)\n      );\n    }\n    this.poly(polygon, true, transform);\n    return this;\n  }\n  /**\n   * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n   * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n   * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n   * do not affect the original `GraphicsPath` and vice versa.\n   * @param deep - A boolean flag indicating whether the clone should be deep.\n   * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n   */\n  clone(deep = false) {\n    const newGraphicsPath2D = new GraphicsPath();\n    if (!deep) {\n      newGraphicsPath2D.instructions = this.instructions.slice();\n    } else {\n      for (let i = 0; i < this.instructions.length; i++) {\n        const instruction = this.instructions[i];\n        newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });\n      }\n    }\n    return newGraphicsPath2D;\n  }\n  clear() {\n    this.instructions.length = 0;\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n   * This method enables the modification of the path's geometry according to the provided\n   * transformation matrix, which can include translations, rotations, scaling, and skewing.\n   *\n   * Each drawing instruction in the path is updated to reflect the transformation,\n   * ensuring the visual representation of the path is consistent with the applied matrix.\n   *\n   * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n   * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,\n   * allowing for fine-grained control over the path's appearance.\n   * @param matrix - A `Matrix` object representing the transformation to apply.\n   * @returns The instance of the current object for chaining further operations.\n   */\n  transform(matrix) {\n    if (matrix.isIdentity())\n      return this;\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    let x = 0;\n    let y = 0;\n    let cpx1 = 0;\n    let cpy1 = 0;\n    let cpx2 = 0;\n    let cpy2 = 0;\n    let rx = 0;\n    let ry = 0;\n    for (let i = 0; i < this.instructions.length; i++) {\n      const instruction = this.instructions[i];\n      const data = instruction.data;\n      switch (instruction.action) {\n        case \"moveTo\":\n        case \"lineTo\":\n          x = data[0];\n          y = data[1];\n          data[0] = a * x + c * y + tx;\n          data[1] = b * x + d * y + ty;\n          break;\n        case \"bezierCurveTo\":\n          cpx1 = data[0];\n          cpy1 = data[1];\n          cpx2 = data[2];\n          cpy2 = data[3];\n          x = data[4];\n          y = data[5];\n          data[0] = a * cpx1 + c * cpy1 + tx;\n          data[1] = b * cpx1 + d * cpy1 + ty;\n          data[2] = a * cpx2 + c * cpy2 + tx;\n          data[3] = b * cpx2 + d * cpy2 + ty;\n          data[4] = a * x + c * y + tx;\n          data[5] = b * x + d * y + ty;\n          break;\n        case \"quadraticCurveTo\":\n          cpx1 = data[0];\n          cpy1 = data[1];\n          x = data[2];\n          y = data[3];\n          data[0] = a * cpx1 + c * cpy1 + tx;\n          data[1] = b * cpx1 + d * cpy1 + ty;\n          data[2] = a * x + c * y + tx;\n          data[3] = b * x + d * y + ty;\n          break;\n        case \"arcToSvg\":\n          x = data[5];\n          y = data[6];\n          rx = data[0];\n          ry = data[1];\n          data[0] = a * rx + c * ry;\n          data[1] = b * rx + d * ry;\n          data[5] = a * x + c * y + tx;\n          data[6] = b * x + d * y + ty;\n          break;\n        case \"circle\":\n          data[4] = adjustTransform(data[3], matrix);\n          break;\n        case \"rect\":\n          data[4] = adjustTransform(data[4], matrix);\n          break;\n        case \"ellipse\":\n          data[8] = adjustTransform(data[8], matrix);\n          break;\n        case \"roundRect\":\n          data[5] = adjustTransform(data[5], matrix);\n          break;\n        case \"addPath\":\n          data[0].transform(matrix);\n          break;\n        case \"poly\":\n          data[2] = adjustTransform(data[2], matrix);\n          break;\n        default:\n          warn(\"unknown transform action\", instruction.action);\n          break;\n      }\n    }\n    this._dirty = true;\n    return this;\n  }\n  get bounds() {\n    return this.shapePath.bounds;\n  }\n  /**\n   * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n   * This method is useful for operations that depend on the path's current endpoint,\n   * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n   * ensuring the last point's position is accurately determined regardless of the path's complexity.\n   *\n   * If the last instruction is a `closePath`, the method iterates backward through the instructions\n   *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n   * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n   * the last point from the nested path.\n   * @param out - A `Point` object where the last point's coordinates will be stored.\n   * This object is modified directly to contain the result.\n   * @returns The `Point` object containing the last point's coordinates.\n   */\n  getLastPoint(out) {\n    let index = this.instructions.length - 1;\n    let lastInstruction = this.instructions[index];\n    if (!lastInstruction) {\n      out.x = 0;\n      out.y = 0;\n      return out;\n    }\n    while (lastInstruction.action === \"closePath\") {\n      index--;\n      if (index < 0) {\n        out.x = 0;\n        out.y = 0;\n        return out;\n      }\n      lastInstruction = this.instructions[index];\n    }\n    switch (lastInstruction.action) {\n      case \"moveTo\":\n      case \"lineTo\":\n        out.x = lastInstruction.data[0];\n        out.y = lastInstruction.data[1];\n        break;\n      case \"quadraticCurveTo\":\n        out.x = lastInstruction.data[2];\n        out.y = lastInstruction.data[3];\n        break;\n      case \"bezierCurveTo\":\n        out.x = lastInstruction.data[4];\n        out.y = lastInstruction.data[5];\n        break;\n      case \"arc\":\n      case \"arcToSvg\":\n        out.x = lastInstruction.data[5];\n        out.y = lastInstruction.data[6];\n        break;\n      case \"addPath\":\n        lastInstruction.data[0].getLastPoint(out);\n        break;\n    }\n    return out;\n  }\n}\nfunction adjustTransform(currentMatrix, transform) {\n  if (currentMatrix) {\n    return currentMatrix.prepend(transform);\n  }\n  return transform.clone();\n}\n\nexport { GraphicsPath };\n//# sourceMappingURL=GraphicsPath.mjs.map\n","import { Point } from '../../../../maths/point/Point';\nimport { uid } from '../../../../utils/data/uid';\nimport { warn } from '../../../../utils/logging/warn';\nimport { SVGToGraphicsPath } from '../svg/SVGToGraphicsPath';\nimport { ShapePath } from './ShapePath';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { Bounds } from '../../../container/bounds/Bounds';\nimport type { RoundedPoint } from './roundShape';\n\nexport interface PathInstruction\n{\n    action: 'moveTo' | 'lineTo' | 'quadraticCurveTo' |\n    'bezierCurveTo' | 'arc' | 'closePath' |\n    'addPath' | 'arcTo' | 'ellipse' |\n    'rect' | 'roundRect' | 'arcToSvg' |\n    'poly' | 'circle' |\n    'regularPoly' | 'roundPoly' | 'roundShape' | 'filletRect' | 'chamferRect'\n    data: any[];\n}\n\n/**\n * The `GraphicsPath` class is designed to represent a graphical path consisting of multiple drawing instructions.\n * This class serves as a collection of drawing commands that can be executed to render shapes and paths on a canvas or\n * similar graphical context. It supports high-level drawing operations like lines, arcs, curves, and more, enabling\n * complex graphic constructions with relative ease.\n */\nexport class GraphicsPath\n{\n    public instructions: PathInstruction[] = [];\n\n    public uid = uid('graphicsPath');\n\n    private _dirty = true;\n    // needed for hit testing and bounds calculations\n    private _shapePath: ShapePath;\n\n    /**\n     * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n     * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n     */\n    get shapePath(): ShapePath\n    {\n        if (!this._shapePath)\n        {\n            this._shapePath = new ShapePath(this);\n        }\n\n        if (this._dirty)\n        {\n            this._dirty = false;\n            this._shapePath.buildPath();\n        }\n\n        return this._shapePath;\n    }\n\n    /**\n     * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n     * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n     */\n    constructor(instructions?: string | PathInstruction[])\n    {\n        if (typeof instructions === 'string')\n        {\n            SVGToGraphicsPath(instructions, this);\n        }\n        else\n        {\n            this.instructions = instructions?.slice() ?? [];\n        }\n    }\n\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @param transform - An optional transformation to apply to the added path.\n     * @returns The instance of the current object for chaining.\n     */\n    public addPath(path: GraphicsPath, transform?: Matrix): this\n    {\n        path = path.clone();\n        this.instructions.push({ action: 'addPath', data: [path, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path. The arc is centered at (x, y)\n     *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The radius of the arc.\n     * @param startAngle - The starting angle of the arc, in radians.\n     * @param endAngle - The ending angle of the arc, in radians.\n     * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n    public arc(...args: [number, number, number, number, number, boolean]): this\n    {\n        this.instructions.push({ action: 'arc', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path with the arc tangent to the line joining two specified points.\n     * The arc radius is specified by `radius`.\n     * @param x1 - The x-coordinate of the first point.\n     * @param y1 - The y-coordinate of the first point.\n     * @param x2 - The x-coordinate of the second point.\n     * @param y2 - The y-coordinate of the second point.\n     * @param radius - The radius of the arc.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n    public arcTo(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'arcTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    // eslint-disable-next-line max-len\n    public arcToSvg(rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number): this;\n    public arcToSvg(...args: [number, number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'arcToSvg', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number,\n        x: number, y: number,\n        smoothness?: number\n    ): this;\n    public bezierCurveTo(...args: [number, number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'bezierCurveTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires two points: the second control point and the end point. The first control point is assumed to be\n     * The starting point is the last point in the current path.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveToShort(cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this\n    {\n        const last = this.instructions[this.instructions.length - 1];\n\n        const lastPoint = this.getLastPoint(Point.shared);\n\n        let cp1x = 0;\n        let cp1y = 0;\n\n        if (!last || last.action !== 'bezierCurveTo')\n        {\n            cp1x = lastPoint.x;\n            cp1y = lastPoint.y;\n        }\n        else\n        {\n            cp1x = last.data[2];\n            cp1y = last.data[3];\n\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n\n            cp1x = currentX + (currentX - cp1x);\n            cp1y = currentY + (currentY - cp1y);\n        }\n\n        this.instructions.push({ action: 'bezierCurveTo', data: [cp1x, cp1y, cp2x, cp2y, x, y, smoothness] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this.instructions.push({ action: 'closePath', data: [] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number, matrix?: Matrix): this;\n    public ellipse(...args: [number, number, number, number, Matrix]): this\n    {\n        this.instructions.push({ action: 'ellipse', data: args });\n\n        // TODO nail this!\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this;\n    public lineTo(...args: [number, number]): this\n    {\n        this.instructions.push({ action: 'lineTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this;\n    public moveTo(...args: [number, number]): this\n    {\n        this.instructions.push({ action: 'moveTo', data: args });\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the control point.\n     * @param cp1y - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n    public quadraticCurveTo(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'quadraticCurveTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It uses the previous point as the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveToShort(x: number, y: number, smoothness?: number): this\n    {\n        // check if we have a previous quadraticCurveTo\n        const last = this.instructions[this.instructions.length - 1];\n\n        const lastPoint = this.getLastPoint(Point.shared);\n\n        let cpx1 = 0;\n        let cpy1 = 0;\n\n        if (!last || last.action !== 'quadraticCurveTo')\n        {\n            cpx1 = lastPoint.x;\n            cpy1 = lastPoint.y;\n        }\n        else\n        {\n            cpx1 = last.data[0];\n            cpy1 = last.data[1];\n\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n\n            cpx1 = currentX + (currentX - cpx1);\n            cpy1 = currentY + (currentY - cpy1);\n        }\n\n        this.instructions.push({ action: 'quadraticCurveTo', data: [cpx1, cpy1, x, y, smoothness] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number, transform?: Matrix): this\n    {\n        this.instructions.push({ action: 'rect', data: [x, y, w, h, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number, transform?: Matrix): this\n    {\n        this.instructions.push({ action: 'circle', data: [x, y, radius, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number, transform?: Matrix): this;\n    public roundRect(...args: [number, number, number, number, number, Matrix?]): this\n    {\n        this.instructions.push({ action: 'roundRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers representing the x and y coordinates of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public poly(points: number[] | PointData[], close?: boolean, transform?: Matrix): this;\n    public poly(...args: [number[] | PointData[], boolean, Matrix?]): this\n    {\n        this.instructions.push({ action: 'poly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n    public regularPoly(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'regularPoly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n    public roundPoly(...args: [number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'roundPoly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n    public roundShape(...args: [RoundedPoint[], number, boolean, number]): this\n    {\n        this.instructions.push({ action: 'roundShape', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n    public filletRect(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'filletRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n    public chamferRect(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'chamferRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @param transform - An optional `Matrix` object to apply a transformation to the star.\n     * This can include rotations, scaling, and translations.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    // eslint-disable-next-line max-len\n    public star(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number, transform?: Matrix): this\n    {\n        innerRadius = innerRadius || radius / 2;\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const len = points * 2;\n        const delta = (Math.PI * 2) / len;\n        const polygon = [];\n\n        for (let i = 0; i < len; i++)\n        {\n            const r = i % 2 ? innerRadius : radius;\n            const angle = (i * delta) + startAngle;\n\n            polygon.push(\n                x + (r * Math.cos(angle)),\n                y + (r * Math.sin(angle))\n            );\n        }\n\n        this.poly(polygon, true, transform);\n\n        return this;\n    }\n\n    /**\n     * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n     * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n     * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n     * do not affect the original `GraphicsPath` and vice versa.\n     * @param deep - A boolean flag indicating whether the clone should be deep.\n     * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n     */\n    public clone(deep = false): GraphicsPath\n    {\n        const newGraphicsPath2D = new GraphicsPath();\n\n        if (!deep)\n        {\n            newGraphicsPath2D.instructions = this.instructions.slice();\n        }\n        else\n        {\n            for (let i = 0; i < this.instructions.length; i++)\n            {\n                const instruction = this.instructions[i];\n\n                newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });\n            }\n        }\n\n        return newGraphicsPath2D;\n    }\n\n    public clear(): this\n    {\n        this.instructions.length = 0;\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n     * This method enables the modification of the path's geometry according to the provided\n     * transformation matrix, which can include translations, rotations, scaling, and skewing.\n     *\n     * Each drawing instruction in the path is updated to reflect the transformation,\n     * ensuring the visual representation of the path is consistent with the applied matrix.\n     *\n     * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n     * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,\n     * allowing for fine-grained control over the path's appearance.\n     * @param matrix - A `Matrix` object representing the transformation to apply.\n     * @returns The instance of the current object for chaining further operations.\n     */\n    public transform(matrix: Matrix): this\n    {\n        if (matrix.isIdentity()) return this;\n\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let x = 0;\n        let y = 0;\n\n        let cpx1 = 0;\n        let cpy1 = 0;\n        let cpx2 = 0;\n        let cpy2 = 0;\n\n        let rx = 0;\n        let ry = 0;\n\n        for (let i = 0; i < this.instructions.length; i++)\n        {\n            const instruction = this.instructions[i];\n            const data = instruction.data as any[];\n\n            switch (instruction.action)\n            {\n                case 'moveTo':\n                case 'lineTo':\n\n                    x = data[0];\n                    y = data[1];\n\n                    data[0] = (a * x) + (c * y) + tx;\n                    data[1] = (b * x) + (d * y) + ty;\n                    break;\n                case 'bezierCurveTo':\n\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n                    cpx2 = data[2];\n                    cpy2 = data[3];\n\n                    x = data[4];\n                    y = data[5];\n\n                    data[0] = (a * cpx1) + (c * cpy1) + tx;\n                    data[1] = (b * cpx1) + (d * cpy1) + ty;\n                    data[2] = (a * cpx2) + (c * cpy2) + tx;\n                    data[3] = (b * cpx2) + (d * cpy2) + ty;\n                    data[4] = (a * x) + (c * y) + tx;\n                    data[5] = (b * x) + (d * y) + ty;\n                    break;\n\n                case 'quadraticCurveTo':\n\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n\n                    x = data[2];\n                    y = data[3];\n\n                    data[0] = (a * cpx1) + (c * cpy1) + tx;\n                    data[1] = (b * cpx1) + (d * cpy1) + ty;\n\n                    data[2] = (a * x) + (c * y) + tx;\n                    data[3] = (b * x) + (d * y) + ty;\n\n                    break;\n\n                case 'arcToSvg':\n\n                    x = data[5];\n                    y = data[6];\n\n                    rx = data[0];\n                    ry = data[1];\n\n                    // multiply the radius by the transform..\n\n                    data[0] = (a * rx) + (c * ry);\n                    data[1] = (b * rx) + (d * ry);\n\n                    data[5] = (a * x) + (c * y) + tx;\n                    data[6] = (b * x) + (d * y) + ty;\n\n                    break;\n\n                case 'circle':\n                    data[4] = adjustTransform(data[3], matrix);\n                    break;\n                case 'rect':\n                    data[4] = adjustTransform(data[4], matrix);\n                    break;\n                case 'ellipse':\n                    data[8] = adjustTransform(data[8], matrix);\n                    break;\n                case 'roundRect':\n                    data[5] = adjustTransform(data[5], matrix);\n                    break;\n                case 'addPath':\n                    data[0].transform(matrix);\n                    break;\n                case 'poly':\n                    data[2] = adjustTransform(data[2], matrix);\n                    break;\n                default:\n                    // #if _DEBUG\n                    warn('unknown transform action', instruction.action);\n                    // #endif\n                    break;\n            }\n        }\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    get bounds(): Bounds\n    {\n        return this.shapePath.bounds;\n    }\n\n    /**\n     * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n     * This method is useful for operations that depend on the path's current endpoint,\n     * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n     * ensuring the last point's position is accurately determined regardless of the path's complexity.\n     *\n     * If the last instruction is a `closePath`, the method iterates backward through the instructions\n     *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n     * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n     * the last point from the nested path.\n     * @param out - A `Point` object where the last point's coordinates will be stored.\n     * This object is modified directly to contain the result.\n     * @returns The `Point` object containing the last point's coordinates.\n     */\n    public getLastPoint(out: Point): Point\n    {\n        let index = this.instructions.length - 1;\n\n        let lastInstruction = this.instructions[index];\n\n        if (!lastInstruction)\n        {\n            out.x = 0;\n            out.y = 0;\n\n            return out;\n        }\n\n        while (lastInstruction.action === 'closePath')\n        {\n            index--;\n\n            if (index < 0)\n            {\n                out.x = 0;\n                out.y = 0;\n\n                return out;\n            }\n\n            lastInstruction = this.instructions[index];\n        }\n\n        switch (lastInstruction.action)\n        {\n            case 'moveTo':\n            case 'lineTo':\n                out.x = lastInstruction.data[0];\n                out.y = lastInstruction.data[1];\n                break;\n            case 'quadraticCurveTo':\n                out.x = lastInstruction.data[2];\n                out.y = lastInstruction.data[3];\n                break;\n            case 'bezierCurveTo':\n                out.x = lastInstruction.data[4];\n                out.y = lastInstruction.data[5];\n                break;\n            case 'arc':\n            case 'arcToSvg':\n                out.x = lastInstruction.data[5];\n                out.y = lastInstruction.data[6];\n                break;\n            case 'addPath':\n                // TODO prolly should transform the last point of the path\n                lastInstruction.data[0].getLastPoint(out);\n                break;\n        }\n\n        return out;\n    }\n}\n\nfunction adjustTransform(currentMatrix?: Matrix, transform?: Matrix): Matrix\n{\n    if (currentMatrix)\n    {\n        return currentMatrix.prepend(transform);\n    }\n\n    return transform.clone();\n}\n","import parse from 'parse-svg-path';\nimport { warn } from '../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nfunction SVGToGraphicsPath(svgPath, path) {\n  const commands = parse(svgPath);\n  const subpaths = [];\n  let currentSubPath = null;\n  let lastX = 0;\n  let lastY = 0;\n  for (let i = 0; i < commands.length; i++) {\n    const command = commands[i];\n    const type = command[0];\n    const data = command;\n    switch (type) {\n      case \"M\":\n        lastX = data[1];\n        lastY = data[2];\n        path.moveTo(lastX, lastY);\n        break;\n      case \"m\":\n        lastX += data[1];\n        lastY += data[2];\n        path.moveTo(lastX, lastY);\n        break;\n      case \"H\":\n        lastX = data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"h\":\n        lastX += data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"V\":\n        lastY = data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"v\":\n        lastY += data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"L\":\n        lastX = data[1];\n        lastY = data[2];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"l\":\n        lastX += data[1];\n        lastY += data[2];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"C\":\n        lastX = data[5];\n        lastY = data[6];\n        path.bezierCurveTo(\n          data[1],\n          data[2],\n          data[3],\n          data[4],\n          lastX,\n          lastY\n        );\n        break;\n      case \"c\":\n        path.bezierCurveTo(\n          lastX + data[1],\n          lastY + data[2],\n          lastX + data[3],\n          lastY + data[4],\n          lastX + data[5],\n          lastY + data[6]\n        );\n        lastX += data[5];\n        lastY += data[6];\n        break;\n      case \"S\":\n        lastX = data[3];\n        lastY = data[4];\n        path.bezierCurveToShort(\n          data[1],\n          data[2],\n          lastX,\n          lastY\n        );\n        break;\n      case \"s\":\n        path.bezierCurveToShort(\n          lastX + data[1],\n          lastY + data[2],\n          lastX + data[3],\n          lastY + data[4]\n        );\n        lastX += data[3];\n        lastY += data[4];\n        break;\n      case \"Q\":\n        lastX = data[3];\n        lastY = data[4];\n        path.quadraticCurveTo(\n          data[1],\n          data[2],\n          lastX,\n          lastY\n        );\n        break;\n      case \"q\":\n        path.quadraticCurveTo(\n          lastX + data[1],\n          lastY + data[2],\n          lastX + data[3],\n          lastY + data[4]\n        );\n        lastX += data[3];\n        lastY += data[4];\n        break;\n      case \"T\":\n        lastX = data[1];\n        lastY = data[2];\n        path.quadraticCurveToShort(\n          lastX,\n          lastY\n        );\n        break;\n      case \"t\":\n        lastX += data[1];\n        lastY += data[2];\n        path.quadraticCurveToShort(\n          lastX,\n          lastY\n        );\n        break;\n      case \"A\":\n        lastX = data[6];\n        lastY = data[7];\n        path.arcToSvg(\n          data[1],\n          data[2],\n          data[3],\n          data[4],\n          data[5],\n          lastX,\n          lastY\n        );\n        break;\n      case \"a\":\n        lastX += data[6];\n        lastY += data[7];\n        path.arcToSvg(\n          data[1],\n          data[2],\n          data[3],\n          data[4],\n          data[5],\n          lastX,\n          lastY\n        );\n        break;\n      case \"Z\":\n      case \"z\":\n        path.closePath();\n        if (subpaths.length > 0) {\n          currentSubPath = subpaths.pop();\n          if (currentSubPath) {\n            lastX = currentSubPath.startX;\n            lastY = currentSubPath.startY;\n          } else {\n            lastX = 0;\n            lastY = 0;\n          }\n        }\n        currentSubPath = null;\n        break;\n      default:\n        warn(`Unknown SVG path command: ${type}`);\n    }\n    if (type !== \"Z\" && type !== \"z\") {\n      if (currentSubPath === null) {\n        currentSubPath = { startX: lastX, startY: lastY };\n        subpaths.push(currentSubPath);\n      }\n    }\n  }\n  return path;\n}\n\nexport { SVGToGraphicsPath };\n//# sourceMappingURL=SVGToGraphicsPath.mjs.map\n","/* eslint-disable no-console */\nimport parse from 'parse-svg-path';\nimport { warn } from '../../../../utils/logging/warn';\n\nimport type { GraphicsPath } from '../path/GraphicsPath';\n\ninterface SubPath\n{\n    startX: number;\n    startY: number;\n}\n\n// TODO optimise and cache the paths?\nexport function SVGToGraphicsPath(svgPath: string, path: GraphicsPath): GraphicsPath\n{\n    const commands = parse(svgPath);\n\n    const subpaths: SubPath[] = [];\n    let currentSubPath: SubPath | null = null;\n\n    let lastX = 0;\n    let lastY = 0;\n\n    for (let i = 0; i < commands.length; i++)\n    {\n        const command = commands[i];\n        const type = command[0];\n        const data = command; // alias for 1-based referencing\n\n        switch (type)\n        {\n            case 'M':\n                lastX = data[1];\n                lastY = data[2];\n\n                path.moveTo(lastX, lastY);\n                break;\n            case 'm':\n\n                lastX += data[1];\n                lastY += data[2];\n\n                path.moveTo(lastX, lastY);\n                break;\n            case 'H':\n                lastX = data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'h':\n                lastX += data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'V':\n                lastY = data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'v':\n                lastY += data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'L':\n                lastX = data[1];\n                lastY = data[2];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'l':\n                lastX += data[1];\n                lastY += data[2];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'C':\n\n                lastX = data[5];\n                lastY = data[6];\n\n                path.bezierCurveTo(\n                    data[1], data[2],\n                    data[3], data[4],\n                    lastX, lastY\n                );\n                break;\n            case 'c':\n                path.bezierCurveTo(\n                    lastX + data[1], lastY + data[2],\n                    lastX + data[3], lastY + data[4],\n                    lastX + data[5], lastY + data[6]\n                );\n\n                lastX += data[5];\n                lastY += data[6];\n                break;\n            case 'S':\n                lastX = data[3];\n                lastY = data[4];\n\n                path.bezierCurveToShort(\n                    data[1], data[2],\n                    lastX, lastY\n                );\n                break;\n            case 's':\n                path.bezierCurveToShort(\n                    lastX + data[1], lastY + data[2],\n                    lastX + data[3], lastY + data[4],\n                );\n\n                lastX += data[3];\n                lastY += data[4];\n                break;\n            case 'Q':\n                lastX = data[3];\n                lastY = data[4];\n\n                path.quadraticCurveTo(\n                    data[1], data[2],\n                    lastX, lastY\n                );\n                break;\n            case 'q':\n                path.quadraticCurveTo(\n                    lastX + data[1], lastY + data[2],\n                    lastX + data[3], lastY + data[4]\n                );\n\n                lastX += data[3];\n                lastY += data[4];\n                break;\n            case 'T':\n                lastX = data[1];\n                lastY = data[2];\n\n                path.quadraticCurveToShort(\n                    lastX, lastY\n                );\n                break;\n            case 't':\n                lastX += data[1];\n                lastY += data[2];\n\n                path.quadraticCurveToShort(\n                    lastX, lastY\n                );\n                break;\n            case 'A':\n                lastX = data[6];\n                lastY = data[7];\n\n                path.arcToSvg(\n                    data[1],\n                    data[2],\n                    data[3],\n                    data[4],\n                    data[5],\n                    lastX, lastY\n                );\n                break;\n            case 'a':\n                lastX += data[6];\n                lastY += data[7];\n\n                path.arcToSvg(\n                    data[1],\n                    data[2],\n                    data[3],\n                    data[4],\n                    data[5],\n                    lastX, lastY\n                );\n                break;\n            case 'Z':\n            case 'z':\n                path.closePath();\n                if (subpaths.length > 0)\n                {\n                    currentSubPath = subpaths.pop();\n                    if (currentSubPath)\n                    {\n                        lastX = currentSubPath.startX;\n                        lastY = currentSubPath.startY;\n                    }\n                    else\n                    {\n                        lastX = 0;\n                        lastY = 0;\n                    }\n                }\n                currentSubPath = null;\n                break;\n            default:\n                // #if _DEBUG\n                warn(`Unknown SVG path command: ${type}`);\n                // #endif\n        }\n\n        if (type !== 'Z' && type !== 'z')\n        {\n            if (currentSubPath === null)\n            {\n                currentSubPath = { startX: lastX, startY: lastY };\n                subpaths.push(currentSubPath);\n            }\n        }\n    }\n\n    return path;\n}\n","\nmodule.exports = parse\n\n/**\n * expected argument lengths\n * @type {Object}\n */\n\nvar length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}\n\n/**\n * segment pattern\n * @type {RegExp}\n */\n\nvar segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig\n\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * @param {String} path\n * @return {Array}\n */\n\nfunction parse(path) {\n\tvar data = []\n\tpath.replace(segment, function(_, command, args){\n\t\tvar type = command.toLowerCase()\n\t\targs = parseValues(args)\n\n\t\t// overloaded moveTo\n\t\tif (type == 'm' && args.length > 2) {\n\t\t\tdata.push([command].concat(args.splice(0, 2)))\n\t\t\ttype = 'l'\n\t\t\tcommand = command == 'm' ? 'l' : 'L'\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (args.length == length[type]) {\n\t\t\t\targs.unshift(command)\n\t\t\t\treturn data.push(args)\n\t\t\t}\n\t\t\tif (args.length < length[type]) throw new Error('malformed path data')\n\t\t\tdata.push([command].concat(args.splice(0, length[type])))\n\t\t}\n\t})\n\treturn data\n}\n\nvar number = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig\n\nfunction parseValues(args) {\n\tvar numbers = args.match(number)\n\treturn numbers ? numbers.map(Number) : []\n}\n","import { Circle } from '../../../../maths/shapes/Circle.mjs';\nimport { Ellipse } from '../../../../maths/shapes/Ellipse.mjs';\nimport { Polygon } from '../../../../maths/shapes/Polygon.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle.mjs';\nimport { Bounds } from '../../../container/bounds/Bounds.mjs';\nimport { buildAdaptiveBezier } from '../buildCommands/buildAdaptiveBezier.mjs';\nimport { buildAdaptiveQuadratic } from '../buildCommands/buildAdaptiveQuadratic.mjs';\nimport { buildArc } from '../buildCommands/buildArc.mjs';\nimport { buildArcTo } from '../buildCommands/buildArcTo.mjs';\nimport { buildArcToSvg } from '../buildCommands/buildArcToSvg.mjs';\nimport { roundedShapeQuadraticCurve, roundedShapeArc } from './roundShape.mjs';\n\n\"use strict\";\nconst tempRectangle = new Rectangle();\nclass ShapePath {\n  constructor(graphicsPath2D) {\n    /** The list of shape primitives that make up the path. */\n    this.shapePrimitives = [];\n    this._currentPoly = null;\n    this._bounds = new Bounds();\n    this._graphicsPath2D = graphicsPath2D;\n  }\n  /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */\n  moveTo(x, y) {\n    this.startPoly(x, y);\n    return this;\n  }\n  /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */\n  lineTo(x, y) {\n    this._ensurePoly();\n    const points = this._currentPoly.points;\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n    if (fromX !== x || fromY !== y) {\n      points.push(x, y);\n    }\n    return this;\n  }\n  /**\n   * Adds an arc to the path. The arc is centered at (x, y)\n   *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n   * @param x - The x-coordinate of the arc's center.\n   * @param y - The y-coordinate of the arc's center.\n   * @param radius - The radius of the arc.\n   * @param startAngle - The starting angle of the arc, in radians.\n   * @param endAngle - The ending angle of the arc, in radians.\n   * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n   * @returns The instance of the current object for chaining.\n   */\n  arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n    this._ensurePoly(false);\n    const points = this._currentPoly.points;\n    buildArc(points, x, y, radius, startAngle, endAngle, counterclockwise);\n    return this;\n  }\n  /**\n   * Adds an arc to the path with the arc tangent to the line joining two specified points.\n   * The arc radius is specified by `radius`.\n   * @param x1 - The x-coordinate of the first point.\n   * @param y1 - The y-coordinate of the first point.\n   * @param x2 - The x-coordinate of the second point.\n   * @param y2 - The y-coordinate of the second point.\n   * @param radius - The radius of the arc.\n   * @returns The instance of the current object for chaining.\n   */\n  arcTo(x1, y1, x2, y2, radius) {\n    this._ensurePoly();\n    const points = this._currentPoly.points;\n    buildArcTo(points, x1, y1, x2, y2, radius);\n    return this;\n  }\n  /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc's end point.\n   * @param y - The y-coordinate of the arc's end point.\n   * @returns The instance of the current object for chaining.\n   */\n  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n    const points = this._currentPoly.points;\n    buildArcToSvg(\n      points,\n      this._currentPoly.lastX,\n      this._currentPoly.lastY,\n      x,\n      y,\n      rx,\n      ry,\n      xAxisRotation,\n      largeArcFlag,\n      sweepFlag\n    );\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n    this._ensurePoly();\n    const currentPoly = this._currentPoly;\n    buildAdaptiveBezier(\n      this._currentPoly.points,\n      currentPoly.lastX,\n      currentPoly.lastY,\n      cp1x,\n      cp1y,\n      cp2x,\n      cp2y,\n      x,\n      y,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the control point.\n   * @param cp1y - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveTo(cp1x, cp1y, x, y, smoothing) {\n    this._ensurePoly();\n    const currentPoly = this._currentPoly;\n    buildAdaptiveQuadratic(\n      this._currentPoly.points,\n      currentPoly.lastX,\n      currentPoly.lastY,\n      cp1x,\n      cp1y,\n      x,\n      y,\n      smoothing\n    );\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this.endPoly(true);\n    return this;\n  }\n  /**\n   * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n   * @param path - The `GraphicsPath` object representing the path to add.\n   * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n   * @returns The instance of the current object for chaining.\n   */\n  addPath(path, transform) {\n    this.endPoly();\n    if (transform && !transform.isIdentity()) {\n      path = path.clone(true);\n      path.transform(transform);\n    }\n    for (let i = 0; i < path.instructions.length; i++) {\n      const instruction = path.instructions[i];\n      this[instruction.action](...instruction.data);\n    }\n    return this;\n  }\n  /**\n   * Finalizes the drawing of the current path. Optionally, it can close the path.\n   * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n   */\n  finish(closePath = false) {\n    this.endPoly(closePath);\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h, transform) {\n    this.drawShape(new Rectangle(x, y, w, h), transform);\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius, transform) {\n    this.drawShape(new Circle(x, y, radius), transform);\n    return this;\n  }\n  /**\n   * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n   * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates of the polygon's vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  poly(points, close, transform) {\n    const polygon = new Polygon(points);\n    polygon.closePath = close;\n    this.drawShape(polygon, transform);\n    return this;\n  }\n  /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  regularPoly(x, y, radius, sides, rotation = 0, transform) {\n    sides = Math.max(sides | 0, 3);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const delta = Math.PI * 2 / sides;\n    const polygon = [];\n    for (let i = 0; i < sides; i++) {\n      const angle = i * delta + startAngle;\n      polygon.push(\n        x + radius * Math.cos(angle),\n        y + radius * Math.sin(angle)\n      );\n    }\n    this.poly(polygon, true, transform);\n    return this;\n  }\n  /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n   * @returns The instance of the current object for chaining.\n   */\n  roundPoly(x, y, radius, sides, corner, rotation = 0, smoothness) {\n    sides = Math.max(sides | 0, 3);\n    if (corner <= 0) {\n      return this.regularPoly(x, y, radius, sides, rotation);\n    }\n    const sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;\n    corner = Math.min(corner, sideLength);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const delta = Math.PI * 2 / sides;\n    const internalAngle = (sides - 2) * Math.PI / sides / 2;\n    for (let i = 0; i < sides; i++) {\n      const angle = i * delta + startAngle;\n      const x0 = x + radius * Math.cos(angle);\n      const y0 = y + radius * Math.sin(angle);\n      const a1 = angle + Math.PI + internalAngle;\n      const a2 = angle - Math.PI - internalAngle;\n      const x1 = x0 + corner * Math.cos(a1);\n      const y1 = y0 + corner * Math.sin(a1);\n      const x3 = x0 + corner * Math.cos(a2);\n      const y3 = y0 + corner * Math.sin(a2);\n      if (i === 0) {\n        this.moveTo(x1, y1);\n      } else {\n        this.lineTo(x1, y1);\n      }\n      this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n    }\n    return this.closePath();\n  }\n  /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */\n  roundShape(points, radius, useQuadratic = false, smoothness) {\n    if (points.length < 3) {\n      return this;\n    }\n    if (useQuadratic) {\n      roundedShapeQuadraticCurve(this, points, radius, smoothness);\n    } else {\n      roundedShapeArc(this, points, radius);\n    }\n    return this.closePath();\n  }\n  /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */\n  filletRect(x, y, width, height, fillet) {\n    if (fillet === 0) {\n      return this.rect(x, y, width, height);\n    }\n    const maxFillet = Math.min(width, height) / 2;\n    const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n    const right = x + width;\n    const bottom = y + height;\n    const dir = inset < 0 ? -inset : 0;\n    const size = Math.abs(inset);\n    return this.moveTo(x, y + size).arcTo(x + dir, y + dir, x + size, y, size).lineTo(right - size, y).arcTo(right - dir, y + dir, right, y + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x + width - size, bottom, size).lineTo(x + size, bottom).arcTo(x + dir, bottom - dir, x, bottom - size, size).closePath();\n  }\n  /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */\n  chamferRect(x, y, width, height, chamfer, transform) {\n    if (chamfer <= 0) {\n      return this.rect(x, y, width, height);\n    }\n    const inset = Math.min(chamfer, Math.min(width, height) / 2);\n    const right = x + width;\n    const bottom = y + height;\n    const points = [\n      x + inset,\n      y,\n      right - inset,\n      y,\n      right,\n      y + inset,\n      right,\n      bottom - inset,\n      right - inset,\n      bottom,\n      x + inset,\n      bottom,\n      x,\n      bottom - inset,\n      x,\n      y + inset\n    ];\n    for (let i = points.length - 1; i >= 2; i -= 2) {\n      if (points[i] === points[i - 2] && points[i - 1] === points[i - 3]) {\n        points.splice(i - 1, 2);\n      }\n    }\n    return this.poly(points, true, transform);\n  }\n  /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n   * @returns The instance of the current object for chaining.\n   */\n  ellipse(x, y, radiusX, radiusY, transform) {\n    this.drawShape(new Ellipse(x, y, radiusX, radiusY), transform);\n    return this;\n  }\n  /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  roundRect(x, y, w, h, radius, transform) {\n    this.drawShape(new RoundedRectangle(x, y, w, h, radius), transform);\n    return this;\n  }\n  /**\n   * Draws a given shape on the canvas.\n   * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n   * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n   * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n   * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n   * scaling, and translations.\n   * @returns The instance of the current object for chaining.\n   */\n  drawShape(shape, matrix) {\n    this.endPoly();\n    this.shapePrimitives.push({ shape, transform: matrix });\n    return this;\n  }\n  /**\n   * Starts a new polygon path from the specified starting point.\n   * This method initializes a new polygon or ends the current one if it exists.\n   * @param x - The x-coordinate of the starting point of the new polygon.\n   * @param y - The y-coordinate of the starting point of the new polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  startPoly(x, y) {\n    let currentPoly = this._currentPoly;\n    if (currentPoly) {\n      this.endPoly();\n    }\n    currentPoly = new Polygon();\n    currentPoly.points.push(x, y);\n    this._currentPoly = currentPoly;\n    return this;\n  }\n  /**\n   * Ends the current polygon path. If `closePath` is set to true,\n   * the path is closed by connecting the last point to the first one.\n   * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n   * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n   *  back to the starting point. False by default.\n   * @returns The instance of the current object for chaining.\n   */\n  endPoly(closePath = false) {\n    const shape = this._currentPoly;\n    if (shape && shape.points.length > 2) {\n      shape.closePath = closePath;\n      this.shapePrimitives.push({ shape });\n    }\n    this._currentPoly = null;\n    return this;\n  }\n  _ensurePoly(start = true) {\n    if (this._currentPoly)\n      return;\n    this._currentPoly = new Polygon();\n    if (start) {\n      const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n      if (lastShape) {\n        let lx = lastShape.shape.x;\n        let ly = lastShape.shape.y;\n        if (!lastShape.transform.isIdentity()) {\n          const t = lastShape.transform;\n          const tempX = lx;\n          lx = t.a * lx + t.c * ly + t.tx;\n          ly = t.b * tempX + t.d * ly + t.ty;\n        }\n        this._currentPoly.points.push(lx, ly);\n      } else {\n        this._currentPoly.points.push(0, 0);\n      }\n    }\n  }\n  /** Builds the path. */\n  buildPath() {\n    const path = this._graphicsPath2D;\n    this.shapePrimitives.length = 0;\n    this._currentPoly = null;\n    for (let i = 0; i < path.instructions.length; i++) {\n      const instruction = path.instructions[i];\n      this[instruction.action](...instruction.data);\n    }\n    this.finish();\n  }\n  /** Gets the bounds of the path. */\n  get bounds() {\n    const bounds = this._bounds;\n    bounds.clear();\n    const shapePrimitives = this.shapePrimitives;\n    for (let i = 0; i < shapePrimitives.length; i++) {\n      const shapePrimitive = shapePrimitives[i];\n      const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);\n      if (shapePrimitive.transform) {\n        bounds.addRect(boundsRect, shapePrimitive.transform);\n      } else {\n        bounds.addRect(boundsRect);\n      }\n    }\n    return bounds;\n  }\n}\n\nexport { ShapePath };\n//# sourceMappingURL=ShapePath.mjs.map\n","// a shape lets you build out a shape with lines and curves and primitives..\n\nimport { Circle } from '../../../../maths/shapes/Circle';\nimport { Ellipse } from '../../../../maths/shapes/Ellipse';\nimport { Polygon } from '../../../../maths/shapes/Polygon';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle';\nimport { Bounds } from '../../../container/bounds/Bounds';\nimport { buildAdaptiveBezier } from '../buildCommands/buildAdaptiveBezier';\nimport { buildAdaptiveQuadratic } from '../buildCommands/buildAdaptiveQuadratic';\nimport { buildArc } from '../buildCommands/buildArc';\nimport { buildArcTo } from '../buildCommands/buildArcTo';\nimport { buildArcToSvg } from '../buildCommands/buildArcToSvg';\nimport { roundedShapeArc, roundedShapeQuadraticCurve } from './roundShape';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { ShapePrimitive } from '../../../../maths/shapes/ShapePrimitive';\nimport type { GraphicsPath } from './GraphicsPath';\nimport type { RoundedPoint } from './roundShape';\n\nconst tempRectangle = new Rectangle();\n\n/**\n * The `ShapePath` class acts as a bridge between high-level drawing commands\n * and the lower-level `GraphicsContext` rendering engine.\n * It translates drawing commands, such as those for creating lines, arcs, ellipses, rectangles, and complex polygons, into a\n * format that can be efficiently processed by a `GraphicsContext`. This includes handling path starts,\n * ends, and transformations for shapes.\n *\n * It is used internally by `GraphicsPath` to build up the path.\n * @memberof scene\n */\nexport class ShapePath\n{\n    /** The list of shape primitives that make up the path. */\n    public shapePrimitives: { shape: ShapePrimitive, transform?: Matrix }[] = [];\n    private _currentPoly: Polygon | null = null;\n    private readonly _graphicsPath2D: GraphicsPath;\n    private readonly _bounds = new Bounds();\n\n    constructor(graphicsPath2D: GraphicsPath)\n    {\n        this._graphicsPath2D = graphicsPath2D;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this.startPoly(x, y);\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this\n    {\n        this._ensurePoly();\n\n        const points = this._currentPoly.points;\n\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        if (fromX !== x || fromY !== y)\n        {\n            points.push(x, y);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path. The arc is centered at (x, y)\n     *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The radius of the arc.\n     * @param startAngle - The starting angle of the arc, in radians.\n     * @param endAngle - The ending angle of the arc, in radians.\n     * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise: boolean): this\n    {\n        // TODO - if its 360 degrees.. make it a circle object?\n\n        this._ensurePoly(false);\n\n        const points = this._currentPoly.points;\n\n        buildArc(points, x, y, radius, startAngle, endAngle, counterclockwise);\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path with the arc tangent to the line joining two specified points.\n     * The arc radius is specified by `radius`.\n     * @param x1 - The x-coordinate of the first point.\n     * @param y1 - The y-coordinate of the first point.\n     * @param x2 - The x-coordinate of the second point.\n     * @param y2 - The y-coordinate of the second point.\n     * @param radius - The radius of the arc.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._ensurePoly();\n\n        const points = this._currentPoly.points;\n\n        buildArcTo(points, x1, y1, x2, y2, radius);\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number,\n        xAxisRotation: number, largeArcFlag: number, sweepFlag: number,\n        x: number, y: number\n    ): this\n    {\n        const points = this._currentPoly.points;\n\n        // this needs to work on both canvas and GPU backends so might want to move this to the Graphics2D path..\n        buildArcToSvg(\n            points,\n            this._currentPoly.lastX,\n            this._currentPoly.lastY,\n            x,\n            y,\n            rx,\n            ry,\n            xAxisRotation,\n            largeArcFlag,\n            sweepFlag,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number,\n        x: number, y: number,\n        smoothness?: number\n    ): this\n    {\n        this._ensurePoly();\n\n        const currentPoly = this._currentPoly;\n\n        // ensure distance from last point to first control point is not too small\n\n        // TODO - make this a plugin that people can override..\n        buildAdaptiveBezier(\n            this._currentPoly.points,\n            currentPoly.lastX, currentPoly.lastY,\n            cp1x, cp1y, cp2x, cp2y, x, y,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the control point.\n     * @param cp1y - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cp1x: number, cp1y: number, x: number, y: number, smoothing?: number): this\n    {\n        this._ensurePoly();\n\n        const currentPoly = this._currentPoly;\n\n        // ensure distance from last point to first control point is not too small\n\n        // TODO - make this a plugin that people can override..\n        buildAdaptiveQuadratic(\n            this._currentPoly.points,\n            currentPoly.lastX, currentPoly.lastY,\n            cp1x, cp1y, x, y,\n            smoothing,\n        );\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this.endPoly(true);\n\n        return this;\n    }\n\n    /**\n     * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n     * @param path - The `GraphicsPath` object representing the path to add.\n     * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n     * @returns The instance of the current object for chaining.\n     */\n    public addPath(path: GraphicsPath, transform?: Matrix): this\n    {\n        this.endPoly();\n\n        if (transform && !transform.isIdentity())\n        {\n            path = path.clone(true);\n            path.transform(transform);\n        }\n\n        for (let i = 0; i < path.instructions.length; i++)\n        {\n            const instruction = path.instructions[i];\n\n            // Sorry TS! this is the best we could do...\n            this[instruction.action](...(instruction.data as [never, never, never, never, never, never, never]));\n            // build out the path points\n        }\n\n        return this;\n    }\n\n    /**\n     * Finalizes the drawing of the current path. Optionally, it can close the path.\n     * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n     */\n    public finish(closePath = false)\n    {\n        this.endPoly(closePath);\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number, transform?: Matrix): this\n    {\n        this.drawShape(new Rectangle(x, y, w, h), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number, transform?: Matrix): this\n    {\n        this.drawShape(new Circle(x, y, radius), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n     * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public poly(points: number[] | PointData[], close?: boolean, transform?: Matrix): this\n    {\n        const polygon = new Polygon(points);\n\n        polygon.closePath = close;\n\n        this.drawShape(polygon, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation = 0, transform?: Matrix): this\n    {\n        sides = Math.max(sides | 0, 3);\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const delta = (Math.PI * 2) / sides;\n        const polygon = [];\n\n        for (let i = 0; i < sides; i++)\n        {\n            const angle = (i * delta) + startAngle;\n\n            polygon.push(\n                x + (radius * Math.cos(angle)),\n                y + (radius * Math.sin(angle))\n            );\n        }\n\n        this.poly(polygon, true, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(\n        x: number, y: number,\n        radius: number,\n        sides: number, corner: number,\n        rotation = 0,\n        smoothness?: number,\n    ): this\n    {\n        sides = Math.max((sides | 0), 3);\n\n        if (corner <= 0)\n        {\n            return this.regularPoly(x, y, radius, sides, rotation);\n        }\n\n        const sideLength = (radius * Math.sin(Math.PI / sides)) - 0.001;\n\n        corner = Math.min(corner, sideLength);\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const delta = (Math.PI * 2) / sides;\n        const internalAngle = ((sides - 2) * Math.PI) / sides / 2;\n\n        for (let i = 0; i < sides; i++)\n        {\n            const angle = (i * delta) + startAngle;\n            const x0 = x + (radius * Math.cos(angle));\n            const y0 = y + (radius * Math.sin(angle));\n            const a1 = angle + (Math.PI) + internalAngle;\n            const a2 = angle - (Math.PI) - internalAngle;\n            const x1 = x0 + (corner * Math.cos(a1));\n            const y1 = y0 + (corner * Math.sin(a1));\n            const x3 = x0 + (corner * Math.cos(a2));\n            const y3 = y0 + (corner * Math.sin(a2));\n\n            if (i === 0)\n            {\n                this.moveTo(x1, y1);\n            }\n            else\n            {\n                this.lineTo(x1, y1);\n            }\n            this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n        }\n\n        return this.closePath();\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic = false, smoothness?: number): this\n    {\n        if (points.length < 3)\n        {\n            return this;\n        }\n\n        if (useQuadratic)\n        {\n            roundedShapeQuadraticCurve(this, points, radius, smoothness);\n        }\n        else\n        {\n            roundedShapeArc(this, points, radius);\n        }\n\n        return this.closePath();\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this\n    {\n        if (fillet === 0)\n        {\n            return this.rect(x, y, width, height);\n        }\n\n        const maxFillet = Math.min(width, height) / 2;\n        const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n        const right = x + width;\n        const bottom = y + height;\n        const dir = inset < 0 ? -inset : 0;\n        const size = Math.abs(inset);\n\n        return this\n            .moveTo(x, y + size)\n            .arcTo(x + dir, y + dir, x + size, y, size)\n            .lineTo(right - size, y)\n            .arcTo(right - dir, y + dir, right, y + size, size)\n            .lineTo(right, bottom - size)\n            .arcTo(right - dir, bottom - dir, x + width - size, bottom, size)\n            .lineTo(x + size, bottom)\n            .arcTo(x + dir, bottom - dir, x, bottom - size, size)\n            .closePath();\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this\n    {\n        if (chamfer <= 0)\n        {\n            return this.rect(x, y, width, height);\n        }\n\n        const inset = Math.min(chamfer, Math.min(width, height) / 2);\n        const right = x + width;\n        const bottom = y + height;\n        const points = [\n            x + inset, y,\n            right - inset, y,\n            right, y + inset,\n            right, bottom - inset,\n            right - inset, bottom,\n            x + inset, bottom,\n            x, bottom - inset,\n            x, y + inset,\n        ];\n\n        // Remove overlapping points\n        for (let i = points.length - 1; i >= 2; i -= 2)\n        {\n            if (points[i] === points[i - 2] && points[i - 1] === points[i - 3])\n            {\n                points.splice(i - 1, 2);\n            }\n        }\n\n        return this.poly(points, true, transform);\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number, transform?: Matrix): this\n    {\n        // TODO apply rotation to transform...\n\n        this.drawShape(new Ellipse(x, y, radiusX, radiusY), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number, transform?: Matrix): this\n    {\n        this.drawShape(new RoundedRectangle(x, y, w, h, radius), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a given shape on the canvas.\n     * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n     * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n     * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n     * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n     * scaling, and translations.\n     * @returns The instance of the current object for chaining.\n     */\n    public drawShape(shape: ShapePrimitive, matrix?: Matrix): this\n    {\n        this.endPoly();\n\n        this.shapePrimitives.push({ shape, transform: matrix });\n\n        return this;\n    }\n\n    /**\n     * Starts a new polygon path from the specified starting point.\n     * This method initializes a new polygon or ends the current one if it exists.\n     * @param x - The x-coordinate of the starting point of the new polygon.\n     * @param y - The y-coordinate of the starting point of the new polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public startPoly(x: number, y: number): this\n    {\n        let currentPoly = this._currentPoly;\n\n        if (currentPoly)\n        {\n            this.endPoly();\n        }\n\n        currentPoly = new Polygon();\n\n        currentPoly.points.push(x, y);\n\n        this._currentPoly = currentPoly;\n\n        return this;\n    }\n\n    /**\n     * Ends the current polygon path. If `closePath` is set to true,\n     * the path is closed by connecting the last point to the first one.\n     * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n     * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n     *  back to the starting point. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public endPoly(closePath = false): this\n    {\n        const shape = this._currentPoly;\n\n        if (shape && shape.points.length > 2)\n        {\n            shape.closePath = closePath;\n\n            this.shapePrimitives.push({ shape });\n        }\n\n        this._currentPoly = null;\n\n        return this;\n    }\n\n    private _ensurePoly(start = true): void\n    {\n        if (this._currentPoly) return;\n\n        this._currentPoly = new Polygon();\n\n        if (start)\n        {\n            // get last points..\n            const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n\n            if (lastShape)\n            {\n                // i KNOW its a rect..\n                let lx = lastShape.shape.x;\n                let ly = lastShape.shape.y;\n\n                if (!lastShape.transform.isIdentity())\n                {\n                    const t = lastShape.transform;\n\n                    const tempX = lx;\n\n                    lx = (t.a * lx) + (t.c * ly) + t.tx;\n                    ly = (t.b * tempX) + (t.d * ly) + t.ty;\n                }\n\n                this._currentPoly.points.push(lx, ly);\n            }\n            else\n            {\n                this._currentPoly.points.push(0, 0);\n            }\n        }\n    }\n\n    /** Builds the path. */\n    public buildPath()\n    {\n        const path = this._graphicsPath2D;\n\n        this.shapePrimitives.length = 0;\n        this._currentPoly = null;\n\n        for (let i = 0; i < path.instructions.length; i++)\n        {\n            const instruction = path.instructions[i];\n\n            // Sorry TS! this is the best we could do...\n            this[instruction.action](...(instruction.data as [never, never, never, never, never, never, never]));\n        }\n\n        this.finish();\n    }\n\n    /** Gets the bounds of the path. */\n    get bounds(): Bounds\n    {\n        const bounds = this._bounds;\n\n        bounds.clear();\n\n        const shapePrimitives = this.shapePrimitives;\n\n        for (let i = 0; i < shapePrimitives.length; i++)\n        {\n            const shapePrimitive = shapePrimitives[i];\n\n            const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);\n\n            if (shapePrimitive.transform)\n            {\n                bounds.addRect(boundsRect, shapePrimitive.transform);\n            }\n            else\n            {\n                bounds.addRect(boundsRect);\n            }\n        }\n\n        return bounds;\n    }\n}\n","import { Rectangle } from './Rectangle.mjs';\n\n\"use strict\";\nclass Circle {\n  /**\n   * @param x - The X coordinate of the center of this circle\n   * @param y - The Y coordinate of the center of this circle\n   * @param radius - The radius of the circle\n   */\n  constructor(x = 0, y = 0, radius = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'circle'\n     */\n    this.type = \"circle\";\n    this.x = x;\n    this.y = y;\n    this.radius = radius;\n  }\n  /**\n   * Creates a clone of this Circle instance\n   * @returns A copy of the Circle\n   */\n  clone() {\n    return new Circle(this.x, this.y, this.radius);\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this circle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Circle\n   */\n  contains(x, y) {\n    if (this.radius <= 0)\n      return false;\n    const r2 = this.radius * this.radius;\n    let dx = this.x - x;\n    let dy = this.y - y;\n    dx *= dx;\n    dy *= dy;\n    return dx + dy <= r2;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this circle including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param width - The width of the line to check\n   * @returns Whether the x/y coordinates are within this Circle\n   */\n  strokeContains(x, y, width) {\n    if (this.radius === 0)\n      return false;\n    const dx = this.x - x;\n    const dy = this.y - y;\n    const r = this.radius;\n    const w2 = width / 2;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    return distance < r + w2 && distance > r - w2;\n  }\n  /**\n   * Returns the framing rectangle of the circle as a Rectangle object\n   * @param out\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle();\n    out.x = this.x - this.radius;\n    out.y = this.y - this.radius;\n    out.width = this.radius * 2;\n    out.height = this.radius * 2;\n    return out;\n  }\n  /**\n   * Copies another circle to this one.\n   * @param circle - The circle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(circle) {\n    this.x = circle.x;\n    this.y = circle.y;\n    this.radius = circle.radius;\n    return this;\n  }\n  /**\n   * Copies this circle to another one.\n   * @param circle - The circle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(circle) {\n    circle.copyFrom(this);\n    return circle;\n  }\n  toString() {\n    return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;\n  }\n}\n\nexport { Circle };\n//# sourceMappingURL=Circle.mjs.map\n","import { Rectangle } from './Rectangle';\n\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n/**\n * The Circle object is used to help draw graphics and can also be used to specify a hit area for containers.\n * @memberof maths\n */\nexport class Circle implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the center of this circle\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the center of this circle\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The radius of the circle\n     *  @default 0\n     */\n    public radius: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'circle'\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'circle';\n\n    /**\n     * @param x - The X coordinate of the center of this circle\n     * @param y - The Y coordinate of the center of this circle\n     * @param radius - The radius of the circle\n     */\n    constructor(x = 0, y = 0, radius = 0)\n    {\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n    }\n\n    /**\n     * Creates a clone of this Circle instance\n     * @returns A copy of the Circle\n     */\n    public clone(): Circle\n    {\n        return new Circle(this.x, this.y, this.radius);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this circle\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coordinates are within this Circle\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.radius <= 0) return false;\n\n        const r2 = this.radius * this.radius;\n        let dx = (this.x - x);\n        let dy = (this.y - y);\n\n        dx *= dx;\n        dy *= dy;\n\n        return (dx + dy <= r2);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this circle including the stroke.\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param width - The width of the line to check\n     * @returns Whether the x/y coordinates are within this Circle\n     */\n    public strokeContains(x: number, y: number, width: number): boolean\n    {\n        if (this.radius === 0) return false;\n\n        const dx = (this.x - x);\n        const dy = (this.y - y);\n        const r = this.radius;\n        const w2 = width / 2;\n        const distance = Math.sqrt((dx * dx) + (dy * dy));\n\n        return (distance < r + w2 && distance > r - w2);\n    }\n\n    /**\n     * Returns the framing rectangle of the circle as a Rectangle object\n     * @param out\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out = out || new Rectangle();\n\n        out.x = this.x - this.radius;\n        out.y = this.y - this.radius;\n        out.width = this.radius * 2;\n        out.height = this.radius * 2;\n\n        return out;\n    }\n\n    /**\n     * Copies another circle to this one.\n     * @param circle - The circle to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(circle: Circle): this\n    {\n        this.x = circle.x;\n        this.y = circle.y;\n        this.radius = circle.radius;\n\n        return this;\n    }\n\n    /**\n     * Copies this circle to another one.\n     * @param circle - The circle to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(circle: Circle): Circle\n    {\n        circle.copyFrom(this);\n\n        return circle;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;\n    }\n    // #endif\n}\n","import { Rectangle } from './Rectangle.mjs';\n\n\"use strict\";\nclass Ellipse {\n  /**\n   * @param x - The X coordinate of the center of this ellipse\n   * @param y - The Y coordinate of the center of this ellipse\n   * @param halfWidth - The half width of this ellipse\n   * @param halfHeight - The half height of this ellipse\n   */\n  constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'ellipse'\n     */\n    this.type = \"ellipse\";\n    this.x = x;\n    this.y = y;\n    this.halfWidth = halfWidth;\n    this.halfHeight = halfHeight;\n  }\n  /**\n   * Creates a clone of this Ellipse instance\n   * @returns {Ellipse} A copy of the ellipse\n   */\n  clone() {\n    return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this ellipse\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coords are within this ellipse\n   */\n  contains(x, y) {\n    if (this.halfWidth <= 0 || this.halfHeight <= 0) {\n      return false;\n    }\n    let normx = (x - this.x) / this.halfWidth;\n    let normy = (y - this.y) / this.halfHeight;\n    normx *= normx;\n    normy *= normy;\n    return normx + normy <= 1;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this ellipse including stroke\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param width\n   * @returns Whether the x/y coords are within this ellipse\n   */\n  strokeContains(x, y, width) {\n    const { halfWidth, halfHeight } = this;\n    if (halfWidth <= 0 || halfHeight <= 0) {\n      return false;\n    }\n    const halfStrokeWidth = width / 2;\n    const innerA = halfWidth - halfStrokeWidth;\n    const innerB = halfHeight - halfStrokeWidth;\n    const outerA = halfWidth + halfStrokeWidth;\n    const outerB = halfHeight + halfStrokeWidth;\n    const normalizedX = x - this.x;\n    const normalizedY = y - this.y;\n    const innerEllipse = normalizedX * normalizedX / (innerA * innerA) + normalizedY * normalizedY / (innerB * innerB);\n    const outerEllipse = normalizedX * normalizedX / (outerA * outerA) + normalizedY * normalizedY / (outerB * outerB);\n    return innerEllipse > 1 && outerEllipse <= 1;\n  }\n  /**\n   * Returns the framing rectangle of the ellipse as a Rectangle object\n   * @returns The framing rectangle\n   */\n  getBounds() {\n    return new Rectangle(this.x - this.halfWidth, this.y - this.halfHeight, this.halfWidth * 2, this.halfHeight * 2);\n  }\n  /**\n   * Copies another ellipse to this one.\n   * @param ellipse - The ellipse to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(ellipse) {\n    this.x = ellipse.x;\n    this.y = ellipse.y;\n    this.halfWidth = ellipse.halfWidth;\n    this.halfHeight = ellipse.halfHeight;\n    return this;\n  }\n  /**\n   * Copies this ellipse to another one.\n   * @param ellipse - The ellipse to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(ellipse) {\n    ellipse.copyFrom(this);\n    return ellipse;\n  }\n  toString() {\n    return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;\n  }\n}\n\nexport { Ellipse };\n//# sourceMappingURL=Ellipse.mjs.map\n","import { Rectangle } from './Rectangle';\n\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n/**\n * The Ellipse object is used to help draw graphics and can also be used to specify a hit area for containers.\n * ```js\n * import { Ellipse } from 'pixi.js';\n *\n * const ellipse = new Ellipse(0, 0, 20, 10); // 40x20 rectangle\n * const isPointInEllipse = ellipse.contains(0, 0); // true\n * ```\n * @memberof maths\n */\nexport class Ellipse implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the center of this ellipse\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the center of this ellipse\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The half width of this ellipse\n     * @default 0\n     */\n    public halfWidth: number;\n\n    /**\n     * The half height of this ellipse\n     * @default 0\n     */\n    public halfHeight: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'ellipse'\n     */\n    public readonly type = 'ellipse';\n\n    /**\n     * @param x - The X coordinate of the center of this ellipse\n     * @param y - The Y coordinate of the center of this ellipse\n     * @param halfWidth - The half width of this ellipse\n     * @param halfHeight - The half height of this ellipse\n     */\n    constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0)\n    {\n        this.x = x;\n        this.y = y;\n        this.halfWidth = halfWidth;\n        this.halfHeight = halfHeight;\n    }\n\n    /**\n     * Creates a clone of this Ellipse instance\n     * @returns {Ellipse} A copy of the ellipse\n     */\n    public clone(): Ellipse\n    {\n        return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this ellipse\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coords are within this ellipse\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.halfWidth <= 0 || this.halfHeight <= 0)\n        {\n            return false;\n        }\n\n        // normalize the coords to an ellipse with center 0,0\n        let normx = ((x - this.x) / this.halfWidth);\n        let normy = ((y - this.y) / this.halfHeight);\n\n        normx *= normx;\n        normy *= normy;\n\n        return (normx + normy <= 1);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this ellipse including stroke\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param width\n     * @returns Whether the x/y coords are within this ellipse\n     */\n    public strokeContains(x: number, y: number, width: number): boolean\n    {\n        const { halfWidth, halfHeight } = this;\n\n        if (halfWidth <= 0 || halfHeight <= 0)\n        {\n            return false;\n        }\n\n        const halfStrokeWidth = width / 2;\n        const innerA = halfWidth - halfStrokeWidth;\n        const innerB = halfHeight - halfStrokeWidth;\n        const outerA = halfWidth + halfStrokeWidth;\n        const outerB = halfHeight + halfStrokeWidth;\n\n        const normalizedX = x - this.x;\n        const normalizedY = y - this.y;\n\n        const innerEllipse = ((normalizedX * normalizedX) / (innerA * innerA))\n                           + ((normalizedY * normalizedY) / (innerB * innerB));\n        const outerEllipse = ((normalizedX * normalizedX) / (outerA * outerA))\n                           + ((normalizedY * normalizedY) / (outerB * outerB));\n\n        return innerEllipse > 1 && outerEllipse <= 1;\n    }\n\n    /**\n     * Returns the framing rectangle of the ellipse as a Rectangle object\n     * @returns The framing rectangle\n     */\n    public getBounds(): Rectangle\n    {\n        return new Rectangle(this.x - this.halfWidth, this.y - this.halfHeight, this.halfWidth * 2, this.halfHeight * 2);\n    }\n\n    /**\n     * Copies another ellipse to this one.\n     * @param ellipse - The ellipse to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(ellipse: Ellipse): this\n    {\n        this.x = ellipse.x;\n        this.y = ellipse.y;\n        this.halfWidth = ellipse.halfWidth;\n        this.halfHeight = ellipse.halfHeight;\n\n        return this;\n    }\n\n    /**\n     * Copies this ellipse to another one.\n     * @param ellipse - The ellipse to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(ellipse: Ellipse): Ellipse\n    {\n        ellipse.copyFrom(this);\n\n        return ellipse;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;\n    }\n    // #endif\n}\n","import { squaredDistanceToLineSegment } from '../misc/squaredDistanceToLineSegment.mjs';\nimport { Rectangle } from './Rectangle.mjs';\n\n\"use strict\";\nclass Polygon {\n  /**\n   * @param points - This can be an array of Points\n   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n   *  the arguments passed can be all the points of the polygon e.g.\n   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat\n   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n   */\n  constructor(...points) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'polygon'\n     */\n    this.type = \"polygon\";\n    let flat = Array.isArray(points[0]) ? points[0] : points;\n    if (typeof flat[0] !== \"number\") {\n      const p = [];\n      for (let i = 0, il = flat.length; i < il; i++) {\n        p.push(flat[i].x, flat[i].y);\n      }\n      flat = p;\n    }\n    this.points = flat;\n    this.closePath = true;\n  }\n  /**\n   * Creates a clone of this polygon.\n   * @returns - A copy of the polygon.\n   */\n  clone() {\n    const points = this.points.slice();\n    const polygon = new Polygon(points);\n    polygon.closePath = this.closePath;\n    return polygon;\n  }\n  /**\n   * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this polygon.\n   */\n  contains(x, y) {\n    let inside = false;\n    const length = this.points.length / 2;\n    for (let i = 0, j = length - 1; i < length; j = i++) {\n      const xi = this.points[i * 2];\n      const yi = this.points[i * 2 + 1];\n      const xj = this.points[j * 2];\n      const yj = this.points[j * 2 + 1];\n      const intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;\n      if (intersect) {\n        inside = !inside;\n      }\n    }\n    return inside;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this polygon including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this polygon\n   */\n  strokeContains(x, y, strokeWidth) {\n    const halfStrokeWidth = strokeWidth / 2;\n    const halfStrokeWidthSqrd = halfStrokeWidth * halfStrokeWidth;\n    const { points } = this;\n    for (let i = 0; i < points.length; i += 2) {\n      const x1 = points[i];\n      const y1 = points[i + 1];\n      const x2 = points[(i + 2) % points.length];\n      const y2 = points[(i + 3) % points.length];\n      const distanceSqrd = squaredDistanceToLineSegment(x, y, x1, y1, x2, y2);\n      if (distanceSqrd <= halfStrokeWidthSqrd) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Returns the framing rectangle of the polygon as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle();\n    const points = this.points;\n    let minX = Infinity;\n    let maxX = -Infinity;\n    let minY = Infinity;\n    let maxY = -Infinity;\n    for (let i = 0, n = points.length; i < n; i += 2) {\n      const x = points[i];\n      const y = points[i + 1];\n      minX = x < minX ? x : minX;\n      maxX = x > maxX ? x : maxX;\n      minY = y < minY ? y : minY;\n      maxY = y > maxY ? y : maxY;\n    }\n    out.x = minX;\n    out.width = maxX - minX;\n    out.y = minY;\n    out.height = maxY - minY;\n    return out;\n  }\n  /**\n   * Copies another polygon to this one.\n   * @param polygon - The polygon to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(polygon) {\n    this.points = polygon.points.slice();\n    this.closePath = polygon.closePath;\n    return this;\n  }\n  /**\n   * Copies this polygon to another one.\n   * @param polygon - The polygon to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(polygon) {\n    polygon.copyFrom(this);\n    return polygon;\n  }\n  toString() {\n    return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, \"\")}]`;\n  }\n  /**\n   * Get the last X coordinate of the polygon\n   * @readonly\n   */\n  get lastX() {\n    return this.points[this.points.length - 2];\n  }\n  /**\n   * Get the last Y coordinate of the polygon\n   * @readonly\n   */\n  get lastY() {\n    return this.points[this.points.length - 1];\n  }\n  /**\n   * Get the first X coordinate of the polygon\n   * @readonly\n   */\n  get x() {\n    return this.points[this.points.length - 2];\n  }\n  /**\n   * Get the first Y coordinate of the polygon\n   * @readonly\n   */\n  get y() {\n    return this.points[this.points.length - 1];\n  }\n}\n\nexport { Polygon };\n//# sourceMappingURL=Polygon.mjs.map\n","import { squaredDistanceToLineSegment } from '../misc/squaredDistanceToLineSegment';\nimport { Rectangle } from './Rectangle';\n\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { PointData } from '../point/PointData';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n/**\n * A class to define a shape via user defined coordinates.\n *\n *\n * `Polygon` can accept the following different constructor arguments:\n * - An array of `Point` objects\n * - An array of coordinate pairs\n *\n *\n * These can be passed as a single array, or as a sequence of arguments.\n * ```js\n * import { Polygon } from 'pixi.js';\n *\n * // create a polygon object from an array of points, or an array of coordinate pairs\n * const polygon1 = new Polygon([ new Point(0, 0), new Point(0, 100), new Point(100, 100) ]);\n * const polygon2 = new Polygon([ 0, 0, 0, 100, 100, 100 ]);\n *\n * // or create a polygon object from a sequence of points, or coordinate pairs\n * const polygon3 = new Polygon(new Point(0, 0), new Point(0, 100), new Point(100, 100));\n * const polygon4 = new Polygon(0, 0, 0, 100, 100, 100);\n * ```\n * @memberof maths\n */\nexport class Polygon implements ShapePrimitive\n{\n    /** An array of the points of this polygon. */\n    public points: number[];\n\n    /** `false` after moveTo, `true` after `closePath`. In all other cases it is `true`. */\n    public closePath: boolean;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'polygon'\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'polygon';\n\n    constructor(points: PointData[] | number[]);\n    constructor(...points: PointData[] | number[]);\n    /**\n     * @param points - This can be an array of Points\n     *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n     *  the arguments passed can be all the points of the polygon e.g.\n     *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat\n     *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n     */\n    constructor(...points: (PointData[] | number[])[] | PointData[] | number[])\n    {\n        let flat = Array.isArray(points[0]) ? points[0] : points;\n\n        // if this is an array of points, convert it to a flat array of numbers\n        if (typeof flat[0] !== 'number')\n        {\n            const p: number[] = [];\n\n            for (let i = 0, il = flat.length; i < il; i++)\n            {\n                p.push((flat[i] as PointData).x, (flat[i] as PointData).y);\n            }\n\n            flat = p;\n        }\n\n        this.points = flat as number[];\n\n        this.closePath = true;\n    }\n\n    /**\n     * Creates a clone of this polygon.\n     * @returns - A copy of the polygon.\n     */\n    public clone(): Polygon\n    {\n        const points = this.points.slice();\n        const polygon = new Polygon(points);\n\n        polygon.closePath = this.closePath;\n\n        return polygon;\n    }\n\n    /**\n     * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n     * @param x - The X coordinate of the point to test.\n     * @param y - The Y coordinate of the point to test.\n     * @returns - Whether the x/y coordinates are within this polygon.\n     */\n    public contains(x: number, y: number): boolean\n    {\n        let inside = false;\n\n        // use some raycasting to test hits\n        // https://github.com/substack/point-in-polygon/blob/master/index.js\n        const length = this.points.length / 2;\n\n        for (let i = 0, j = length - 1; i < length; j = i++)\n        {\n            const xi = this.points[i * 2];\n            const yi = this.points[(i * 2) + 1];\n            const xj = this.points[j * 2];\n            const yj = this.points[(j * 2) + 1];\n            const intersect = ((yi > y) !== (yj > y)) && (x < ((xj - xi) * ((y - yi) / (yj - yi))) + xi);\n\n            if (intersect)\n            {\n                inside = !inside;\n            }\n        }\n\n        return inside;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this polygon including the stroke.\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @returns Whether the x/y coordinates are within this polygon\n     */\n    public strokeContains(x: number, y: number, strokeWidth: number): boolean\n    {\n        const halfStrokeWidth = strokeWidth / 2;\n        const halfStrokeWidthSqrd = halfStrokeWidth * halfStrokeWidth;\n        const { points } = this;\n\n        for (let i = 0; i < points.length; i += 2)\n        {\n            const x1 = points[i];\n            const y1 = points[i + 1];\n            const x2 = points[(i + 2) % points.length];\n            const y2 = points[(i + 3) % points.length];\n\n            const distanceSqrd = squaredDistanceToLineSegment(x, y, x1, y1, x2, y2);\n\n            if (distanceSqrd <= halfStrokeWidthSqrd)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns the framing rectangle of the polygon as a Rectangle object\n     * @param out - optional rectangle to store the result\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out = out || new Rectangle();\n\n        const points = this.points;\n\n        let minX = Infinity;\n        let maxX = -Infinity;\n\n        let minY = Infinity;\n        let maxY = -Infinity;\n\n        for (let i = 0, n = points.length; i < n; i += 2)\n        {\n            const x = points[i];\n            const y = points[i + 1];\n\n            minX = x < minX ? x : minX;\n            maxX = x > maxX ? x : maxX;\n\n            minY = y < minY ? y : minY;\n            maxY = y > maxY ? y : maxY;\n        }\n\n        out.x = minX;\n        out.width = maxX - minX;\n\n        out.y = minY;\n        out.height = maxY - minY;\n\n        return out;\n    }\n\n    /**\n     * Copies another polygon to this one.\n     * @param polygon - The polygon to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(polygon: Polygon): this\n    {\n        this.points = polygon.points.slice();\n        this.closePath = polygon.closePath;\n\n        return this;\n    }\n\n    /**\n     * Copies this polygon to another one.\n     * @param polygon - The polygon to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(polygon: Polygon): Polygon\n    {\n        polygon.copyFrom(this);\n\n        return polygon;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Polygon`\n            + `closeStroke=${this.closePath}`\n            + `points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, '')}]`;\n    }\n    // #endif\n\n    /**\n     * Get the last X coordinate of the polygon\n     * @readonly\n     */\n    get lastX(): number\n    {\n        return this.points[this.points.length - 2];\n    }\n\n    /**\n     * Get the last Y coordinate of the polygon\n     * @readonly\n     */\n    get lastY(): number\n    {\n        return this.points[this.points.length - 1];\n    }\n\n    /**\n     * Get the first X coordinate of the polygon\n     * @readonly\n     */\n    get x(): number\n    {\n        return this.points[this.points.length - 2];\n    }\n    /**\n     * Get the first Y coordinate of the polygon\n     * @readonly\n     */\n    get y(): number\n    {\n        return this.points[this.points.length - 1];\n    }\n}\n\n","\"use strict\";\nfunction squaredDistanceToLineSegment(x, y, x1, y1, x2, y2) {\n  const a = x - x1;\n  const b = y - y1;\n  const c = x2 - x1;\n  const d = y2 - y1;\n  const dot = a * c + b * d;\n  const lenSq = c * c + d * d;\n  let param = -1;\n  if (lenSq !== 0) {\n    param = dot / lenSq;\n  }\n  let xx;\n  let yy;\n  if (param < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (param > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + param * c;\n    yy = y1 + param * d;\n  }\n  const dx = x - xx;\n  const dy = y - yy;\n  return dx * dx + dy * dy;\n}\n\nexport { squaredDistanceToLineSegment };\n//# sourceMappingURL=squaredDistanceToLineSegment.mjs.map\n","export function squaredDistanceToLineSegment(\n    x: number, y: number,\n    x1: number, y1: number,\n    x2: number, y2: number\n): number\n{\n    const a = x - x1;\n    const b = y - y1;\n    const c = x2 - x1;\n    const d = y2 - y1;\n\n    const dot = (a * c) + (b * d);\n    const lenSq = (c * c) + (d * d);\n    let param = -1;\n\n    if (lenSq !== 0)\n    {\n        param = dot / lenSq;\n    }\n\n    let xx; let\n        yy;\n\n    if (param < 0)\n    {\n        xx = x1;\n        yy = y1;\n    }\n    else if (param > 1)\n    {\n        xx = x2;\n        yy = y2;\n    }\n\n    else\n    {\n        xx = x1 + (param * c);\n        yy = y1 + (param * d);\n    }\n\n    const dx = x - xx;\n    const dy = y - yy;\n\n    return (dx * dx) + (dy * dy);\n}\n","import { Rectangle } from './Rectangle.mjs';\n\n\"use strict\";\nconst isCornerWithinStroke = (pX, pY, cornerX, cornerY, radius, halfStrokeWidth) => {\n  const dx = pX - cornerX;\n  const dy = pY - cornerY;\n  const distance = Math.sqrt(dx * dx + dy * dy);\n  return distance >= radius - halfStrokeWidth && distance <= radius + halfStrokeWidth;\n};\nclass RoundedRectangle {\n  /**\n   * @param x - The X coordinate of the upper-left corner of the rounded rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\n   * @param width - The overall width of this rounded rectangle\n   * @param height - The overall height of this rounded rectangle\n   * @param radius - Controls the radius of the rounded corners\n   */\n  constructor(x = 0, y = 0, width = 0, height = 0, radius = 20) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'roundedRectangle'\n     */\n    this.type = \"roundedRectangle\";\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.radius = radius;\n  }\n  /**\n   * Returns the framing rectangle of the rounded rectangle as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle();\n    out.x = this.x;\n    out.y = this.y;\n    out.width = this.width;\n    out.height = this.height;\n    return out;\n  }\n  /**\n   * Creates a clone of this Rounded Rectangle.\n   * @returns - A copy of the rounded rectangle.\n   */\n  clone() {\n    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);\n  }\n  /**\n   * Copies another rectangle to this one.\n   * @param rectangle - The rectangle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(rectangle) {\n    this.x = rectangle.x;\n    this.y = rectangle.y;\n    this.width = rectangle.width;\n    this.height = rectangle.height;\n    return this;\n  }\n  /**\n   * Copies this rectangle to another one.\n   * @param rectangle - The rectangle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(rectangle) {\n    rectangle.copyFrom(this);\n    return rectangle;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this Rounded Rectangle.\n   */\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    if (x >= this.x && x <= this.x + this.width) {\n      if (y >= this.y && y <= this.y + this.height) {\n        const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n        if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius) {\n          return true;\n        }\n        let dx = x - (this.x + radius);\n        let dy = y - (this.y + radius);\n        const radius2 = radius * radius;\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dx = x - (this.x + this.width - radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dy = y - (this.y + this.height - radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dx = x - (this.x + radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n   * @param pX - The X coordinate of the point to test\n   * @param pY - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this rectangle\n   */\n  strokeContains(pX, pY, strokeWidth) {\n    const { x, y, width, height, radius } = this;\n    const halfStrokeWidth = strokeWidth / 2;\n    const innerX = x + radius;\n    const innerY = y + radius;\n    const innerWidth = width - radius * 2;\n    const innerHeight = height - radius * 2;\n    const rightBound = x + width;\n    const bottomBound = y + height;\n    if ((pX >= x - halfStrokeWidth && pX <= x + halfStrokeWidth || pX >= rightBound - halfStrokeWidth && pX <= rightBound + halfStrokeWidth) && pY >= innerY && pY <= innerY + innerHeight) {\n      return true;\n    }\n    if ((pY >= y - halfStrokeWidth && pY <= y + halfStrokeWidth || pY >= bottomBound - halfStrokeWidth && pY <= bottomBound + halfStrokeWidth) && pX >= innerX && pX <= innerX + innerWidth) {\n      return true;\n    }\n    return (\n      // Top-left\n      pX < innerX && pY < innerY && isCornerWithinStroke(pX, pY, innerX, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY < innerY && isCornerWithinStroke(pX, pY, rightBound - radius, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius, radius, halfStrokeWidth) || pX < innerX && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, innerX, bottomBound - radius, radius, halfStrokeWidth)\n    );\n  }\n  toString() {\n    return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;\n  }\n}\n\nexport { RoundedRectangle };\n//# sourceMappingURL=RoundedRectangle.mjs.map\n","import { Rectangle } from './Rectangle';\n\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n// Check corner within stroke width\nconst isCornerWithinStroke = (\n    pX: number,\n    pY: number,\n    cornerX: number,\n    cornerY: number,\n    radius: number,\n    halfStrokeWidth: number\n) =>\n{\n    const dx = pX - cornerX;\n    const dy = pY - cornerY;\n    const distance = Math.sqrt((dx * dx) + (dy * dy));\n\n    return distance >= radius - halfStrokeWidth && distance <= radius + halfStrokeWidth;\n};\n\n/**\n * The `RoundedRectangle` object is an area defined by its position, as indicated by its top-left corner\n * point (`x`, `y`) and by its `width` and its `height`, including a `radius` property that\n * defines the radius of the rounded corners.\n * @memberof maths\n */\nexport class RoundedRectangle implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the upper-left corner of the rounded rectangle\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the upper-left corner of the rounded rectangle\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The overall width of this rounded rectangle\n     * @default 0\n     */\n    public width: number;\n\n    /**\n     * The overall height of this rounded rectangle\n     * @default 0\n     */\n    public height: number;\n\n    /**\n     * Controls the radius of the rounded corners\n     * @default 20\n     */\n    public radius: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'roundedRectangle'\n     */\n    public readonly type = 'roundedRectangle';\n\n    /**\n     * @param x - The X coordinate of the upper-left corner of the rounded rectangle\n     * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\n     * @param width - The overall width of this rounded rectangle\n     * @param height - The overall height of this rounded rectangle\n     * @param radius - Controls the radius of the rounded corners\n     */\n    constructor(x = 0, y = 0, width = 0, height = 0, radius = 20)\n    {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.radius = radius;\n    }\n\n    /**\n     * Returns the framing rectangle of the rounded rectangle as a Rectangle object\n     * @param out - optional rectangle to store the result\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out = out || new Rectangle();\n\n        out.x = this.x;\n        out.y = this.y;\n        out.width = this.width;\n        out.height = this.height;\n\n        return out;\n    }\n\n    /**\n     * Creates a clone of this Rounded Rectangle.\n     * @returns - A copy of the rounded rectangle.\n     */\n    public clone(): RoundedRectangle\n    {\n        return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);\n    }\n\n    /**\n     * Copies another rectangle to this one.\n     * @param rectangle - The rectangle to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(rectangle: RoundedRectangle): this\n    {\n        this.x = rectangle.x;\n        this.y = rectangle.y;\n        this.width = rectangle.width;\n        this.height = rectangle.height;\n\n        return this;\n    }\n\n    /**\n     * Copies this rectangle to another one.\n     * @param rectangle - The rectangle to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(rectangle: RoundedRectangle): RoundedRectangle\n    {\n        rectangle.copyFrom(this);\n\n        return rectangle;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n     * @param x - The X coordinate of the point to test.\n     * @param y - The Y coordinate of the point to test.\n     * @returns - Whether the x/y coordinates are within this Rounded Rectangle.\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.width <= 0 || this.height <= 0)\n        {\n            return false;\n        }\n        if (x >= this.x && x <= this.x + this.width)\n        {\n            if (y >= this.y && y <= this.y + this.height)\n            {\n                const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n\n                if ((y >= this.y + radius && y <= this.y + this.height - radius)\n                || (x >= this.x + radius && x <= this.x + this.width - radius))\n                {\n                    return true;\n                }\n                let dx = x - (this.x + radius);\n                let dy = y - (this.y + radius);\n                const radius2 = radius * radius;\n\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dx = x - (this.x + this.width - radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dy = y - (this.y + this.height - radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dx = x - (this.x + radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n     * @param pX - The X coordinate of the point to test\n     * @param pY - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @returns Whether the x/y coordinates are within this rectangle\n     */\n    public strokeContains(pX: number, pY: number, strokeWidth: number): boolean\n    {\n        const { x, y, width, height, radius } = this;\n\n        const halfStrokeWidth = strokeWidth / 2;\n        const innerX = x + radius;\n        const innerY = y + radius;\n        const innerWidth = width - (radius * 2);\n        const innerHeight = height - (radius * 2);\n        const rightBound = x + width;\n        const bottomBound = y + height;\n\n        // Check if point is within the vertical edges (excluding corners)\n        if (((pX >= x - halfStrokeWidth && pX <= x + halfStrokeWidth)\n             || (pX >= rightBound - halfStrokeWidth && pX <= rightBound + halfStrokeWidth))\n            && pY >= innerY && pY <= innerY + innerHeight)\n        {\n            return true;\n        }\n\n        // Check if point is within the horizontal edges (excluding corners)\n        if (((pY >= y - halfStrokeWidth && pY <= y + halfStrokeWidth)\n             || (pY >= bottomBound - halfStrokeWidth && pY <= bottomBound + halfStrokeWidth))\n            && pX >= innerX && pX <= innerX + innerWidth)\n        {\n            return true;\n        }\n\n        // Top-left, top-right, bottom-right, bottom-left corners\n        return (\n            // Top-left\n            (pX < innerX && pY < innerY\n                && isCornerWithinStroke(pX, pY, innerX, innerY, radius, halfStrokeWidth))\n            //  top-right\n            || (pX > rightBound - radius && pY < innerY\n                && isCornerWithinStroke(pX, pY, rightBound - radius, innerY, radius, halfStrokeWidth))\n            // bottom-right\n            || (pX > rightBound - radius && pY > bottomBound - radius\n                && isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius, radius, halfStrokeWidth))\n            // bottom-left\n            || (pX < innerX && pY > bottomBound - radius\n                && isCornerWithinStroke(pX, pY, innerX, bottomBound - radius, radius, halfStrokeWidth)));\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}`\n            + `width=${this.width} height=${this.height} radius=${this.radius}]`;\n    }\n    // #endif\n}\n","import { GraphicsContextSystem } from '../GraphicsContextSystem.mjs';\n\n\"use strict\";\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 11920929e-14;\nconst PATH_DISTANCE_EPSILON = 1;\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nconst mCuspLimit = 0;\nfunction buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {\n  const scale = 1;\n  const smoothing = Math.min(\n    0.99,\n    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n  );\n  let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n  distanceTolerance *= distanceTolerance;\n  begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);\n  return points;\n}\nfunction begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {\n  recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);\n  points.push(eX, eY);\n}\nfunction recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {\n  if (level > RECURSION_LIMIT) {\n    return;\n  }\n  const pi = Math.PI;\n  const x12 = (x1 + x2) / 2;\n  const y12 = (y1 + y2) / 2;\n  const x23 = (x2 + x3) / 2;\n  const y23 = (y2 + y3) / 2;\n  const x34 = (x3 + x4) / 2;\n  const y34 = (y3 + y4) / 2;\n  const x123 = (x12 + x23) / 2;\n  const y123 = (y12 + y23) / 2;\n  const x234 = (x23 + x34) / 2;\n  const y234 = (y23 + y34) / 2;\n  const x1234 = (x123 + x234) / 2;\n  const y1234 = (y123 + y234) / 2;\n  if (level > 0) {\n    let dx = x4 - x1;\n    let dy = y4 - y1;\n    const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);\n    const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);\n    let da1;\n    let da2;\n    if (d2 > FLT_EPSILON && d3 > FLT_EPSILON) {\n      if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        const a23 = Math.atan2(y3 - y2, x3 - x2);\n        da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));\n        da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da2 >= pi)\n          da2 = 2 * pi - da2;\n        if (da1 + da2 < mAngleTolerance) {\n          points.push(x1234, y1234);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x2, y2);\n            return;\n          }\n          if (da2 > mCuspLimit) {\n            points.push(x3, y3);\n            return;\n          }\n        }\n      }\n    } else if (d2 > FLT_EPSILON) {\n      if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da1 < mAngleTolerance) {\n          points.push(x2, y2);\n          points.push(x3, y3);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x2, y2);\n            return;\n          }\n        }\n      }\n    } else if (d3 > FLT_EPSILON) {\n      if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da1 < mAngleTolerance) {\n          points.push(x2, y2);\n          points.push(x3, y3);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x3, y3);\n            return;\n          }\n        }\n      }\n    } else {\n      dx = x1234 - (x1 + x4) / 2;\n      dy = y1234 - (y1 + y4) / 2;\n      if (dx * dx + dy * dy <= distanceTolerance) {\n        points.push(x1234, y1234);\n        return;\n      }\n    }\n  }\n  recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);\n  recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);\n}\n\nexport { buildAdaptiveBezier };\n//# sourceMappingURL=buildAdaptiveBezier.mjs.map\n","// thanks to https://github.com/mattdesl/adaptive-bezier-curve\n// for the original code!\n\nimport { GraphicsContextSystem } from '../GraphicsContextSystem';\n\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 1.19209290e-7;\nconst PATH_DISTANCE_EPSILON = 1.0;\n\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nconst mCuspLimit = 0;\n\nexport function buildAdaptiveBezier(\n    points: number[],\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    cp2x: number, cp2y: number,\n    eX: number, eY: number,\n    smoothness?: number,\n)\n{\n    // TODO expose as a parameter\n    const scale = 1;\n    const smoothing = Math.min(\n        0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n        Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n    );\n    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n\n    distanceTolerance *= distanceTolerance;\n    begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);\n\n    return points;\n}\n\n// //// Based on:\n// //// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp\n\nfunction begin(\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    cp2x: number, cp2y: number,\n    eX: number, eY: number,\n    points: number[],\n    distanceTolerance: number\n)\n{\n    // dont need to actually ad this!\n    // points.push(sX, sY);\n    recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);\n    points.push(eX, eY);\n}\n\n// eslint-disable-next-line max-params\nfunction recursive(\n    x1: number, y1: number,\n    x2: number, y2: number,\n    x3: number, y3: number,\n    x4: number, y4: number,\n    points: number[],\n    distanceTolerance: number,\n    level: number)\n{\n    if (level > RECURSION_LIMIT)\n    { return; }\n\n    const pi = Math.PI;\n\n    // Calculate all the mid-points of the line segments\n    // ----------------------\n    const x12 = (x1 + x2) / 2;\n    const y12 = (y1 + y2) / 2;\n    const x23 = (x2 + x3) / 2;\n    const y23 = (y2 + y3) / 2;\n    const x34 = (x3 + x4) / 2;\n    const y34 = (y3 + y4) / 2;\n    const x123 = (x12 + x23) / 2;\n    const y123 = (y12 + y23) / 2;\n    const x234 = (x23 + x34) / 2;\n    const y234 = (y23 + y34) / 2;\n    const x1234 = (x123 + x234) / 2;\n    const y1234 = (y123 + y234) / 2;\n\n    if (level > 0)\n    { // Enforce subdivision first time\n        // Try to approximate the full cubic curve by a single straight line\n        // ------------------\n        let dx = x4 - x1;\n        let dy = y4 - y1;\n\n        const d2 = Math.abs(((x2 - x4) * dy) - ((y2 - y4) * dx));\n        const d3 = Math.abs(((x3 - x4) * dy) - ((y3 - y4) * dx));\n\n        let da1; let da2;\n\n        if (d2 > FLT_EPSILON && d3 > FLT_EPSILON)\n        {\n            // Regular care\n            // -----------------\n            if ((d2 + d3) * (d2 + d3) <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                // If the curvature doesn't exceed the distanceTolerance value\n                // we tend to finish subdivisions.\n                // ----------------------\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle & Cusp Condition\n                // ----------------------\n                const a23 = Math.atan2(y3 - y2, x3 - x2);\n\n                da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));\n                da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n                if (da2 >= pi) da2 = (2 * pi) - da2;\n\n                if (da1 + da2 < mAngleTolerance)\n                {\n                    // Finally we can stop the recursion\n                    // ----------------------\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x2, y2);\n\n                        return;\n                    }\n\n                    if (da2 > mCuspLimit)\n                    {\n                        points.push(x3, y3);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else if (d2 > FLT_EPSILON)\n        {\n            // p1,p3,p4 are collinear, p2 is considerable\n            // ----------------------\n            if (d2 * d2 <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle Condition\n                // ----------------------\n                da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n\n                if (da1 < mAngleTolerance)\n                {\n                    points.push(x2, y2);\n                    points.push(x3, y3);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x2, y2);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else if (d3 > FLT_EPSILON)\n        {\n            // p1,p2,p4 are collinear, p3 is considerable\n            // ----------------------\n            if (d3 * d3 <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle Condition\n                // ----------------------\n                da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n\n                if (da1 < mAngleTolerance)\n                {\n                    points.push(x2, y2);\n                    points.push(x3, y3);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x3, y3);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else\n        {\n            // Collinear case\n            // -----------------\n            dx = x1234 - ((x1 + x4) / 2);\n            dy = y1234 - ((y1 + y4) / 2);\n            if ((dx * dx) + (dy * dy) <= distanceTolerance)\n            {\n                points.push(x1234, y1234);\n\n                return;\n            }\n        }\n    }\n\n    // Continue subdivision\n    // ----------------------\n    recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);\n    recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);\n}\n\n","import { GraphicsContextSystem } from '../GraphicsContextSystem.mjs';\n\n\"use strict\";\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 11920929e-14;\nconst PATH_DISTANCE_EPSILON = 1;\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nfunction buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {\n  const scale = 1;\n  const smoothing = Math.min(\n    0.99,\n    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n  );\n  let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n  distanceTolerance *= distanceTolerance;\n  begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);\n  return points;\n}\nfunction begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {\n  recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);\n  points.push(eX, eY);\n}\nfunction recursive(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {\n  if (level > RECURSION_LIMIT) {\n    return;\n  }\n  const pi = Math.PI;\n  const x12 = (x1 + x2) / 2;\n  const y12 = (y1 + y2) / 2;\n  const x23 = (x2 + x3) / 2;\n  const y23 = (y2 + y3) / 2;\n  const x123 = (x12 + x23) / 2;\n  const y123 = (y12 + y23) / 2;\n  let dx = x3 - x1;\n  let dy = y3 - y1;\n  const d = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);\n  if (d > FLT_EPSILON) {\n    if (d * d <= distanceTolerance * (dx * dx + dy * dy)) {\n      if (mAngleTolerance < curveAngleToleranceEpsilon) {\n        points.push(x123, y123);\n        return;\n      }\n      let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n      if (da >= pi)\n        da = 2 * pi - da;\n      if (da < mAngleTolerance) {\n        points.push(x123, y123);\n        return;\n      }\n    }\n  } else {\n    dx = x123 - (x1 + x3) / 2;\n    dy = y123 - (y1 + y3) / 2;\n    if (dx * dx + dy * dy <= distanceTolerance) {\n      points.push(x123, y123);\n      return;\n    }\n  }\n  recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);\n  recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);\n}\n\nexport { buildAdaptiveQuadratic };\n//# sourceMappingURL=buildAdaptiveQuadratic.mjs.map\n","// thanks to https://github.com/mattdesl/adaptive-quadratic-curve\n// for the original code!\n\nimport { GraphicsContextSystem } from '../GraphicsContextSystem';\n\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 1.19209290e-7;\nconst PATH_DISTANCE_EPSILON = 1.0;\n\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\n\nexport function buildAdaptiveQuadratic(\n    points: number[],\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    eX: number, eY: number,\n    smoothness?: number,\n)\n{\n    const scale = 1.0;\n    const smoothing = Math.min(\n        0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n        Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n    );\n    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n\n    distanceTolerance *= distanceTolerance;\n    begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);\n\n    return points;\n}\n\n// //// Based on:\n// //// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp\n\nfunction begin(\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    eX: number, eY: number,\n    points: number[],\n    distanceTolerance: number\n)\n{\n    recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);\n\n    points.push(eX, eY);\n}\n\nfunction recursive(\n    points: number[],\n    x1: number, y1: number,\n    x2: number, y2: number,\n    x3: number, y3: number,\n    distanceTolerance: number,\n    level: number\n)\n{\n    if (level > RECURSION_LIMIT)\n    { return; }\n\n    const pi = Math.PI;\n\n    // Calculate all the mid-points of the line segments\n    // ----------------------\n    const x12 = (x1 + x2) / 2;\n    const y12 = (y1 + y2) / 2;\n    const x23 = (x2 + x3) / 2;\n    const y23 = (y2 + y3) / 2;\n    const x123 = (x12 + x23) / 2;\n    const y123 = (y12 + y23) / 2;\n\n    let dx = x3 - x1;\n    let dy = y3 - y1;\n    const d = Math.abs((((x2 - x3) * dy) - ((y2 - y3) * dx)));\n\n    if (d > FLT_EPSILON)\n    {\n        // Regular care\n        // -----------------\n        if (d * d <= distanceTolerance * ((dx * dx) + (dy * dy)))\n        {\n            // If the curvature doesn't exceed the distance_tolerance value\n            // we tend to finish subdivisions.\n            // ----------------------\n            if (mAngleTolerance < curveAngleToleranceEpsilon)\n            {\n                points.push(x123, y123);\n\n                return;\n            }\n\n            // Angle & Cusp Condition\n            // ----------------------\n            let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n\n            if (da >= pi) da = (2 * pi) - da;\n\n            if (da < mAngleTolerance)\n            {\n                // Finally we can stop the recursion\n                // ----------------------\n                points.push(x123, y123);\n\n                return;\n            }\n        }\n    }\n    else\n    {\n        // Collinear case\n        // -----------------\n        dx = x123 - ((x1 + x3) / 2);\n        dy = y123 - ((y1 + y3) / 2);\n        if ((dx * dx) + (dy * dy) <= distanceTolerance)\n        {\n            points.push(x123, y123);\n\n            return;\n        }\n    }\n\n    // Continue subdivision\n    // ----------------------\n    recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);\n    recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);\n}\n\n","\"use strict\";\nfunction buildArc(points, x, y, radius, start, end, clockwise, steps) {\n  let dist = Math.abs(start - end);\n  if (!clockwise && start > end) {\n    dist = 2 * Math.PI - dist;\n  } else if (clockwise && end > start) {\n    dist = 2 * Math.PI - dist;\n  }\n  steps = steps || Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI)));\n  steps = Math.max(steps, 3);\n  let f = dist / steps;\n  let t = start;\n  f *= clockwise ? -1 : 1;\n  for (let i = 0; i < steps + 1; i++) {\n    const cs = Math.cos(t);\n    const sn = Math.sin(t);\n    const nx = x + cs * radius;\n    const ny = y + sn * radius;\n    points.push(nx, ny);\n    t += f;\n  }\n}\n\nexport { buildArc };\n//# sourceMappingURL=buildArc.mjs.map\n","export function buildArc(\n    points: number[],\n    x: number, y: number,\n    radius: number,\n    start: number,\n    end: number,\n    clockwise: boolean,\n    steps?: number\n)\n{\n    // determine distance between the two angles\n    // ...probably a nicer way of writing this\n    let dist = Math.abs(start - end);\n\n    if (!clockwise && start > end)\n    {\n        dist = (2 * Math.PI) - dist;\n    }\n    else if (clockwise && end > start)\n    {\n        dist = (2 * Math.PI) - dist;\n    }\n\n    // approximate the # of steps using the cube root of the radius\n\n    steps = steps || Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / (Math.PI))));\n\n    // ensure we have at least 3 steps..\n    steps = Math.max(steps, 3);\n\n    let f = dist / (steps);\n    let t = start;\n\n    // modify direction\n    f *= clockwise ? -1 : 1;\n\n    for (let i = 0; i < steps + 1; i++)\n    {\n        const cs = Math.cos(t);\n        const sn = Math.sin(t);\n\n        const nx = x + (cs * radius);\n        const ny = y + (sn * radius);\n\n        points.push(nx, ny);\n\n        t += f;\n    }\n}\n","import { buildArc } from './buildArc.mjs';\n\n\"use strict\";\nfunction buildArcTo(points, x1, y1, x2, y2, radius) {\n  const fromX = points[points.length - 2];\n  const fromY = points[points.length - 1];\n  const a1 = fromY - y1;\n  const b1 = fromX - x1;\n  const a2 = y2 - y1;\n  const b2 = x2 - x1;\n  const mm = Math.abs(a1 * b2 - b1 * a2);\n  if (mm < 1e-8 || radius === 0) {\n    if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {\n      points.push(x1, y1);\n    }\n    return;\n  }\n  const dd = a1 * a1 + b1 * b1;\n  const cc = a2 * a2 + b2 * b2;\n  const tt = a1 * a2 + b1 * b2;\n  const k1 = radius * Math.sqrt(dd) / mm;\n  const k2 = radius * Math.sqrt(cc) / mm;\n  const j1 = k1 * tt / dd;\n  const j2 = k2 * tt / cc;\n  const cx = k1 * b2 + k2 * b1;\n  const cy = k1 * a2 + k2 * a1;\n  const px = b1 * (k2 + j1);\n  const py = a1 * (k2 + j1);\n  const qx = b2 * (k1 + j2);\n  const qy = a2 * (k1 + j2);\n  const startAngle = Math.atan2(py - cy, px - cx);\n  const endAngle = Math.atan2(qy - cy, qx - cx);\n  buildArc(\n    points,\n    cx + x1,\n    cy + y1,\n    radius,\n    startAngle,\n    endAngle,\n    b1 * a2 > b2 * a1\n  );\n}\n\nexport { buildArcTo };\n//# sourceMappingURL=buildArcTo.mjs.map\n","import { buildArc } from './buildArc';\n\n/**\n * The arcTo() method creates an arc/curve between two tangents on the canvas.\n *\n * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n * @param points\n * @param x1\n * @param y1\n * @param x2\n * @param y2\n * @param radius\n */\nexport function buildArcTo(\n    points: number[],\n    x1: number, y1: number,\n    x2: number, y2: number,\n    radius: number,\n): void\n{\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n\n    const a1 = fromY - y1;\n    const b1 = fromX - x1;\n    const a2 = y2 - y1;\n    const b2 = x2 - x1;\n    const mm = Math.abs((a1 * b2) - (b1 * a2));\n\n    if (mm < 1.0e-8 || radius === 0)\n    {\n        if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1)\n        {\n            points.push(x1, y1);\n        }\n\n        return;\n    }\n\n    const dd = (a1 * a1) + (b1 * b1);\n    const cc = (a2 * a2) + (b2 * b2);\n    const tt = (a1 * a2) + (b1 * b2);\n    const k1 = radius * Math.sqrt(dd) / mm;\n    const k2 = radius * Math.sqrt(cc) / mm;\n    const j1 = k1 * tt / dd;\n    const j2 = k2 * tt / cc;\n    const cx = (k1 * b2) + (k2 * b1);\n    const cy = (k1 * a2) + (k2 * a1);\n    const px = b1 * (k2 + j1);\n    const py = a1 * (k2 + j1);\n    const qx = b2 * (k1 + j2);\n    const qy = a2 * (k1 + j2);\n    const startAngle = Math.atan2(py - cy, px - cx);\n    const endAngle = Math.atan2(qy - cy, qx - cx);\n\n    buildArc(points,\n        (cx + x1),\n        (cy + y1),\n        radius,\n        startAngle,\n        endAngle,\n        b1 * a2 > b2 * a1\n    );\n}\n","import { buildAdaptiveBezier } from './buildAdaptiveBezier.mjs';\n\n\"use strict\";\nconst TAU = Math.PI * 2;\nconst out = {\n  centerX: 0,\n  centerY: 0,\n  ang1: 0,\n  ang2: 0\n};\nconst mapToEllipse = ({ x, y }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2) => {\n  x *= rx;\n  y *= ry;\n  const xp = cosPhi * x - sinPhi * y;\n  const yp = sinPhi * x + cosPhi * y;\n  out2.x = xp + centerX;\n  out2.y = yp + centerY;\n  return out2;\n};\nfunction approxUnitArc(ang1, ang2) {\n  const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n  const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;\n  const x1 = Math.cos(ang1);\n  const y1 = Math.sin(ang1);\n  const x2 = Math.cos(ang1 + ang2);\n  const y2 = Math.sin(ang1 + ang2);\n  return [\n    {\n      x: x1 - y1 * a,\n      y: y1 + x1 * a\n    },\n    {\n      x: x2 + y2 * a,\n      y: y2 - x2 * a\n    },\n    {\n      x: x2,\n      y: y2\n    }\n  ];\n}\nconst vectorAngle = (ux, uy, vx, vy) => {\n  const sign = ux * vy - uy * vx < 0 ? -1 : 1;\n  let dot = ux * vx + uy * vy;\n  if (dot > 1) {\n    dot = 1;\n  }\n  if (dot < -1) {\n    dot = -1;\n  }\n  return sign * Math.acos(dot);\n};\nconst getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2) => {\n  const rxSq = Math.pow(rx, 2);\n  const rySq = Math.pow(ry, 2);\n  const pxpSq = Math.pow(pxp, 2);\n  const pypSq = Math.pow(pyp, 2);\n  let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;\n  if (radicant < 0) {\n    radicant = 0;\n  }\n  radicant /= rxSq * pypSq + rySq * pxpSq;\n  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n  const centerXp = radicant * rx / ry * pyp;\n  const centerYp = radicant * -ry / rx * pxp;\n  const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;\n  const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;\n  const vx1 = (pxp - centerXp) / rx;\n  const vy1 = (pyp - centerYp) / ry;\n  const vx2 = (-pxp - centerXp) / rx;\n  const vy2 = (-pyp - centerYp) / ry;\n  const ang1 = vectorAngle(1, 0, vx1, vy1);\n  let ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n  if (sweepFlag === 0 && ang2 > 0) {\n    ang2 -= TAU;\n  }\n  if (sweepFlag === 1 && ang2 < 0) {\n    ang2 += TAU;\n  }\n  out2.centerX = centerX;\n  out2.centerY = centerY;\n  out2.ang1 = ang1;\n  out2.ang2 = ang2;\n};\nfunction buildArcToSvg(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {\n  if (rx === 0 || ry === 0) {\n    return;\n  }\n  const sinPhi = Math.sin(xAxisRotation * TAU / 360);\n  const cosPhi = Math.cos(xAxisRotation * TAU / 360);\n  const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;\n  const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;\n  if (pxp === 0 && pyp === 0) {\n    return;\n  }\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n  getArcCenter(\n    px,\n    py,\n    cx,\n    cy,\n    rx,\n    ry,\n    largeArcFlag,\n    sweepFlag,\n    sinPhi,\n    cosPhi,\n    pxp,\n    pyp,\n    out\n  );\n  let { ang1, ang2 } = out;\n  const { centerX, centerY } = out;\n  let ratio = Math.abs(ang2) / (TAU / 4);\n  if (Math.abs(1 - ratio) < 1e-7) {\n    ratio = 1;\n  }\n  const segments = Math.max(Math.ceil(ratio), 1);\n  ang2 /= segments;\n  let lastX = points[points.length - 2];\n  let lastY = points[points.length - 1];\n  const outCurvePoint = { x: 0, y: 0 };\n  for (let i = 0; i < segments; i++) {\n    const curve = approxUnitArc(ang1, ang2);\n    const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    const { x, y } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    buildAdaptiveBezier(\n      points,\n      lastX,\n      lastY,\n      x1,\n      y1,\n      x2,\n      y2,\n      x,\n      y\n    );\n    lastX = x;\n    lastY = y;\n    ang1 += ang2;\n  }\n}\n\nexport { buildArcToSvg };\n//# sourceMappingURL=buildArcToSvg.mjs.map\n","import { buildAdaptiveBezier } from './buildAdaptiveBezier';\n\nconst TAU = Math.PI * 2;\n\nconst out = {\n    centerX: 0,\n    centerY: 0,\n    ang1: 0,\n    ang2: 0\n};\n\nconst mapToEllipse = (\n    { x, y }: {x: number, y: number},\n    rx: number, ry: number,\n    cosPhi: number, sinPhi: number,\n    centerX: number, centerY: number,\n    out: {x: number, y: number}\n): {x: number, y: number} =>\n{\n    x *= rx;\n    y *= ry;\n\n    const xp = (cosPhi * x) - (sinPhi * y);\n    const yp = (sinPhi * x) + (cosPhi * y);\n\n    out.x = xp + centerX;\n    out.y = yp + centerY;\n\n    return out;\n};\n\nfunction approxUnitArc(ang1: number, ang2: number): {x: number, y: number}[]\n{\n    // If 90 degree circular arc, use a constant\n    // as derived from http://spencermortensen.com/articles/bezier-circle\n\n    const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n\n    const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;\n\n    const x1 = Math.cos(ang1);\n    const y1 = Math.sin(ang1);\n    const x2 = Math.cos(ang1 + ang2);\n    const y2 = Math.sin(ang1 + ang2);\n\n    return [\n        {\n            x: x1 - (y1 * a),\n            y: y1 + (x1 * a)\n        },\n        {\n            x: x2 + (y2 * a),\n            y: y2 - (x2 * a)\n        },\n        {\n            x: x2,\n            y: y2\n        }\n    ];\n}\n\nconst vectorAngle = (ux: number, uy: number, vx: number, vy: number) =>\n{\n    const sign = ((ux * vy) - (uy * vx) < 0) ? -1 : 1;\n\n    let dot = (ux * vx) + (uy * vy);\n\n    if (dot > 1)\n    {\n        dot = 1;\n    }\n\n    if (dot < -1)\n    {\n        dot = -1;\n    }\n\n    return sign * Math.acos(dot);\n};\n\nconst getArcCenter = (\n    px: number,\n    py: number,\n    cx: number,\n    cy: number,\n    rx: number,\n    ry: number,\n    largeArcFlag: number,\n    sweepFlag: number,\n    sinPhi: number,\n    cosPhi: number,\n    pxp: number,\n    pyp: number,\n    out: {\n        centerX: number,\n        centerY: number,\n        ang1: number,\n        ang2: number\n    }\n// eslint-disable-next-line max-params\n) =>\n{\n    const rxSq = Math.pow(rx, 2);\n    const rySq = Math.pow(ry, 2);\n    const pxpSq = Math.pow(pxp, 2);\n    const pypSq = Math.pow(pyp, 2);\n\n    let radicant = (rxSq * rySq) - (rxSq * pypSq) - (rySq * pxpSq);\n\n    if (radicant < 0)\n    {\n        radicant = 0;\n    }\n\n    radicant /= (rxSq * pypSq) + (rySq * pxpSq);\n    radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n\n    const centerXp = radicant * rx / ry * pyp;\n    const centerYp = radicant * -ry / rx * pxp;\n\n    const centerX = (cosPhi * centerXp) - (sinPhi * centerYp) + ((px + cx) / 2);\n    const centerY = (sinPhi * centerXp) + (cosPhi * centerYp) + ((py + cy) / 2);\n\n    const vx1 = (pxp - centerXp) / rx;\n    const vy1 = (pyp - centerYp) / ry;\n    const vx2 = (-pxp - centerXp) / rx;\n    const vy2 = (-pyp - centerYp) / ry;\n\n    const ang1 = vectorAngle(1, 0, vx1, vy1);\n    let ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n\n    if (sweepFlag === 0 && ang2 > 0)\n    {\n        ang2 -= TAU;\n    }\n\n    if (sweepFlag === 1 && ang2 < 0)\n    {\n        ang2 += TAU;\n    }\n\n    out.centerX = centerX;\n    out.centerY = centerY;\n    out.ang1 = ang1;\n    out.ang2 = ang2;\n};\n\nexport function buildArcToSvg(\n    points: number[],\n    px: number,\n    py: number,\n    cx: number,\n    cy: number,\n    rx: number,\n    ry: number,\n    xAxisRotation = 0,\n    largeArcFlag = 0,\n    sweepFlag = 0\n): void\n{\n    if (rx === 0 || ry === 0)\n    {\n        return;\n    }\n\n    const sinPhi = Math.sin(xAxisRotation * TAU / 360);\n    const cosPhi = Math.cos(xAxisRotation * TAU / 360);\n\n    const pxp = (cosPhi * (px - cx) / 2) + (sinPhi * (py - cy) / 2);\n    const pyp = (-sinPhi * (px - cx) / 2) + (cosPhi * (py - cy) / 2);\n\n    if (pxp === 0 && pyp === 0)\n    {\n        return;\n    }\n\n    rx = Math.abs(rx);\n    ry = Math.abs(ry);\n\n    const lambda = (Math.pow(pxp, 2) / Math.pow(rx, 2)) + (Math.pow(pyp, 2) / Math.pow(ry, 2));\n\n    if (lambda > 1)\n    {\n        rx *= Math.sqrt(lambda);\n        ry *= Math.sqrt(lambda);\n    }\n\n    getArcCenter(\n        px,\n        py,\n        cx,\n        cy,\n        rx,\n        ry,\n        largeArcFlag,\n        sweepFlag,\n        sinPhi,\n        cosPhi,\n        pxp,\n        pyp,\n        out\n    );\n\n    let { ang1, ang2 } = out;\n    const { centerX, centerY } = out;\n\n    // If 'ang2' == 90.0000000001, then `ratio` will devalue to\n    // 1.0000000001. This causes `segments` to be greater than one, which is an\n    // unnecessary split, and adds extra points to the bezier curve. To alleviate\n    // this issue, we round to 1.0 when the ratio is close to 1.0.\n    let ratio = Math.abs(ang2) / (TAU / 4);\n\n    if (Math.abs(1.0 - ratio) < 0.0000001)\n    {\n        ratio = 1.0;\n    }\n\n    const segments = Math.max(Math.ceil(ratio), 1);\n\n    ang2 /= segments;\n\n    let lastX = points[points.length - 2];\n    let lastY = points[points.length - 1];\n\n    const outCurvePoint = { x: 0, y: 0 };\n\n    for (let i = 0; i < segments; i++)\n    {\n        const curve = approxUnitArc(ang1, ang2);\n\n        const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        const { x, y } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n\n        buildAdaptiveBezier(\n            points,\n            lastX, lastY,\n            x1, y1, x2, y2, x, y\n        );\n\n        lastX = x;\n        lastY = y;\n\n        ang1 += ang2;\n    }\n}\n","\"use strict\";\nfunction roundedShapeArc(g, points, radius) {\n  const vecFrom = (p, pp) => {\n    const x = pp.x - p.x;\n    const y = pp.y - p.y;\n    const len = Math.sqrt(x * x + y * y);\n    const nx = x / len;\n    const ny = y / len;\n    return { len, nx, ny };\n  };\n  const sharpCorner = (i, p) => {\n    if (i === 0) {\n      g.moveTo(p.x, p.y);\n    } else {\n      g.lineTo(p.x, p.y);\n    }\n  };\n  let p1 = points[points.length - 1];\n  for (let i = 0; i < points.length; i++) {\n    const p2 = points[i % points.length];\n    const pRadius = p2.radius ?? radius;\n    if (pRadius <= 0) {\n      sharpCorner(i, p2);\n      p1 = p2;\n      continue;\n    }\n    const p3 = points[(i + 1) % points.length];\n    const v1 = vecFrom(p2, p1);\n    const v2 = vecFrom(p2, p3);\n    if (v1.len < 1e-4 || v2.len < 1e-4) {\n      sharpCorner(i, p2);\n      p1 = p2;\n      continue;\n    }\n    let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);\n    let radDirection = 1;\n    let drawDirection = false;\n    if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {\n      if (angle < 0) {\n        angle = Math.PI + angle;\n      } else {\n        angle = Math.PI - angle;\n        radDirection = -1;\n        drawDirection = true;\n      }\n    } else if (angle > 0) {\n      radDirection = -1;\n      drawDirection = true;\n    }\n    const halfAngle = angle / 2;\n    let cRadius;\n    let lenOut = Math.abs(\n      Math.cos(halfAngle) * pRadius / Math.sin(halfAngle)\n    );\n    if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {\n      lenOut = Math.min(v1.len / 2, v2.len / 2);\n      cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));\n    } else {\n      cRadius = pRadius;\n    }\n    const cX = p2.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;\n    const cY = p2.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;\n    const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;\n    const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;\n    if (i === 0) {\n      g.moveTo(\n        cX + Math.cos(startAngle) * cRadius,\n        cY + Math.sin(startAngle) * cRadius\n      );\n    }\n    g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n    p1 = p2;\n  }\n}\nfunction roundedShapeQuadraticCurve(g, points, radius, smoothness) {\n  const distance = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);\n  const pointLerp = (p1, p2, t) => ({\n    x: p1.x + (p2.x - p1.x) * t,\n    y: p1.y + (p2.y - p1.y) * t\n  });\n  const numPoints = points.length;\n  for (let i = 0; i < numPoints; i++) {\n    const thisPoint = points[(i + 1) % numPoints];\n    const pRadius = thisPoint.radius ?? radius;\n    if (pRadius <= 0) {\n      if (i === 0) {\n        g.moveTo(thisPoint.x, thisPoint.y);\n      } else {\n        g.lineTo(thisPoint.x, thisPoint.y);\n      }\n      continue;\n    }\n    const lastPoint = points[i];\n    const nextPoint = points[(i + 2) % numPoints];\n    const lastEdgeLength = distance(lastPoint, thisPoint);\n    let start;\n    if (lastEdgeLength < 1e-4) {\n      start = thisPoint;\n    } else {\n      const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n      start = pointLerp(\n        thisPoint,\n        lastPoint,\n        lastOffsetDistance / lastEdgeLength\n      );\n    }\n    const nextEdgeLength = distance(nextPoint, thisPoint);\n    let end;\n    if (nextEdgeLength < 1e-4) {\n      end = thisPoint;\n    } else {\n      const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n      end = pointLerp(\n        thisPoint,\n        nextPoint,\n        nextOffsetDistance / nextEdgeLength\n      );\n    }\n    if (i === 0) {\n      g.moveTo(start.x, start.y);\n    } else {\n      g.lineTo(start.x, start.y);\n    }\n    g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);\n  }\n}\n\nexport { roundedShapeArc, roundedShapeQuadraticCurve };\n//# sourceMappingURL=roundShape.mjs.map\n","import type { PointData } from '../../../../maths/point/PointData';\nimport type { ShapePath } from './ShapePath';\n\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/44856925#44856925\n * @param g - Graphics to be drawn on.\n * @param points - Corners of the shape to draw. Minimum length is 3.\n * @param radius - Corners default radius.\n * @ignore\n */\nexport function roundedShapeArc(\n    g: ShapePath,\n    points: RoundedPoint[],\n    radius: number\n): void\n{\n    const vecFrom = (p: PointData, pp: PointData) =>\n    {\n        const x = pp.x - p.x;\n        const y = pp.y - p.y;\n        const len = Math.sqrt((x * x) + (y * y));\n        const nx = x / len;\n        const ny = y / len;\n\n        return { len, nx, ny };\n    };\n\n    const sharpCorner = (i: number, p: PointData) =>\n    {\n        if (i === 0)\n        {\n            g.moveTo(p.x, p.y);\n        }\n        else\n        {\n            g.lineTo(p.x, p.y);\n        }\n    };\n\n    let p1 = points[points.length - 1];\n\n    for (let i = 0; i < points.length; i++)\n    {\n        const p2 = points[i % points.length];\n        const pRadius = p2.radius ?? radius;\n\n        if (pRadius <= 0)\n        {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n\n        const p3 = points[(i + 1) % points.length];\n        const v1 = vecFrom(p2, p1);\n        const v2 = vecFrom(p2, p3);\n\n        if (v1.len < 1e-4 || v2.len < 1e-4)\n        {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n\n        let angle = Math.asin((v1.nx * v2.ny) - (v1.ny * v2.nx));\n        let radDirection = 1;\n        let drawDirection = false;\n\n        if ((v1.nx * v2.nx) - (v1.ny * -v2.ny) < 0)\n        {\n            if (angle < 0)\n            {\n                angle = Math.PI + angle;\n            }\n            else\n            {\n                angle = Math.PI - angle;\n                radDirection = -1;\n                drawDirection = true;\n            }\n        }\n        else if (angle > 0)\n        {\n            radDirection = -1;\n            drawDirection = true;\n        }\n\n        const halfAngle = angle / 2;\n\n        let cRadius: number;\n        let lenOut = Math.abs(\n            (Math.cos(halfAngle) * pRadius) / Math.sin(halfAngle)\n        );\n\n        if (lenOut > Math.min(v1.len / 2, v2.len / 2))\n        {\n            lenOut = Math.min(v1.len / 2, v2.len / 2);\n            cRadius = Math.abs((lenOut * Math.sin(halfAngle)) / Math.cos(halfAngle));\n        }\n        else\n        {\n            cRadius = pRadius;\n        }\n\n        const cX = p2.x + (v2.nx * lenOut) + (-v2.ny * cRadius * radDirection);\n        const cY = p2.y + (v2.ny * lenOut) + (v2.nx * cRadius * radDirection);\n        const startAngle = Math.atan2(v1.ny, v1.nx) + ((Math.PI / 2) * radDirection);\n        const endAngle = Math.atan2(v2.ny, v2.nx) - ((Math.PI / 2) * radDirection);\n\n        if (i === 0)\n        {\n            g.moveTo(\n                cX + (Math.cos(startAngle) * cRadius),\n                cY + (Math.sin(startAngle) * cRadius)\n            );\n        }\n\n        g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n\n        p1 = p2;\n    }\n}\n\nexport type RoundedPoint = PointData & { radius?: number };\n\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/56214413#56214413\n * @param g - Graphics to be drawn on.\n * @param points - Corners of the shape to draw. Minimum length is 3.\n * @param radius - Corners default radius.\n * @ignore\n */\nexport function roundedShapeQuadraticCurve(\n    g: ShapePath,\n    points: RoundedPoint[],\n    radius: number,\n    smoothness?: number,\n): void\n{\n    const distance = (p1: PointData, p2: PointData) =>\n        Math.sqrt(((p1.x - p2.x) ** 2) + ((p1.y - p2.y) ** 2));\n\n    const pointLerp = (p1: PointData, p2: PointData, t: number) => ({\n        x: p1.x + ((p2.x - p1.x) * t),\n        y: p1.y + ((p2.y - p1.y) * t),\n    });\n\n    const numPoints = points.length;\n\n    for (let i = 0; i < numPoints; i++)\n    {\n        const thisPoint = points[(i + 1) % numPoints];\n        const pRadius = thisPoint.radius ?? radius;\n\n        if (pRadius <= 0)\n        {\n            if (i === 0)\n            {\n                g.moveTo(thisPoint.x, thisPoint.y);\n            }\n            else\n            {\n                g.lineTo(thisPoint.x, thisPoint.y);\n            }\n\n            continue;\n        }\n\n        const lastPoint = points[i];\n        const nextPoint = points[(i + 2) % numPoints];\n\n        const lastEdgeLength = distance(lastPoint, thisPoint);\n        let start;\n\n        if (lastEdgeLength < 1e-4)\n        {\n            start = thisPoint;\n        }\n        else\n        {\n            const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n\n            start = pointLerp(\n                thisPoint,\n                lastPoint,\n                lastOffsetDistance / lastEdgeLength\n            );\n        }\n\n        const nextEdgeLength = distance(nextPoint, thisPoint);\n        let end;\n\n        if (nextEdgeLength < 1e-4)\n        {\n            end = thisPoint;\n        }\n        else\n        {\n            const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n\n            end = pointLerp(\n                thisPoint,\n                nextPoint,\n                nextOffsetDistance / nextEdgeLength\n            );\n        }\n\n        if (i === 0)\n        {\n            g.moveTo(start.x, start.y);\n        }\n        else\n        {\n            g.lineTo(start.x, start.y);\n        }\n        g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);\n    }\n}\n","import { Color } from '../../../../color/Color.mjs';\nimport { GraphicsPath } from '../path/GraphicsPath.mjs';\n\n\"use strict\";\nfunction SVGParser(svg, graphicsContext) {\n  if (typeof svg === \"string\") {\n    const div = document.createElement(\"div\");\n    div.innerHTML = svg.trim();\n    svg = div.querySelector(\"svg\");\n  }\n  const session = {\n    context: graphicsContext,\n    path: new GraphicsPath()\n  };\n  renderChildren(svg, session, null, null);\n  return graphicsContext;\n}\nfunction renderChildren(svg, session, fillStyle, strokeStyle) {\n  const children = svg.children;\n  const { fillStyle: f1, strokeStyle: s1 } = parseStyle(svg);\n  if (f1 && fillStyle) {\n    fillStyle = { ...fillStyle, ...f1 };\n  } else if (f1) {\n    fillStyle = f1;\n  }\n  if (s1 && strokeStyle) {\n    strokeStyle = { ...strokeStyle, ...s1 };\n  } else if (s1) {\n    strokeStyle = s1;\n  }\n  session.context.fillStyle = fillStyle;\n  session.context.strokeStyle = strokeStyle;\n  let x;\n  let y;\n  let x1;\n  let y1;\n  let x2;\n  let y2;\n  let cx;\n  let cy;\n  let r;\n  let rx;\n  let ry;\n  let points;\n  let pointsString;\n  let d;\n  let graphicsPath;\n  let width;\n  let height;\n  switch (svg.nodeName.toLowerCase()) {\n    case \"path\":\n      d = svg.getAttribute(\"d\");\n      graphicsPath = new GraphicsPath(d);\n      session.context.path(graphicsPath);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"circle\":\n      cx = parseFloatAttribute(svg, \"cx\", 0);\n      cy = parseFloatAttribute(svg, \"cy\", 0);\n      r = parseFloatAttribute(svg, \"r\", 0);\n      session.context.ellipse(cx, cy, r, r);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"rect\":\n      x = parseFloatAttribute(svg, \"x\", 0);\n      y = parseFloatAttribute(svg, \"y\", 0);\n      width = parseFloatAttribute(svg, \"width\", 0);\n      height = parseFloatAttribute(svg, \"height\", 0);\n      rx = parseFloatAttribute(svg, \"rx\", 0);\n      ry = parseFloatAttribute(svg, \"ry\", 0);\n      if (rx || ry) {\n        session.context.roundRect(x, y, width, height, rx || ry);\n      } else {\n        session.context.rect(x, y, width, height);\n      }\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"ellipse\":\n      cx = parseFloatAttribute(svg, \"cx\", 0);\n      cy = parseFloatAttribute(svg, \"cy\", 0);\n      rx = parseFloatAttribute(svg, \"rx\", 0);\n      ry = parseFloatAttribute(svg, \"ry\", 0);\n      session.context.beginPath();\n      session.context.ellipse(cx, cy, rx, ry);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"line\":\n      x1 = parseFloatAttribute(svg, \"x1\", 0);\n      y1 = parseFloatAttribute(svg, \"y1\", 0);\n      x2 = parseFloatAttribute(svg, \"x2\", 0);\n      y2 = parseFloatAttribute(svg, \"y2\", 0);\n      session.context.beginPath();\n      session.context.moveTo(x1, y1);\n      session.context.lineTo(x2, y2);\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"polygon\":\n      pointsString = svg.getAttribute(\"points\");\n      points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n      session.context.poly(points, true);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"polyline\":\n      pointsString = svg.getAttribute(\"points\");\n      points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n      session.context.poly(points, false);\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"g\":\n    case \"svg\":\n      break;\n    default: {\n      console.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);\n      break;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    renderChildren(children[i], session, fillStyle, strokeStyle);\n  }\n}\nfunction parseFloatAttribute(svg, id, defaultValue) {\n  const value = svg.getAttribute(id);\n  return value ? Number(value) : defaultValue;\n}\nfunction parseStyle(svg) {\n  const style = svg.getAttribute(\"style\");\n  const strokeStyle = {};\n  const fillStyle = {};\n  let useFill = false;\n  let useStroke = false;\n  if (style) {\n    const styleParts = style.split(\";\");\n    for (let i = 0; i < styleParts.length; i++) {\n      const stylePart = styleParts[i];\n      const [key, value] = stylePart.split(\":\");\n      switch (key) {\n        case \"stroke\":\n          if (value !== \"none\") {\n            strokeStyle.color = Color.shared.setValue(value).toNumber();\n            useStroke = true;\n          }\n          break;\n        case \"stroke-width\":\n          strokeStyle.width = Number(value);\n          break;\n        case \"fill\":\n          if (value !== \"none\") {\n            useFill = true;\n            fillStyle.color = Color.shared.setValue(value).toNumber();\n          }\n          break;\n        case \"fill-opacity\":\n          fillStyle.alpha = Number(value);\n          break;\n        case \"stroke-opacity\":\n          strokeStyle.alpha = Number(value);\n          break;\n        case \"opacity\":\n          fillStyle.alpha = Number(value);\n          strokeStyle.alpha = Number(value);\n          break;\n      }\n    }\n  } else {\n    const stroke = svg.getAttribute(\"stroke\");\n    if (stroke && stroke !== \"none\") {\n      useStroke = true;\n      strokeStyle.color = Color.shared.setValue(stroke).toNumber();\n      strokeStyle.width = parseFloatAttribute(svg, \"stroke-width\", 1);\n    }\n    const fill = svg.getAttribute(\"fill\");\n    if (fill && fill !== \"none\") {\n      useFill = true;\n      fillStyle.color = Color.shared.setValue(fill).toNumber();\n    }\n  }\n  return {\n    strokeStyle: useStroke ? strokeStyle : null,\n    fillStyle: useFill ? fillStyle : null\n  };\n}\n\nexport { SVGParser };\n//# sourceMappingURL=SVGParser.mjs.map\n","import { Color } from '../../../../color/Color';\nimport { GraphicsPath } from '../path/GraphicsPath';\n\nimport type {\n    ConvertedFillStyle,\n    ConvertedStrokeStyle,\n    FillStyle,\n    GraphicsContext,\n    StrokeStyle,\n} from '../GraphicsContext';\n\ninterface Session\n{\n    context: GraphicsContext;\n    path: GraphicsPath;\n}\n\nexport function SVGParser(\n    svg: string | SVGElement | SVGSVGElement,\n    graphicsContext?: GraphicsContext\n): GraphicsContext\n{\n    if (typeof svg === 'string')\n    {\n        const div = document.createElement('div');\n\n        div.innerHTML = svg.trim();\n        svg = div.querySelector('svg') as SVGElement;\n    }\n\n    const session = {\n        context: graphicsContext,\n        path: new GraphicsPath(),\n    };\n\n    renderChildren(svg, session, null, null);\n\n    return graphicsContext;\n}\n\nfunction renderChildren(svg: SVGElement, session: Session, fillStyle: FillStyle, strokeStyle: StrokeStyle): void\n{\n    const children = svg.children;\n\n    const { fillStyle: f1, strokeStyle: s1 } = parseStyle(svg);\n\n    if (f1 && fillStyle)\n    {\n        fillStyle = { ...fillStyle, ...f1 };\n    }\n    else if (f1)\n    {\n        fillStyle = f1;\n    }\n\n    if (s1 && strokeStyle)\n    {\n        strokeStyle = { ...strokeStyle, ...s1 };\n    }\n    else if (s1)\n    {\n        strokeStyle = s1;\n    }\n\n    session.context.fillStyle = fillStyle;\n    session.context.strokeStyle = strokeStyle;\n\n    let x;\n    let y;\n    let x1;\n    let y1;\n    let x2;\n    let y2;\n    let cx;\n    let cy;\n    let r;\n    let rx;\n    let ry;\n    let points;\n    let pointsString;\n    let d;\n    let graphicsPath;\n    let width;\n    let height;\n\n    switch (svg.nodeName.toLowerCase())\n    {\n        case 'path':\n            d = svg.getAttribute('d') as string;\n\n            graphicsPath = new GraphicsPath(d);\n\n            session.context.path(graphicsPath);\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'circle':\n            cx = parseFloatAttribute(svg, 'cx', 0);\n            cy = parseFloatAttribute(svg, 'cy', 0);\n\n            r = parseFloatAttribute(svg, 'r', 0);\n\n            session.context.ellipse(cx, cy, r, r);\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'rect':\n            x = parseFloatAttribute(svg, 'x', 0);\n            y = parseFloatAttribute(svg, 'y', 0);\n\n            width = parseFloatAttribute(svg, 'width', 0);\n            height = parseFloatAttribute(svg, 'height', 0);\n\n            rx = parseFloatAttribute(svg, 'rx', 0);\n            ry = parseFloatAttribute(svg, 'ry', 0);\n\n            if (rx || ry)\n            {\n                session.context.roundRect(x, y, width, height, rx || ry);\n            }\n            else\n            {\n                session.context.rect(x, y, width, height);\n            }\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'ellipse':\n            cx = parseFloatAttribute(svg, 'cx', 0);\n            cy = parseFloatAttribute(svg, 'cy', 0);\n\n            rx = parseFloatAttribute(svg, 'rx', 0);\n            ry = parseFloatAttribute(svg, 'ry', 0);\n\n            session.context.beginPath();\n            session.context.ellipse(cx, cy, rx, ry); // , 0, Math.PI * 2);\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'line':\n            x1 = parseFloatAttribute(svg, 'x1', 0);\n            y1 = parseFloatAttribute(svg, 'y1', 0);\n\n            x2 = parseFloatAttribute(svg, 'x2', 0);\n            y2 = parseFloatAttribute(svg, 'y2', 0);\n\n            session.context.beginPath();\n            session.context.moveTo(x1, y1);\n            session.context.lineTo(x2, y2);\n\n            if (strokeStyle) session.context.stroke();\n\n            break;\n\n        case 'polygon':\n            pointsString = svg.getAttribute('points') as string;\n\n            points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n\n            session.context.poly(points, true);\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'polyline':\n            pointsString = svg.getAttribute('points') as string;\n\n            points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n\n            session.context.poly(points, false);\n\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        // children will cover these two..\n        case 'g':\n        case 'svg':\n            break;\n        default: {\n            // eslint-disable-next-line no-console\n            console.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);\n            break;\n        }\n    }\n\n    for (let i = 0; i < children.length; i++)\n    {\n        renderChildren(children[i] as SVGElement, session, fillStyle, strokeStyle);\n    }\n}\n\nfunction parseFloatAttribute(svg: SVGElement, id: string, defaultValue: number): number\n{\n    const value = svg.getAttribute(id) as string;\n\n    return value ? Number(value) : defaultValue;\n}\n\nfunction parseStyle(svg: SVGElement): { strokeStyle: ConvertedStrokeStyle; fillStyle: ConvertedFillStyle }\n{\n    const style = svg.getAttribute('style');\n\n    const strokeStyle: StrokeStyle = {};\n\n    const fillStyle: FillStyle = {};\n\n    let useFill = false;\n    let useStroke = false;\n\n    if (style)\n    {\n        const styleParts = style.split(';');\n\n        for (let i = 0; i < styleParts.length; i++)\n        {\n            const stylePart = styleParts[i];\n\n            const [key, value] = stylePart.split(':');\n\n            switch (key)\n            {\n                case 'stroke':\n                    if (value !== 'none')\n                    {\n                        strokeStyle.color = Color.shared.setValue(value).toNumber();\n                        useStroke = true;\n                    }\n\n                    break;\n                case 'stroke-width':\n                    strokeStyle.width = Number(value);\n                    break;\n                case 'fill':\n                    if (value !== 'none')\n                    {\n                        useFill = true;\n                        fillStyle.color = Color.shared.setValue(value).toNumber();\n                    }\n                    break;\n                case 'fill-opacity':\n                    fillStyle.alpha = Number(value);\n                    break;\n                case 'stroke-opacity':\n                    strokeStyle.alpha = Number(value);\n                    break;\n                case 'opacity':\n                    fillStyle.alpha = Number(value);\n                    strokeStyle.alpha = Number(value);\n                    break;\n            }\n        }\n    }\n    else\n    {\n        const stroke = svg.getAttribute('stroke');\n\n        if (stroke && stroke !== 'none')\n        {\n            useStroke = true;\n            strokeStyle.color = Color.shared.setValue(stroke).toNumber();\n\n            strokeStyle.width = parseFloatAttribute(svg, 'stroke-width', 1);\n        }\n\n        const fill = svg.getAttribute('fill');\n\n        if (fill && fill !== 'none')\n        {\n            useFill = true;\n            fillStyle.color = Color.shared.setValue(fill).toNumber();\n        }\n    }\n\n    return {\n        strokeStyle: useStroke ? (strokeStyle as ConvertedStrokeStyle) : null,\n        fillStyle: useFill ? (fillStyle as ConvertedFillStyle) : null,\n    };\n}\n","import { Color } from '../../../../color/Color.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { FillGradient } from '../fill/FillGradient.mjs';\nimport { FillPattern } from '../fill/FillPattern.mjs';\n\n\"use strict\";\nfunction convertFillInputToFillStyle(value, defaultStyle) {\n  if (value === void 0 || value === null) {\n    return null;\n  }\n  let fillStyleToParse;\n  let styleToMerge;\n  if (value?.fill) {\n    styleToMerge = value.fill;\n    fillStyleToParse = { ...defaultStyle, ...value };\n  } else {\n    styleToMerge = value;\n    fillStyleToParse = defaultStyle;\n  }\n  if (Color.isColorLike(styleToMerge)) {\n    const temp = Color.shared.setValue(styleToMerge ?? 0);\n    const opts = {\n      ...fillStyleToParse,\n      color: temp.toNumber(),\n      alpha: temp.alpha === 1 ? fillStyleToParse.alpha : temp.alpha,\n      texture: Texture.WHITE\n    };\n    return opts;\n  } else if (styleToMerge instanceof FillPattern) {\n    const pattern = styleToMerge;\n    return {\n      ...fillStyleToParse,\n      color: 16777215,\n      texture: pattern.texture,\n      matrix: pattern.transform,\n      fill: fillStyleToParse.fill ?? null\n    };\n  } else if (styleToMerge instanceof FillGradient) {\n    const gradient = styleToMerge;\n    gradient.buildLinearGradient();\n    return {\n      ...fillStyleToParse,\n      color: 16777215,\n      texture: gradient.texture,\n      matrix: gradient.transform\n    };\n  }\n  const style = { ...defaultStyle, ...value };\n  if (style.texture) {\n    if (style.texture !== Texture.WHITE) {\n      const m = style.matrix?.invert() || new Matrix();\n      m.scale(\n        1 / style.texture.frame.width,\n        1 / style.texture.frame.height\n      );\n      style.matrix = m;\n    }\n    const sourceStyle = style.texture.source.style;\n    if (sourceStyle.addressMode === \"clamp-to-edge\") {\n      sourceStyle.addressMode = \"repeat\";\n    }\n  }\n  const color = Color.shared.setValue(style.color);\n  style.alpha *= color.alpha;\n  style.color = color.toNumber();\n  style.matrix = style.matrix ? style.matrix.clone() : null;\n  return style;\n}\n\nexport { convertFillInputToFillStyle };\n//# sourceMappingURL=convertFillInputToFillStyle.mjs.map\n","import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { FillGradient } from '../fill/FillGradient';\nimport { FillPattern } from '../fill/FillPattern';\n\nimport type { ColorSource } from '../../../../color/Color';\nimport type {\n    ConvertedFillStyle,\n    FillStyle,\n    FillStyleInputs,\n    PatternFillStyle,\n} from '../GraphicsContext';\n\nexport function convertFillInputToFillStyle(\n    value: FillStyleInputs,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    if (value === undefined || value === null)\n    {\n        return null;\n    }\n\n    let fillStyleToParse: ConvertedFillStyle;\n    let styleToMerge: FillStyleInputs;\n\n    if ((value as PatternFillStyle)?.fill)\n    {\n        styleToMerge = (value as PatternFillStyle).fill;\n        fillStyleToParse = { ...defaultStyle, ...(value as PatternFillStyle) };\n    }\n    else\n    {\n        styleToMerge = value;\n        fillStyleToParse = defaultStyle;\n    }\n\n    if (Color.isColorLike(styleToMerge as ColorSource))\n    {\n        const temp = Color.shared.setValue(styleToMerge as ColorSource ?? 0);\n        const opts: ConvertedFillStyle = {\n            ...fillStyleToParse,\n            color: temp.toNumber(),\n            alpha: temp.alpha === 1 ? fillStyleToParse.alpha : temp.alpha,\n            texture: Texture.WHITE,\n        };\n\n        return opts;\n    }\n    else if (styleToMerge instanceof FillPattern)\n    {\n        const pattern = styleToMerge as FillPattern;\n\n        return {\n            ...fillStyleToParse,\n            color: 0xffffff,\n            texture: pattern.texture,\n            matrix: pattern.transform,\n            fill: fillStyleToParse.fill ?? null,\n        };\n    }\n\n    // // TODO Texture\n    else if (styleToMerge instanceof FillGradient)\n    {\n        const gradient = styleToMerge as FillGradient;\n\n        gradient.buildLinearGradient();\n\n        return {\n            ...fillStyleToParse,\n            color: 0xffffff,\n            texture: gradient.texture,\n            matrix: gradient.transform,\n        };\n    }\n\n    const style: FillStyle = { ...defaultStyle, ...(value as FillStyle) };\n\n    if (style.texture)\n    {\n        if (style.texture !== Texture.WHITE)\n        {\n            const m = style.matrix?.invert() || new Matrix();\n\n            m.scale(\n                1 / style.texture.frame.width,\n                1 / style.texture.frame.height\n            );\n\n            style.matrix = m;\n        }\n\n        const sourceStyle = style.texture.source.style;\n\n        if (sourceStyle.addressMode === 'clamp-to-edge')\n        {\n            sourceStyle.addressMode = 'repeat';\n        }\n    }\n\n    const color = Color.shared.setValue(style.color);\n\n    style.alpha *= color.alpha;\n    style.color = color.toNumber();\n    style.matrix = style.matrix ? style.matrix.clone() : null; // todo: lets optimise this!\n\n    // its a regular fill style!\n    return style as ConvertedFillStyle;\n}\n","\"use strict\";\nconst valuesToIterateForKeys = [\n  \"_fontFamily\",\n  \"_fontStyle\",\n  \"_fontSize\",\n  \"_fontVariant\",\n  \"_fontWeight\",\n  \"_breakWords\",\n  \"_align\",\n  \"_leading\",\n  \"_letterSpacing\",\n  \"_lineHeight\",\n  \"_textBaseline\",\n  \"_whiteSpace\",\n  \"_wordWrap\",\n  \"_wordWrapWidth\",\n  \"_padding\",\n  \"_cssOverrides\",\n  \"_trim\"\n];\nfunction generateTextStyleKey(style) {\n  const key = [];\n  let index = 0;\n  for (let i = 0; i < valuesToIterateForKeys.length; i++) {\n    const prop = valuesToIterateForKeys[i];\n    key[index++] = style[prop];\n  }\n  index = addFillStyleKey(style._fill, key, index);\n  index = addStokeStyleKey(style._stroke, key, index);\n  return key.join(\"-\");\n}\nfunction addFillStyleKey(fillStyle, key, index) {\n  if (!fillStyle)\n    return index;\n  key[index++] = fillStyle.color;\n  key[index++] = fillStyle.alpha;\n  key[index++] = fillStyle.fill?.uid;\n  return index;\n}\nfunction addStokeStyleKey(strokeStyle, key, index) {\n  if (!strokeStyle)\n    return index;\n  index = addFillStyleKey(strokeStyle, key, index);\n  key[index++] = strokeStyle.width;\n  key[index++] = strokeStyle.alignment;\n  key[index++] = strokeStyle.cap;\n  key[index++] = strokeStyle.join;\n  key[index++] = strokeStyle.miterLimit;\n  return index;\n}\n\nexport { generateTextStyleKey };\n//# sourceMappingURL=generateTextStyleKey.mjs.map\n","import type { FillGradient } from '../../graphics/shared/fill/FillGradient';\nimport type { ConvertedFillStyle, ConvertedStrokeStyle } from '../../graphics/shared/GraphicsContext';\nimport type { TextStyle } from '../TextStyle';\n\nconst valuesToIterateForKeys = [\n    '_fontFamily',\n    '_fontStyle',\n    '_fontSize',\n    '_fontVariant',\n    '_fontWeight',\n    '_breakWords',\n    '_align',\n    '_leading',\n    '_letterSpacing',\n    '_lineHeight',\n    '_textBaseline',\n    '_whiteSpace',\n    '_wordWrap',\n    '_wordWrapWidth',\n    '_padding',\n    '_cssOverrides',\n    '_trim'\n];\n\n/**\n * Generates a unique key for the text style.\n * @param style - The style to generate a key for.\n * @returns the key for the style.\n */\nexport function generateTextStyleKey(style: TextStyle): string\n{\n    const key = [];\n\n    let index = 0;\n\n    for (let i = 0; i < valuesToIterateForKeys.length; i++)\n    {\n        const prop = valuesToIterateForKeys[i];\n\n        key[index++] = style[prop as keyof typeof style];\n    }\n\n    index = addFillStyleKey(style._fill, key as string[], index);\n    index = addStokeStyleKey(style._stroke, key as string[], index);\n\n    // TODO - we need to add some shadow stuff here!\n\n    return key.join('-');\n}\n\nfunction addFillStyleKey(fillStyle: ConvertedFillStyle, key: (number | string)[], index: number)\n{\n    if (!fillStyle) return index;\n\n    key[index++] = fillStyle.color;\n    key[index++] = fillStyle.alpha;\n    key[index++] = (fillStyle.fill as FillGradient)?.uid;\n\n    return index;\n}\n\nfunction addStokeStyleKey(strokeStyle: ConvertedStrokeStyle, key: (number | string)[], index: number)\n{\n    if (!strokeStyle) return index;\n\n    index = addFillStyleKey(strokeStyle, key, index);\n\n    key[index++] = strokeStyle.width;\n    key[index++] = strokeStyle.alignment;\n    key[index++] = strokeStyle.cap;\n    key[index++] = strokeStyle.join;\n    key[index++] = strokeStyle.miterLimit;\n\n    return index;\n}\n","import { Color } from '../../color/Color.mjs';\nimport { Rectangle } from '../../maths/shapes/Rectangle.mjs';\nimport { CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool.mjs';\nimport { ImageSource } from '../../rendering/renderers/shared/texture/sources/ImageSource.mjs';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics.mjs';\nimport { fontStringFromTextStyle } from '../text/canvas/utils/fontStringFromTextStyle.mjs';\nimport { getCanvasFillStyle } from '../text/canvas/utils/getCanvasFillStyle.mjs';\nimport { AbstractBitmapFont } from './AbstractBitmapFont.mjs';\nimport { resolveCharacters } from './utils/resolveCharacters.mjs';\n\n\"use strict\";\nclass DynamicBitmapFont extends AbstractBitmapFont {\n  /**\n   * @param options - The options for the dynamic bitmap font.\n   */\n  constructor(options) {\n    super();\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    this.resolution = 1;\n    /** The pages of the font. */\n    this.pages = [];\n    this._padding = 4;\n    this._measureCache = /* @__PURE__ */ Object.create(null);\n    this._currentChars = [];\n    this._currentX = 0;\n    this._currentY = 0;\n    this._currentPageIndex = -1;\n    this._skipKerning = false;\n    const dynamicOptions = options;\n    const style = dynamicOptions.style.clone();\n    if (dynamicOptions.overrideFill) {\n      style._fill.color = 16777215;\n      style._fill.alpha = 1;\n      style._fill.texture = Texture.WHITE;\n      style._fill.fill = null;\n    }\n    const requestedFontSize = style.fontSize;\n    style.fontSize = this.baseMeasurementFontSize;\n    const font = fontStringFromTextStyle(style);\n    if (dynamicOptions.overrideSize) {\n      if (style._stroke) {\n        style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n      }\n    } else {\n      style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n    }\n    this._style = style;\n    this._skipKerning = dynamicOptions.skipKerning ?? false;\n    this.resolution = dynamicOptions.resolution ?? 1;\n    this._padding = dynamicOptions.padding ?? 4;\n    this.fontMetrics = CanvasTextMetrics.measureFont(font);\n    this.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n  }\n  ensureCharacters(chars) {\n    const charList = resolveCharacters(chars).filter((char) => !this._currentChars.includes(char)).filter((char, index, self) => self.indexOf(char) === index);\n    if (!charList.length)\n      return;\n    this._currentChars = [...this._currentChars, ...charList];\n    let pageData;\n    if (this._currentPageIndex === -1) {\n      pageData = this._nextPage();\n    } else {\n      pageData = this.pages[this._currentPageIndex];\n    }\n    let { canvas, context } = pageData.canvasAndContext;\n    let textureSource = pageData.texture.source;\n    const style = this._style;\n    let currentX = this._currentX;\n    let currentY = this._currentY;\n    const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n    const padding = this._padding * fontScale;\n    const widthScale = style.fontStyle === \"italic\" ? 2 : 1;\n    let maxCharHeight = 0;\n    let skipTexture = false;\n    for (let i = 0; i < charList.length; i++) {\n      const char = charList[i];\n      const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);\n      metrics.lineHeight = metrics.height;\n      const width = widthScale * metrics.width * fontScale;\n      const height = metrics.height * fontScale;\n      const paddedWidth = width + padding * 2;\n      const paddedHeight = height + padding * 2;\n      skipTexture = false;\n      if (char !== \"\\n\" && char !== \"\\r\" && char !== \"\t\" && char !== \" \") {\n        skipTexture = true;\n        maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));\n      }\n      if (currentX + paddedWidth > 512) {\n        currentY += maxCharHeight;\n        maxCharHeight = paddedHeight;\n        currentX = 0;\n        if (currentY + maxCharHeight > 512) {\n          textureSource.update();\n          const pageData2 = this._nextPage();\n          canvas = pageData2.canvasAndContext.canvas;\n          context = pageData2.canvasAndContext.context;\n          textureSource = pageData2.texture.source;\n          currentY = 0;\n        }\n      }\n      const xAdvance = width / fontScale - (style.dropShadow?.distance ?? 0) - (style._stroke?.width ?? 0);\n      this.chars[char] = {\n        id: char.codePointAt(0),\n        xOffset: -this._padding,\n        yOffset: -this._padding,\n        xAdvance,\n        kerning: {}\n      };\n      if (skipTexture) {\n        this._drawGlyph(\n          context,\n          metrics,\n          currentX + padding,\n          currentY + padding,\n          fontScale,\n          style\n        );\n        const px = textureSource.width * fontScale;\n        const py = textureSource.height * fontScale;\n        const frame = new Rectangle(\n          currentX / px * textureSource.width,\n          currentY / py * textureSource.height,\n          paddedWidth / px * textureSource.width,\n          paddedHeight / py * textureSource.height\n        );\n        this.chars[char].texture = new Texture({\n          source: textureSource,\n          frame\n        });\n        currentX += Math.ceil(paddedWidth);\n      }\n    }\n    textureSource.update();\n    this._currentX = currentX;\n    this._currentY = currentY;\n    this._skipKerning && this._applyKerning(charList, context);\n  }\n  /**\n   * @deprecated since 8.0.0\n   * The map of base page textures (i.e., sheets of glyphs).\n   */\n  get pageTextures() {\n    deprecation(v8_0_0, \"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.\");\n    return this.pages;\n  }\n  _applyKerning(newChars, context) {\n    const measureCache = this._measureCache;\n    for (let i = 0; i < newChars.length; i++) {\n      const first = newChars[i];\n      for (let j = 0; j < this._currentChars.length; j++) {\n        const second = this._currentChars[j];\n        let c1 = measureCache[first];\n        if (!c1)\n          c1 = measureCache[first] = context.measureText(first).width;\n        let c2 = measureCache[second];\n        if (!c2)\n          c2 = measureCache[second] = context.measureText(second).width;\n        let total = context.measureText(first + second).width;\n        let amount = total - (c1 + c2);\n        if (amount) {\n          this.chars[first].kerning[second] = amount;\n        }\n        total = context.measureText(first + second).width;\n        amount = total - (c1 + c2);\n        if (amount) {\n          this.chars[second].kerning[first] = amount;\n        }\n      }\n    }\n  }\n  _nextPage() {\n    this._currentPageIndex++;\n    const textureResolution = this.resolution;\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(512, 512, textureResolution);\n    this._setupContext(canvasAndContext.context, this._style, textureResolution);\n    const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n    const texture = new Texture({\n      source: new ImageSource({\n        resource: canvasAndContext.canvas,\n        resolution,\n        alphaMode: \"premultiply-alpha-on-upload\"\n      })\n    });\n    const pageData = {\n      canvasAndContext,\n      texture\n    };\n    this.pages[this._currentPageIndex] = pageData;\n    return pageData;\n  }\n  // canvas style!\n  _setupContext(context, style, resolution) {\n    style.fontSize = this.baseRenderedFontSize;\n    context.scale(resolution, resolution);\n    context.font = fontStringFromTextStyle(style);\n    style.fontSize = this.baseMeasurementFontSize;\n    context.textBaseline = style.textBaseline;\n    const stroke = style._stroke;\n    const strokeThickness = stroke?.width ?? 0;\n    if (stroke) {\n      context.lineWidth = strokeThickness;\n      context.lineJoin = stroke.join;\n      context.miterLimit = stroke.miterLimit;\n      context.strokeStyle = getCanvasFillStyle(stroke, context);\n    }\n    if (style._fill) {\n      context.fillStyle = getCanvasFillStyle(style._fill, context);\n    }\n    if (style.dropShadow) {\n      const shadowOptions = style.dropShadow;\n      const rgb = Color.shared.setValue(shadowOptions.color).toArray();\n      const dropShadowBlur = shadowOptions.blur * resolution;\n      const dropShadowDistance = shadowOptions.distance * resolution;\n      context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n      context.shadowBlur = dropShadowBlur;\n      context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n      context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n    } else {\n      context.shadowColor = \"black\";\n      context.shadowBlur = 0;\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n    }\n  }\n  _drawGlyph(context, metrics, x, y, fontScale, style) {\n    const char = metrics.text;\n    const fontProperties = metrics.fontProperties;\n    const stroke = style._stroke;\n    const strokeThickness = (stroke?.width ?? 0) * fontScale;\n    const tx = x + strokeThickness / 2;\n    const ty = y - strokeThickness / 2;\n    const descent = fontProperties.descent * fontScale;\n    const lineHeight = metrics.lineHeight * fontScale;\n    if (style.stroke && strokeThickness) {\n      context.strokeText(char, tx, ty + lineHeight - descent);\n    }\n    if (style._fill) {\n      context.fillText(char, tx, ty + lineHeight - descent);\n    }\n  }\n  destroy() {\n    super.destroy();\n    for (let i = 0; i < this.pages.length; i++) {\n      const { canvasAndContext, texture } = this.pages[i];\n      CanvasPool.returnCanvasAndContext(canvasAndContext);\n      texture.destroy(true);\n    }\n    this.pages = null;\n  }\n}\n\nexport { DynamicBitmapFont };\n//# sourceMappingURL=DynamicBitmapFont.mjs.map\n","import { Color } from '../../color/Color';\nimport { Rectangle } from '../../maths/shapes/Rectangle';\nimport { CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport { ImageSource } from '../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics';\nimport { fontStringFromTextStyle } from '../text/canvas/utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from '../text/canvas/utils/getCanvasFillStyle';\nimport { AbstractBitmapFont } from './AbstractBitmapFont';\nimport { resolveCharacters } from './utils/resolveCharacters';\n\nimport type { ICanvasRenderingContext2D } from '../../environment/canvas/ICanvasRenderingContext2D';\nimport type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\nimport type { TextStyle } from '../text/TextStyle';\n\nexport interface DynamicBitmapFontOptions\n{\n    style: TextStyle\n    skipKerning?: boolean\n    resolution?: number\n    padding?: number\n    overrideFill?: boolean\n    overrideSize?: boolean\n}\n\n/**\n * A BitmapFont that generates its glyphs dynamically.\n * @memberof text\n * @ignore\n */\nexport class DynamicBitmapFont extends AbstractBitmapFont<DynamicBitmapFont>\n{\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    public resolution = 1;\n    /** The pages of the font. */\n    public override readonly pages: {canvasAndContext?: CanvasAndContext, texture: Texture}[] = [];\n\n    private readonly _padding: number = 4;\n    private readonly _measureCache: Record<string, number> = Object.create(null);\n    private _currentChars: string[] = [];\n    private _currentX = 0;\n    private _currentY = 0;\n    private _currentPageIndex = -1;\n    private readonly _style: TextStyle;\n    private readonly _skipKerning: boolean = false;\n\n    /**\n     * @param options - The options for the dynamic bitmap font.\n     */\n    constructor(options: DynamicBitmapFontOptions)\n    {\n        super();\n\n        const dynamicOptions = options;\n        const style = dynamicOptions.style.clone();\n\n        if (dynamicOptions.overrideFill)\n        {\n            // assuming no shape fill..\n            style._fill.color = 0xffffff;\n            style._fill.alpha = 1;\n            style._fill.texture = Texture.WHITE;\n            style._fill.fill = null;\n        }\n\n        const requestedFontSize = style.fontSize;\n\n        // adjust font size to match the base measurement size\n        style.fontSize = this.baseMeasurementFontSize;\n\n        const font = fontStringFromTextStyle(style);\n\n        if (dynamicOptions.overrideSize)\n        {\n            if (style._stroke)\n            {\n                // we want the stroke to fit the size of the requested text, so we need to scale it\n                // accordingly (eg font size 20, with stroke 10 - stroke is 50% of size,\n                // as dynamic font is size 100, the stroke should be adjusted to 50 to make it look right)\n                style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n            }\n        }\n        else\n        {\n            style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n        }\n\n        this._style = style;\n        this._skipKerning = dynamicOptions.skipKerning ?? false;\n        this.resolution = dynamicOptions.resolution ?? 1;\n        this._padding = dynamicOptions.padding ?? 4;\n\n        (this.fontMetrics as FontMetrics) = CanvasTextMetrics.measureFont(font);\n        (this.lineHeight as number) = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n    }\n\n    public ensureCharacters(chars: string): void\n    {\n        const charList = resolveCharacters(chars)\n            .filter((char) => !this._currentChars.includes(char))\n            .filter((char, index, self) => self.indexOf(char) === index);\n        // filter returns..\n\n        if (!charList.length) return;\n\n        this._currentChars = [...this._currentChars, ...charList];\n\n        let pageData;\n\n        if (this._currentPageIndex === -1)\n        {\n            pageData = this._nextPage();\n        }\n        else\n        {\n            pageData = this.pages[this._currentPageIndex];\n        }\n\n        let { canvas, context } = pageData.canvasAndContext;\n        let textureSource = pageData.texture.source;\n\n        const style = this._style;\n\n        let currentX = this._currentX;\n        let currentY = this._currentY;\n\n        const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n        const padding = this._padding * fontScale;\n\n        const widthScale = style.fontStyle === 'italic' ? 2 : 1;\n        let maxCharHeight = 0;\n        let skipTexture = false;\n\n        for (let i = 0; i < charList.length; i++)\n        {\n            const char = charList[i];\n\n            const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);\n\n            // override the line height.. we want this to be the glyps heigh\n            // not the user specified one.\n            metrics.lineHeight = metrics.height;\n\n            const width = (widthScale * metrics.width) * fontScale;\n            const height = (metrics.height) * fontScale;\n\n            const paddedWidth = width + (padding * 2);\n            const paddedHeight = height + (padding * 2);\n\n            skipTexture = false;\n            // don't let empty characters count towards the maxCharHeight\n            if (char !== '\\n' && char !== '\\r' && char !== '\\t' && char !== ' ')\n            {\n                skipTexture = true;\n                maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));// / 1.5;\n            }\n\n            if (currentX + paddedWidth > 512)\n            {\n                currentY += maxCharHeight;\n\n                // reset the line x and height..\n                maxCharHeight = paddedHeight;\n                currentX = 0;\n\n                if (currentY + maxCharHeight > 512)\n                {\n                    textureSource.update();\n\n                    const pageData = this._nextPage();\n\n                    canvas = pageData.canvasAndContext.canvas;\n                    context = pageData.canvasAndContext.context;\n                    textureSource = pageData.texture.source;\n\n                    currentY = 0;\n                }\n            }\n\n            const xAdvance = (width / fontScale)\n                - (style.dropShadow?.distance ?? 0)\n                - (style._stroke?.width ?? 0);\n\n            // This is in coord space of the measurements.. not the texture\n            this.chars[char] = {\n                id: char.codePointAt(0),\n                xOffset: -this._padding,\n                yOffset: -this._padding,\n                xAdvance,\n                kerning: {},\n            };\n\n            if (skipTexture)\n            {\n                this._drawGlyph(\n                    context,\n                    metrics,\n                    currentX + padding,\n                    currentY + padding,\n                    fontScale,\n                    style,\n                );\n\n                const px = textureSource.width * fontScale;\n                const py = textureSource.height * fontScale;\n\n                const frame = new Rectangle(\n                    ((currentX) / px) * textureSource.width,\n                    ((currentY) / py) * textureSource.height,\n                    ((paddedWidth) / px) * textureSource.width,\n                    ((paddedHeight) / py) * textureSource.height,\n                );\n\n                this.chars[char].texture = new Texture({\n                    source: textureSource,\n                    frame,\n                });\n\n                currentX += Math.ceil(paddedWidth);\n            }\n\n            // now add it to the font data..\n        }\n\n        textureSource.update();\n\n        this._currentX = currentX;\n        this._currentY = currentY;\n\n        // now apply kerning..\n        this._skipKerning && this._applyKerning(charList, context);\n    }\n\n    /**\n     * @deprecated since 8.0.0\n     * The map of base page textures (i.e., sheets of glyphs).\n     */\n    public override get pageTextures(): DynamicBitmapFont['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    private _applyKerning(newChars: string[], context: ICanvasRenderingContext2D): void\n    {\n        const measureCache = this._measureCache;\n\n        for (let i = 0; i < newChars.length; i++)\n        {\n            const first = newChars[i];\n\n            for (let j = 0; j < this._currentChars.length; j++)\n            {\n                // first go through new char being first\n                const second = this._currentChars[j];\n\n                let c1 = measureCache[first];\n\n                if (!c1) c1 = measureCache[first] = context.measureText(first).width;\n\n                let c2 = measureCache[second];\n\n                if (!c2) c2 = measureCache[second] = context.measureText(second).width;\n\n                let total = context.measureText(first + second).width;\n                let amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[first].kerning[second] = amount;\n                }\n\n                // then go through new char being second\n                total = context.measureText(first + second).width;\n                amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[second].kerning[first] = amount;\n                }\n            }\n        }\n    }\n\n    private _nextPage(): {canvasAndContext: CanvasAndContext, texture: Texture}\n    {\n        this._currentPageIndex++;\n\n        const textureResolution = this.resolution;\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(512, 512, textureResolution);\n\n        this._setupContext(canvasAndContext.context, this._style, textureResolution);\n\n        const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n        const texture = new Texture({\n            source: new ImageSource({\n                resource: canvasAndContext.canvas,\n                resolution,\n                alphaMode: 'premultiply-alpha-on-upload'\n            }),\n\n        });\n\n        const pageData = {\n            canvasAndContext,\n            texture,\n        };\n\n        this.pages[this._currentPageIndex] = pageData;\n\n        return pageData;\n    }\n\n    // canvas style!\n    private _setupContext(context: ICanvasRenderingContext2D, style: TextStyle, resolution: number): void\n    {\n        style.fontSize = this.baseRenderedFontSize;\n        context.scale(resolution, resolution);\n        context.font = fontStringFromTextStyle(style);\n        style.fontSize = this.baseMeasurementFontSize;\n        context.textBaseline = style.textBaseline;\n\n        const stroke = style._stroke;\n        const strokeThickness = stroke?.width ?? 0;\n\n        if (stroke)\n        {\n            context.lineWidth = strokeThickness;\n            context.lineJoin = stroke.join;\n            context.miterLimit = stroke.miterLimit;\n\n            // TODO prolly cache this??\n            context.strokeStyle = getCanvasFillStyle(stroke, context);\n        }\n\n        if (style._fill)\n        {\n            // set canvas text styles\n            context.fillStyle = getCanvasFillStyle(style._fill, context);\n        }\n\n        if (style.dropShadow)\n        {\n            const shadowOptions = style.dropShadow;\n            const rgb = Color.shared.setValue(shadowOptions.color).toArray();\n\n            const dropShadowBlur = shadowOptions.blur * resolution;\n            const dropShadowDistance = shadowOptions.distance * resolution;\n\n            context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n            context.shadowBlur = dropShadowBlur;\n            context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n            context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n        }\n        else\n        {\n            context.shadowColor = 'black';\n            context.shadowBlur = 0;\n            context.shadowOffsetX = 0;\n            context.shadowOffsetY = 0;\n        }\n    }\n\n    private _drawGlyph(\n        context: ICanvasRenderingContext2D,\n        metrics: CanvasTextMetrics,\n        x: number,\n        y: number,\n        fontScale: number,\n        style: TextStyle\n    ): void\n    {\n        const char = metrics.text;\n        const fontProperties = metrics.fontProperties;\n        const stroke = style._stroke;\n\n        const strokeThickness = (stroke?.width ?? 0) * fontScale;\n\n        const tx = x + (strokeThickness / 2);\n        const ty = y - (strokeThickness / 2);\n\n        const descent = fontProperties.descent * fontScale;\n        const lineHeight = metrics.lineHeight * fontScale;\n\n        if (style.stroke && strokeThickness)\n        {\n            context.strokeText(char, tx, ty + lineHeight - descent);\n        }\n\n        if (style._fill)\n        {\n            context.fillText(char, tx, ty + lineHeight - descent);\n        }\n    }\n\n    public override destroy(): void\n    {\n        super.destroy();\n\n        for (let i = 0; i < this.pages.length; i++)\n        {\n            const { canvasAndContext, texture } = this.pages[i];\n\n            CanvasPool.returnCanvasAndContext(canvasAndContext);\n            texture.destroy(true);\n        }\n\n        (this.pages as null) = null;\n    }\n}\n","\"use strict\";\nfunction resolveCharacters(chars) {\n  if (chars === \"\") {\n    return [];\n  }\n  if (typeof chars === \"string\") {\n    chars = [chars];\n  }\n  const result = [];\n  for (let i = 0, j = chars.length; i < j; i++) {\n    const item = chars[i];\n    if (Array.isArray(item)) {\n      if (item.length !== 2) {\n        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n      }\n      if (item[0].length === 0 || item[1].length === 0) {\n        throw new Error(\"[BitmapFont]: Invalid character delimiter.\");\n      }\n      const startCode = item[0].charCodeAt(0);\n      const endCode = item[1].charCodeAt(0);\n      if (endCode < startCode) {\n        throw new Error(\"[BitmapFont]: Invalid character range.\");\n      }\n      for (let i2 = startCode, j2 = endCode; i2 <= j2; i2++) {\n        result.push(String.fromCharCode(i2));\n      }\n    } else {\n      result.push(...Array.from(item));\n    }\n  }\n  if (result.length === 0) {\n    throw new Error(\"[BitmapFont]: Empty set when resolving characters.\");\n  }\n  return result;\n}\n\nexport { resolveCharacters };\n//# sourceMappingURL=resolveCharacters.mjs.map\n","/**\n * Processes the passed character set data and returns a flattened array of all the characters.\n *\n * Ignored because not directly exposed.\n * @ignore\n * @param {string | string[] | string[][] } chars\n * @returns {string[]} the flattened array of characters\n */\n\nexport function resolveCharacters(chars: string | (string | string[])[]): string[]\n{\n    // Skip unexpected 'empty set' check at end\n    if (chars === '')\n    {\n        return [];\n    }\n\n    // Split the chars string into individual characters\n    if (typeof chars === 'string')\n    {\n        chars = [chars];\n    }\n\n    // Handle an array of characters+ranges\n    const result: string[] = [];\n\n    for (let i = 0, j = chars.length; i < j; i++)\n    {\n        const item = chars[i];\n\n        // Handle range delimited by start/end chars\n        if (Array.isArray(item))\n        {\n            if (item.length !== 2)\n            {\n                throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n            }\n            if (item[0].length === 0 || item[1].length === 0)\n            {\n                throw new Error('[BitmapFont]: Invalid character delimiter.');\n            }\n\n            const startCode = item[0].charCodeAt(0);\n            const endCode = item[1].charCodeAt(0);\n\n            if (endCode < startCode)\n            {\n                throw new Error('[BitmapFont]: Invalid character range.');\n            }\n\n            for (let i = startCode, j = endCode; i <= j; i++)\n            {\n                result.push(String.fromCharCode(i));\n            }\n        }\n        else\n        {\n            result.push(...Array.from(item));\n        }\n    }\n\n    if (result.length === 0)\n    {\n        throw new Error('[BitmapFont]: Empty set when resolving characters.');\n    }\n\n    return result;\n}\n","\"use strict\";\nfunction getBitmapTextLayout(chars, style, font) {\n  const layoutData = {\n    width: 0,\n    height: 0,\n    offsetY: 0,\n    scale: style.fontSize / font.baseMeasurementFontSize,\n    lines: [{\n      width: 0,\n      charPositions: [],\n      spaceWidth: 0,\n      spacesIndex: [],\n      chars: []\n    }]\n  };\n  layoutData.offsetY = font.baseLineOffset;\n  let currentLine = layoutData.lines[0];\n  let previousChar = null;\n  let firstWord = true;\n  const currentWord = {\n    spaceWord: false,\n    width: 0,\n    start: 0,\n    index: 0,\n    // use index to not modify the array as we use it a lot!\n    positions: [],\n    chars: []\n  };\n  const nextWord = (word) => {\n    const start = currentLine.width;\n    for (let j = 0; j < currentWord.index; j++) {\n      const position = word.positions[j];\n      currentLine.chars.push(word.chars[j]);\n      currentLine.charPositions.push(position + start);\n    }\n    currentLine.width += word.width;\n    firstWord = false;\n    currentWord.width = 0;\n    currentWord.index = 0;\n    currentWord.chars.length = 0;\n  };\n  const nextLine = () => {\n    let index = currentLine.chars.length - 1;\n    let lastChar = currentLine.chars[index];\n    while (lastChar === \" \") {\n      currentLine.width -= font.chars[lastChar].xAdvance;\n      lastChar = currentLine.chars[--index];\n    }\n    layoutData.width = Math.max(layoutData.width, currentLine.width);\n    currentLine = {\n      width: 0,\n      charPositions: [],\n      chars: [],\n      spaceWidth: 0,\n      spacesIndex: []\n    };\n    firstWord = true;\n    layoutData.lines.push(currentLine);\n    layoutData.height += font.lineHeight;\n  };\n  const scale = font.baseMeasurementFontSize / style.fontSize;\n  const adjustedLetterSpacing = style.letterSpacing * scale;\n  const adjustedWordWrapWidth = style.wordWrapWidth * scale;\n  for (let i = 0; i < chars.length + 1; i++) {\n    let char;\n    const isEnd = i === chars.length;\n    if (!isEnd) {\n      char = chars[i];\n    }\n    const charData = font.chars[char] || font.chars[\" \"];\n    const isSpace = /(?:\\s)/.test(char);\n    const isWordBreak = isSpace || char === \"\\r\" || char === \"\\n\" || isEnd;\n    if (isWordBreak) {\n      const addWordToNextLine = !firstWord && style.wordWrap && currentLine.width + currentWord.width - adjustedLetterSpacing > adjustedWordWrapWidth;\n      if (addWordToNextLine) {\n        nextLine();\n        nextWord(currentWord);\n        if (!isEnd) {\n          currentLine.charPositions.push(0);\n        }\n      } else {\n        currentWord.start = currentLine.width;\n        nextWord(currentWord);\n        if (!isEnd) {\n          currentLine.charPositions.push(0);\n        }\n      }\n      if (char === \"\\r\" || char === \"\\n\") {\n        if (currentLine.width !== 0) {\n          nextLine();\n        }\n      } else if (!isEnd) {\n        const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;\n        currentLine.width += spaceWidth;\n        currentLine.spaceWidth = spaceWidth;\n        currentLine.spacesIndex.push(currentLine.charPositions.length);\n        currentLine.chars.push(char);\n      }\n    } else {\n      const kerning = charData.kerning[previousChar] || 0;\n      const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;\n      currentWord.positions[currentWord.index++] = currentWord.width + kerning;\n      currentWord.chars.push(char);\n      currentWord.width += nextCharWidth;\n    }\n    previousChar = char;\n  }\n  nextLine();\n  if (style.align === \"center\") {\n    alignCenter(layoutData);\n  } else if (style.align === \"right\") {\n    alignRight(layoutData);\n  } else if (style.align === \"justify\") {\n    alignJustify(layoutData);\n  }\n  return layoutData;\n}\nfunction alignCenter(measurementData) {\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    const offset = measurementData.width / 2 - line.width / 2;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      line.charPositions[j] += offset;\n    }\n  }\n}\nfunction alignRight(measurementData) {\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    const offset = measurementData.width - line.width;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      line.charPositions[j] += offset;\n    }\n  }\n}\nfunction alignJustify(measurementData) {\n  const width = measurementData.width;\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    let indy = 0;\n    let spaceIndex = line.spacesIndex[indy++];\n    let offset = 0;\n    const totalSpaces = line.spacesIndex.length;\n    const newSpaceWidth = (width - line.width) / totalSpaces;\n    const spaceWidth = newSpaceWidth;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      if (j === spaceIndex) {\n        spaceIndex = line.spacesIndex[indy++];\n        offset += spaceWidth;\n      }\n      line.charPositions[j] += offset;\n    }\n  }\n}\n\nexport { getBitmapTextLayout };\n//# sourceMappingURL=getBitmapTextLayout.mjs.map\n","import type { TextStyle } from '../../text/TextStyle';\nimport type { AbstractBitmapFont } from '../AbstractBitmapFont';\n\nexport interface BitmapTextLayoutData\n{\n    width: number;\n    height: number;\n    scale: number;\n    offsetY: number;\n    lines: {\n        width: number\n        charPositions: number[],\n        chars: string[],\n        // / spaces: number\n        spaceWidth: number\n        spacesIndex: number[]\n    }[];\n}\n\nexport function getBitmapTextLayout(chars: string[], style: TextStyle, font: AbstractBitmapFont<any>): BitmapTextLayoutData\n{\n    const layoutData: BitmapTextLayoutData = {\n        width: 0,\n        height: 0,\n        offsetY: 0,\n        scale: style.fontSize / font.baseMeasurementFontSize,\n        lines: [{\n            width: 0,\n            charPositions: [] as number[],\n            spaceWidth: 0,\n            spacesIndex: [],\n            chars: [],\n        }]\n    };\n\n    layoutData.offsetY = font.baseLineOffset;\n\n    let currentLine = layoutData.lines[0];\n\n    let previousChar: string = null;\n    let firstWord = true;\n    //    let spaceCount = 0;\n\n    const currentWord = {\n        spaceWord: false,\n        width: 0,\n        start: 0,\n        index: 0, // use index to not modify the array as we use it a lot!\n        positions: [] as number[],\n        chars: [] as string[],\n    };\n\n    const nextWord = (word: typeof currentWord) =>\n    {\n        const start = currentLine.width;\n\n        for (let j = 0; j < currentWord.index; j++)\n        {\n            const position = word.positions[j];\n\n            currentLine.chars.push(word.chars[j]);\n            currentLine.charPositions.push(position + start);\n        }\n\n        currentLine.width += word.width;\n\n        firstWord = false;\n\n        // reset the word..\n        currentWord.width = 0;\n        currentWord.index = 0;\n        currentWord.chars.length = 0;\n\n        // spaceCount = 0;\n    };\n\n    const nextLine = () =>\n    {\n        let index = currentLine.chars.length - 1;\n        let lastChar = currentLine.chars[index];\n\n        while (lastChar === ' ')\n        {\n            currentLine.width -= font.chars[lastChar].xAdvance;\n            lastChar = currentLine.chars[--index];\n        }\n\n        layoutData.width = Math.max(layoutData.width, currentLine.width);\n\n        currentLine = {\n            width: 0,\n            charPositions: [],\n            chars: [],\n            spaceWidth: 0,\n            spacesIndex: [],\n        };\n\n        firstWord = true;\n        layoutData.lines.push(currentLine);\n        layoutData.height += font.lineHeight;\n    };\n\n    const scale = font.baseMeasurementFontSize / style.fontSize;\n\n    const adjustedLetterSpacing = style.letterSpacing * scale;\n    const adjustedWordWrapWidth = style.wordWrapWidth * scale;\n\n    // loop an extra time to force a line break..\n    for (let i = 0; i < chars.length + 1; i++)\n    {\n        let char: string;\n\n        const isEnd = i === chars.length;\n\n        if (!isEnd)\n        {\n            char = chars[i];\n        }\n\n        const charData = font.chars[char] || font.chars[' '];\n\n        const isSpace = (/(?:\\s)/).test(char);\n        const isWordBreak = isSpace || char === '\\r' || char === '\\n' || isEnd;\n\n        // spaceCount++;\n        // wasSpace = isSpace;\n\n        if (isWordBreak)\n        {\n            const addWordToNextLine = !firstWord\n                && style.wordWrap\n                && (currentLine.width + currentWord.width - adjustedLetterSpacing) > adjustedWordWrapWidth;\n\n            if (addWordToNextLine)\n            {\n                nextLine();\n\n                nextWord(currentWord);\n\n                if (!isEnd)\n                {\n                    currentLine.charPositions.push(0);\n                }\n            }\n            else\n            {\n                currentWord.start = currentLine.width;\n\n                nextWord(currentWord);\n\n                if (!isEnd)\n                {\n                    currentLine.charPositions.push(0);\n                }\n            }\n\n            if (char === '\\r' || char === '\\n')\n            {\n                if (currentLine.width !== 0)\n                {\n                    nextLine();\n                }\n            }\n            else if (!isEnd)\n            {\n                const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;\n\n                currentLine.width += spaceWidth;\n\n                currentLine.spaceWidth = spaceWidth;\n                currentLine.spacesIndex.push(currentLine.charPositions.length);\n                currentLine.chars.push(char);\n\n                // spaceCount++;\n            }\n        }\n        else\n        {\n            const kerning = charData.kerning[previousChar] || 0;\n\n            const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;\n\n            currentWord.positions[currentWord.index++] = currentWord.width + kerning;\n            currentWord.chars.push(char);\n\n            currentWord.width += nextCharWidth;\n        }\n\n        previousChar = char;\n        // lastChar = char;\n    }\n\n    nextLine();\n\n    if (style.align === 'center')\n    {\n        alignCenter(layoutData);\n    }\n    else if (style.align === 'right')\n    {\n        alignRight(layoutData);\n    }\n    else if (style.align === 'justify')\n    {\n        alignJustify(layoutData);\n    }\n\n    return layoutData;\n}\n\nfunction alignCenter(measurementData: BitmapTextLayoutData)\n{\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n        const offset = ((measurementData.width / 2) - (line.width / 2));\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\nfunction alignRight(measurementData: BitmapTextLayoutData)\n{\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n        const offset = ((measurementData.width) - (line.width));\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\nfunction alignJustify(measurementData: BitmapTextLayoutData)\n{\n    const width = measurementData.width;\n\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n\n        let indy = 0;\n        let spaceIndex = line.spacesIndex[indy++];\n\n        let offset = 0;\n\n        const totalSpaces = line.spacesIndex.length;\n\n        const newSpaceWidth = (width - line.width) / totalSpaces;\n\n        const spaceWidth = newSpaceWidth;\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            if (j === spaceIndex)\n            {\n                spaceIndex = line.spacesIndex[indy++];\n\n                offset += spaceWidth;\n            }\n\n            line.charPositions[j] += offset;\n        }\n    }\n}\n","\"use strict\";\nconst bitmapFontTextParser = {\n  test(data) {\n    return typeof data === \"string\" && data.startsWith(\"info face=\");\n  },\n  parse(txt) {\n    const items = txt.match(/^[a-z]+\\s+.+$/gm);\n    const rawData = {\n      info: [],\n      common: [],\n      page: [],\n      char: [],\n      chars: [],\n      kerning: [],\n      kernings: [],\n      distanceField: []\n    };\n    for (const i in items) {\n      const name = items[i].match(/^[a-z]+/gm)[0];\n      const attributeList = items[i].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm);\n      const itemData = {};\n      for (const i2 in attributeList) {\n        const split = attributeList[i2].split(\"=\");\n        const key = split[0];\n        const strValue = split[1].replace(/\"/gm, \"\");\n        const floatValue = parseFloat(strValue);\n        const value = isNaN(floatValue) ? strValue : floatValue;\n        itemData[key] = value;\n      }\n      rawData[name].push(itemData);\n    }\n    const font = {\n      chars: {},\n      pages: [],\n      lineHeight: 0,\n      fontSize: 0,\n      fontFamily: \"\",\n      distanceField: null,\n      baseLineOffset: 0\n    };\n    const [info] = rawData.info;\n    const [common] = rawData.common;\n    const [distanceField] = rawData.distanceField ?? [];\n    if (distanceField) {\n      font.distanceField = {\n        range: parseInt(distanceField.distanceRange, 10),\n        type: distanceField.fieldType\n      };\n    }\n    font.fontSize = parseInt(info.size, 10);\n    font.fontFamily = info.face;\n    font.lineHeight = parseInt(common.lineHeight, 10);\n    const page = rawData.page;\n    for (let i = 0; i < page.length; i++) {\n      font.pages.push({\n        id: parseInt(page[i].id, 10) || 0,\n        file: page[i].file\n      });\n    }\n    const map = {};\n    font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);\n    const char = rawData.char;\n    for (let i = 0; i < char.length; i++) {\n      const charNode = char[i];\n      const id = parseInt(charNode.id, 10);\n      let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id);\n      if (letter === \"space\")\n        letter = \" \";\n      map[id] = letter;\n      font.chars[letter] = {\n        id,\n        // texture deets..\n        page: parseInt(charNode.page, 10) || 0,\n        x: parseInt(charNode.x, 10),\n        y: parseInt(charNode.y, 10),\n        width: parseInt(charNode.width, 10),\n        height: parseInt(charNode.height, 10),\n        xOffset: parseInt(charNode.xoffset, 10),\n        yOffset: parseInt(charNode.yoffset, 10),\n        xAdvance: parseInt(charNode.xadvance, 10),\n        kerning: {}\n      };\n    }\n    const kerning = rawData.kerning || [];\n    for (let i = 0; i < kerning.length; i++) {\n      const first = parseInt(kerning[i].first, 10);\n      const second = parseInt(kerning[i].second, 10);\n      const amount = parseInt(kerning[i].amount, 10);\n      font.chars[map[second]].kerning[map[first]] = amount;\n    }\n    return font;\n  }\n};\n\nexport { bitmapFontTextParser };\n//# sourceMappingURL=bitmapFontTextParser.mjs.map\n","import type { BitmapFontData, RawCharData } from '../AbstractBitmapFont';\n\n/**\n * Internal data format used to convert to BitmapFontData.\n * @private\n */\nexport interface BitmapFontRawData\n{\n    info: {\n        face: string;\n        size: string;\n    }[];\n    common: { lineHeight: string, base: string }[];\n    page: {\n        id: string;\n        file: string;\n    }[];\n    chars: {\n        count: number;\n    }[];\n    char: {\n        id: string\n        page: string\n        xoffset: string\n        yoffset: string\n        xadvance: string,\n        x: string\n        y: string\n        width: string\n        height: string\n        letter?: string\n        char?: string\n    }[];\n    kernings?: {\n        count: number;\n    }[];\n    kerning?: {\n        first: string;\n        second: string;\n        amount: string;\n    }[];\n    distanceField?: {\n        fieldType: 'sdf' | 'msdf' | 'none';\n        distanceRange: string;\n    }[]\n}\n\nexport const bitmapFontTextParser = {\n    test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        return typeof data === 'string' && data.startsWith('info face=');\n    },\n\n    parse(txt: string): BitmapFontData\n    {\n        // Retrieve data item\n        const items = txt.match(/^[a-z]+\\s+.+$/gm);\n        const rawData: BitmapFontRawData = {\n            info: [],\n            common: [],\n            page: [],\n            char: [],\n            chars: [],\n            kerning: [],\n            kernings: [],\n            distanceField: [],\n        };\n\n        for (const i in items)\n        {\n            // Extract item name\n            const name = items[i].match(/^[a-z]+/gm)[0] as keyof BitmapFontRawData;\n\n            // Extract item attribute list as string ex.: \"width=10\"\n            const attributeList = items[i].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm);\n\n            // Convert attribute list into an object\n            const itemData: any = {};\n\n            for (const i in attributeList)\n            {\n                // Split key-value pairs\n                const split = attributeList[i].split('=');\n                const key = split[0];\n\n                // Remove eventual quotes from value\n                const strValue = split[1].replace(/\"/gm, '');\n\n                // Try to convert value into float\n                const floatValue = parseFloat(strValue);\n\n                // Use string value case float value is NaN\n                const value = isNaN(floatValue) ? strValue : floatValue;\n\n                itemData[key] = value;\n            }\n\n            // Push current item to the resulting data\n            rawData[name].push(itemData);\n        }\n\n        const font: BitmapFontData = {\n            chars: {},\n            pages: [],\n            lineHeight: 0,\n            fontSize: 0,\n            fontFamily: '',\n            distanceField: null,\n            baseLineOffset: 0,\n        };\n\n        const [info] = rawData.info;\n        const [common] = rawData.common;\n        const [distanceField] = rawData.distanceField ?? [];\n\n        if (distanceField)\n        {\n            font.distanceField = {\n                range: parseInt(distanceField.distanceRange, 10),\n                type: distanceField.fieldType\n            };\n        }\n\n        font.fontSize = parseInt(info.size, 10);\n        font.fontFamily = info.face;\n        font.lineHeight = parseInt(common.lineHeight, 10);\n\n        const page = rawData.page;\n\n        for (let i = 0; i < page.length; i++)\n        {\n            font.pages.push({\n                id: parseInt(page[i].id, 10) || 0,\n                file: page[i].file,\n            });\n        }\n\n        const map: Record<string, string> = {};\n\n        font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);\n\n        const char = rawData.char;\n\n        for (let i = 0; i < char.length; i++)\n        {\n            const charNode = char[i];\n            const id = parseInt(charNode.id, 10);\n\n            let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id);\n\n            if (letter === 'space')letter = ' ';\n\n            map[id] = letter;\n\n            font.chars[letter] = {\n                id,\n                // texture deets..\n                page: parseInt(charNode.page, 10) || 0,\n                x: parseInt(charNode.x, 10),\n                y: parseInt(charNode.y, 10),\n                width: parseInt(charNode.width, 10),\n                height: parseInt(charNode.height, 10),\n                xOffset: parseInt(charNode.xoffset, 10),\n                yOffset: parseInt(charNode.yoffset, 10),\n                xAdvance: parseInt(charNode.xadvance, 10),\n                kerning: {},\n            } as RawCharData;\n        }\n\n        const kerning = rawData.kerning || [];\n\n        for (let i = 0; i < kerning.length; i++)\n        {\n            const first = parseInt(kerning[i].first, 10);\n            const second = parseInt(kerning[i].second, 10);\n            const amount = parseInt(kerning[i].amount, 10);\n\n            font.chars[map[second]].kerning[map[first]] = amount;\n        }\n\n        return font;\n    }\n};\n","import { DOMAdapter } from '../../../environment/adapter.mjs';\nimport { bitmapFontXMLParser } from './bitmapFontXMLParser.mjs';\n\n\"use strict\";\nconst bitmapFontXMLStringParser = {\n  test(data) {\n    if (typeof data === \"string\" && data.includes(\"<font>\")) {\n      return bitmapFontXMLParser.test(DOMAdapter.get().parseXML(data));\n    }\n    return false;\n  },\n  parse(data) {\n    return bitmapFontXMLParser.parse(DOMAdapter.get().parseXML(data));\n  }\n};\n\nexport { bitmapFontXMLStringParser };\n//# sourceMappingURL=bitmapFontXMLStringParser.mjs.map\n","import { DOMAdapter } from '../../../environment/adapter';\nimport { bitmapFontXMLParser } from './bitmapFontXMLParser';\n\nimport type { BitmapFontData } from '../AbstractBitmapFont';\n\nexport const bitmapFontXMLStringParser = {\n    test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        if (typeof data === 'string' && data.includes('<font>'))\n        {\n            return bitmapFontXMLParser.test(DOMAdapter.get().parseXML(data));\n        }\n\n        return false;\n    },\n\n    parse(data: string): BitmapFontData\n    {\n        return bitmapFontXMLParser.parse(DOMAdapter.get().parseXML(data));\n    }\n};\n","\"use strict\";\nconst bitmapFontXMLParser = {\n  test(data) {\n    const xml = data;\n    return typeof xml !== \"string\" && \"getElementsByTagName\" in xml && xml.getElementsByTagName(\"page\").length && xml.getElementsByTagName(\"info\")[0].getAttribute(\"face\") !== null;\n  },\n  parse(xml) {\n    const data = {\n      chars: {},\n      pages: [],\n      lineHeight: 0,\n      fontSize: 0,\n      fontFamily: \"\",\n      distanceField: null,\n      baseLineOffset: 0\n    };\n    const info = xml.getElementsByTagName(\"info\")[0];\n    const common = xml.getElementsByTagName(\"common\")[0];\n    const distanceField = xml.getElementsByTagName(\"distanceField\")[0];\n    if (distanceField) {\n      data.distanceField = {\n        type: distanceField.getAttribute(\"fieldType\"),\n        range: parseInt(distanceField.getAttribute(\"distanceRange\"), 10)\n      };\n    }\n    const page = xml.getElementsByTagName(\"page\");\n    const char = xml.getElementsByTagName(\"char\");\n    const kerning = xml.getElementsByTagName(\"kerning\");\n    data.fontSize = parseInt(info.getAttribute(\"size\"), 10);\n    data.fontFamily = info.getAttribute(\"face\");\n    data.lineHeight = parseInt(common.getAttribute(\"lineHeight\"), 10);\n    for (let i = 0; i < page.length; i++) {\n      data.pages.push({\n        id: parseInt(page[i].getAttribute(\"id\"), 10) || 0,\n        file: page[i].getAttribute(\"file\")\n      });\n    }\n    const map = {};\n    data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute(\"base\"), 10);\n    for (let i = 0; i < char.length; i++) {\n      const charNode = char[i];\n      const id = parseInt(charNode.getAttribute(\"id\"), 10);\n      let letter = charNode.getAttribute(\"letter\") ?? charNode.getAttribute(\"char\") ?? String.fromCharCode(id);\n      if (letter === \"space\")\n        letter = \" \";\n      map[id] = letter;\n      data.chars[letter] = {\n        id,\n        // texture deets..\n        page: parseInt(charNode.getAttribute(\"page\"), 10) || 0,\n        x: parseInt(charNode.getAttribute(\"x\"), 10),\n        y: parseInt(charNode.getAttribute(\"y\"), 10),\n        width: parseInt(charNode.getAttribute(\"width\"), 10),\n        height: parseInt(charNode.getAttribute(\"height\"), 10),\n        // render deets..\n        xOffset: parseInt(charNode.getAttribute(\"xoffset\"), 10),\n        yOffset: parseInt(charNode.getAttribute(\"yoffset\"), 10),\n        // + baseLineOffset,\n        xAdvance: parseInt(charNode.getAttribute(\"xadvance\"), 10),\n        kerning: {}\n      };\n    }\n    for (let i = 0; i < kerning.length; i++) {\n      const first = parseInt(kerning[i].getAttribute(\"first\"), 10);\n      const second = parseInt(kerning[i].getAttribute(\"second\"), 10);\n      const amount = parseInt(kerning[i].getAttribute(\"amount\"), 10);\n      data.chars[map[second]].kerning[map[first]] = amount;\n    }\n    return data;\n  }\n};\n\nexport { bitmapFontXMLParser };\n//# sourceMappingURL=bitmapFontXMLParser.mjs.map\n","import type { BitmapFontData, RawCharData } from '../AbstractBitmapFont';\n\nexport const bitmapFontXMLParser = {\n    test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        const xml = data as Document;\n\n        return typeof xml !== 'string'\n            && 'getElementsByTagName' in xml\n            && xml.getElementsByTagName('page').length\n            && xml.getElementsByTagName('info')[0].getAttribute('face') !== null;\n    },\n\n    parse(xml: Document): BitmapFontData\n    {\n        const data: BitmapFontData = {\n            chars: {},\n            pages: [],\n            lineHeight: 0,\n            fontSize: 0,\n            fontFamily: '',\n            distanceField: null,\n            baseLineOffset: 0,\n        };\n\n        const info = xml.getElementsByTagName('info')[0];\n        const common = xml.getElementsByTagName('common')[0];\n        const distanceField = xml.getElementsByTagName('distanceField')[0];\n\n        if (distanceField)\n        {\n            data.distanceField = {\n                type: distanceField.getAttribute('fieldType') as 'sdf' | 'msdf' | 'none',\n                range: parseInt(distanceField.getAttribute('distanceRange'), 10),\n            };\n        }\n\n        // pages and chars:\n        const page = xml.getElementsByTagName('page');\n        const char = xml.getElementsByTagName('char');\n        const kerning = xml.getElementsByTagName('kerning');\n\n        data.fontSize = parseInt(info.getAttribute('size'), 10);\n        data.fontFamily = info.getAttribute('face');\n        data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10);\n\n        for (let i = 0; i < page.length; i++)\n        {\n            data.pages.push({\n                id: parseInt(page[i].getAttribute('id'), 10) || 0,\n                file: page[i].getAttribute('file'),\n            });\n        }\n\n        const map: Record<string, string> = {};\n\n        data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute('base'), 10);\n\n        for (let i = 0; i < char.length; i++)\n        {\n            const charNode = char[i];\n            const id = parseInt(charNode.getAttribute('id'), 10);\n\n            let letter = charNode.getAttribute('letter') ?? charNode.getAttribute('char') ?? String.fromCharCode(id);\n\n            if (letter === 'space')letter = ' ';\n\n            map[id] = letter;\n\n            data.chars[letter] = {\n                id,\n                // texture deets..\n                page: parseInt(charNode.getAttribute('page'), 10) || 0,\n                x: parseInt(charNode.getAttribute('x'), 10),\n                y: parseInt(charNode.getAttribute('y'), 10),\n                width: parseInt(charNode.getAttribute('width'), 10),\n                height: parseInt(charNode.getAttribute('height'), 10),\n\n                // render deets..\n                xOffset: parseInt(charNode.getAttribute('xoffset'), 10),\n                yOffset: parseInt(charNode.getAttribute('yoffset'), 10), // + baseLineOffset,\n                xAdvance: parseInt(charNode.getAttribute('xadvance'), 10),\n                kerning: {},\n            } as RawCharData;\n        }\n\n        for (let i = 0; i < kerning.length; i++)\n        {\n            const first = parseInt(kerning[i].getAttribute('first'), 10);\n            const second = parseInt(kerning[i].getAttribute('second'), 10);\n            const amount = parseInt(kerning[i].getAttribute('amount'), 10);\n\n            data.chars[map[second]].kerning[map[first]] = amount;// * 10000;\n        }\n\n        return data;\n    }\n};\n","import { Cache } from '../../assets/cache/Cache.mjs';\nimport { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\nimport { Graphics } from '../graphics/shared/Graphics.mjs';\nimport { SdfShader } from '../text/sdfShader/SdfShader.mjs';\nimport { BitmapFontManager } from './BitmapFontManager.mjs';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout.mjs';\n\n\"use strict\";\nclass BitmapTextPipe {\n  constructor(renderer) {\n    this._gpuBitmapText = {};\n    this._renderer = renderer;\n  }\n  validateRenderable(bitmapText) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    if (bitmapText._didTextUpdate) {\n      bitmapText._didTextUpdate = false;\n      this._updateContext(bitmapText, graphicsRenderable);\n    }\n    return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n  }\n  addRenderable(bitmapText, instructionSet) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    syncWithProxy(bitmapText, graphicsRenderable);\n    if (bitmapText._didTextUpdate) {\n      bitmapText._didTextUpdate = false;\n      this._updateContext(bitmapText, graphicsRenderable);\n    }\n    this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n    if (graphicsRenderable.context.customShader) {\n      this._updateDistanceField(bitmapText);\n    }\n  }\n  destroyRenderable(bitmapText) {\n    this._destroyRenderableByUid(bitmapText.uid);\n  }\n  _destroyRenderableByUid(renderableUid) {\n    BigPool.return(this._gpuBitmapText[renderableUid]);\n    this._gpuBitmapText[renderableUid] = null;\n  }\n  updateRenderable(bitmapText) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    syncWithProxy(bitmapText, graphicsRenderable);\n    this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n    if (graphicsRenderable.context.customShader) {\n      this._updateDistanceField(bitmapText);\n    }\n  }\n  _updateContext(bitmapText, proxyGraphics) {\n    const { context } = proxyGraphics;\n    const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n    context.clear();\n    if (bitmapFont.distanceField.type !== \"none\") {\n      if (!context.customShader) {\n        if (!this._sdfShader) {\n          this._sdfShader = new SdfShader();\n        }\n        context.customShader = this._sdfShader;\n      }\n    }\n    const chars = Array.from(bitmapText.text);\n    const style = bitmapText._style;\n    let currentY = (style._stroke?.width || 0) / 2;\n    currentY += bitmapFont.baseLineOffset;\n    const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont);\n    let index = 0;\n    const padding = style.padding;\n    const scale = bitmapTextLayout.scale;\n    context.translate(\n      -bitmapText._anchor._x * bitmapTextLayout.width - padding,\n      -bitmapText._anchor._y * (bitmapTextLayout.height + bitmapTextLayout.offsetY) - padding\n    ).scale(scale, scale);\n    const tint = style._fill.color;\n    for (let i = 0; i < bitmapTextLayout.lines.length; i++) {\n      const line = bitmapTextLayout.lines[i];\n      for (let j = 0; j < line.charPositions.length; j++) {\n        const char = chars[index++];\n        const charData = bitmapFont.chars[char];\n        if (charData?.texture) {\n          context.texture(\n            charData.texture,\n            tint ? tint : \"black\",\n            Math.round(line.charPositions[j] + charData.xOffset),\n            Math.round(currentY + charData.yOffset)\n          );\n        }\n      }\n      currentY += bitmapFont.lineHeight;\n    }\n  }\n  _getGpuBitmapText(bitmapText) {\n    return this._gpuBitmapText[bitmapText.uid] || this.initGpuText(bitmapText);\n  }\n  initGpuText(bitmapText) {\n    const proxyRenderable = BigPool.get(Graphics);\n    this._gpuBitmapText[bitmapText.uid] = proxyRenderable;\n    this._updateContext(bitmapText, proxyRenderable);\n    bitmapText.on(\"destroyed\", () => {\n      this.destroyRenderable(bitmapText);\n    });\n    return this._gpuBitmapText[bitmapText.uid];\n  }\n  _updateDistanceField(bitmapText) {\n    const context = this._getGpuBitmapText(bitmapText).context;\n    const fontFamily = bitmapText._style.fontFamily;\n    const dynamicFont = Cache.get(`${fontFamily}-bitmap`);\n    const { a, b, c, d } = bitmapText.groupTransform;\n    const dx = Math.sqrt(a * a + b * b);\n    const dy = Math.sqrt(c * c + d * d);\n    const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n    const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n    const resolution = bitmapText.resolution ?? this._renderer.resolution;\n    const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale) * resolution;\n    context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n  }\n  destroy() {\n    for (const uid in this._gpuBitmapText) {\n      this._destroyRenderableByUid(uid);\n    }\n    this._gpuBitmapText = null;\n    this._sdfShader?.destroy(true);\n    this._sdfShader = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nBitmapTextPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"bitmapText\"\n};\nfunction syncWithProxy(container, proxy) {\n  proxy.groupTransform = container.groupTransform;\n  proxy.groupColorAlpha = container.groupColorAlpha;\n  proxy.groupColor = container.groupColor;\n  proxy.groupBlendMode = container.groupBlendMode;\n  proxy.globalDisplayStatus = container.globalDisplayStatus;\n  proxy.groupTransform = container.groupTransform;\n  proxy.localDisplayStatus = container.localDisplayStatus;\n  proxy.groupAlpha = container.groupAlpha;\n  proxy._roundPixels = container._roundPixels;\n}\n\nexport { BitmapTextPipe };\n//# sourceMappingURL=BitmapTextPipe.mjs.map\n","import { Cache } from '../../assets/cache/Cache';\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { Graphics } from '../graphics/shared/Graphics';\nimport { SdfShader } from '../text/sdfShader/SdfShader';\nimport { BitmapFontManager } from './BitmapFontManager';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../rendering/renderers/shared/Renderable';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { BitmapText } from './BitmapText';\n\nexport class BitmapTextPipe implements RenderPipe<BitmapText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'bitmapText',\n    } as const;\n\n    private _renderer: Renderer;\n    private _gpuBitmapText: Record<number, Graphics> = {};\n    private _sdfShader: SdfShader;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(bitmapText: BitmapText): boolean\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n\n        // TODO - need to shift all the verts in the graphicsData to the new anchor\n\n        // update the anchor...\n    }\n\n    public addRenderable(bitmapText: BitmapText, instructionSet: InstructionSet)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    public destroyRenderable(bitmapText: BitmapText)\n    {\n        this._destroyRenderableByUid(bitmapText.uid);\n    }\n\n    private _destroyRenderableByUid(renderableUid: number)\n    {\n        BigPool.return(this._gpuBitmapText[renderableUid] as PoolItem);\n        this._gpuBitmapText[renderableUid] = null;\n    }\n\n    public updateRenderable(bitmapText: BitmapText)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    private _updateContext(bitmapText: BitmapText, proxyGraphics: Graphics)\n    {\n        const { context } = proxyGraphics;\n\n        const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n\n        context.clear();\n\n        if (bitmapFont.distanceField.type !== 'none')\n        {\n            if (!context.customShader)\n            {\n                if (!this._sdfShader)\n                {\n                    this._sdfShader = new SdfShader();\n                }\n\n                context.customShader = this._sdfShader;\n            }\n        }\n\n        const chars = Array.from(bitmapText.text);\n        const style = bitmapText._style;\n\n        let currentY = (style._stroke?.width || 0) / 2;\n\n        currentY += bitmapFont.baseLineOffset;\n\n        // measure our text...\n        const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont);\n\n        let index = 0;\n\n        const padding = style.padding;\n        const scale = bitmapTextLayout.scale;\n\n        context\n            .translate(\n                (-bitmapText._anchor._x * bitmapTextLayout.width) - padding,\n                (-bitmapText._anchor._y * (bitmapTextLayout.height + bitmapTextLayout.offsetY)) - padding)\n            .scale(scale, scale);\n\n        const tint = style._fill.color;\n\n        for (let i = 0; i < bitmapTextLayout.lines.length; i++)\n        {\n            const line = bitmapTextLayout.lines[i];\n\n            for (let j = 0; j < line.charPositions.length; j++)\n            {\n                const char = chars[index++];\n\n                const charData = bitmapFont.chars[char];\n\n                if (charData?.texture)\n                {\n                    context.texture(\n                        charData.texture,\n                        tint ? tint : 'black',\n                        Math.round(line.charPositions[j] + charData.xOffset),\n                        Math.round(currentY + charData.yOffset),\n                    );\n                }\n            }\n\n            currentY += bitmapFont.lineHeight;\n        }\n    }\n\n    private _getGpuBitmapText(bitmapText: BitmapText)\n    {\n        return this._gpuBitmapText[bitmapText.uid] || this.initGpuText(bitmapText);\n    }\n\n    public initGpuText(bitmapText: BitmapText)\n    {\n        // TODO we could keep a bunch of contexts around and reuse one that hav the same style!\n        const proxyRenderable = BigPool.get(Graphics);\n\n        this._gpuBitmapText[bitmapText.uid] = proxyRenderable;\n\n        this._updateContext(bitmapText, proxyRenderable);\n\n        bitmapText.on('destroyed', () =>\n        {\n            this.destroyRenderable(bitmapText);\n        });\n\n        return this._gpuBitmapText[bitmapText.uid];\n    }\n\n    private _updateDistanceField(bitmapText: BitmapText)\n    {\n        const context = this._getGpuBitmapText(bitmapText).context;\n\n        const fontFamily = bitmapText._style.fontFamily as string;\n        const dynamicFont = Cache.get(`${fontFamily as string}-bitmap`);\n\n        // Inject the shader code with the correct value\n        const { a, b, c, d } = bitmapText.groupTransform;\n\n        const dx = Math.sqrt((a * a) + (b * b));\n        const dy = Math.sqrt((c * c) + (d * d));\n        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n\n        const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n\n        const resolution = bitmapText.resolution ?? this._renderer.resolution;\n        const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale) * resolution;\n\n        context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n    }\n\n    public destroy()\n    {\n        for (const uid in this._gpuBitmapText)\n        {\n            this._destroyRenderableByUid(uid as unknown as number);\n        }\n\n        this._gpuBitmapText = null;\n\n        this._sdfShader?.destroy(true);\n        this._sdfShader = null;\n\n        this._renderer = null;\n    }\n}\n\nfunction syncWithProxy(container: Renderable, proxy: Renderable)\n{\n    proxy.groupTransform = container.groupTransform;\n    proxy.groupColorAlpha = container.groupColorAlpha;\n    proxy.groupColor = container.groupColor;\n    proxy.groupBlendMode = container.groupBlendMode;\n    proxy.globalDisplayStatus = container.globalDisplayStatus;\n    proxy.groupTransform = container.groupTransform;\n    proxy.localDisplayStatus = container.localDisplayStatus;\n    proxy.groupAlpha = container.groupAlpha;\n    proxy._roundPixels = container._roundPixels;\n}\n","import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\nimport { Container } from '../../container/Container.mjs';\nimport { GraphicsContext } from './GraphicsContext.mjs';\n\n\"use strict\";\nclass Graphics extends Container {\n  /**\n   * @param options - Options for the Graphics.\n   */\n  constructor(options) {\n    if (options instanceof GraphicsContext) {\n      options = { context: options };\n    }\n    const { context, roundPixels, ...rest } = options || {};\n    super({\n      label: \"Graphics\",\n      ...rest\n    });\n    this.canBundle = true;\n    this.renderPipeId = \"graphics\";\n    this._roundPixels = 0;\n    if (!context) {\n      this._context = this._ownedContext = new GraphicsContext();\n    } else {\n      this._context = context;\n    }\n    this._context.on(\"update\", this.onViewUpdate, this);\n    this.allowChildren = false;\n    this.roundPixels = roundPixels ?? false;\n  }\n  set context(context) {\n    if (context === this._context)\n      return;\n    this._context.off(\"update\", this.onViewUpdate, this);\n    this._context = context;\n    this._context.on(\"update\", this.onViewUpdate, this);\n    this.onViewUpdate();\n  }\n  get context() {\n    return this._context;\n  }\n  /**\n   * The local bounds of the graphic.\n   * @type {rendering.Bounds}\n   */\n  get bounds() {\n    return this._context.bounds;\n  }\n  /**\n   * Adds the bounds of this object to the bounds object.\n   * @param bounds - The output bounds object.\n   */\n  addBounds(bounds) {\n    bounds.addBounds(this._context.bounds);\n  }\n  /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    return this._context.containsPoint(point);\n  }\n  /**\n   *  Whether or not to round the x/y position of the graphic.\n   * @type {boolean}\n   */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  set roundPixels(value) {\n    this._roundPixels = value ? 1 : 0;\n  }\n  onViewUpdate() {\n    this._didChangeId += 1 << 12;\n    this._didGraphicsUpdate = true;\n    if (this.didViewUpdate)\n      return;\n    this.didViewUpdate = true;\n    if (this.renderGroup) {\n      this.renderGroup.onChildViewUpdate(this);\n    }\n  }\n  /**\n   * Destroys this graphics renderable and optionally its context.\n   * @param options - Options parameter. A boolean will act as if all options\n   *\n   * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n   * then the context will still be destroyed.\n   *\n   * If you want to explicitly not destroy this context that this graphics created,\n   * then you should pass destroy({ context: false })\n   *\n   * If the context was passed in as an argument to the constructor then it will not be destroyed\n   * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context\n   * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context\n   * @param {boolean} [options.context=false] - Should destroy the context\n   */\n  destroy(options) {\n    if (this._ownedContext && !options) {\n      this._ownedContext.destroy(options);\n    } else if (options === true || options?.context === true) {\n      this._context.destroy(options);\n    }\n    this._ownedContext = null;\n    this._context = null;\n    super.destroy(options);\n  }\n  _callContextMethod(method, args) {\n    this.context[method](...args);\n    return this;\n  }\n  // --------------------------------------- GraphicsContext methods ---------------------------------------\n  /**\n   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n   * pattern, or a more complex style defined by a FillStyle object.\n   * @param {FillStyleInputs} args - The fill style to apply. This can be a simple color, a gradient or\n   * pattern object, or a FillStyle or ConvertedFillStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setFillStyle(...args) {\n    return this._callContextMethod(\"setFillStyle\", args);\n  }\n  /**\n   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   * @param {FillStyleInputs} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n   * or a StrokeStyle or ConvertedStrokeStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setStrokeStyle(...args) {\n    return this._callContextMethod(\"setStrokeStyle\", args);\n  }\n  fill(...args) {\n    return this._callContextMethod(\"fill\", args);\n  }\n  /**\n   * Strokes the current path with the current stroke style. This method can take an optional\n   * FillStyleInputs parameter to define the stroke's appearance, including its color, width, and other properties.\n   * @param {FillStyleInputs} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more\n   * complex style object. If omitted, uses the current stroke style.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  stroke(...args) {\n    return this._callContextMethod(\"stroke\", args);\n  }\n  texture(...args) {\n    return this._callContextMethod(\"texture\", args);\n  }\n  /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  beginPath() {\n    return this._callContextMethod(\"beginPath\", []);\n  }\n  /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n   * fail to cut correctly!\n   */\n  cut() {\n    return this._callContextMethod(\"cut\", []);\n  }\n  arc(...args) {\n    return this._callContextMethod(\"arc\", args);\n  }\n  arcTo(...args) {\n    return this._callContextMethod(\"arcTo\", args);\n  }\n  arcToSvg(...args) {\n    return this._callContextMethod(\"arcToSvg\", args);\n  }\n  bezierCurveTo(...args) {\n    return this._callContextMethod(\"bezierCurveTo\", args);\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    return this._callContextMethod(\"closePath\", []);\n  }\n  ellipse(...args) {\n    return this._callContextMethod(\"ellipse\", args);\n  }\n  circle(...args) {\n    return this._callContextMethod(\"circle\", args);\n  }\n  path(...args) {\n    return this._callContextMethod(\"path\", args);\n  }\n  lineTo(...args) {\n    return this._callContextMethod(\"lineTo\", args);\n  }\n  moveTo(...args) {\n    return this._callContextMethod(\"moveTo\", args);\n  }\n  quadraticCurveTo(...args) {\n    return this._callContextMethod(\"quadraticCurveTo\", args);\n  }\n  rect(...args) {\n    return this._callContextMethod(\"rect\", args);\n  }\n  roundRect(...args) {\n    return this._callContextMethod(\"roundRect\", args);\n  }\n  poly(...args) {\n    return this._callContextMethod(\"poly\", args);\n  }\n  regularPoly(...args) {\n    return this._callContextMethod(\"regularPoly\", args);\n  }\n  roundPoly(...args) {\n    return this._callContextMethod(\"roundPoly\", args);\n  }\n  roundShape(...args) {\n    return this._callContextMethod(\"roundShape\", args);\n  }\n  filletRect(...args) {\n    return this._callContextMethod(\"filletRect\", args);\n  }\n  chamferRect(...args) {\n    return this._callContextMethod(\"chamferRect\", args);\n  }\n  star(...args) {\n    return this._callContextMethod(\"star\", args);\n  }\n  svg(...args) {\n    return this._callContextMethod(\"svg\", args);\n  }\n  restore(...args) {\n    return this._callContextMethod(\"restore\", args);\n  }\n  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n  save() {\n    return this._callContextMethod(\"save\", []);\n  }\n  /**\n   * Returns the current transformation matrix of the graphics context.\n   * @returns The current transformation matrix.\n   */\n  getTransform() {\n    return this.context.getTransform();\n  }\n  /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing\n   * any transformations (rotation, scaling, translation) previously applied.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  resetTransform() {\n    return this._callContextMethod(\"resetTransform\", []);\n  }\n  rotateTransform(...args) {\n    return this._callContextMethod(\"rotate\", args);\n  }\n  scaleTransform(...args) {\n    return this._callContextMethod(\"scale\", args);\n  }\n  setTransform(...args) {\n    return this._callContextMethod(\"setTransform\", args);\n  }\n  transform(...args) {\n    return this._callContextMethod(\"transform\", args);\n  }\n  translateTransform(...args) {\n    return this._callContextMethod(\"translate\", args);\n  }\n  /**\n   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n   * and optionally resetting transformations to the identity matrix.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  clear() {\n    return this._callContextMethod(\"clear\", []);\n  }\n  /**\n   * The fill style to use.\n   * @type {ConvertedFillStyle}\n   */\n  get fillStyle() {\n    return this._context.fillStyle;\n  }\n  set fillStyle(value) {\n    this._context.fillStyle = value;\n  }\n  /**\n   * The stroke style to use.\n   * @type {ConvertedStrokeStyle}\n   */\n  get strokeStyle() {\n    return this._context.strokeStyle;\n  }\n  set strokeStyle(value) {\n    this._context.strokeStyle = value;\n  }\n  /**\n   * Creates a new Graphics object.\n   * Note that only the context of the object is cloned, not its transform (position,scale,etc)\n   * @param deep - Whether to create a deep clone of the graphics object. If false, the context\n   * will be shared between the two objects (default false). If true, the context will be\n   * cloned (recommended if you need to modify the context in any way).\n   * @returns - A clone of the graphics object\n   */\n  clone(deep = false) {\n    if (deep) {\n      return new Graphics(this._context.clone());\n    }\n    this._ownedContext = null;\n    const clone = new Graphics(this._context);\n    return clone;\n  }\n  // -------- v7 deprecations ---------\n  /**\n   * @param width\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n   */\n  lineStyle(width, color, alpha) {\n    deprecation(v8_0_0, \"Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.\");\n    const strokeStyle = {};\n    width && (strokeStyle.width = width);\n    color && (strokeStyle.color = color);\n    alpha && (strokeStyle.alpha = alpha);\n    this.context.strokeStyle = strokeStyle;\n    return this;\n  }\n  /**\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  beginFill(color, alpha) {\n    deprecation(v8_0_0, \"Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.\");\n    const fillStyle = {};\n    color && (fillStyle.color = color);\n    alpha && (fillStyle.alpha = alpha);\n    this.context.fillStyle = fillStyle;\n    return this;\n  }\n  /**\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  endFill() {\n    deprecation(v8_0_0, \"Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.\");\n    this.context.fill();\n    const strokeStyle = this.context.strokeStyle;\n    if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha) {\n      this.context.stroke();\n    }\n    return this;\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n   */\n  drawCircle(...args) {\n    deprecation(v8_0_0, \"Graphics#drawCircle has been renamed to Graphics#circle\");\n    return this._callContextMethod(\"circle\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n   */\n  drawEllipse(...args) {\n    deprecation(v8_0_0, \"Graphics#drawEllipse has been renamed to Graphics#ellipse\");\n    return this._callContextMethod(\"ellipse\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n   */\n  drawPolygon(...args) {\n    deprecation(v8_0_0, \"Graphics#drawPolygon has been renamed to Graphics#poly\");\n    return this._callContextMethod(\"poly\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n   */\n  drawRect(...args) {\n    deprecation(v8_0_0, \"Graphics#drawRect has been renamed to Graphics#rect\");\n    return this._callContextMethod(\"rect\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n   */\n  drawRoundedRect(...args) {\n    deprecation(v8_0_0, \"Graphics#drawRoundedRect has been renamed to Graphics#roundRect\");\n    return this._callContextMethod(\"roundRect\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n   */\n  drawStar(...args) {\n    deprecation(v8_0_0, \"Graphics#drawStar has been renamed to Graphics#star\");\n    return this._callContextMethod(\"star\", args);\n  }\n}\n\nexport { Graphics };\n//# sourceMappingURL=Graphics.mjs.map\n","import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { Container } from '../../container/Container';\nimport { GraphicsContext } from './GraphicsContext';\n\nimport type { ColorSource } from '../../../color/Color';\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Instruction } from '../../../rendering/renderers/shared/instructions/Instruction';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { View } from '../../../rendering/renderers/shared/view/View';\nimport type { Bounds } from '../../container/bounds/Bounds';\nimport type { ContainerOptions } from '../../container/Container';\nimport type { ContextDestroyOptions, DestroyOptions } from '../../container/destroyTypes';\nimport type { FillStyle, FillStyleInputs, StrokeStyle } from './GraphicsContext';\nimport type { GraphicsPath } from './path/GraphicsPath';\nimport type { RoundedPoint } from './path/roundShape';\n\n/**\n * Constructor options used for `Graphics` instances.\n * ```js\n * const graphics = new Graphics({\n *    fillStyle: { color: 0xff0000, alpha: 0.5 },\n *    strokeStyle: { color: 0x00ff00, width: 2 },\n * });\n * ```\n * @see {@link scene.Graphics}\n * @memberof scene\n */\nexport interface GraphicsOptions extends ContainerOptions\n{\n    /** The GraphicsContext to use, useful for reuse and optimisation */\n    context?: GraphicsContext;\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n\n/**\n * The Graphics class is primarily used to render primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.  However, you can also use a Graphics\n * object to build a list of primitives to use as a mask, or as a complex hitArea.\n * @memberof scene\n * @extends scene.Container\n */\nexport class Graphics extends Container implements View, Instruction\n{\n    public readonly canBundle = true;\n    public readonly renderPipeId = 'graphics';\n    public batched: boolean;\n\n    public _roundPixels: 0 | 1 = 0;\n\n    public _didGraphicsUpdate: boolean;\n\n    private _context: GraphicsContext;\n    private readonly _ownedContext: GraphicsContext;\n\n    /**\n     * @param options - Options for the Graphics.\n     */\n    constructor(options?: GraphicsOptions | GraphicsContext)\n    {\n        if (options instanceof GraphicsContext)\n        {\n            options = { context: options };\n        }\n\n        const { context, roundPixels, ...rest } = options || {};\n\n        super({\n            label: 'Graphics',\n            ...rest\n        });\n\n        if (!context)\n        {\n            this._context = this._ownedContext = new GraphicsContext();\n        }\n        else\n        {\n            this._context = context;\n        }\n\n        this._context.on('update', this.onViewUpdate, this);\n\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n    }\n\n    set context(context: GraphicsContext)\n    {\n        if (context === this._context) return;\n\n        this._context.off('update', this.onViewUpdate, this);\n\n        this._context = context;\n\n        // TODO store this bound function somewhere else..\n        this._context.on('update', this.onViewUpdate, this);\n\n        this.onViewUpdate();\n    }\n\n    get context(): GraphicsContext\n    {\n        return this._context;\n    }\n\n    /**\n     * The local bounds of the graphic.\n     * @type {rendering.Bounds}\n     */\n    get bounds(): Bounds\n    {\n        return this._context.bounds;\n    }\n\n    /**\n     * Adds the bounds of this object to the bounds object.\n     * @param bounds - The output bounds object.\n     */\n    public addBounds(bounds: Bounds)\n    {\n        bounds.addBounds(this._context.bounds);\n    }\n\n    /**\n     * Checks if the object contains the given point.\n     * @param point - The point to check\n     */\n    public containsPoint(point: PointData)\n    {\n        return this._context.containsPoint(point);\n    }\n\n    /**\n     *  Whether or not to round the x/y position of the graphic.\n     * @type {boolean}\n     */\n    get roundPixels()\n    {\n        return !!this._roundPixels;\n    }\n\n    set roundPixels(value: boolean)\n    {\n        this._roundPixels = value ? 1 : 0;\n    }\n\n    protected onViewUpdate()\n    {\n        // increment from the 12th bit!\n        this._didChangeId += 1 << 12;\n        this._didGraphicsUpdate = true;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        if (this.renderGroup)\n        {\n            this.renderGroup.onChildViewUpdate(this);\n        }\n    }\n\n    /**\n     * Destroys this graphics renderable and optionally its context.\n     * @param options - Options parameter. A boolean will act as if all options\n     *\n     * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n     * then the context will still be destroyed.\n     *\n     * If you want to explicitly not destroy this context that this graphics created,\n     * then you should pass destroy({ context: false })\n     *\n     * If the context was passed in as an argument to the constructor then it will not be destroyed\n     * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context\n     * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context\n     * @param {boolean} [options.context=false] - Should destroy the context\n     */\n    public destroy(options?: DestroyOptions): void\n    {\n        if (this._ownedContext && !options)\n        {\n            this._ownedContext.destroy(options);\n        }\n        else if (options === true || (options as ContextDestroyOptions)?.context === true)\n        {\n            this._context.destroy(options);\n        }\n\n        (this._ownedContext as null) = null;\n        this._context = null;\n\n        super.destroy(options);\n    }\n\n    private _callContextMethod(method: keyof GraphicsContext, args: any[]): this\n    {\n        (this.context as any)[method](...args);\n\n        return this;\n    }\n\n    // --------------------------------------- GraphicsContext methods ---------------------------------------\n    /**\n     * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n     * pattern, or a more complex style defined by a FillStyle object.\n     * @param {FillStyleInputs} args - The fill style to apply. This can be a simple color, a gradient or\n     * pattern object, or a FillStyle or ConvertedFillStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setFillStyle(...args: Parameters<GraphicsContext['setFillStyle']>): this\n    {\n        return this._callContextMethod('setFillStyle', args);\n    }\n\n    /**\n     * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n     * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     * @param {FillStyleInputs} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n     * or a StrokeStyle or ConvertedStrokeStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setStrokeStyle(...args: Parameters<GraphicsContext['setStrokeStyle']>): this\n    {\n        return this._callContextMethod('setStrokeStyle', args);\n    }\n\n    /**\n     * Fills the current or given path with the current fill style. This method can optionally take\n     * a color and alpha for a simple fill, or a more complex FillStyleInputs object for advanced fills.\n     * @param {FillStyleInputs} style - (Optional) The style to fill the path with. Can be a color, gradient, pattern, or a\n     * complex style object. If omitted, uses the current fill style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public fill(style?: FillStyleInputs): this;\n    /** @deprecated 8.0.0 */\n    public fill(color: ColorSource, alpha: number): this;\n    public fill(...args: [FillStyleInputs, ColorSource?]): this\n    {\n        return this._callContextMethod('fill', args);\n    }\n    /**\n     * Strokes the current path with the current stroke style. This method can take an optional\n     * FillStyleInputs parameter to define the stroke's appearance, including its color, width, and other properties.\n     * @param {FillStyleInputs} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more\n     * complex style object. If omitted, uses the current stroke style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public stroke(...args: Parameters<GraphicsContext['stroke']>): this\n    {\n        return this._callContextMethod('stroke', args);\n    }\n    /**\n     * Adds a texture to the graphics context. This method supports multiple overloads for specifying the texture,\n     * tint, and dimensions. If only a texture is provided, it uses the texture's width and height for drawing.\n     * Additional parameters allow for specifying a tint color, and custom dimensions for the texture drawing area.\n     * @param texture - The Texture object to use.\n     * @param tint - (Optional) A ColorSource to tint the texture. If not provided, defaults to white (0xFFFFFF).\n     * @param dx - (Optional) The x-coordinate in the destination canvas at which to place the top-left corner of\n     * the source image.\n     * @param dy - (Optional) The y-coordinate in the destination canvas at which to place the top-left corner of\n     * the source image.\n     * @param dw - (Optional) The width of the rectangle within the source image to draw onto the destination canvas.\n     * If not provided, uses the texture's frame width.\n     * @param dh - (Optional) The height of the rectangle within the source image to draw onto the destination canvas.\n     * If not provided, uses the texture's frame height.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public texture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this;\n    public texture(texture: Texture): this;\n    public texture(...args: [Texture, number?, number?, number?, number?, number?]): this\n    {\n        return this._callContextMethod('texture', args);\n    }\n    /**\n     * Resets the current path. Any previous path and its commands are discarded and a new path is\n     * started. This is typically called before beginning a new shape or series of drawing commands.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public beginPath(): this\n    {\n        return this._callContextMethod('beginPath', []);\n    }\n    /**\n     * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n     * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n     * fail to cut correctly!\n     */\n    public cut(): this\n    {\n        return this._callContextMethod('cut', []);\n    }\n    /**\n     * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n     * starting and ending angles, and direction.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The arc's radius.\n     * @param startAngle - The starting angle, in radians.\n     * @param endAngle - The ending angle, in radians.\n     * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise\n     * (false). Defaults to false.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n    public arc(...args: Parameters<GraphicsContext['arc']>): this\n    {\n        return this._callContextMethod('arc', args);\n    }\n    /**\n     * Adds an arc to the current path with the given control points and radius, connected to the previous point\n     * by a straight line if necessary.\n     * @param x1 - The x-coordinate of the first control point.\n     * @param y1 - The y-coordinate of the first control point.\n     * @param x2 - The x-coordinate of the second control point.\n     * @param y2 - The y-coordinate of the second control point.\n     * @param radius - The arc's radius.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n    public arcTo(...args: Parameters<GraphicsContext['arcTo']>): this\n    {\n        return this._callContextMethod('arcTo', args);\n    }\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number\n    ): this;\n    public arcToSvg(...args: Parameters<GraphicsContext['arcToSvg']>): this\n    {\n        return this._callContextMethod('arcToSvg', args);\n    }\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number\n    ): this;\n    public bezierCurveTo(...args: Parameters<GraphicsContext['bezierCurveTo']>): this\n    {\n        return this._callContextMethod('bezierCurveTo', args);\n    }\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        return this._callContextMethod('closePath', []);\n    }\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number): this;\n    public ellipse(...args: Parameters<GraphicsContext['ellipse']>): this\n    {\n        return this._callContextMethod('ellipse', args);\n    }\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number): this;\n    public circle(...args: Parameters<GraphicsContext['circle']>): this\n    {\n        return this._callContextMethod('circle', args);\n    }\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @returns The instance of the current object for chaining.\n     */\n    public path(path: GraphicsPath): this;\n    public path(...args: Parameters<GraphicsContext['path']>): this\n    {\n        return this._callContextMethod('path', args);\n    }\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this;\n    public lineTo(...args: Parameters<GraphicsContext['lineTo']>): this\n    {\n        return this._callContextMethod('lineTo', args);\n    }\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this;\n    public moveTo(...args: Parameters<GraphicsContext['moveTo']>): this\n    {\n        return this._callContextMethod('moveTo', args);\n    }\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cpx - The x-coordinate of the control point.\n     * @param cpy - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n    public quadraticCurveTo(...args: Parameters<GraphicsContext['quadraticCurveTo']>): this\n    {\n        return this._callContextMethod('quadraticCurveTo', args);\n    }\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number): this;\n    public rect(...args: Parameters<GraphicsContext['rect']>): this\n    {\n        return this._callContextMethod('rect', args);\n    }\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number): this;\n    public roundRect(...args: Parameters<GraphicsContext['roundRect']>): this\n    {\n        return this._callContextMethod('roundRect', args);\n    }\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates, of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public poly(points: number[] | PointData[], close?: boolean): this;\n    public poly(...args: Parameters<GraphicsContext['poly']>): this\n    {\n        return this._callContextMethod('poly', args);\n    }\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n    public regularPoly(...args: Parameters<GraphicsContext['regularPoly']>): this\n    {\n        return this._callContextMethod('regularPoly', args);\n    }\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n    public roundPoly(...args: Parameters<GraphicsContext['roundPoly']>): this\n    {\n        return this._callContextMethod('roundPoly', args);\n    }\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n    public roundShape(...args: Parameters<GraphicsContext['roundShape']>): this\n    {\n        return this._callContextMethod('roundShape', args);\n    }\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n    public filletRect(...args: Parameters<GraphicsContext['filletRect']>): this\n    {\n        return this._callContextMethod('filletRect', args);\n    }\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n    public chamferRect(...args: Parameters<GraphicsContext['chamferRect']>): this\n    {\n        return this._callContextMethod('chamferRect', args);\n    }\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public star(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number): this;\n    public star(...args: Parameters<GraphicsContext['star']>): this\n    {\n        return this._callContextMethod('star', args);\n    }\n    /**\n     * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n     * defined in SVG format to be drawn within the graphics context.\n     * @param svg - The SVG string to be parsed and rendered.\n     */\n    public svg(svg: string): this;\n    public svg(...args: Parameters<GraphicsContext['svg']>): this\n    {\n        return this._callContextMethod('svg', args);\n    }\n    /**\n     * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n     * This includes transformations, fill styles, and stroke styles.\n     */\n    public restore(): this;\n    public restore(...args: Parameters<GraphicsContext['restore']>): this\n    {\n        return this._callContextMethod('restore', args);\n    }\n    /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n    public save(): this\n    {\n        return this._callContextMethod('save', []);\n    }\n    /**\n     * Returns the current transformation matrix of the graphics context.\n     * @returns The current transformation matrix.\n     */\n    public getTransform(): Matrix\n    {\n        return this.context.getTransform();\n    }\n    /**\n     * Resets the current transformation matrix to the identity matrix, effectively removing\n     * any transformations (rotation, scaling, translation) previously applied.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public resetTransform(): this\n    {\n        return this._callContextMethod('resetTransform', []);\n    }\n    /**\n     * Applies a rotation transformation to the graphics context around the current origin.\n     * @param angle - The angle of rotation in radians.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public rotateTransform(angle: number): this;\n    public rotateTransform(...args: Parameters<GraphicsContext['rotate']>): this\n    {\n        return this._callContextMethod('rotate', args);\n    }\n    /**\n     * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n     * @param x - The scale factor in the horizontal direction.\n     * @param y - (Optional) The scale factor in the vertical direction.\n     * If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public scaleTransform(x: number, y?: number): this;\n    public scaleTransform(...args: Parameters<GraphicsContext['scale']>): this\n    {\n        return this._callContextMethod('scale', args);\n    }\n    /**\n     * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n     * This replaces the current transformation matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(transform: Matrix): this;\n    public setTransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public setTransform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n    public setTransform(...args: [Matrix] | [number, number, number, number, number, number]): this\n    {\n        return this._callContextMethod('setTransform', args);\n    }\n    /**\n     * Applies the specified transformation matrix to the current graphics context by multiplying\n     * the current matrix with the specified matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(transform: Matrix): this;\n    public transform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public transform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n    public transform(...args: [Matrix] | [number, number, number, number, number, number]): this\n    {\n        return this._callContextMethod('transform', args);\n    }\n    /**\n     * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n     * @param x - The amount to translate in the horizontal direction.\n     * @param y - (Optional) The amount to translate in the vertical direction. If not specified,\n     * the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public translateTransform(x: number, y?: number): this;\n    public translateTransform(...args: Parameters<GraphicsContext['translate']>): this\n    {\n        return this._callContextMethod('translate', args);\n    }\n    /**\n     * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n     * and optionally resetting transformations to the identity matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public clear(): this\n    {\n        return this._callContextMethod('clear', []);\n    }\n    /**\n     * The fill style to use.\n     * @type {ConvertedFillStyle}\n     */\n    get fillStyle(): GraphicsContext['fillStyle']\n    {\n        return this._context.fillStyle;\n    }\n    set fillStyle(value: FillStyleInputs)\n    {\n        this._context.fillStyle = value;\n    }\n    /**\n     * The stroke style to use.\n     * @type {ConvertedStrokeStyle}\n     */\n    get strokeStyle(): GraphicsContext['strokeStyle']\n    {\n        return this._context.strokeStyle;\n    }\n    set strokeStyle(value: FillStyleInputs)\n    {\n        this._context.strokeStyle = value;\n    }\n\n    /**\n     * Creates a new Graphics object.\n     * Note that only the context of the object is cloned, not its transform (position,scale,etc)\n     * @param deep - Whether to create a deep clone of the graphics object. If false, the context\n     * will be shared between the two objects (default false). If true, the context will be\n     * cloned (recommended if you need to modify the context in any way).\n     * @returns - A clone of the graphics object\n     */\n    public clone(deep = false): Graphics\n    {\n        if (deep)\n        {\n            return new Graphics(this._context.clone());\n        }\n\n        (this._ownedContext as null) = null;\n        const clone = new Graphics(this._context);\n\n        return clone;\n    }\n\n    // -------- v7 deprecations ---------\n\n    /**\n     * @param width\n     * @param color\n     * @param alpha\n     * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n     */\n    public lineStyle(width?: number, color?: ColorSource, alpha?: number): this\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.');\n        // #endif\n\n        const strokeStyle: Partial<StrokeStyle> = {};\n\n        // avoid undefined assignment\n        width && (strokeStyle.width = width);\n        color && (strokeStyle.color = color);\n        alpha && (strokeStyle.alpha = alpha);\n\n        this.context.strokeStyle = strokeStyle;\n\n        return this;\n    }\n\n    /**\n     * @param color\n     * @param alpha\n     * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n     */\n    public beginFill(color: ColorSource, alpha?: number)\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.');\n        // #endif\n\n        const fillStyle: Partial<FillStyle> = {};\n\n        // avoid undefined assignment\n        color && (fillStyle.color = color);\n        alpha && (fillStyle.alpha = alpha);\n\n        this.context.fillStyle = fillStyle;\n\n        return this;\n    }\n\n    /**\n     * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n     */\n    public endFill()\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.');\n        // #endif\n\n        this.context.fill();\n        const strokeStyle = this.context.strokeStyle;\n\n        if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width\n            || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color\n            || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha)\n        {\n            this.context.stroke();\n        }\n\n        return this;\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n     */\n    public drawCircle(...args: Parameters<GraphicsContext['circle']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawCircle has been renamed to Graphics#circle');\n        // #endif\n\n        return this._callContextMethod('circle', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n     */\n    public drawEllipse(...args: Parameters<GraphicsContext['ellipse']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawEllipse has been renamed to Graphics#ellipse');\n        // #endif\n\n        return this._callContextMethod('ellipse', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n     */\n    public drawPolygon(...args: Parameters<GraphicsContext['poly']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawPolygon has been renamed to Graphics#poly');\n        // #endif\n\n        return this._callContextMethod('poly', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n     */\n    public drawRect(...args: Parameters<GraphicsContext['rect']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawRect has been renamed to Graphics#rect');\n        // #endif\n\n        return this._callContextMethod('rect', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n     */\n    public drawRoundedRect(...args: Parameters<GraphicsContext['roundRect']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawRoundedRect has been renamed to Graphics#roundRect');\n        // #endif\n\n        return this._callContextMethod('roundRect', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n     */\n    public drawStar(...args: Parameters<GraphicsContext['star']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawStar has been renamed to Graphics#star');\n        // #endif\n\n        return this._callContextMethod('star', args);\n    }\n}\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { MAX_TEXTURES } from '../../../rendering/batcher/shared/const.mjs';\nimport { compileHighShaderGpuProgram, compileHighShaderGlProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { colorBit, colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit.mjs';\nimport { generateTextureBatchBit, generateTextureBatchBitGl } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit.mjs';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { batchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/batchSamplersUniformGroup.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { localUniformMSDFBit, localUniformMSDFBitGl } from './shader-bits/localUniformMSDFBit.mjs';\nimport { mSDFBit, mSDFBitGl } from './shader-bits/mSDFBit.mjs';\n\n\"use strict\";\nclass SdfShader extends Shader {\n  constructor() {\n    const uniforms = new UniformGroup({\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n      uTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uDistance: { value: 4, type: \"f32\" },\n      uRound: { value: 0, type: \"f32\" }\n    });\n    const gpuProgram = compileHighShaderGpuProgram({\n      name: \"sdf-shader\",\n      bits: [\n        colorBit,\n        generateTextureBatchBit(MAX_TEXTURES),\n        localUniformMSDFBit,\n        mSDFBit,\n        roundPixelsBit\n      ]\n    });\n    const glProgram = compileHighShaderGlProgram({\n      name: \"sdf-shader\",\n      bits: [\n        colorBitGl,\n        generateTextureBatchBitGl(MAX_TEXTURES),\n        localUniformMSDFBitGl,\n        mSDFBitGl,\n        roundPixelsBitGl\n      ]\n    });\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        localUniforms: uniforms,\n        batchSamplers: batchSamplersUniformGroup\n      }\n    });\n  }\n}\n\nexport { SdfShader };\n//# sourceMappingURL=SdfShader.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { MAX_TEXTURES } from '../../../rendering/batcher/shared/const';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBit, colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport {\n    generateTextureBatchBit,\n    generateTextureBatchBitGl\n} from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { batchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/batchSamplersUniformGroup';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { localUniformMSDFBit, localUniformMSDFBitGl } from './shader-bits/localUniformMSDFBit';\nimport { mSDFBit, mSDFBitGl } from './shader-bits/mSDFBit';\n\nexport class SdfShader extends Shader\n{\n    constructor()\n    {\n        const uniforms = new UniformGroup({\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uDistance: { value: 4, type: 'f32' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(MAX_TEXTURES),\n                localUniformMSDFBit,\n                mSDFBit,\n                roundPixelsBit\n            ]\n        });\n\n        const glProgram = compileHighShaderGlProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(MAX_TEXTURES),\n                localUniformMSDFBitGl,\n                mSDFBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: uniforms,\n                batchSamplers: batchSamplersUniformGroup,\n            }\n        });\n    }\n}\n","\"use strict\";\nconst localUniformMSDFBit = {\n  name: \"local-uniform-msdf-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `\n    ),\n    main: (\n      /* wgsl */\n      ` \n            outColor = vColor * calculateMSDFAlpha(outColor, localUniforms.uDistance);\n        `\n    )\n  }\n};\nconst localUniformMSDFBitGl = {\n  name: \"local-uniform-msdf-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            uniform float uDistance;\n         `\n    ),\n    main: (\n      /* glsl */\n      ` \n            outColor = vColor * calculateMSDFAlpha(outColor, uDistance);\n        `\n    )\n  }\n};\n\nexport { localUniformMSDFBit, localUniformMSDFBitGl };\n//# sourceMappingURL=localUniformMSDFBit.mjs.map\n","// TODO eventually we should not use this bit, but instead use the localUniformBit\n// have the MSDF bit be merged in with the localUniformBit\n\nexport const localUniformMSDFBit = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `,\n        main: /* wgsl */` \n            outColor = vColor * calculateMSDFAlpha(outColor, localUniforms.uDistance);\n        `\n\n    }\n};\n\nexport const localUniformMSDFBitGl = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform float uDistance;\n         `,\n        main: /* glsl */` \n            outColor = vColor * calculateMSDFAlpha(outColor, uDistance);\n        `\n\n    }\n};\n","\"use strict\";\nconst mSDFBit = {\n  name: \"msdf-bit\",\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, distance:f32) -> f32 {\n                \n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n            \n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                return alpha;\n            }\n        `\n    )\n  }\n};\nconst mSDFBitGl = {\n  name: \"msdf-bit\",\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            float calculateMSDFAlpha(vec4 msdfColor, float distance) {\n                \n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n               \n                // SDF\n                median = min(median, msdfColor.a);\n            \n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n           \n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                return alpha;\n            }\n        `\n    )\n  }\n};\n\nexport { mSDFBit, mSDFBitGl };\n//# sourceMappingURL=mSDFBit.mjs.map\n","export const mSDFBit = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* wgsl */`\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, distance:f32) -> f32 {\n                \n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n            \n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                return alpha;\n            }\n        `,\n    }\n\n};\n\nexport const mSDFBitGl = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* glsl */`\n            float calculateMSDFAlpha(vec4 msdfColor, float distance) {\n                \n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n               \n                // SDF\n                median = min(median, msdfColor.a);\n            \n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n           \n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                return alpha;\n            }\n        `,\n    }\n\n};\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { HTMLTextPipe } from './HTMLTextPipe.mjs';\nimport { HTMLTextSystem } from './HTMLTextSystem.mjs';\n\n\"use strict\";\nextensions.add(HTMLTextSystem);\nextensions.add(HTMLTextPipe);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../../extensions/Extensions';\nimport { HTMLTextPipe } from './HTMLTextPipe';\nimport { HTMLTextSystem } from './HTMLTextSystem';\n\nextensions.add(HTMLTextSystem);\nextensions.add(HTMLTextPipe);\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { updateQuadBounds } from '../../utils/data/updateQuadBounds.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\nimport { BatchableSprite } from '../sprite/BatchableSprite.mjs';\n\n\"use strict\";\nclass HTMLTextPipe {\n  constructor(renderer) {\n    this._gpuText = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  validateRenderable(htmlText) {\n    const gpuText = this._getGpuText(htmlText);\n    const newKey = htmlText._getKey();\n    if (gpuText.textureNeedsUploading) {\n      gpuText.textureNeedsUploading = false;\n      return true;\n    }\n    if (gpuText.currentKey !== newKey) {\n      return true;\n    }\n    return false;\n  }\n  addRenderable(htmlText) {\n    const gpuText = this._getGpuText(htmlText);\n    const batchableSprite = gpuText.batchableSprite;\n    if (htmlText._didTextUpdate) {\n      this._updateText(htmlText);\n    }\n    this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n  }\n  updateRenderable(htmlText) {\n    const gpuText = this._getGpuText(htmlText);\n    const batchableSprite = gpuText.batchableSprite;\n    if (htmlText._didTextUpdate) {\n      this._updateText(htmlText);\n    }\n    batchableSprite.batcher.updateElement(batchableSprite);\n  }\n  destroyRenderable(htmlText) {\n    this._destroyRenderableById(htmlText.uid);\n  }\n  _destroyRenderableById(htmlTextUid) {\n    const gpuText = this._gpuText[htmlTextUid];\n    this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n    BigPool.return(gpuText.batchableSprite);\n    this._gpuText[htmlTextUid] = null;\n  }\n  _updateText(htmlText) {\n    const newKey = htmlText._getKey();\n    const gpuText = this._getGpuText(htmlText);\n    const batchableSprite = gpuText.batchableSprite;\n    if (gpuText.currentKey !== newKey) {\n      this._updateGpuText(htmlText).catch((e) => {\n        console.error(e);\n      });\n    }\n    htmlText._didTextUpdate = false;\n    const padding = htmlText._style.padding;\n    updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n  }\n  async _updateGpuText(htmlText) {\n    htmlText._didTextUpdate = false;\n    const gpuText = this._getGpuText(htmlText);\n    if (gpuText.generatingTexture)\n      return;\n    const newKey = htmlText._getKey();\n    this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n    gpuText.generatingTexture = true;\n    gpuText.currentKey = newKey;\n    const resolution = htmlText.resolution ?? this._renderer.resolution;\n    const texture = await this._renderer.htmlText.getManagedTexture(\n      htmlText.text,\n      resolution,\n      htmlText._style,\n      htmlText._getKey()\n    );\n    const batchableSprite = gpuText.batchableSprite;\n    batchableSprite.texture = gpuText.texture = texture;\n    gpuText.generatingTexture = false;\n    gpuText.textureNeedsUploading = true;\n    htmlText.onViewUpdate();\n    const padding = htmlText._style.padding;\n    updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n  }\n  _getGpuText(htmlText) {\n    return this._gpuText[htmlText.uid] || this.initGpuText(htmlText);\n  }\n  initGpuText(htmlText) {\n    const gpuTextData = {\n      texture: Texture.EMPTY,\n      currentKey: \"--\",\n      batchableSprite: BigPool.get(BatchableSprite),\n      textureNeedsUploading: false,\n      generatingTexture: false\n    };\n    const batchableSprite = gpuTextData.batchableSprite;\n    batchableSprite.renderable = htmlText;\n    batchableSprite.texture = Texture.EMPTY;\n    batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    batchableSprite.roundPixels = this._renderer._roundPixels | htmlText._roundPixels;\n    this._gpuText[htmlText.uid] = gpuTextData;\n    htmlText.on(\"destroyed\", () => {\n      this.destroyRenderable(htmlText);\n    });\n    return gpuTextData;\n  }\n  destroy() {\n    for (const i in this._gpuText) {\n      this._destroyRenderableById(i);\n    }\n    this._gpuText = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nHTMLTextPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"htmlText\"\n};\n\nexport { HTMLTextPipe };\n//# sourceMappingURL=HTMLTextPipe.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { updateQuadBounds } from '../../utils/data/updateQuadBounds';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../sprite/BatchableSprite';\n\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { HTMLText } from './HTMLText';\nimport type { HTMLTextStyle } from './HtmlTextStyle';\n\nexport class HTMLTextPipe implements RenderPipe<HTMLText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _gpuText: Record<number, {\n        textureNeedsUploading: boolean;\n        generatingTexture: boolean;\n        texture: Texture,\n        currentKey: string,\n        batchableSprite: BatchableSprite,\n    }> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(htmlText: HTMLText): boolean\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const newKey = htmlText._getKey();\n\n        if (gpuText.textureNeedsUploading)\n        {\n            gpuText.textureNeedsUploading = false;\n\n            return true;\n        }\n\n        if (gpuText.currentKey !== newKey)\n        {\n            // TODO - could look into optimising this a tad!\n            // if its a single texture, then we could just swap it?\n            // same for CanvasText..\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(htmlText: HTMLText)\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (htmlText._didTextUpdate)\n        {\n            this._updateText(htmlText);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n    }\n\n    public updateRenderable(htmlText: HTMLText)\n    {\n        const gpuText = this._getGpuText(htmlText);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (htmlText._didTextUpdate)\n        {\n            this._updateText(htmlText);\n        }\n\n        batchableSprite.batcher.updateElement(batchableSprite);\n    }\n\n    public destroyRenderable(htmlText: HTMLText)\n    {\n        this._destroyRenderableById(htmlText.uid);\n    }\n\n    private _destroyRenderableById(htmlTextUid: number)\n    {\n        const gpuText = this._gpuText[htmlTextUid];\n\n        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n\n        BigPool.return(gpuText.batchableSprite);\n\n        this._gpuText[htmlTextUid] = null;\n    }\n\n    private _updateText(htmlText: HTMLText)\n    {\n        const newKey = htmlText._getKey();\n        const gpuText = this._getGpuText(htmlText);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            this._updateGpuText(htmlText).catch((e) =>\n            {\n                console.error(e);\n            });\n        }\n\n        htmlText._didTextUpdate = false;\n\n        const padding = htmlText._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n    }\n\n    private async _updateGpuText(htmlText: HTMLText)\n    {\n        htmlText._didTextUpdate = false;\n\n        const gpuText = this._getGpuText(htmlText);\n\n        if (gpuText.generatingTexture) return;\n\n        const newKey = htmlText._getKey();\n\n        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n\n        gpuText.generatingTexture = true;\n\n        gpuText.currentKey = newKey;\n\n        const resolution = htmlText.resolution ?? this._renderer.resolution;\n\n        const texture = await this._renderer.htmlText.getManagedTexture(\n            htmlText.text,\n            resolution,\n            htmlText._style as HTMLTextStyle,\n            htmlText._getKey()\n        );\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        batchableSprite.texture = gpuText.texture = texture;\n\n        gpuText.generatingTexture = false;\n\n        gpuText.textureNeedsUploading = true;\n        htmlText.onViewUpdate();\n\n        const padding = htmlText._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n    }\n\n    private _getGpuText(htmlText: HTMLText)\n    {\n        return this._gpuText[htmlText.uid] || this.initGpuText(htmlText);\n    }\n\n    public initGpuText(htmlText: HTMLText)\n    {\n        const gpuTextData: HTMLTextPipe['_gpuText'][number] = {\n            texture: Texture.EMPTY,\n            currentKey: '--',\n            batchableSprite: BigPool.get(BatchableSprite),\n            textureNeedsUploading: false,\n            generatingTexture: false,\n        };\n\n        const batchableSprite = gpuTextData.batchableSprite;\n\n        batchableSprite.renderable = htmlText;\n        batchableSprite.texture = Texture.EMPTY;\n        batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        batchableSprite.roundPixels = (this._renderer._roundPixels | htmlText._roundPixels) as 0 | 1;\n\n        this._gpuText[htmlText.uid] = gpuTextData;\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        htmlText.on('destroyed', () =>\n        {\n            this.destroyRenderable(htmlText);\n        });\n\n        return gpuTextData;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuText)\n        {\n            this._destroyRenderableById(i as unknown as number);\n        }\n\n        this._gpuText = null;\n        this._renderer = null;\n    }\n}\n\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../../rendering/renderers/types.mjs';\nimport { isSafari } from '../../utils/browser/isSafari.mjs';\nimport { warn } from '../../utils/logging/warn.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\nimport { getPo2TextureFromSource } from '../text/utils/getPo2TextureFromSource.mjs';\nimport { HTMLTextRenderData } from './HTMLTextRenderData.mjs';\nimport { HTMLTextStyle } from './HtmlTextStyle.mjs';\nimport { extractFontFamilies } from './utils/extractFontFamilies.mjs';\nimport { getFontCss } from './utils/getFontCss.mjs';\nimport { getSVGUrl } from './utils/getSVGUrl.mjs';\nimport { getTemporaryCanvasFromImage } from './utils/getTemporaryCanvasFromImage.mjs';\nimport { loadSVGImage } from './utils/loadSVGImage.mjs';\nimport { measureHtmlText } from './utils/measureHtmlText.mjs';\n\n\"use strict\";\nclass HTMLTextSystem {\n  constructor(renderer) {\n    this._activeTextures = {};\n    this._renderer = renderer;\n    this._createCanvas = renderer.type === RendererType.WEBGPU;\n  }\n  getTexture(options) {\n    return this._buildTexturePromise(\n      options.text,\n      options.resolution,\n      options.style\n    );\n  }\n  getManagedTexture(text, resolution, style, textKey) {\n    if (this._activeTextures[textKey]) {\n      this._increaseReferenceCount(textKey);\n      return this._activeTextures[textKey].promise;\n    }\n    const promise = this._buildTexturePromise(text, resolution, style).then((texture) => {\n      this._activeTextures[textKey].texture = texture;\n      return texture;\n    });\n    this._activeTextures[textKey] = {\n      texture: null,\n      promise,\n      usageCount: 1\n    };\n    return promise;\n  }\n  async _buildTexturePromise(text, resolution, style) {\n    const htmlTextData = BigPool.get(HTMLTextRenderData);\n    const fontFamilies = extractFontFamilies(text, style);\n    const fontCSS = await getFontCss(\n      fontFamilies,\n      style,\n      HTMLTextStyle.defaultTextStyle\n    );\n    const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n    const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    const image = htmlTextData.image;\n    image.width = width | 0;\n    image.height = height | 0;\n    const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n    await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n    let resource = image;\n    if (this._createCanvas) {\n      resource = getTemporaryCanvasFromImage(image, resolution);\n    }\n    const texture = getPo2TextureFromSource(resource, image.width, image.height, resolution);\n    if (this._createCanvas) {\n      this._renderer.texture.initSource(texture.source);\n    }\n    BigPool.return(htmlTextData);\n    return texture;\n  }\n  _increaseReferenceCount(textKey) {\n    this._activeTextures[textKey].usageCount++;\n  }\n  decreaseReferenceCount(textKey) {\n    const activeTexture = this._activeTextures[textKey];\n    if (!activeTexture)\n      return;\n    activeTexture.usageCount--;\n    if (activeTexture.usageCount === 0) {\n      if (activeTexture.texture) {\n        this._cleanUp(activeTexture);\n      } else {\n        activeTexture.promise.then((texture) => {\n          activeTexture.texture = texture;\n          this._cleanUp(activeTexture);\n        }).catch(() => {\n          warn(\"HTMLTextSystem: Failed to clean texture\");\n        });\n      }\n      this._activeTextures[textKey] = null;\n    }\n  }\n  _cleanUp(activeTexture) {\n    TexturePool.returnTexture(activeTexture.texture);\n    activeTexture.texture.source.resource = null;\n    activeTexture.texture.source.uploadMethodId = \"unknown\";\n  }\n  getReferenceCount(textKey) {\n    return this._activeTextures[textKey].usageCount;\n  }\n  destroy() {\n    this._activeTextures = null;\n  }\n}\n/** @ignore */\nHTMLTextSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"htmlText\"\n};\nHTMLTextSystem.defaultFontOptions = {\n  fontFamily: \"Arial\",\n  fontStyle: \"normal\",\n  fontWeight: \"normal\"\n};\n\nexport { HTMLTextSystem };\n//# sourceMappingURL=HTMLTextSystem.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { isSafari } from '../../utils/browser/isSafari';\nimport { warn } from '../../utils/logging/warn';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { getPo2TextureFromSource } from '../text/utils/getPo2TextureFromSource';\nimport { HTMLTextRenderData } from './HTMLTextRenderData';\nimport { HTMLTextStyle } from './HtmlTextStyle';\nimport { extractFontFamilies } from './utils/extractFontFamilies';\nimport { getFontCss } from './utils/getFontCss';\nimport { getSVGUrl } from './utils/getSVGUrl';\nimport { getTemporaryCanvasFromImage } from './utils/getTemporaryCanvasFromImage';\nimport { loadSVGImage } from './utils/loadSVGImage';\nimport { measureHtmlText } from './utils/measureHtmlText';\n\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { HTMLTextOptions } from './HTMLText';\nimport type { FontCSSStyleOptions } from './utils/loadFontCSS';\n\ninterface HTMLTextTexture\n{\n    texture: Texture,\n    usageCount: number,\n    promise: Promise<Texture>,\n}\n\n/**\n * System plugin to the renderer to manage HTMLText\n * @memberof rendering\n */\nexport class HTMLTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    public static defaultFontOptions: FontCSSStyleOptions = {\n        fontFamily: 'Arial',\n        fontStyle: 'normal',\n        fontWeight: 'normal',\n    };\n\n    private _activeTextures: Record<string, HTMLTextTexture> = {};\n\n    /**\n     * WebGPU has a cors issue when uploading an image that is an SVGImage\n     * To get around this we need to create a canvas draw the image to it and upload that instead.\n     * Bit of a shame.. but no other work around just yet!\n     */\n    private readonly _createCanvas: boolean;\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._createCanvas = renderer.type === RendererType.WEBGPU;\n    }\n\n    public getTexture(options: HTMLTextOptions): Promise<Texture>\n    {\n        return this._buildTexturePromise(\n            options.text as string,\n            options.resolution,\n            options.style as HTMLTextStyle\n        );\n    }\n\n    public getManagedTexture(\n        text: string,\n        resolution: number,\n        style: HTMLTextStyle,\n        textKey: string\n    ): Promise<Texture>\n    {\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].promise;\n        }\n\n        const promise = this._buildTexturePromise(text, resolution, style)\n            .then((texture) =>\n            {\n                this._activeTextures[textKey].texture = texture;\n\n                return texture;\n            });\n\n        this._activeTextures[textKey] = {\n            texture: null,\n            promise,\n            usageCount: 1,\n        };\n\n        return promise;\n    }\n\n    private async _buildTexturePromise(\n        text: string,\n        resolution: number,\n        style: HTMLTextStyle,\n    )\n    {\n        const htmlTextData = BigPool.get(HTMLTextRenderData);\n        const fontFamilies = extractFontFamilies(text, style);\n        const fontCSS = await getFontCss(\n            fontFamilies,\n            style,\n            HTMLTextStyle.defaultTextStyle as {fontWeight: string, fontStyle: string}\n        );\n        const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const image = htmlTextData.image;\n\n        image.width = width | 0;\n        image.height = height | 0;\n\n        const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n\n        await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n\n        let resource: HTMLImageElement | HTMLCanvasElement = image;\n\n        if (this._createCanvas)\n        {\n            // silly webGPU workaround..\n            resource = getTemporaryCanvasFromImage(image, resolution);\n        }\n\n        const texture = getPo2TextureFromSource(resource, image.width, image.height, resolution);\n\n        if (this._createCanvas)\n        {\n            this._renderer.texture.initSource(texture.source);\n        }\n\n        BigPool.return(htmlTextData as PoolItem);\n\n        return texture;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        // TODO SHOULD NOT BE NEEDED\n        if (!activeTexture) return;\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            if (activeTexture.texture)\n            {\n                this._cleanUp(activeTexture);\n            }\n            else\n            {\n                // we did not resolve...\n                activeTexture.promise.then((texture) =>\n                {\n                    activeTexture.texture = texture;\n\n                    this._cleanUp(activeTexture);\n                }).catch(() =>\n                {\n                    // #if _DEBUG\n                    warn('HTMLTextSystem: Failed to clean texture');\n                    // #endif\n                });\n            }\n\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    private _cleanUp(activeTexture: HTMLTextTexture)\n    {\n        TexturePool.returnTexture(activeTexture.texture);\n        activeTexture.texture.source.resource = null;\n        activeTexture.texture.source.uploadMethodId = 'unknown';\n    }\n\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey].usageCount;\n    }\n\n    public destroy(): void\n    {\n        this._activeTextures = null;\n    }\n}\n","import { DOMAdapter } from '../../environment/adapter.mjs';\n\n\"use strict\";\nfunction isSafari() {\n  const { userAgent } = DOMAdapter.get().getNavigator();\n  return /^((?!chrome|android).)*safari/i.test(userAgent);\n}\n\nexport { isSafari };\n//# sourceMappingURL=isSafari.mjs.map\n","import { DOMAdapter } from '../../environment/adapter';\n\nexport function isSafari(): boolean\n{\n    const { userAgent } = DOMAdapter.get().getNavigator();\n\n    return (/^((?!chrome|android).)*safari/i).test(userAgent);\n}\n","\"use strict\";\nconst nssvg = \"http://www.w3.org/2000/svg\";\nconst nsxhtml = \"http://www.w3.org/1999/xhtml\";\nclass HTMLTextRenderData {\n  constructor() {\n    this.svgRoot = document.createElementNS(nssvg, \"svg\");\n    this.foreignObject = document.createElementNS(nssvg, \"foreignObject\");\n    this.domElement = document.createElementNS(nsxhtml, \"div\");\n    this.styleElement = document.createElementNS(nsxhtml, \"style\");\n    this.image = new Image();\n    const { foreignObject, svgRoot, styleElement, domElement } = this;\n    foreignObject.setAttribute(\"width\", \"10000\");\n    foreignObject.setAttribute(\"height\", \"10000\");\n    foreignObject.style.overflow = \"hidden\";\n    svgRoot.appendChild(foreignObject);\n    foreignObject.appendChild(styleElement);\n    foreignObject.appendChild(domElement);\n  }\n}\n\nexport { HTMLTextRenderData, nssvg, nsxhtml };\n//# sourceMappingURL=HTMLTextRenderData.mjs.map\n","import type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\n\nexport const nssvg = 'http://www.w3.org/2000/svg';\nexport const nsxhtml = 'http://www.w3.org/1999/xhtml';\n\nexport class HTMLTextRenderData\n{\n    public svgRoot = document.createElementNS(nssvg, 'svg');\n    public foreignObject = document.createElementNS(nssvg, 'foreignObject');\n    public domElement = document.createElementNS(nsxhtml, 'div');\n    public styleElement = document.createElementNS(nsxhtml, 'style');\n    public image = new Image();\n    public canvasAndContext?: CanvasAndContext;\n\n    constructor()\n    {\n        const { foreignObject, svgRoot, styleElement, domElement } = this;\n        // Arbitrary max size\n\n        foreignObject.setAttribute('width', '10000');\n        foreignObject.setAttribute('height', '10000');\n        foreignObject.style.overflow = 'hidden';\n\n        svgRoot.appendChild(foreignObject);\n\n        foreignObject.appendChild(styleElement);\n        foreignObject.appendChild(domElement);\n    }\n}\n","import { warn } from '../../utils/logging/warn.mjs';\nimport { TextStyle } from '../text/TextStyle.mjs';\nimport { generateTextStyleKey } from '../text/utils/generateTextStyleKey.mjs';\nimport { textStyleToCSS } from './utils/textStyleToCSS.mjs';\n\n\"use strict\";\nclass HTMLTextStyle extends TextStyle {\n  constructor(options = {}) {\n    super(options);\n    this._cssOverrides = [];\n    this.cssOverrides ?? (this.cssOverrides = options.cssOverrides);\n    this.tagStyles = options.tagStyles ?? {};\n  }\n  /** List of style overrides that will be applied to the HTML text. */\n  set cssOverrides(value) {\n    this._cssOverrides = value instanceof Array ? value : [value];\n    this.update();\n  }\n  get cssOverrides() {\n    return this._cssOverrides;\n  }\n  _generateKey() {\n    this._styleKey = generateTextStyleKey(this) + this._cssOverrides.join(\"-\");\n    return this._styleKey;\n  }\n  update() {\n    this._cssStyle = null;\n    super.update();\n  }\n  /**\n   * Creates a new HTMLTextStyle object with the same values as this one.\n   * @returns New cloned HTMLTextStyle object\n   */\n  clone() {\n    return new HTMLTextStyle({\n      align: this.align,\n      breakWords: this.breakWords,\n      dropShadow: this.dropShadow,\n      fill: this._fill,\n      fontFamily: this.fontFamily,\n      fontSize: this.fontSize,\n      fontStyle: this.fontStyle,\n      fontVariant: this.fontVariant,\n      fontWeight: this.fontWeight,\n      letterSpacing: this.letterSpacing,\n      lineHeight: this.lineHeight,\n      padding: this.padding,\n      stroke: this._stroke,\n      whiteSpace: this.whiteSpace,\n      wordWrap: this.wordWrap,\n      wordWrapWidth: this.wordWrapWidth,\n      cssOverrides: this.cssOverrides\n    });\n  }\n  get cssStyle() {\n    if (!this._cssStyle) {\n      this._cssStyle = textStyleToCSS(this);\n    }\n    return this._cssStyle;\n  }\n  /**\n   * Add a style override, this can be any CSS property\n   * it will override any built-in style. This is the\n   * property and the value as a string (e.g., `color: red`).\n   * This will override any other internal style.\n   * @param {string} value - CSS style(s) to add.\n   * @example\n   * style.addOverride('background-color: red');\n   */\n  addOverride(...value) {\n    const toAdd = value.filter((v) => !this.cssOverrides.includes(v));\n    if (toAdd.length > 0) {\n      this.cssOverrides.push(...toAdd);\n      this.update();\n    }\n  }\n  /**\n   * Remove any overrides that match the value.\n   * @param {string} value - CSS style to remove.\n   * @example\n   * style.removeOverride('background-color: red');\n   */\n  removeOverride(...value) {\n    const toRemove = value.filter((v) => this.cssOverrides.includes(v));\n    if (toRemove.length > 0) {\n      this.cssOverrides = this.cssOverrides.filter((v) => !toRemove.includes(v));\n      this.update();\n    }\n  }\n  set fill(value) {\n    if (typeof value !== \"string\" && typeof value !== \"number\") {\n      warn(\"[HTMLTextStyle] only color fill is not supported by HTMLText\");\n    }\n    super.fill = value;\n  }\n  set stroke(value) {\n    if (value && typeof value !== \"string\" && typeof value !== \"number\") {\n      warn(\"[HTMLTextStyle] only color stroke is not supported by HTMLText\");\n    }\n    super.stroke = value;\n  }\n}\n\nexport { HTMLTextStyle };\n//# sourceMappingURL=HtmlTextStyle.mjs.map\n","/* eslint-disable accessor-pairs */\nimport { warn } from '../../utils/logging/warn';\nimport { TextStyle } from '../text/TextStyle';\nimport { generateTextStyleKey } from '../text/utils/generateTextStyleKey';\nimport { textStyleToCSS } from './utils/textStyleToCSS';\n\nimport type { FillStyleInputs } from '../graphics/shared/GraphicsContext';\nimport type { TextStyleOptions } from '../text/TextStyle';\n\n/**\n * Options for HTML text style, extends {@link TextStyle}.\n * @memberof text\n * @extends text.TextStyleOptions\n * @property {string[]} [cssOverrides] - CSS style(s) to add.\n * @property {Record<string, text.HTMLTextStyleOptions>} [tagStyles] - Tag styles.\n */\nexport interface HTMLTextStyleOptions extends Omit<TextStyleOptions, 'leading' | 'textBaseline' | 'trim' >\n{\n    cssOverrides?: string[];\n    tagStyles?: Record<string, HTMLTextStyleOptions>;\n}\n\n/**\n * A TextStyle object rendered by the HTMLTextSystem.\n * @memberof text\n */\nexport class HTMLTextStyle extends TextStyle\n{\n    private _cssOverrides: string[] = [];\n    private _cssStyle: string;\n    /**\n     * List of styles per tag.\n     * @example\n     * new HTMLText({\n     *   text:'<red>Red</red>,<blue>Blue</blue>,<green>Green</green>',\n     *   style:{\n     *       fontFamily: 'DM Sans',\n     *       fill: 'white',\n     *       fontSize:100,\n     *       tagStyles:{\n     *           red:{\n     *               fill:'red',\n     *           },\n     *           blue:{\n     *               fill:'blue',\n     *           },\n     *           green:{\n     *               fill:'green',\n     *           }\n     *       }\n     *   }\n     * );\n     */\n    public tagStyles: Record<string, HTMLTextStyleOptions>;\n\n    constructor(options: HTMLTextStyleOptions = {})\n    {\n        super(options);\n\n        this.cssOverrides ??= options.cssOverrides;\n        this.tagStyles = options.tagStyles ?? {};\n    }\n\n    /** List of style overrides that will be applied to the HTML text. */\n    set cssOverrides(value: string | string[])\n    {\n        this._cssOverrides = value instanceof Array ? value : [value];\n        this.update();\n    }\n\n    get cssOverrides(): string[]\n    {\n        return this._cssOverrides;\n    }\n\n    protected override _generateKey(): string\n    {\n        this._styleKey = generateTextStyleKey(this) + this._cssOverrides.join('-');\n\n        return this._styleKey;\n    }\n\n    public update()\n    {\n        this._cssStyle = null;\n        super.update();\n    }\n\n    /**\n     * Creates a new HTMLTextStyle object with the same values as this one.\n     * @returns New cloned HTMLTextStyle object\n     */\n    public clone(): HTMLTextStyle\n    {\n        return new HTMLTextStyle({\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this.dropShadow,\n            fill: this._fill,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth,\n            cssOverrides: this.cssOverrides,\n        });\n    }\n\n    get cssStyle(): string\n    {\n        if (!this._cssStyle)\n        {\n            this._cssStyle = textStyleToCSS(this);\n        }\n\n        return this._cssStyle;\n    }\n\n    /**\n     * Add a style override, this can be any CSS property\n     * it will override any built-in style. This is the\n     * property and the value as a string (e.g., `color: red`).\n     * This will override any other internal style.\n     * @param {string} value - CSS style(s) to add.\n     * @example\n     * style.addOverride('background-color: red');\n     */\n    public addOverride(...value: string[]): void\n    {\n        const toAdd = value.filter((v) => !this.cssOverrides.includes(v));\n\n        if (toAdd.length > 0)\n        {\n            this.cssOverrides.push(...toAdd);\n            this.update();\n        }\n    }\n\n    /**\n     * Remove any overrides that match the value.\n     * @param {string} value - CSS style to remove.\n     * @example\n     * style.removeOverride('background-color: red');\n     */\n    public removeOverride(...value: string[]): void\n    {\n        const toRemove = value.filter((v) => this.cssOverrides.includes(v));\n\n        if (toRemove.length > 0)\n        {\n            this.cssOverrides = this.cssOverrides.filter((v) => !toRemove.includes(v));\n            this.update();\n        }\n    }\n\n    override set fill(value: FillStyleInputs)\n    {\n        // if its not a string or a number, then its a texture!\n        if (typeof value !== 'string' && typeof value !== 'number')\n        {\n            // #if _DEBUG\n            warn('[HTMLTextStyle] only color fill is not supported by HTMLText');\n            // #endif\n        }\n\n        super.fill = value;\n    }\n\n    override set stroke(value: FillStyleInputs)\n    {\n        // if its not a string or a number, then its a texture!\n        if (value && typeof value !== 'string' && typeof value !== 'number')\n        {\n            // #if _DEBUG\n            warn('[HTMLTextStyle] only color stroke is not supported by HTMLText');\n            // #endif\n        }\n\n        super.stroke = value;\n    }\n}\n","import { Color } from '../../../color/Color.mjs';\n\n\"use strict\";\nfunction textStyleToCSS(style) {\n  const stroke = style._stroke;\n  const fill = style._fill;\n  const cssStyleString = [\n    `color: ${Color.shared.setValue(fill.color).toHex()}`,\n    `font-size: ${style.fontSize}px`,\n    `font-family: ${style.fontFamily}`,\n    `font-weight: ${style.fontWeight}`,\n    `font-style: ${style.fontStyle}`,\n    `font-variant: ${style.fontVariant}`,\n    `letter-spacing: ${style.letterSpacing}px`,\n    `text-align: ${style.align}`,\n    `padding: ${style.padding}px`,\n    `white-space: ${style.whiteSpace === \"pre\" && style.wordWrap ? \"pre-wrap\" : style.whiteSpace}`,\n    ...style.lineHeight ? [`line-height: ${style.lineHeight}px`] : [],\n    ...style.wordWrap ? [\n      `word-wrap: ${style.breakWords ? \"break-all\" : \"break-word\"}`,\n      `max-width: ${style.wordWrapWidth}px`\n    ] : [],\n    ...stroke ? [strokeToCSS(stroke)] : [],\n    ...style.dropShadow ? [dropShadowToCSS(style.dropShadow)] : [],\n    ...style.cssOverrides\n  ].join(\";\");\n  const cssStyles = [`div { ${cssStyleString} }`];\n  tagStyleToCSS(style.tagStyles, cssStyles);\n  return cssStyles.join(\" \");\n}\nfunction dropShadowToCSS(dropShadowStyle) {\n  const color = Color.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();\n  const x = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);\n  const y = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);\n  const position = `${x}px ${y}px`;\n  if (dropShadowStyle.blur > 0) {\n    return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;\n  }\n  return `text-shadow: ${position} ${color}`;\n}\nfunction strokeToCSS(stroke) {\n  return [\n    `-webkit-text-stroke-width: ${stroke.width}px`,\n    `-webkit-text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,\n    `text-stroke-width: ${stroke.width}px`,\n    `text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,\n    \"paint-order: stroke\"\n  ].join(\";\");\n}\nconst templates = {\n  fontSize: `font-size: {{VALUE}}px`,\n  fontFamily: `font-family: {{VALUE}}`,\n  fontWeight: `font-weight: {{VALUE}}`,\n  fontStyle: `font-style: {{VALUE}}`,\n  fontVariant: `font-variant: {{VALUE}}`,\n  letterSpacing: `letter-spacing: {{VALUE}}px`,\n  align: `text-align: {{VALUE}}`,\n  padding: `padding: {{VALUE}}px`,\n  whiteSpace: `white-space: {{VALUE}}`,\n  lineHeight: `line-height: {{VALUE}}px`,\n  wordWrapWidth: `max-width: {{VALUE}}px`\n};\nconst transform = {\n  fill: (value) => `color: ${Color.shared.setValue(value).toHex()}`,\n  breakWords: (value) => `word-wrap: ${value ? \"break-all\" : \"break-word\"}`,\n  stroke: strokeToCSS,\n  dropShadow: dropShadowToCSS\n};\nfunction tagStyleToCSS(tagStyles, out) {\n  for (const i in tagStyles) {\n    const tagStyle = tagStyles[i];\n    const cssTagStyle = [];\n    for (const j in tagStyle) {\n      if (transform[j]) {\n        cssTagStyle.push(transform[j](tagStyle[j]));\n      } else if (templates[j]) {\n        cssTagStyle.push(templates[j].replace(\"{{VALUE}}\", tagStyle[j]));\n      }\n    }\n    out.push(`${i} { ${cssTagStyle.join(\";\")} }`);\n  }\n}\n\nexport { textStyleToCSS };\n//# sourceMappingURL=textStyleToCSS.mjs.map\n","import { Color } from '../../../color/Color';\n\nimport type { StrokeStyle } from '../../graphics/shared/GraphicsContext';\nimport type { TextStyle } from '../../text/TextStyle';\nimport type { HTMLTextStyle, HTMLTextStyleOptions } from '../HtmlTextStyle';\n\n/**\n * Internally converts all of the style properties into CSS equivalents.\n * @param style\n * @returns The CSS style string, for setting `style` property of root HTMLElement.\n */\nexport function textStyleToCSS(style: HTMLTextStyle): string\n{\n    const stroke = style._stroke;\n    const fill = style._fill;\n\n    const cssStyleString = [\n        `color: ${Color.shared.setValue(fill.color).toHex()}`,\n        `font-size: ${(style.fontSize as number)}px`,\n        `font-family: ${style.fontFamily}`,\n        `font-weight: ${style.fontWeight}`,\n        `font-style: ${style.fontStyle}`,\n        `font-variant: ${style.fontVariant}`,\n        `letter-spacing: ${style.letterSpacing}px`,\n        `text-align: ${style.align}`,\n        `padding: ${style.padding}px`,\n        `white-space: ${(style.whiteSpace === 'pre' && style.wordWrap) ? 'pre-wrap' : style.whiteSpace}`,\n        ...style.lineHeight ? [`line-height: ${style.lineHeight}px`] : [],\n        ...style.wordWrap ? [\n            `word-wrap: ${style.breakWords ? 'break-all' : 'break-word'}`,\n            `max-width: ${style.wordWrapWidth}px`\n        ] : [],\n        ...stroke ? [strokeToCSS(stroke)] : [],\n        ...style.dropShadow ? [dropShadowToCSS(style.dropShadow)] : [],\n        ...style.cssOverrides,\n    ].join(';');\n\n    const cssStyles = [`div { ${cssStyleString} }`];\n\n    tagStyleToCSS(style.tagStyles, cssStyles);\n\n    return cssStyles.join(' ');\n}\n\nfunction dropShadowToCSS(dropShadowStyle: TextStyle['dropShadow']): string\n{\n    const color = Color.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();\n    const x = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);\n    const y = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);\n\n    const position = `${x}px ${y}px`;\n\n    if (dropShadowStyle.blur > 0)\n    {\n        return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;\n    }\n\n    return `text-shadow: ${position} ${color}`;\n}\n\nfunction strokeToCSS(stroke: StrokeStyle): string\n{\n    return [\n        `-webkit-text-stroke-width: ${stroke.width}px`,\n        `-webkit-text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,\n        `text-stroke-width: ${stroke.width}px`,\n        `text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,\n        'paint-order: stroke',\n    ].join(';');\n}\n\n/** Converts the tag styles into CSS. */\nconst templates = {\n    fontSize: `font-size: {{VALUE}}px`,\n    fontFamily: `font-family: {{VALUE}}`,\n    fontWeight: `font-weight: {{VALUE}}`,\n    fontStyle: `font-style: {{VALUE}}`,\n    fontVariant: `font-variant: {{VALUE}}`,\n    letterSpacing: `letter-spacing: {{VALUE}}px`,\n    align: `text-align: {{VALUE}}`,\n    padding: `padding: {{VALUE}}px`,\n    whiteSpace: `white-space: {{VALUE}}`,\n    lineHeight: `line-height: {{VALUE}}px`,\n    wordWrapWidth: `max-width: {{VALUE}}px`,\n};\n\n/** Converts the tag styles into CSS if modifications are required */\nconst transform = {\n    fill: (value: string) => `color: ${Color.shared.setValue(value).toHex()}`,\n    breakWords: (value: string) => `word-wrap: ${value ? 'break-all' : 'break-word'}`,\n    stroke: strokeToCSS,\n    dropShadow: dropShadowToCSS\n};\n\nfunction tagStyleToCSS(tagStyles: Record<string, HTMLTextStyleOptions>, out: string[])\n{\n    for (const i in tagStyles)\n    {\n        const tagStyle = tagStyles[i];\n        const cssTagStyle = [];\n\n        for (const j in tagStyle)\n        {\n            if (transform[j as keyof typeof transform])\n            {\n                // eslint-disable-next-line max-len\n                cssTagStyle.push(transform[j as keyof typeof transform](tagStyle[j as keyof HTMLTextStyleOptions] as any));\n            }\n            else if (templates[j as keyof typeof templates])\n            {\n                // eslint-disable-next-line max-len\n                cssTagStyle.push(templates[j as keyof typeof templates].replace('{{VALUE}}', tagStyle[j as keyof HTMLTextStyleOptions] as any));\n            }\n        }\n\n        out.push(`${i} { ${cssTagStyle.join(';')} }`);\n    }\n}\n","\"use strict\";\nfunction extractFontFamilies(text, style) {\n  const fontFamily = style.fontFamily;\n  const fontFamilies = [];\n  const dedupe = {};\n  const regex = /font-family:([^;\"\\s]+)/g;\n  const matches = text.match(regex);\n  function addFontFamily(fontFamily2) {\n    if (!dedupe[fontFamily2]) {\n      fontFamilies.push(fontFamily2);\n      dedupe[fontFamily2] = true;\n    }\n  }\n  if (Array.isArray(fontFamily)) {\n    for (let i = 0; i < fontFamily.length; i++) {\n      addFontFamily(fontFamily[i]);\n    }\n  } else {\n    addFontFamily(fontFamily);\n  }\n  if (matches) {\n    matches.forEach((match) => {\n      const fontFamily2 = match.split(\":\")[1].trim();\n      addFontFamily(fontFamily2);\n    });\n  }\n  for (const i in style.tagStyles) {\n    const fontFamily2 = style.tagStyles[i].fontFamily;\n    addFontFamily(fontFamily2);\n  }\n  return fontFamilies;\n}\n\nexport { extractFontFamilies };\n//# sourceMappingURL=extractFontFamilies.mjs.map\n","import type { HTMLTextStyle } from '../HtmlTextStyle';\n\n/**\n * Extracts font families from text. It will extract font families from the style, tagStyles and any font families\n * embedded in the text. It should also strip out duplicates as it goes.\n * @param  text - The text to extract font families from\n * @param style - The style to extract font families from\n * @returns {string[]} - The font families as an array of strings\n */\nexport function extractFontFamilies(text: string, style: HTMLTextStyle): string[]\n{\n    const fontFamily = style.fontFamily;\n    const fontFamilies: string[] = [];\n    const dedupe: Record<string, boolean> = {};\n\n    // first ensure fonts are loaded inline..\n    // find any font..\n    const regex = /font-family:([^;\"\\s]+)/g;\n\n    const matches = text.match(regex);\n\n    function addFontFamily(fontFamily: string)\n    {\n        if (!dedupe[fontFamily])\n        {\n            fontFamilies.push(fontFamily);\n\n            dedupe[fontFamily] = true;\n        }\n    }\n\n    if (Array.isArray(fontFamily))\n    {\n        for (let i = 0; i < fontFamily.length; i++)\n        {\n            addFontFamily(fontFamily[i]);\n        }\n    }\n    else\n    {\n        addFontFamily(fontFamily);\n    }\n\n    if (matches)\n    {\n        matches.forEach((match) =>\n        {\n            const fontFamily = match.split(':')[1].trim();\n\n            addFontFamily(fontFamily);\n        });\n    }\n\n    for (const i in style.tagStyles)\n    {\n        const fontFamily = style.tagStyles[i].fontFamily;\n\n        addFontFamily(fontFamily as string);\n    }\n\n    return fontFamilies;\n}\n","import { Cache } from '../../../assets/cache/Cache.mjs';\nimport { loadFontCSS } from './loadFontCSS.mjs';\n\n\"use strict\";\nconst FontStylePromiseCache = /* @__PURE__ */ new Map();\nasync function getFontCss(fontFamilies, style, defaultOptions) {\n  const fontPromises = fontFamilies.filter((fontFamily) => Cache.has(`${fontFamily}-and-url`)).map((fontFamily, i) => {\n    if (!FontStylePromiseCache.has(fontFamily)) {\n      const { url } = Cache.get(`${fontFamily}-and-url`);\n      if (i === 0) {\n        FontStylePromiseCache.set(fontFamily, loadFontCSS(style, url));\n      } else {\n        FontStylePromiseCache.set(fontFamily, loadFontCSS({\n          fontWeight: defaultOptions.fontWeight,\n          fontStyle: defaultOptions.fontStyle,\n          fontFamily\n        }, url));\n      }\n    }\n    return FontStylePromiseCache.get(fontFamily);\n  });\n  return (await Promise.all(fontPromises)).join(\"\\n\");\n}\n\nexport { FontStylePromiseCache, getFontCss };\n//# sourceMappingURL=getFontCss.mjs.map\n","import { Cache } from '../../../assets/cache/Cache';\nimport { loadFontCSS } from './loadFontCSS';\n\nimport type { FontCSSStyleOptions } from './loadFontCSS';\n\nexport const FontStylePromiseCache = new Map<string, Promise<string>>();\n\n/**\n * takes the font families and returns a css string that can be injected into a style tag\n * It will contain the font families and the font urls encoded as base64\n * @param fontFamilies - The font families to load\n * @param style - The FontCSSStyleOptions to load the font with (used for the first font family)\n * @param defaultOptions - The default options to load the font with (used for the rest of the font families)\n * @param defaultOptions.fontWeight - The default font weight\n * @param defaultOptions.fontStyle - The default font style\n * @returns - The css string\n */\nexport async function getFontCss(\n    fontFamilies: string[],\n    style: FontCSSStyleOptions,\n    defaultOptions: {fontWeight: string, fontStyle: string}\n)\n{\n    const fontPromises = fontFamilies\n        .filter((fontFamily) => Cache.has(`${fontFamily}-and-url`))\n        .map((fontFamily, i) =>\n        {\n            if (!FontStylePromiseCache.has(fontFamily))\n            {\n                const { url } = Cache.get(`${fontFamily}-and-url`);\n\n                if (i === 0)\n                {\n                    FontStylePromiseCache.set(fontFamily, loadFontCSS(style, url));\n                }\n\n                else\n                {\n                    FontStylePromiseCache.set(fontFamily, loadFontCSS({\n                        fontWeight: defaultOptions.fontWeight,\n                        fontStyle: defaultOptions.fontStyle,\n                        fontFamily,\n                    }, url));\n                }\n            }\n\n            return FontStylePromiseCache.get(fontFamily);\n        });\n\n    return (await Promise.all(fontPromises)).join('\\n');\n}\n","import { loadFontAsBase64 } from './loadFontAsBase64.mjs';\n\n\"use strict\";\nasync function loadFontCSS(style, url) {\n  const dataSrc = await loadFontAsBase64(url);\n  return `@font-face {\n        font-family: \"${style.fontFamily}\";\n        src: url('${dataSrc}');\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n    }`;\n}\n\nexport { loadFontCSS };\n//# sourceMappingURL=loadFontCSS.mjs.map\n","import { loadFontAsBase64 } from './loadFontAsBase64';\n\nexport interface FontCSSStyleOptions\n{\n    fontFamily: string | string[]\n    fontWeight: string\n    fontStyle: string\n}\n\n/**\n * This will take a font url and a style and return a css string that can be injected into a style tag\n * This will contain inlined base64 font and the font family information\n * @param style - the style to generate the css for\n * @param url - The url to load the font from\n * @returns - The css string\n */\nexport async function loadFontCSS(style: FontCSSStyleOptions, url: string): Promise<string>\n{\n    const dataSrc = await loadFontAsBase64(url);\n\n    return `@font-face {\n        font-family: \"${style.fontFamily}\";\n        src: url('${dataSrc}');\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n    }`;\n}\n","import { DOMAdapter } from '../../../environment/adapter.mjs';\n\n\"use strict\";\nasync function loadFontAsBase64(url) {\n  const response = await DOMAdapter.get().fetch(url);\n  const blob = await response.blob();\n  const reader = new FileReader();\n  const dataSrc = await new Promise((resolve, reject) => {\n    reader.onloadend = () => resolve(reader.result);\n    reader.onerror = reject;\n    reader.readAsDataURL(blob);\n  });\n  return dataSrc;\n}\n\nexport { loadFontAsBase64 };\n//# sourceMappingURL=loadFontAsBase64.mjs.map\n","import { DOMAdapter } from '../../../environment/adapter';\n\n/**\n * Resolves a font url to a base64 string\n * @param url - The url to load the font from\n * @returns - The font as a base64 string\n */\nexport async function loadFontAsBase64(url: string): Promise<string>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    const blob = await response.blob();\n\n    const reader = new FileReader();\n\n    const dataSrc: string = await new Promise((resolve, reject) =>\n    {\n        reader.onloadend = () => resolve(reader.result as string);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n    });\n\n    return dataSrc;\n}\n","\"use strict\";\nfunction getSVGUrl(text, style, resolution, fontCSS, htmlTextData) {\n  const { domElement, styleElement, svgRoot } = htmlTextData;\n  domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n  domElement.setAttribute(\"style\", `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n  styleElement.textContent = fontCSS;\n  const { width, height } = htmlTextData.image;\n  svgRoot.setAttribute(\"width\", width.toString());\n  svgRoot.setAttribute(\"height\", height.toString());\n  return new XMLSerializer().serializeToString(svgRoot);\n}\n\nexport { getSVGUrl };\n//# sourceMappingURL=getSVGUrl.mjs.map\n","import type { HTMLTextRenderData } from '../HTMLTextRenderData';\nimport type { HTMLTextStyle } from '../HtmlTextStyle';\n\n/**\n * takes all the data and returns a svg url string can be loaded by an image element\n * @param text - The text to measure\n * @param style - The style to use\n * @param resolution - The resolution to use\n * @param fontCSS - The font css to use\n * @param htmlTextData - The HTMLTextRenderData to write the SVG to\n * @returns - The SVG as a url string\n */\nexport function getSVGUrl(\n    text: string,\n    style: HTMLTextStyle,\n    resolution: number,\n    fontCSS: string,\n    htmlTextData: HTMLTextRenderData\n)\n{\n    const { domElement, styleElement, svgRoot } = htmlTextData;\n\n    domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n    domElement.setAttribute('style', `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n    styleElement.textContent = fontCSS;\n\n    const { width, height } = htmlTextData.image;\n\n    svgRoot.setAttribute('width', width.toString());\n    svgRoot.setAttribute('height', height.toString());\n\n    return new XMLSerializer().serializeToString(svgRoot);\n}\n","import { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool.mjs';\n\n\"use strict\";\nfunction getTemporaryCanvasFromImage(image, resolution) {\n  const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n    image.width,\n    image.height,\n    resolution\n  );\n  const { context } = canvasAndContext;\n  context.clearRect(0, 0, image.width, image.height);\n  context.drawImage(image, 0, 0);\n  CanvasPool.returnCanvasAndContext(canvasAndContext);\n  return canvasAndContext.canvas;\n}\n\nexport { getTemporaryCanvasFromImage };\n//# sourceMappingURL=getTemporaryCanvasFromImage.mjs.map\n","import { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\n\n/**\n * This function converts an image to a canvas, and returns the canvas.\n * It is used to convert images to canvases to work around a CORS issue where WebGPU cannot\n * upload an SVGImage to a texture.\n *\n * It uses the CanvasPool to get an optimal canvas and context, and then draws the image onto it.\n * This canvas is immediately returned to the CanvasPool for reuse, so use the result straight away!\n * (eg upload it to the GPU!)\n * @param image - The image to convert to a canvas.\n * @param resolution - The resolution of the canvas.\n */\nexport function getTemporaryCanvasFromImage(image: HTMLImageElement, resolution: number): HTMLCanvasElement\n{\n    // Get an optimal canvas and context from the CanvasPool, based on the\n    // dimensions of the image and the desired resolution.\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n        image.width,\n        image.height,\n        resolution\n    );\n\n    // Clear the context of the canvas, and draw the image onto it.\n    const { context } = canvasAndContext;\n\n    context.clearRect(0, 0, image.width, image.height);\n    context.drawImage(image, 0, 0);\n\n    // Return the canvas and context to the CanvasPool.\n    CanvasPool.returnCanvasAndContext(canvasAndContext);\n\n    // Return the canvas.\n    return canvasAndContext.canvas as HTMLCanvasElement;\n}\n\n","\"use strict\";\nfunction loadSVGImage(image, url, delay) {\n  return new Promise(async (resolve) => {\n    if (delay) {\n      await new Promise((resolve2) => setTimeout(resolve2, 100));\n    }\n    image.onload = () => {\n      resolve();\n    };\n    image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n    image.crossOrigin = \"anonymous\";\n  });\n}\n\nexport { loadSVGImage };\n//# sourceMappingURL=loadSVGImage.mjs.map\n","/**\n * This function loads an SVG image into an HTMLImageElement.\n * The image can then be uploaded as texture to the GPU.\n * iOS has a bug where embedded fonts are not available immediately after the image loads,\n * so we wait an arbitrary amount of time before resolving the promise.\n * @param image - The image to load the SVG into\n * @param url - The url to load the SVG from\n * @param delay - Whether to delay the load\n * @returns - A promise that resolves when the image has loaded\n */\nexport function loadSVGImage(image: HTMLImageElement, url: string, delay: boolean)\n{\n    return new Promise<void>(async (resolve) =>\n    {\n        // Safari has a known bug where embedded fonts are not available\n        // immediately after the image loads, to compensate we wait an\n        // arbitrary amount of time\n        // @see https://bugs.webkit.org/show_bug.cgi?id=219770\n        if (delay)\n        {\n            await new Promise<void>((resolve) => setTimeout(resolve, 100));\n        }\n\n        image.onload = () =>\n        {\n            resolve();\n        };\n\n        image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n        image.crossOrigin = 'anonymous';\n    });\n}\n","import { CanvasTextMetrics } from '../../text/canvas/CanvasTextMetrics.mjs';\nimport { HTMLTextRenderData } from '../HTMLTextRenderData.mjs';\n\n\"use strict\";\nlet tempHTMLTextRenderData;\nfunction measureHtmlText(text, style, fontStyleCSS, htmlTextRenderData) {\n  htmlTextRenderData = htmlTextRenderData || tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());\n  const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n  domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n  domElement.setAttribute(\"style\", \"transform-origin: top left; display: inline-block\");\n  if (fontStyleCSS) {\n    styleElement.textContent = fontStyleCSS;\n  }\n  document.body.appendChild(svgRoot);\n  const contentBounds = domElement.getBoundingClientRect();\n  svgRoot.remove();\n  const descenderPadding = CanvasTextMetrics.measureFont(style.fontStyle).descent;\n  return {\n    width: contentBounds.width,\n    height: contentBounds.height + descenderPadding\n  };\n}\n\nexport { measureHtmlText };\n//# sourceMappingURL=measureHtmlText.mjs.map\n","import { CanvasTextMetrics } from '../../text/canvas/CanvasTextMetrics';\nimport { HTMLTextRenderData } from '../HTMLTextRenderData';\n\nimport type { Size } from '../../../maths/misc/Size';\nimport type { HTMLTextStyle } from '../HtmlTextStyle';\n\nlet tempHTMLTextRenderData: HTMLTextRenderData;\n\n/**\n * Measures the HTML text without actually generating an image.\n * This is used to calculate the size of the text.\n * @param text - The text to measure\n * @param style - The style to use\n * @param fontStyleCSS - The font css to use\n * @param htmlTextRenderData - The HTMLTextRenderData to write the SVG to\n * @returns - The size of the text\n */\nexport function measureHtmlText(\n    text: string,\n    style: HTMLTextStyle,\n    fontStyleCSS?: string,\n    htmlTextRenderData?: HTMLTextRenderData\n): Size\n{\n    htmlTextRenderData = htmlTextRenderData || tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());\n\n    const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n\n    domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n\n    domElement.setAttribute('style', 'transform-origin: top left; display: inline-block');\n\n    if (fontStyleCSS)\n    {\n        styleElement.textContent = fontStyleCSS;\n    }\n\n    // Measure the contents using the shadow DOM\n    document.body.appendChild(svgRoot);\n\n    const contentBounds = domElement.getBoundingClientRect();\n\n    svgRoot.remove();\n\n    const descenderPadding = CanvasTextMetrics.measureFont(style.fontStyle).descent;\n\n    return {\n        width: contentBounds.width,\n        height: contentBounds.height + descenderPadding,\n    };\n}\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { TilingSpritePipe } from './TilingSpritePipe.mjs';\n\n\"use strict\";\nextensions.add(TilingSpritePipe);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../../extensions/Extensions';\nimport { TilingSpritePipe } from './TilingSpritePipe';\n\nextensions.add(TilingSpritePipe);\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { State } from '../../rendering/renderers/shared/state/State.mjs';\nimport { RendererType } from '../../rendering/renderers/types.mjs';\nimport { color32BitToUniform } from '../graphics/gpu/colorToUniform.mjs';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh.mjs';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry.mjs';\nimport { TilingSpriteShader } from './shader/TilingSpriteShader.mjs';\nimport { QuadGeometry } from './utils/QuadGeometry.mjs';\nimport { setPositions } from './utils/setPositions.mjs';\nimport { setUvs } from './utils/setUvs.mjs';\n\n\"use strict\";\nconst sharedQuad = new QuadGeometry();\nclass TilingSpritePipe {\n  constructor(renderer) {\n    this._tilingSpriteDataHash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  validateRenderable(renderable) {\n    const tilingSpriteData = this._getTilingSpriteData(renderable);\n    const couldBatch = tilingSpriteData.canBatch;\n    this._updateCanBatch(renderable);\n    const canBatch = tilingSpriteData.canBatch;\n    if (canBatch && canBatch === couldBatch) {\n      const { batchableMesh } = tilingSpriteData;\n      if (batchableMesh.texture._source !== renderable.texture._source) {\n        return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, renderable.texture);\n      }\n    }\n    return couldBatch !== canBatch;\n  }\n  addRenderable(tilingSprite, instructionSet) {\n    const batcher = this._renderer.renderPipes.batch;\n    this._updateCanBatch(tilingSprite);\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    const { geometry, canBatch } = tilingSpriteData;\n    if (canBatch) {\n      tilingSpriteData.batchableMesh || (tilingSpriteData.batchableMesh = new BatchableMesh());\n      const batchableMesh = tilingSpriteData.batchableMesh;\n      if (tilingSprite._didTilingSpriteUpdate) {\n        tilingSprite._didTilingSpriteUpdate = false;\n        this._updateBatchableMesh(tilingSprite);\n        batchableMesh.geometry = geometry;\n        batchableMesh.mesh = tilingSprite;\n        batchableMesh.texture = tilingSprite._texture;\n      }\n      batchableMesh.roundPixels = this._renderer._roundPixels | tilingSprite._roundPixels;\n      batcher.addToBatch(batchableMesh);\n    } else {\n      batcher.break(instructionSet);\n      tilingSpriteData.shader || (tilingSpriteData.shader = new TilingSpriteShader());\n      this.updateRenderable(tilingSprite);\n      instructionSet.add(tilingSprite);\n    }\n  }\n  execute(tilingSprite) {\n    const { shader } = this._tilingSpriteDataHash[tilingSprite.uid];\n    shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n    const localUniforms = shader.resources.localUniforms.uniforms;\n    localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n    localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n    color32BitToUniform(\n      tilingSprite.groupColorAlpha,\n      localUniforms.uColor,\n      0\n    );\n    this._renderer.encoder.draw({\n      geometry: sharedQuad,\n      shader,\n      state: State.default2d\n    });\n  }\n  updateRenderable(tilingSprite) {\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    const { canBatch } = tilingSpriteData;\n    if (canBatch) {\n      const { batchableMesh } = tilingSpriteData;\n      if (tilingSprite._didTilingSpriteUpdate)\n        this._updateBatchableMesh(tilingSprite);\n      batchableMesh.batcher.updateElement(batchableMesh);\n    } else if (tilingSprite._didTilingSpriteUpdate) {\n      const { shader } = tilingSpriteData;\n      shader.updateUniforms(\n        tilingSprite.width,\n        tilingSprite.height,\n        tilingSprite._tileTransform.matrix,\n        tilingSprite.anchor.x,\n        tilingSprite.anchor.y,\n        tilingSprite.texture\n      );\n    }\n    tilingSprite._didTilingSpriteUpdate = false;\n  }\n  destroyRenderable(tilingSprite) {\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    tilingSpriteData.batchableMesh = null;\n    tilingSpriteData.shader?.destroy();\n    this._tilingSpriteDataHash[tilingSprite.uid] = null;\n  }\n  _getTilingSpriteData(renderable) {\n    return this._tilingSpriteDataHash[renderable.uid] || this._initTilingSpriteData(renderable);\n  }\n  _initTilingSpriteData(tilingSprite) {\n    const geometry = new MeshGeometry({\n      indices: sharedQuad.indices,\n      positions: sharedQuad.positions.slice(),\n      uvs: sharedQuad.uvs.slice()\n    });\n    this._tilingSpriteDataHash[tilingSprite.uid] = {\n      canBatch: true,\n      renderable: tilingSprite,\n      geometry\n    };\n    tilingSprite.on(\"destroyed\", () => {\n      this.destroyRenderable(tilingSprite);\n    });\n    return this._tilingSpriteDataHash[tilingSprite.uid];\n  }\n  _updateBatchableMesh(tilingSprite) {\n    const renderableData = this._getTilingSpriteData(tilingSprite);\n    const { geometry } = renderableData;\n    const style = tilingSprite.texture.source.style;\n    if (style.addressMode !== \"repeat\") {\n      style.addressMode = \"repeat\";\n      style.update();\n    }\n    setUvs(tilingSprite, geometry.uvs);\n    setPositions(tilingSprite, geometry.positions);\n  }\n  destroy() {\n    for (const i in this._tilingSpriteDataHash) {\n      this.destroyRenderable(this._tilingSpriteDataHash[i].renderable);\n    }\n    this._tilingSpriteDataHash = null;\n    this._renderer = null;\n  }\n  _updateCanBatch(tilingSprite) {\n    const renderableData = this._getTilingSpriteData(tilingSprite);\n    const texture = tilingSprite.texture;\n    let _nonPowOf2wrapping = true;\n    if (this._renderer.type === RendererType.WEBGL) {\n      _nonPowOf2wrapping = this._renderer.context.supports.nonPowOf2wrapping;\n    }\n    renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n    return renderableData.canBatch;\n  }\n}\n/** @ignore */\nTilingSpritePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"tilingSprite\"\n};\n\nexport { TilingSpritePipe };\n//# sourceMappingURL=TilingSpritePipe.mjs.map\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { State } from '../../rendering/renderers/shared/state/State';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { color32BitToUniform } from '../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\nimport { TilingSpriteShader } from './shader/TilingSpriteShader';\nimport { QuadGeometry } from './utils/QuadGeometry';\nimport { setPositions } from './utils/setPositions';\nimport { setUvs } from './utils/setUvs';\n\nimport type { WebGLRenderer } from '../../rendering/renderers/gl/WebGLRenderer';\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { TilingSprite } from './TilingSprite';\n\ninterface RenderableData\n{\n    canBatch: boolean;\n    renderable: TilingSprite\n    batchableMesh?: BatchableMesh;\n    geometry?: MeshGeometry;\n    shader?: TilingSpriteShader;\n}\n\nconst sharedQuad = new QuadGeometry();\n\nexport class TilingSpritePipe implements RenderPipe<TilingSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'tilingSprite',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private readonly _tilingSpriteDataHash: Record<number, RenderableData> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(renderable: TilingSprite): boolean\n    {\n        const tilingSpriteData = this._getTilingSpriteData(renderable);\n\n        const couldBatch = tilingSpriteData.canBatch;\n\n        this._updateCanBatch(renderable);\n\n        const canBatch = tilingSpriteData.canBatch;\n\n        if (canBatch && canBatch === couldBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            // we are batching.. check a texture change!\n            if (batchableMesh.texture._source !== renderable.texture._source)\n\n            { return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, renderable.texture); }\n        }\n\n        return (couldBatch !== canBatch);\n\n        // // TODO - only update if required?\n        // // only texture\n        // // only uvs\n        // // only positions?\n    }\n\n    public addRenderable(tilingSprite: TilingSprite, instructionSet: InstructionSet)\n    {\n        const batcher = this._renderer.renderPipes.batch;\n\n        // init\n        this._updateCanBatch(tilingSprite);\n\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry, canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            tilingSpriteData.batchableMesh ||= new BatchableMesh();\n\n            const batchableMesh = tilingSpriteData.batchableMesh;\n\n            if (tilingSprite._didTilingSpriteUpdate)\n            {\n                tilingSprite._didTilingSpriteUpdate = false;\n\n                this._updateBatchableMesh(tilingSprite);\n\n                batchableMesh.geometry = geometry;\n                batchableMesh.mesh = tilingSprite;\n                batchableMesh.texture = tilingSprite._texture;\n            }\n\n            batchableMesh.roundPixels = (this._renderer._roundPixels | tilingSprite._roundPixels) as 0 | 1;\n\n            batcher.addToBatch(batchableMesh);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            tilingSpriteData.shader ||= new TilingSpriteShader();\n\n            this.updateRenderable(tilingSprite);\n\n            instructionSet.add(tilingSprite);\n        }\n    }\n\n    public execute(tilingSprite: TilingSprite)\n    {\n        const { shader } = this._tilingSpriteDataHash[tilingSprite.uid];\n\n        shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n\n        // deal with local uniforms...\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n        localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n\n        color32BitToUniform(\n            tilingSprite.groupColorAlpha,\n            localUniforms.uColor,\n            0\n        );\n\n        this._renderer.encoder.draw({\n            geometry: sharedQuad,\n            shader,\n            state: State.default2d,\n        });\n    }\n\n    public updateRenderable(tilingSprite: TilingSprite)\n    {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            if (tilingSprite._didTilingSpriteUpdate) this._updateBatchableMesh(tilingSprite);\n\n            batchableMesh.batcher.updateElement(batchableMesh);\n        }\n        else if (tilingSprite._didTilingSpriteUpdate)\n        {\n            const { shader } = tilingSpriteData;\n            // now update uniforms...\n\n            shader.updateUniforms(\n                tilingSprite.width,\n                tilingSprite.height,\n                tilingSprite._tileTransform.matrix,\n                tilingSprite.anchor.x,\n                tilingSprite.anchor.y,\n                tilingSprite.texture,\n            );\n        }\n\n        tilingSprite._didTilingSpriteUpdate = false;\n    }\n\n    public destroyRenderable(tilingSprite: TilingSprite)\n    {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        tilingSpriteData.batchableMesh = null;\n\n        tilingSpriteData.shader?.destroy();\n\n        this._tilingSpriteDataHash[tilingSprite.uid] = null;\n    }\n\n    private _getTilingSpriteData(renderable: TilingSprite): RenderableData\n    {\n        return this._tilingSpriteDataHash[renderable.uid] || this._initTilingSpriteData(renderable);\n    }\n\n    private _initTilingSpriteData(tilingSprite: TilingSprite): RenderableData\n    {\n        const geometry = new MeshGeometry({\n            indices: sharedQuad.indices,\n            positions: sharedQuad.positions.slice(),\n            uvs: sharedQuad.uvs.slice(),\n        });\n\n        this._tilingSpriteDataHash[tilingSprite.uid] = {\n            canBatch: true,\n            renderable: tilingSprite,\n            geometry,\n        };\n\n        tilingSprite.on('destroyed', () =>\n        {\n            this.destroyRenderable(tilingSprite);\n        });\n\n        return this._tilingSpriteDataHash[tilingSprite.uid];\n    }\n\n    private _updateBatchableMesh(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry } = renderableData;\n\n        const style = tilingSprite.texture.source.style;\n\n        if (style.addressMode !== 'repeat')\n        {\n            style.addressMode = 'repeat';\n            style.update();\n        }\n\n        setUvs(tilingSprite, geometry.uvs);\n        setPositions(tilingSprite, geometry.positions);\n    }\n\n    public destroy()\n    {\n        for (const i in this._tilingSpriteDataHash)\n        {\n            this.destroyRenderable(this._tilingSpriteDataHash[i].renderable);\n        }\n\n        (this._tilingSpriteDataHash as null) = null;\n        this._renderer = null;\n    }\n\n    private _updateCanBatch(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n        const texture = tilingSprite.texture;\n\n        let _nonPowOf2wrapping = true;\n\n        if (this._renderer.type === RendererType.WEBGL)\n        {\n            _nonPowOf2wrapping = (this._renderer as WebGLRenderer).context.supports.nonPowOf2wrapping;\n        }\n\n        renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n\n        return renderableData.canBatch;\n    }\n}\n\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer.mjs';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const.mjs';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry.mjs';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nconst _MeshGeometry = class _MeshGeometry extends Geometry {\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (options instanceof Float32Array) {\n      deprecation(v8_0_0, \"use new MeshGeometry({ positions, uvs, indices }) instead\");\n      options = {\n        positions: options,\n        uvs: args[1],\n        indices: args[2]\n      };\n    }\n    options = { ..._MeshGeometry.defaultOptions, ...options };\n    const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n    const uvs = options.uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n    const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n    const shrinkToFit = options.shrinkBuffersToFit;\n    const positionBuffer = new Buffer({\n      data: positions,\n      label: \"attribute-mesh-positions\",\n      shrinkToFit,\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n    });\n    const uvBuffer = new Buffer({\n      data: uvs,\n      label: \"attribute-mesh-uvs\",\n      shrinkToFit,\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n    });\n    const indexBuffer = new Buffer({\n      data: indices,\n      label: \"index-mesh-buffer\",\n      shrinkToFit,\n      usage: BufferUsage.INDEX | BufferUsage.COPY_DST\n    });\n    super({\n      attributes: {\n        aPosition: {\n          buffer: positionBuffer,\n          format: \"float32x2\",\n          stride: 2 * 4,\n          offset: 0\n        },\n        aUV: {\n          buffer: uvBuffer,\n          format: \"float32x2\",\n          stride: 2 * 4,\n          offset: 0\n        }\n      },\n      indexBuffer,\n      topology: options.topology\n    });\n    this.batchMode = \"auto\";\n  }\n  /** The positions of the mesh. */\n  get positions() {\n    return this.attributes.aPosition.buffer.data;\n  }\n  set positions(value) {\n    this.attributes.aPosition.buffer.data = value;\n  }\n  /** The UVs of the mesh. */\n  get uvs() {\n    return this.attributes.aUV.buffer.data;\n  }\n  set uvs(value) {\n    this.attributes.aUV.buffer.data = value;\n  }\n  /** The indices of the mesh. */\n  get indices() {\n    return this.indexBuffer.data;\n  }\n  set indices(value) {\n    this.indexBuffer.data = value;\n  }\n};\n_MeshGeometry.defaultOptions = {\n  topology: \"triangle-list\",\n  shrinkBuffersToFit: false\n};\nlet MeshGeometry = _MeshGeometry;\n\nexport { MeshGeometry };\n//# sourceMappingURL=MeshGeometry.mjs.map\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { BatchMode } from '../../graphics/shared/GraphicsContext';\n\n/**\n * Options for the mesh geometry.\n * @memberof scene\n */\nexport interface MeshGeometryOptions\n{\n    /** The positions of the mesh. */\n    positions?: Float32Array;\n    /** The UVs of the mesh. */\n    uvs?: Float32Array;\n    /** The indices of the mesh. */\n    indices?: Uint32Array;\n    /** The topology of the mesh. */\n    topology?: Topology;\n    /** Whether to shrink the buffers to fit the data. */\n    shrinkBuffersToFit?: boolean;\n}\n\n/**\n * A geometry used to batch multiple meshes with the same texture.\n * @memberof scene\n */\nexport class MeshGeometry extends Geometry\n{\n    public static defaultOptions: MeshGeometryOptions = {\n        topology: 'triangle-list',\n        shrinkBuffersToFit: false,\n    };\n\n    public batchMode: BatchMode = 'auto';\n\n    /**\n     * @param {scene.MeshGeometryOptions} options - The options of the mesh geometry.\n     */\n    constructor(options: MeshGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(positions: Float32Array, uvs: Float32Array, indices: Uint32Array);\n    constructor(...args: [MeshGeometryOptions] | [Float32Array, Float32Array, Uint32Array])\n    {\n        let options = args[0] ?? {};\n\n        if (options instanceof Float32Array)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'use new MeshGeometry({ positions, uvs, indices }) instead');\n            // #endif\n\n            options = {\n                positions: options,\n                uvs: args[1],\n                indices: args[2],\n            };\n        }\n\n        options = { ...MeshGeometry.defaultOptions, ...options };\n\n        const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n        const uvs = options.uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n        const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n\n        const shrinkToFit = options.shrinkBuffersToFit;\n\n        const positionBuffer = new Buffer({\n            data: positions,\n            label: 'attribute-mesh-positions',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const uvBuffer = new Buffer({\n            data: uvs,\n            label: 'attribute-mesh-uvs',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const indexBuffer = new Buffer({\n            data: indices,\n            label: 'index-mesh-buffer',\n            shrinkToFit,\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST,\n        });\n\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: positionBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n                aUV: {\n                    buffer: uvBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n            },\n            indexBuffer,\n            topology: options.topology,\n        });\n    }\n\n    /** The positions of the mesh. */\n    get positions(): Float32Array\n    {\n        return this.attributes.aPosition.buffer.data as Float32Array;\n    }\n\n    set positions(value: Float32Array)\n    {\n        this.attributes.aPosition.buffer.data = value;\n    }\n\n    /** The UVs of the mesh. */\n    get uvs(): Float32Array\n    {\n        return this.attributes.aUV.buffer.data as Float32Array;\n    }\n\n    set uvs(value: Float32Array)\n    {\n        this.attributes.aUV.buffer.data = value;\n    }\n\n    /** The indices of the mesh. */\n    get indices(): Uint32Array\n    {\n        return this.indexBuffer.data as Uint32Array;\n    }\n\n    set indices(value: Uint32Array)\n    {\n        this.indexBuffer.data = value;\n    }\n}\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { compileHighShaderGpuProgram, compileHighShaderGlProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { localUniformBit, localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit.mjs';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { tilingBit, tilingBitGl } from './tilingBit.mjs';\n\n\"use strict\";\nlet gpuProgram;\nlet glProgram;\nclass TilingSpriteShader extends Shader {\n  constructor() {\n    gpuProgram ?? (gpuProgram = compileHighShaderGpuProgram({\n      name: \"tiling-sprite-shader\",\n      bits: [\n        localUniformBit,\n        tilingBit,\n        roundPixelsBit\n      ]\n    }));\n    glProgram ?? (glProgram = compileHighShaderGlProgram({\n      name: \"tiling-sprite-shader\",\n      bits: [\n        localUniformBitGl,\n        tilingBitGl,\n        roundPixelsBitGl\n      ]\n    }));\n    const tilingUniforms = new UniformGroup({\n      uMapCoord: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: \"vec4<f32>\" },\n      uClampOffset: { value: new Float32Array([0, 0]), type: \"vec2<f32>\" },\n      uTextureTransform: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: \"vec4<f32>\" }\n    });\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        localUniforms: new UniformGroup({\n          uTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n          uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n          uRound: { value: 0, type: \"f32\" }\n        }),\n        tilingUniforms,\n        uTexture: Texture.EMPTY.source,\n        uSampler: Texture.EMPTY.source.style\n      }\n    });\n  }\n  updateUniforms(width, height, matrix, anchorX, anchorY, texture) {\n    const tilingUniforms = this.resources.tilingUniforms;\n    const textureWidth = texture.width;\n    const textureHeight = texture.height;\n    const textureMatrix = texture.textureMatrix;\n    const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n    uTextureTransform.set(\n      matrix.a * textureWidth / width,\n      matrix.b * textureWidth / height,\n      matrix.c * textureHeight / width,\n      matrix.d * textureHeight / height,\n      matrix.tx / width,\n      matrix.ty / height\n    );\n    uTextureTransform.invert();\n    tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n    tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n    tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n    tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n    tilingUniforms.uniforms.uSizeAnchor[0] = width;\n    tilingUniforms.uniforms.uSizeAnchor[1] = height;\n    tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n    tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n    if (texture) {\n      this.resources.uTexture = texture.source;\n      this.resources.uSampler = texture.source.style;\n    }\n  }\n}\n\nexport { TilingSpriteShader };\n//# sourceMappingURL=TilingSpriteShader.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBit, localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { tilingBit, tilingBitGl } from './tilingBit';\n\nimport type { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport type { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\n\nlet gpuProgram: GpuProgram;\nlet glProgram: GlProgram;\n\nexport class TilingSpriteShader extends Shader\n{\n    constructor()\n    {\n        gpuProgram ??= compileHighShaderGpuProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBit,\n                tilingBit,\n                roundPixelsBit,\n            ],\n        });\n\n        glProgram ??= compileHighShaderGlProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBitGl,\n                tilingBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        const tilingUniforms = new UniformGroup({\n            uMapCoord: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: 'vec4<f32>' },\n            uClampOffset: { value: new Float32Array([0, 0]), type: 'vec2<f32>' },\n            uTextureTransform: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: 'vec4<f32>' },\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: new UniformGroup({\n                    uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n                    uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n                    uRound: { value: 0, type: 'f32' },\n                }),\n                tilingUniforms,\n                uTexture: Texture.EMPTY.source,\n                uSampler: Texture.EMPTY.source.style,\n            }\n        });\n    }\n\n    public updateUniforms(\n        width: number, height: number,\n        matrix: Matrix,\n        anchorX: number, anchorY: number,\n        texture: Texture\n    ): void\n    {\n        const tilingUniforms = this.resources.tilingUniforms;\n\n        const textureWidth = texture.width;\n        const textureHeight = texture.height;\n        const textureMatrix = texture.textureMatrix;\n\n        const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n\n        uTextureTransform.set(\n            matrix.a * textureWidth / width,\n            matrix.b * textureWidth / height,\n            matrix.c * textureHeight / width,\n            matrix.d * textureHeight / height,\n            matrix.tx / width,\n            matrix.ty / height);\n\n        uTextureTransform.invert();\n\n        tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n        tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n        tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n        tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n        tilingUniforms.uniforms.uSizeAnchor[0] = width;\n        tilingUniforms.uniforms.uSizeAnchor[1] = height;\n        tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n        tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n\n        if (texture)\n        {\n            this.resources.uTexture = texture.source;\n            this.resources.uSampler = texture.source.style;\n        }\n    }\n}\n","\"use strict\";\nconst tilingBit = {\n  name: \"tiling-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            } \n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    )\n  }\n};\nconst tilingBitGl = {\n  name: \"tiling-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n        \n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n        \n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n    \n        `\n    )\n  }\n};\n\nexport { tilingBit, tilingBitGl };\n//# sourceMappingURL=tilingBit.mjs.map\n","export const tilingBit = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            } \n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    }\n\n};\n\nexport const tilingBitGl = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n        \n        `,\n        main: /* glsl */`\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `,\n        main: /* glsl */`\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n        \n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n    \n        `\n    }\n\n};\n","import { MeshGeometry } from '../../mesh/shared/MeshGeometry.mjs';\n\n\"use strict\";\nclass QuadGeometry extends MeshGeometry {\n  constructor() {\n    super({\n      positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      indices: new Uint32Array([0, 1, 2, 0, 2, 3])\n    });\n  }\n}\n\nexport { QuadGeometry };\n//# sourceMappingURL=QuadGeometry.mjs.map\n","import { MeshGeometry } from '../../mesh/shared/MeshGeometry';\n\nexport class QuadGeometry extends MeshGeometry\n{\n    constructor()\n    {\n        super({\n            positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            indices: new Uint32Array([0, 1, 2, 0, 2, 3]),\n        });\n    }\n}\n","\"use strict\";\nfunction setPositions(tilingSprite, positions) {\n  const anchorX = tilingSprite.anchor.x;\n  const anchorY = tilingSprite.anchor.y;\n  positions[0] = -anchorX * tilingSprite.width;\n  positions[1] = -anchorY * tilingSprite.height;\n  positions[2] = (1 - anchorX) * tilingSprite.width;\n  positions[3] = -anchorY * tilingSprite.height;\n  positions[4] = (1 - anchorX) * tilingSprite.width;\n  positions[5] = (1 - anchorY) * tilingSprite.height;\n  positions[6] = -anchorX * tilingSprite.width;\n  positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n\nexport { setPositions };\n//# sourceMappingURL=setPositions.mjs.map\n","import type { TilingSprite } from '../TilingSprite';\n\nexport function setPositions(tilingSprite: TilingSprite, positions: Float32Array)\n{\n    const anchorX = tilingSprite.anchor.x;\n    const anchorY = tilingSprite.anchor.y;\n\n    positions[0] = -anchorX * tilingSprite.width;\n    positions[1] = -anchorY * tilingSprite.height;\n    positions[2] = (1 - anchorX) * tilingSprite.width;\n    positions[3] = -anchorY * tilingSprite.height;\n    positions[4] = (1 - anchorX) * tilingSprite.width;\n    positions[5] = (1 - anchorY) * tilingSprite.height;\n    positions[6] = -anchorX * tilingSprite.width;\n    positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { applyMatrix } from './applyMatrix.mjs';\n\n\"use strict\";\nfunction setUvs(tilingSprite, uvs) {\n  const texture = tilingSprite.texture;\n  const width = texture.frame.width;\n  const height = texture.frame.height;\n  let anchorX = 0;\n  let anchorY = 0;\n  if (tilingSprite._applyAnchorToTexture) {\n    anchorX = tilingSprite.anchor.x;\n    anchorY = tilingSprite.anchor.y;\n  }\n  uvs[0] = uvs[6] = -anchorX;\n  uvs[2] = uvs[4] = 1 - anchorX;\n  uvs[1] = uvs[3] = -anchorY;\n  uvs[5] = uvs[7] = 1 - anchorY;\n  const textureMatrix = Matrix.shared;\n  textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n  textureMatrix.tx /= tilingSprite.width;\n  textureMatrix.ty /= tilingSprite.height;\n  textureMatrix.invert();\n  textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n  applyMatrix(uvs, 2, 0, textureMatrix);\n}\n\nexport { setUvs };\n//# sourceMappingURL=setUvs.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { applyMatrix } from './applyMatrix';\n\nimport type { TilingSprite } from '../TilingSprite';\n\nexport function setUvs(tilingSprite: TilingSprite, uvs: Float32Array)\n{\n    const texture = tilingSprite.texture;\n\n    const width = texture.frame.width;\n    const height = texture.frame.height;\n\n    let anchorX = 0;\n    let anchorY = 0;\n\n    if (tilingSprite._applyAnchorToTexture)\n    {\n        anchorX = tilingSprite.anchor.x;\n        anchorY = tilingSprite.anchor.y;\n    }\n\n    uvs[0] = uvs[6] = -anchorX;\n    uvs[2] = uvs[4] = 1 - anchorX;\n    uvs[1] = uvs[3] = -anchorY;\n    uvs[5] = uvs[7] = 1 - anchorY;\n\n    const textureMatrix = Matrix.shared;\n\n    textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n\n    textureMatrix.tx /= tilingSprite.width;\n    textureMatrix.ty /= tilingSprite.height;\n\n    textureMatrix.invert();\n\n    textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n\n    applyMatrix(uvs, 2, 0, textureMatrix);\n}\n","\"use strict\";\nfunction applyMatrix(array, stride, offset, matrix) {\n  let index = 0;\n  const size = array.length / (stride || 2);\n  const a = matrix.a;\n  const b = matrix.b;\n  const c = matrix.c;\n  const d = matrix.d;\n  const tx = matrix.tx;\n  const ty = matrix.ty;\n  offset *= stride;\n  while (index < size) {\n    const x = array[offset];\n    const y = array[offset + 1];\n    array[offset] = a * x + c * y + tx;\n    array[offset + 1] = b * x + d * y + ty;\n    offset += stride;\n    index++;\n  }\n}\n\nexport { applyMatrix };\n//# sourceMappingURL=applyMatrix.mjs.map\n","import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { TypedArray } from '../../../rendering/renderers/shared/buffer/Buffer';\n\nexport function applyMatrix(array: TypedArray, stride: number, offset: number, matrix: Matrix)\n{\n    let index = 0;\n    const size = array.length / (stride || 2);\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    offset *= stride;\n\n    while (index < size)\n    {\n        const x = array[offset];\n        const y = array[offset + 1];\n\n        array[offset] = (a * x) + (c * y) + tx;\n        array[offset + 1] = (b * x) + (d * y) + ty;\n\n        offset += stride;\n\n        index++;\n    }\n}\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { NineSliceSpritePipe } from './NineSliceSpritePipe.mjs';\n\n\"use strict\";\nextensions.add(NineSliceSpritePipe);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../../extensions/Extensions';\nimport { NineSliceSpritePipe } from './NineSliceSpritePipe';\n\nextensions.add(NineSliceSpritePipe);\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh.mjs';\nimport { NineSliceGeometry } from './NineSliceGeometry.mjs';\n\n\"use strict\";\nclass NineSliceSpritePipe {\n  constructor(renderer) {\n    this._gpuSpriteHash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  addRenderable(sprite, _instructionSet) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite._didSpriteUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    this._renderer.renderPipes.batch.addToBatch(gpuSprite);\n  }\n  updateRenderable(sprite) {\n    const gpuSprite = this._gpuSpriteHash[sprite.uid];\n    if (sprite._didSpriteUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    gpuSprite.batcher.updateElement(gpuSprite);\n  }\n  validateRenderable(sprite) {\n    const texture = sprite._texture;\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (gpuSprite.texture._source !== texture._source) {\n      return !gpuSprite.batcher.checkAndUpdateTexture(gpuSprite, texture);\n    }\n    return false;\n  }\n  destroyRenderable(sprite) {\n    const batchableSprite = this._gpuSpriteHash[sprite.uid];\n    BigPool.return(batchableSprite);\n    this._gpuSpriteHash[sprite.uid] = null;\n  }\n  _updateBatchableSprite(sprite, batchableSprite) {\n    sprite._didSpriteUpdate = false;\n    batchableSprite.geometry.update(sprite);\n    batchableSprite.texture = sprite._texture;\n  }\n  _getGpuSprite(sprite) {\n    return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);\n  }\n  _initGPUSprite(sprite) {\n    const batchableMesh = new BatchableMesh();\n    batchableMesh.geometry = new NineSliceGeometry();\n    batchableMesh.mesh = sprite;\n    batchableMesh.texture = sprite._texture;\n    batchableMesh.roundPixels = this._renderer._roundPixels | sprite._roundPixels;\n    this._gpuSpriteHash[sprite.uid] = batchableMesh;\n    sprite.on(\"destroyed\", () => {\n      this.destroyRenderable(sprite);\n    });\n    return batchableMesh;\n  }\n  destroy() {\n    for (const i in this._gpuSpriteHash) {\n      const batchableMesh = this._gpuSpriteHash[i];\n      batchableMesh.geometry.destroy();\n    }\n    this._gpuSpriteHash = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nNineSliceSpritePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"nineSliceSprite\"\n};\n\nexport { NineSliceSpritePipe };\n//# sourceMappingURL=NineSliceSpritePipe.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { NineSliceGeometry } from './NineSliceGeometry';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { NineSliceSprite } from './NineSliceSprite';\n\nexport class NineSliceSpritePipe implements RenderPipe<NineSliceSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'nineSliceSprite',\n    } as const;\n\n    private readonly _renderer: Renderer;\n    private readonly _gpuSpriteHash: Record<number, BatchableMesh> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public addRenderable(sprite: NineSliceSprite, _instructionSet: InstructionSet)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite._didSpriteUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite);\n    }\n\n    public updateRenderable(sprite: NineSliceSprite)\n    {\n        const gpuSprite = this._gpuSpriteHash[sprite.uid];\n\n        if (sprite._didSpriteUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        gpuSprite.batcher.updateElement(gpuSprite);\n    }\n\n    public validateRenderable(sprite: NineSliceSprite): boolean\n    {\n        const texture = sprite._texture;\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (gpuSprite.texture._source !== texture._source)\n        {\n            return !gpuSprite.batcher.checkAndUpdateTexture(gpuSprite, texture);\n        }\n\n        return false;\n    }\n\n    public destroyRenderable(sprite: NineSliceSprite)\n    {\n        const batchableSprite = this._gpuSpriteHash[sprite.uid];\n\n        // this will call reset!\n        BigPool.return(batchableSprite as PoolItem);\n\n        this._gpuSpriteHash[sprite.uid] = null;\n    }\n\n    private _updateBatchableSprite(sprite: NineSliceSprite, batchableSprite: BatchableMesh)\n    {\n        sprite._didSpriteUpdate = false;\n        (batchableSprite.geometry as NineSliceGeometry)\n            .update(sprite);\n\n        // = sprite.bounds;\n        batchableSprite.texture = sprite._texture;\n    }\n\n    private _getGpuSprite(sprite: NineSliceSprite): BatchableMesh\n    {\n        return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);\n    }\n\n    private _initGPUSprite(sprite: NineSliceSprite): BatchableMesh\n    {\n        const batchableMesh = new BatchableMesh();\n\n        batchableMesh.geometry = new NineSliceGeometry();\n\n        batchableMesh.mesh = sprite;\n\n        batchableMesh.texture = sprite._texture;\n        batchableMesh.roundPixels = (this._renderer._roundPixels | sprite._roundPixels) as 0 | 1;\n\n        this._gpuSpriteHash[sprite.uid] = batchableMesh;\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        sprite.on('destroyed', () =>\n        {\n            this.destroyRenderable(sprite);\n        });\n\n        return batchableMesh;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuSpriteHash)\n        {\n            const batchableMesh = this._gpuSpriteHash[i];\n\n            batchableMesh.geometry.destroy();\n        }\n\n        (this._gpuSpriteHash as null) = null;\n        (this._renderer as null) = null;\n    }\n}\n","import { PlaneGeometry } from '../mesh-plane/PlaneGeometry.mjs';\n\n\"use strict\";\nconst _NineSliceGeometry = class _NineSliceGeometry extends PlaneGeometry {\n  constructor(options = {}) {\n    options = { ..._NineSliceGeometry.defaultOptions, ...options };\n    super({\n      width: options.width,\n      height: options.height,\n      verticesX: 4,\n      verticesY: 4\n    });\n    this.update(options);\n  }\n  /**\n   * Updates the NineSliceGeometry with the options.\n   * @param options - The options of the NineSliceGeometry.\n   */\n  update(options) {\n    this.width = options.width ?? this.width;\n    this.height = options.height ?? this.height;\n    this._originalWidth = options.originalWidth ?? this._originalWidth;\n    this._originalHeight = options.originalHeight ?? this._originalHeight;\n    this._leftWidth = options.leftWidth ?? this._leftWidth;\n    this._rightWidth = options.rightWidth ?? this._rightWidth;\n    this._topHeight = options.topHeight ?? this._topHeight;\n    this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n    this.updateUvs();\n    this.updatePositions();\n  }\n  /** Updates the positions of the vertices. */\n  updatePositions() {\n    const positions = this.positions;\n    const w = this._leftWidth + this._rightWidth;\n    const scaleW = this.width > w ? 1 : this.width / w;\n    const h = this._topHeight + this._bottomHeight;\n    const scaleH = this.height > h ? 1 : this.height / h;\n    const scale = Math.min(scaleW, scaleH);\n    positions[9] = positions[11] = positions[13] = positions[15] = this._topHeight * scale;\n    positions[17] = positions[19] = positions[21] = positions[23] = this.height - this._bottomHeight * scale;\n    positions[25] = positions[27] = positions[29] = positions[31] = this.height;\n    positions[2] = positions[10] = positions[18] = positions[26] = this._leftWidth * scale;\n    positions[4] = positions[12] = positions[20] = positions[28] = this.width - this._rightWidth * scale;\n    positions[6] = positions[14] = positions[22] = positions[30] = this.width;\n    this.getBuffer(\"aPosition\").update();\n  }\n  /** Updates the UVs of the vertices. */\n  updateUvs() {\n    const uvs = this.uvs;\n    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n    const _uvw = 1 / this._originalWidth;\n    const _uvh = 1 / this._originalHeight;\n    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;\n    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;\n    this.getBuffer(\"aUV\").update();\n  }\n};\n/** The default options for the NineSliceGeometry. */\n_NineSliceGeometry.defaultOptions = {\n  /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n  width: 100,\n  /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n  height: 100,\n  /** The width of the left column. */\n  leftWidth: 10,\n  /** The height of the top row. */\n  topHeight: 10,\n  /** The width of the right column. */\n  rightWidth: 10,\n  /** The height of the bottom row. */\n  bottomHeight: 10,\n  /** The original width of the texture */\n  originalWidth: 100,\n  /** The original height of the texture */\n  originalHeight: 100\n};\nlet NineSliceGeometry = _NineSliceGeometry;\n\nexport { NineSliceGeometry };\n//# sourceMappingURL=NineSliceGeometry.mjs.map\n","import { PlaneGeometry } from '../mesh-plane/PlaneGeometry';\n\n/**\n * Options for the NineSliceGeometry.\n * @memberof scene\n */\nexport interface NineSliceGeometryOptions\n{\n\n    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    width?: number\n    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    height?: number\n    /** The original width of the texture */\n    originalWidth?: number\n    /** The original height of the texture */\n    originalHeight?: number\n    /** The width of the left column. */\n    leftWidth?: number\n    /** The height of the top row. */\n    topHeight?: number\n    /** The width of the right column. */\n    rightWidth?: number\n    /** The height of the bottom row. */\n    bottomHeight?: number\n}\n\n/**\n * The NineSliceGeometry class allows you to create a NineSlicePlane object.\n * @memberof scene\n */\nexport class NineSliceGeometry extends PlaneGeometry\n{\n    /** The default options for the NineSliceGeometry. */\n    public static defaultOptions: NineSliceGeometryOptions = {\n        /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        width: 100,\n        /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        height: 100,\n        /** The width of the left column. */\n        leftWidth: 10,\n        /** The height of the top row. */\n        topHeight: 10,\n        /** The width of the right column. */\n        rightWidth: 10,\n        /** The height of the bottom row. */\n        bottomHeight: 10,\n\n        /** The original width of the texture */\n        originalWidth: 100,\n        /** The original height of the texture */\n        originalHeight: 100,\n    };\n\n    public _leftWidth: number;\n    public _rightWidth: number;\n    public _topHeight: number;\n    public _bottomHeight: number;\n\n    private _originalWidth: number;\n    private _originalHeight: number;\n\n    constructor(options: NineSliceGeometryOptions = {})\n    {\n        options = { ...NineSliceGeometry.defaultOptions, ...options };\n\n        super({\n            width: options.width,\n            height: options.height,\n            verticesX: 4,\n            verticesY: 4,\n        });\n\n        this.update(options);\n    }\n\n    /**\n     * Updates the NineSliceGeometry with the options.\n     * @param options - The options of the NineSliceGeometry.\n     */\n    public update(options: NineSliceGeometryOptions)\n    {\n        this.width = options.width ?? this.width;\n        this.height = options.height ?? this.height;\n        this._originalWidth = options.originalWidth ?? this._originalWidth;\n        this._originalHeight = options.originalHeight ?? this._originalHeight;\n        this._leftWidth = options.leftWidth ?? this._leftWidth;\n        this._rightWidth = options.rightWidth ?? this._rightWidth;\n        this._topHeight = options.topHeight ?? this._topHeight;\n        this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n\n        this.updateUvs();\n        this.updatePositions();\n    }\n\n    /** Updates the positions of the vertices. */\n    public updatePositions()\n    {\n        const positions = this.positions;\n\n        const w = this._leftWidth + this._rightWidth;\n        const scaleW = this.width > w ? 1.0 : this.width / w;\n\n        const h = this._topHeight + this._bottomHeight;\n        const scaleH = this.height > h ? 1.0 : this.height / h;\n\n        const scale = Math.min(scaleW, scaleH);\n\n        positions[9] = positions[11] = positions[13] = positions[15] = this._topHeight * scale;\n        positions[17] = positions[19] = positions[21] = positions[23] = this.height - (this._bottomHeight * scale);\n        positions[25] = positions[27] = positions[29] = positions[31] = this.height;\n\n        positions[2] = positions[10] = positions[18] = positions[26] = this._leftWidth * scale;\n        positions[4] = positions[12] = positions[20] = positions[28] = this.width - (this._rightWidth * scale);\n        positions[6] = positions[14] = positions[22] = positions[30] = this.width;\n\n        this.getBuffer('aPosition').update();\n    }\n\n    /** Updates the UVs of the vertices. */\n    public updateUvs()\n    {\n        const uvs = this.uvs;\n\n        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n\n        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n\n        const _uvw = 1.0 / this._originalWidth;\n        const _uvh = 1.0 / this._originalHeight;\n\n        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n\n        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - (_uvw * this._rightWidth);\n        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - (_uvh * this._bottomHeight);\n\n        this.getBuffer('aUV').update();\n    }\n}\n\n","import { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry.mjs';\n\n\"use strict\";\nconst _PlaneGeometry = class _PlaneGeometry extends MeshGeometry {\n  constructor(...args) {\n    super({});\n    let options = args[0] ?? {};\n    if (typeof options === \"number\") {\n      deprecation(v8_0_0, \"PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead\");\n      options = {\n        width: options,\n        height: args[1],\n        verticesX: args[2],\n        verticesY: args[3]\n      };\n    }\n    this.build(options);\n  }\n  /**\n   * Refreshes plane coordinates\n   * @param options - Options to be applied to plane geometry\n   */\n  build(options) {\n    options = { ..._PlaneGeometry.defaultOptions, ...options };\n    this.verticesX = this.verticesX ?? options.verticesX;\n    this.verticesY = this.verticesY ?? options.verticesY;\n    this.width = this.width ?? options.width;\n    this.height = this.height ?? options.height;\n    const total = this.verticesX * this.verticesY;\n    const verts = [];\n    const uvs = [];\n    const indices = [];\n    const verticesX = this.verticesX - 1;\n    const verticesY = this.verticesY - 1;\n    const sizeX = this.width / verticesX;\n    const sizeY = this.height / verticesY;\n    for (let i = 0; i < total; i++) {\n      const x = i % this.verticesX;\n      const y = i / this.verticesX | 0;\n      verts.push(x * sizeX, y * sizeY);\n      uvs.push(x / verticesX, y / verticesY);\n    }\n    const totalSub = verticesX * verticesY;\n    for (let i = 0; i < totalSub; i++) {\n      const xpos = i % verticesX;\n      const ypos = i / verticesX | 0;\n      const value = ypos * this.verticesX + xpos;\n      const value2 = ypos * this.verticesX + xpos + 1;\n      const value3 = (ypos + 1) * this.verticesX + xpos;\n      const value4 = (ypos + 1) * this.verticesX + xpos + 1;\n      indices.push(\n        value,\n        value2,\n        value3,\n        value2,\n        value4,\n        value3\n      );\n    }\n    this.buffers[0].data = new Float32Array(verts);\n    this.buffers[1].data = new Float32Array(uvs);\n    this.indexBuffer.data = new Uint32Array(indices);\n    this.buffers[0].update();\n    this.buffers[1].update();\n    this.indexBuffer.update();\n  }\n};\n_PlaneGeometry.defaultOptions = {\n  width: 100,\n  height: 100,\n  verticesX: 10,\n  verticesY: 10\n};\nlet PlaneGeometry = _PlaneGeometry;\n\nexport { PlaneGeometry };\n//# sourceMappingURL=PlaneGeometry.mjs.map\n","import { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\n\nimport type { MeshGeometryOptions } from '../mesh/shared/MeshGeometry';\n\n/**\n * Constructor options used for `PlaneGeometry` instances.\n * ```js\n * const planeGeometry = new PlaneGeometry({\n *    width: 100,\n *    height: 100,\n *    verticesX: 10,\n *    verticesY: 10,\n * });\n * ```\n * @see {@link scene.PlaneGeometry}\n * @memberof scene\n */\nexport interface PlaneGeometryOptions\n{\n    /** Width of plane */\n    width?: number;\n    /** Height of plane */\n    height?: number;\n    /** Number of vertices on x-axis */\n    verticesX?: number;\n    /** Number of vertices on y-axis */\n    verticesY?: number;\n}\n\n/**\n * The PlaneGeometry allows you to draw a 2d plane\n * @memberof scene\n */\nexport class PlaneGeometry extends MeshGeometry\n{\n    public static defaultOptions: PlaneGeometryOptions & MeshGeometryOptions = {\n        width: 100,\n        height: 100,\n        verticesX: 10,\n        verticesY: 10,\n    };\n\n    /** The number of vertices on x-axis */\n    public verticesX: number;\n    /** The number of vertices on y-axis */\n    public verticesY: number;\n    /** The width of plane */\n    public width: number;\n    /** The height of plane */\n    public height: number;\n\n    /**\n     * @param {PlaneGeometryOptions} options - Options to be applied to plane geometry\n     */\n    constructor(options: PlaneGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(width?: number, height?: number, verticesX?: number, verticesY?: number);\n    constructor(...args: [PlaneGeometryOptions?] | [number?, number?, number?, number?])\n    {\n        super({});\n\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number')\n        {\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead');\n            // #endif\n\n            options = {\n                width: options,\n                height: args[1],\n                verticesX: args[2],\n                verticesY: args[3],\n            };\n        }\n\n        this.build(options);\n    }\n\n    /**\n     * Refreshes plane coordinates\n     * @param options - Options to be applied to plane geometry\n     */\n    public build(options: PlaneGeometryOptions): void\n    {\n        options = { ...PlaneGeometry.defaultOptions, ...options };\n\n        this.verticesX = this.verticesX ?? options.verticesX;\n        this.verticesY = this.verticesY ?? options.verticesY;\n\n        this.width = this.width ?? options.width;\n        this.height = this.height ?? options.height;\n\n        const total = this.verticesX * this.verticesY;\n        const verts = [];\n        const uvs = [];\n        const indices = [];\n\n        const verticesX = this.verticesX - 1;\n        const verticesY = this.verticesY - 1;\n\n        const sizeX = (this.width) / verticesX;\n        const sizeY = (this.height) / verticesY;\n\n        for (let i = 0; i < total; i++)\n        {\n            const x = (i % this.verticesX);\n            const y = ((i / this.verticesX) | 0);\n\n            verts.push(x * sizeX, y * sizeY);\n            uvs.push(x / verticesX, y / verticesY);\n        }\n\n        const totalSub = verticesX * verticesY;\n\n        for (let i = 0; i < totalSub; i++)\n        {\n            const xpos = i % verticesX;\n            const ypos = (i / verticesX) | 0;\n\n            const value = (ypos * this.verticesX) + xpos;\n            const value2 = (ypos * this.verticesX) + xpos + 1;\n            const value3 = ((ypos + 1) * this.verticesX) + xpos;\n            const value4 = ((ypos + 1) * this.verticesX) + xpos + 1;\n\n            indices.push(value, value2, value3,\n                value2, value4, value3);\n        }\n\n        this.buffers[0].data = new Float32Array(verts);\n        this.buffers[1].data = new Float32Array(uvs);\n        this.indexBuffer.data = new Uint32Array(indices);\n\n        // ensure that the changes are uploaded\n        this.buffers[0].update();\n        this.buffers[1].update();\n        this.indexBuffer.update();\n    }\n}\n","import { extensions } from '../extensions/Extensions.mjs';\nimport { FilterPipe } from './FilterPipe.mjs';\nimport { FilterSystem } from './FilterSystem.mjs';\n\n\"use strict\";\nextensions.add(FilterSystem);\nextensions.add(FilterPipe);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../extensions/Extensions';\nimport { FilterPipe } from './FilterPipe';\nimport { FilterSystem } from './FilterSystem';\n\nextensions.add(FilterSystem);\nextensions.add(FilterPipe);\n","import { ExtensionType } from '../extensions/Extensions.mjs';\n\n\"use strict\";\nclass FilterPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  push(filterEffect, container, instructionSet) {\n    const renderPipes = this._renderer.renderPipes;\n    renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"filter\",\n      canBundle: false,\n      action: \"pushFilter\",\n      container,\n      filterEffect\n    });\n  }\n  pop(_filterEffect, _container, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"filter\",\n      action: \"popFilter\",\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    if (instruction.action === \"pushFilter\") {\n      this._renderer.filter.push(instruction);\n    } else if (instruction.action === \"popFilter\") {\n      this._renderer.filter.pop();\n    }\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\nFilterPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"filter\"\n};\n\nexport { FilterPipe };\n//# sourceMappingURL=FilterPipe.mjs.map\n","import { ExtensionType } from '../extensions/Extensions';\n\nimport type { InstructionSet } from '../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { Container } from '../scene/container/Container';\nimport type { Effect } from '../scene/container/Effect';\nimport type { FilterInstruction } from './FilterSystem';\n\n// eslint-disable-next-line max-len\nexport class FilterPipe implements InstructionPipe<FilterInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'filter',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(filterEffect: Effect, container: Container, instructionSet: InstructionSet): void\n    {\n        const renderPipes = this._renderer.renderPipes;\n\n        renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            canBundle: false,\n            action: 'pushFilter',\n            container,\n            filterEffect,\n        } as FilterInstruction);\n    }\n\n    public pop(_filterEffect: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: FilterInstruction)\n    {\n        if (instruction.action === 'pushFilter')\n        {\n            this._renderer.filter.push(instruction);\n        }\n        else if (instruction.action === 'popFilter')\n        {\n            this._renderer.filter.pop();\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions.mjs';\nimport { Matrix } from '../maths/matrix/Matrix.mjs';\nimport { Point } from '../maths/point/Point.mjs';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup.mjs';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry.mjs';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture.mjs';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../rendering/renderers/types.mjs';\nimport { Bounds } from '../scene/container/bounds/Bounds.mjs';\nimport { getFastGlobalBounds } from '../scene/container/bounds/getFastGlobalBounds.mjs';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds.mjs';\nimport { warn } from '../utils/logging/warn.mjs';\n\n\"use strict\";\nconst quadGeometry = new Geometry({\n  attributes: {\n    aPosition: {\n      buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      location: 0,\n      format: \"float32x2\",\n      stride: 2 * 4,\n      offset: 0\n    }\n  },\n  indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])\n});\nclass FilterSystem {\n  constructor(renderer) {\n    this._filterStackIndex = 0;\n    this._filterStack = [];\n    this._filterGlobalUniforms = new UniformGroup({\n      uInputSize: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uInputPixel: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uInputClamp: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uOutputFrame: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uGlobalFrame: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uOutputTexture: { value: new Float32Array(4), type: \"vec4<f32>\" }\n    });\n    this._globalFilterBindGroup = new BindGroup({});\n    this.renderer = renderer;\n  }\n  /**\n   * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n   * @readonly\n   */\n  get activeBackTexture() {\n    return this._activeFilterData?.backTexture;\n  }\n  push(instruction) {\n    const renderer = this.renderer;\n    const filters = instruction.filterEffect.filters;\n    if (!this._filterStack[this._filterStackIndex]) {\n      this._filterStack[this._filterStackIndex] = this._getFilterData();\n    }\n    const filterData = this._filterStack[this._filterStackIndex];\n    this._filterStackIndex++;\n    if (filters.length === 0) {\n      filterData.skip = true;\n      return;\n    }\n    const bounds = filterData.bounds;\n    if (instruction.renderables) {\n      getGlobalRenderableBounds(instruction.renderables, bounds);\n    } else if (instruction.filterEffect.filterArea) {\n      bounds.clear();\n      bounds.addRect(instruction.filterEffect.filterArea);\n      bounds.applyMatrix(instruction.container.worldTransform);\n    } else {\n      getFastGlobalBounds(instruction.container, bounds);\n    }\n    const colorTextureSource = renderer.renderTarget.rootRenderTarget.colorTexture.source;\n    let resolution = colorTextureSource._resolution;\n    let padding = 0;\n    let antialias = colorTextureSource.antialias;\n    let blendRequired = false;\n    let enabled = false;\n    for (let i = 0; i < filters.length; i++) {\n      const filter = filters[i];\n      resolution = Math.min(resolution, filter.resolution);\n      padding += filter.padding;\n      if (filter.antialias !== \"inherit\") {\n        if (filter.antialias === \"on\") {\n          antialias = true;\n        } else {\n          antialias = false;\n        }\n      }\n      const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n      if (!isCompatible) {\n        enabled = false;\n        break;\n      }\n      if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {\n        warn(\"Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.\");\n        enabled = false;\n        break;\n      }\n      enabled = filter.enabled || enabled;\n      blendRequired = blendRequired || filter.blendRequired;\n    }\n    if (!enabled) {\n      filterData.skip = true;\n      return;\n    }\n    const viewPort = renderer.renderTarget.rootViewPort;\n    bounds.scale(resolution).fitBounds(0, viewPort.width, 0, viewPort.height).scale(1 / resolution).pad(padding).ceil();\n    if (!bounds.isPositive) {\n      filterData.skip = true;\n      return;\n    }\n    filterData.skip = false;\n    filterData.bounds = bounds;\n    filterData.blendRequired = blendRequired;\n    filterData.container = instruction.container;\n    filterData.filterEffect = instruction.filterEffect;\n    filterData.previousRenderSurface = renderer.renderTarget.renderSurface;\n    filterData.inputTexture = TexturePool.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      resolution,\n      antialias\n    );\n    renderer.renderTarget.bind(filterData.inputTexture, true);\n    renderer.globalUniforms.push({\n      offset: bounds\n    });\n  }\n  pop() {\n    const renderer = this.renderer;\n    this._filterStackIndex--;\n    const filterData = this._filterStack[this._filterStackIndex];\n    if (filterData.skip) {\n      return;\n    }\n    this._activeFilterData = filterData;\n    const inputTexture = filterData.inputTexture;\n    const bounds = filterData.bounds;\n    let backTexture = Texture.EMPTY;\n    renderer.renderTarget.finishRenderPass();\n    if (filterData.blendRequired) {\n      const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;\n      const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);\n      backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);\n    }\n    filterData.backTexture = backTexture;\n    const filters = filterData.filterEffect.filters;\n    this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n    this._globalFilterBindGroup.setResource(backTexture.source, 3);\n    renderer.globalUniforms.pop();\n    if (filters.length === 1) {\n      filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);\n      TexturePool.returnTexture(inputTexture);\n    } else {\n      let flip = filterData.inputTexture;\n      let flop = TexturePool.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        flip.source._resolution,\n        false\n      );\n      let i = 0;\n      for (i = 0; i < filters.length - 1; ++i) {\n        const filter = filters[i];\n        filter.apply(this, flip, flop, true);\n        const t = flip;\n        flip = flop;\n        flop = t;\n      }\n      filters[i].apply(this, flip, filterData.previousRenderSurface, false);\n      TexturePool.returnTexture(flip);\n      TexturePool.returnTexture(flop);\n    }\n    if (filterData.blendRequired) {\n      TexturePool.returnTexture(backTexture);\n    }\n  }\n  getBackTexture(lastRenderSurface, bounds, previousBounds) {\n    const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n    const backTexture = TexturePool.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      backgroundResolution,\n      false\n    );\n    let x = bounds.minX;\n    let y = bounds.minY;\n    if (previousBounds) {\n      x -= previousBounds.minX;\n      y -= previousBounds.minY;\n    }\n    x = Math.floor(x * backgroundResolution);\n    y = Math.floor(y * backgroundResolution);\n    const width = Math.ceil(bounds.width * backgroundResolution);\n    const height = Math.ceil(bounds.height * backgroundResolution);\n    this.renderer.renderTarget.copyToTexture(\n      lastRenderSurface,\n      backTexture,\n      { x, y },\n      { width, height },\n      { x: 0, y: 0 }\n    );\n    return backTexture;\n  }\n  applyFilter(filter, input, output, clear) {\n    const renderer = this.renderer;\n    const filterData = this._filterStack[this._filterStackIndex];\n    const bounds = filterData.bounds;\n    const offset = Point.shared;\n    const previousRenderSurface = filterData.previousRenderSurface;\n    const isFinalTarget = previousRenderSurface === output;\n    let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n    let currentIndex = this._filterStackIndex - 1;\n    while (currentIndex > 0 && this._filterStack[currentIndex].skip) {\n      --currentIndex;\n    }\n    if (currentIndex > 0) {\n      resolution = this._filterStack[currentIndex].inputTexture.source._resolution;\n    }\n    const filterUniforms = this._filterGlobalUniforms;\n    const uniforms = filterUniforms.uniforms;\n    const outputFrame = uniforms.uOutputFrame;\n    const inputSize = uniforms.uInputSize;\n    const inputPixel = uniforms.uInputPixel;\n    const inputClamp = uniforms.uInputClamp;\n    const globalFrame = uniforms.uGlobalFrame;\n    const outputTexture = uniforms.uOutputTexture;\n    if (isFinalTarget) {\n      let lastIndex = this._filterStackIndex;\n      while (lastIndex > 0) {\n        lastIndex--;\n        const filterData2 = this._filterStack[this._filterStackIndex - 1];\n        if (!filterData2.skip) {\n          offset.x = filterData2.bounds.minX;\n          offset.y = filterData2.bounds.minY;\n          break;\n        }\n      }\n      outputFrame[0] = bounds.minX - offset.x;\n      outputFrame[1] = bounds.minY - offset.y;\n    } else {\n      outputFrame[0] = 0;\n      outputFrame[1] = 0;\n    }\n    outputFrame[2] = input.frame.width;\n    outputFrame[3] = input.frame.height;\n    inputSize[0] = input.source.width;\n    inputSize[1] = input.source.height;\n    inputSize[2] = 1 / inputSize[0];\n    inputSize[3] = 1 / inputSize[1];\n    inputPixel[0] = input.source.pixelWidth;\n    inputPixel[1] = input.source.pixelHeight;\n    inputPixel[2] = 1 / inputPixel[0];\n    inputPixel[3] = 1 / inputPixel[1];\n    inputClamp[0] = 0.5 * inputPixel[2];\n    inputClamp[1] = 0.5 * inputPixel[3];\n    inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];\n    inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];\n    const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n    globalFrame[0] = offset.x * resolution;\n    globalFrame[1] = offset.y * resolution;\n    globalFrame[2] = rootTexture.source.width * resolution;\n    globalFrame[3] = rootTexture.source.height * resolution;\n    const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n    renderer.renderTarget.bind(output, !!clear);\n    if (output instanceof Texture) {\n      outputTexture[0] = output.frame.width;\n      outputTexture[1] = output.frame.height;\n    } else {\n      outputTexture[0] = renderTarget.width;\n      outputTexture[1] = renderTarget.height;\n    }\n    outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n    filterUniforms.update();\n    if (renderer.renderPipes.uniformBatch) {\n      const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(filterUniforms);\n      this._globalFilterBindGroup.setResource(batchUniforms, 0);\n    } else {\n      this._globalFilterBindGroup.setResource(filterUniforms, 0);\n    }\n    this._globalFilterBindGroup.setResource(input.source, 1);\n    this._globalFilterBindGroup.setResource(input.source.style, 2);\n    filter.groups[0] = this._globalFilterBindGroup;\n    renderer.encoder.draw({\n      geometry: quadGeometry,\n      shader: filter,\n      state: filter._state,\n      topology: \"triangle-list\"\n    });\n    if (renderer.type === RendererType.WEBGL) {\n      renderer.renderTarget.finishRenderPass();\n    }\n  }\n  _getFilterData() {\n    return {\n      skip: false,\n      inputTexture: null,\n      bounds: new Bounds(),\n      container: null,\n      filterEffect: null,\n      blendRequired: false,\n      previousRenderSurface: null\n    };\n  }\n  /**\n   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n   *\n   * Use `outputMatrix * vTextureCoord` in the shader.\n   * @param outputMatrix - The matrix to output to.\n   * @param {Sprite} sprite - The sprite to map to.\n   * @returns The mapped matrix.\n   */\n  calculateSpriteMatrix(outputMatrix, sprite) {\n    const data = this._activeFilterData;\n    const mappedMatrix = outputMatrix.set(\n      data.inputTexture._source.width,\n      0,\n      0,\n      data.inputTexture._source.height,\n      data.bounds.minX,\n      data.bounds.minY\n    );\n    const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n    worldTransform.invert();\n    mappedMatrix.prepend(worldTransform);\n    mappedMatrix.scale(\n      1 / sprite.texture.frame.width,\n      1 / sprite.texture.frame.height\n    );\n    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n    return mappedMatrix;\n  }\n}\n/** @ignore */\nFilterSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"filter\"\n};\n\nexport { FilterSystem };\n//# sourceMappingURL=FilterSystem.mjs.map\n","import { ExtensionType } from '../extensions/Extensions';\nimport { Matrix } from '../maths/matrix/Matrix';\nimport { Point } from '../maths/point/Point';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../rendering/renderers/types';\nimport { Bounds } from '../scene/container/bounds/Bounds';\nimport { getFastGlobalBounds } from '../scene/container/bounds/getFastGlobalBounds';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds';\nimport { warn } from '../utils/logging/warn';\n\nimport type { WebGLRenderer } from '../rendering/renderers/gl/WebGLRenderer';\nimport type { WebGPURenderer } from '../rendering/renderers/gpu/WebGPURenderer';\nimport type { Instruction } from '../rendering/renderers/shared/instructions/Instruction';\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { RenderTarget } from '../rendering/renderers/shared/renderTarget/RenderTarget';\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Container } from '../scene/container/Container';\nimport type { Sprite } from '../scene/sprite/Sprite';\nimport type { Filter } from './Filter';\nimport type { FilterEffect } from './FilterEffect';\n\ntype FilterAction = 'pushFilter' | 'popFilter';\n\n//\nconst quadGeometry = new Geometry({\n    attributes: {\n        aPosition: {\n            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            location: 0,\n            format: 'float32x2',\n            stride: 2 * 4,\n            offset: 0,\n        },\n    },\n    indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\n/**\n * The filter pipeline is responsible for applying filters scene items!\n *\n * KNOWN BUGS:\n * 1. Global bounds calculation is incorrect if it is used when flip flopping filters. The maths can be found below\n * eg: filters [noiseFilter, blurFilter] noiseFilter will calculate the global bounds incorrectly.\n *\n * 2. RenderGroups do not work with filters. This is because the renderGroup matrix is not currently taken into account.\n *\n * Implementation notes:\n * 1. Gotcha - nesting filters that require blending will not work correctly. This creates a chicken and egg problem\n * the complexity and performance required to do this is not worth it i feel.. but lets see if others agree!\n *\n * 2. Filters are designed to be changed on the fly, this is means that changing filter information each frame will\n * not trigger an instruction rebuild. If you are constantly turning a filter on and off.. its therefore better to set\n * enabled to true or false on the filter. Or setting an empty array.\n *\n * 3. Need to look at perhaps aliasing when flip flopping filters. Really we should only need to antialias the FIRST\n * Texture we render too. The rest can be non aliased. This might help performance.\n * Currently we flip flop with an antialiased texture if antialiasing is enabled on the filter.\n */\nexport interface FilterInstruction extends Instruction\n{\n    renderPipeId: 'filter',\n    action: FilterAction,\n    container?: Container,\n    renderables?: Renderable[],\n    filterEffect: FilterEffect,\n}\n\nexport interface FilterData\n{\n    skip: boolean;\n    enabledLength?: number;\n    inputTexture: Texture\n    bounds: Bounds,\n    blendRequired: boolean,\n    container: Container,\n    filterEffect: FilterEffect,\n    previousRenderSurface: RenderSurface,\n    backTexture?: Texture,\n}\n\n/**\n * System that manages the filter pipeline\n * @memberof rendering\n */\nexport class FilterSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'filter',\n    } as const;\n\n    public readonly renderer: Renderer;\n\n    private _filterStackIndex = 0;\n    private _filterStack: FilterData[] = [];\n\n    private readonly _filterGlobalUniforms = new UniformGroup({\n        uInputSize: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputPixel: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputClamp: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uGlobalFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputTexture: { value: new Float32Array(4), type: 'vec4<f32>' },\n    });\n\n    private readonly _globalFilterBindGroup: BindGroup = new BindGroup({});\n    private _activeFilterData: FilterData;\n\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n     * @readonly\n     */\n    public get activeBackTexture(): Texture | undefined\n    {\n        return this._activeFilterData?.backTexture;\n    }\n\n    public push(instruction: FilterInstruction)\n    {\n        const renderer = this.renderer;\n\n        const filters = instruction.filterEffect.filters;\n\n        if (!this._filterStack[this._filterStackIndex])\n        {\n            this._filterStack[this._filterStackIndex] = this._getFilterData();\n        }\n\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        this._filterStackIndex++;\n\n        // if there are no filters, we skip the pass\n        if (filters.length === 0)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        const bounds: Bounds = filterData.bounds;\n\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n        if (instruction.renderables)\n        {\n            getGlobalRenderableBounds(instruction.renderables, bounds);\n        }\n        // if a filterArea is provided, we save our selves some measuring and just use that area supplied\n        else if (instruction.filterEffect.filterArea)\n        {\n            bounds.clear();\n\n            // transform the filterArea into global space..\n            bounds.addRect(instruction.filterEffect.filterArea);\n\n            // new for v8, we transform the bounds into the space of the container\n            bounds.applyMatrix(instruction.container.worldTransform);\n        }\n        // classic filter path, we get the bounds of the container and use it by recursively\n        // measuring.\n        else\n        {\n            getFastGlobalBounds(instruction.container, bounds);\n        }\n        // get GLOBAL bounds of the item we are going to apply the filter to\n\n        const colorTextureSource = renderer.renderTarget.rootRenderTarget.colorTexture.source;\n\n        // next we get the settings for the filter\n        // we need to find the LOWEST resolution for the filter list\n        let resolution = colorTextureSource._resolution;\n\n        // Padding is additive to add padding to our padding\n        let padding = 0;\n        // if this is true for any filter, it should be true\n        let antialias = colorTextureSource.antialias;\n        // true if any filter requires the previous render target\n        let blendRequired = false;\n        // true if any filter in the list is enabled\n        let enabled = false;\n\n        for (let i = 0; i < filters.length; i++)\n        {\n            const filter = filters[i];\n\n            resolution = Math.min(resolution, filter.resolution);\n            padding += filter.padding;\n\n            if (filter.antialias !== 'inherit')\n            {\n                if (filter.antialias === 'on')\n                {\n                    antialias = true;\n                }\n                else\n                {\n                    antialias = false;\n                }\n            }\n\n            const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n\n            if (!isCompatible)\n            {\n                enabled = false;\n                break;\n            }\n\n            if (filter.blendRequired && !((renderer as WebGLRenderer).backBuffer?.useBackBuffer ?? true))\n            {\n                // #if _DEBUG\n                // eslint-disable-next-line max-len\n                warn('Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.');\n                // #endif\n\n                enabled = false;\n                break;\n            }\n\n            enabled = filter.enabled || enabled;\n            blendRequired = blendRequired || filter.blendRequired;\n        }\n\n        // if no filters are enabled lets skip!\n        if (!enabled)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        const viewPort = renderer.renderTarget.rootViewPort;\n\n        // here we constrain the bounds to the viewport we will render too\n        // this should not take into account the x, y offset of the viewport - as this is\n        // handled by the viewport on the gpu.\n        // need to factor in resolutions also..\n        bounds.scale(resolution)\n            .fitBounds(0, viewPort.width, 0, viewPort.height)\n            .scale(1 / resolution)\n            .pad(padding)\n            .ceil();\n\n        // skip if the bounds are negative or zero as this means they are\n        // not visible on the screen\n        if (!bounds.isPositive)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // set all the filter data\n        filterData.skip = false;\n\n        filterData.bounds = bounds;\n        filterData.blendRequired = blendRequired;\n        filterData.container = instruction.container;\n        filterData.filterEffect = instruction.filterEffect;\n\n        filterData.previousRenderSurface = renderer.renderTarget.renderSurface;\n\n        // bind...\n        // get a P02 texture from our pool...\n        filterData.inputTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            resolution,\n            antialias,\n        );\n\n        renderer.renderTarget.bind(filterData.inputTexture, true);\n        // set the global uniforms to take into account the bounds offset required\n\n        renderer.globalUniforms.push({\n            offset: bounds,\n        });\n    }\n\n    public pop()\n    {\n        const renderer = this.renderer;\n\n        this._filterStackIndex--;\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        // if we are skipping this filter then we just do nothing :D\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        this._activeFilterData = filterData;\n\n        const inputTexture = filterData.inputTexture;\n\n        const bounds = filterData.bounds;\n\n        let backTexture = Texture.EMPTY;\n\n        renderer.renderTarget.finishRenderPass();\n\n        if (filterData.blendRequired)\n        {\n            // this actually forces the current commandQueue to render everything so far.\n            // if we don't do this, we won't be able to copy pixels for the background\n            const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;\n\n            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);\n\n            backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);\n        }\n\n        filterData.backTexture = backTexture;\n\n        const filters = filterData.filterEffect.filters;\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n        // eslint-disable-next-line max-len\n\n        // update the resources on the bind group...\n        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n        this._globalFilterBindGroup.setResource(backTexture.source, 3);\n\n        renderer.globalUniforms.pop();\n\n        if (filters.length === 1)\n        {\n            // render a single filter...\n            // this.applyFilter(filters[0], inputTexture, filterData.previousRenderSurface, false);\n            filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);\n\n            // return the texture to the pool so we can reuse the next frame\n            TexturePool.returnTexture(inputTexture);\n        }\n        else\n        {\n            let flip = filterData.inputTexture;\n\n            // get another texture that we will render the next filter too\n            let flop = TexturePool.getOptimalTexture(\n                bounds.width,\n                bounds.height,\n                flip.source._resolution,\n                false\n            );\n\n            let i = 0;\n\n            // loop and apply the filters, omitting the last one as we will render that to the final target\n            for (i = 0; i < filters.length - 1; ++i)\n            {\n                const filter = filters[i];\n\n                filter.apply(this, flip, flop, true);\n                const t = flip;\n\n                flip = flop;\n                flop = t;\n            }\n\n            filters[i].apply(this, flip, filterData.previousRenderSurface, false);\n\n            // return those textures for later!\n            TexturePool.returnTexture(flip);\n            TexturePool.returnTexture(flop);\n        }\n\n        // if we made a background texture, lets return that also\n        if (filterData.blendRequired)\n        {\n            TexturePool.returnTexture(backTexture);\n        }\n    }\n\n    public getBackTexture(lastRenderSurface: RenderTarget, bounds: Bounds, previousBounds?: Bounds)\n    {\n        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n\n        const backTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            backgroundResolution,\n            false,\n        );\n\n        let x = bounds.minX;\n        let y = bounds.minY;\n\n        if (previousBounds)\n        {\n            x -= previousBounds.minX;\n            y -= previousBounds.minY;\n        }\n\n        x = Math.floor(x * backgroundResolution);\n        y = Math.floor(y * backgroundResolution);\n\n        const width = Math.ceil(bounds.width * backgroundResolution);\n        const height = Math.ceil(bounds.height * backgroundResolution);\n\n        this.renderer.renderTarget.copyToTexture(\n            lastRenderSurface,\n            backTexture,\n            { x, y },\n            { width, height },\n            { x: 0, y: 0 }\n        );\n\n        return backTexture;\n    }\n\n    public applyFilter(filter: Filter, input: Texture, output: RenderSurface, clear: boolean)\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        const bounds = filterData.bounds;\n\n        const offset = Point.shared;\n        const previousRenderSurface = filterData.previousRenderSurface;\n\n        const isFinalTarget = previousRenderSurface === output;\n\n        let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n\n        // to find the previous resolution we need to account for the skipped filters\n        // the following will find the last non skipped filter...\n        let currentIndex = this._filterStackIndex - 1;\n\n        while (currentIndex > 0 && this._filterStack[currentIndex].skip)\n        {\n            --currentIndex;\n        }\n\n        if (currentIndex > 0)\n        {\n            resolution = this._filterStack[currentIndex].inputTexture.source._resolution;\n        }\n\n        const filterUniforms = this._filterGlobalUniforms;\n        const uniforms = filterUniforms.uniforms;\n\n        const outputFrame = uniforms.uOutputFrame;\n        const inputSize = uniforms.uInputSize;\n        const inputPixel = uniforms.uInputPixel;\n        const inputClamp = uniforms.uInputClamp;\n        const globalFrame = uniforms.uGlobalFrame;\n        const outputTexture = uniforms.uOutputTexture;\n\n        // are we rendering back to the original surface?\n        if (isFinalTarget)\n        {\n            let lastIndex = this._filterStackIndex;\n\n            // get previous bounds.. we must take into account skipped filters also..\n            while (lastIndex > 0)\n            {\n                lastIndex--;\n                const filterData = this._filterStack[this._filterStackIndex - 1];\n\n                if (!filterData.skip)\n                {\n                    offset.x = filterData.bounds.minX;\n                    offset.y = filterData.bounds.minY;\n\n                    break;\n                }\n            }\n\n            outputFrame[0] = bounds.minX - offset.x;\n            outputFrame[1] = bounds.minY - offset.y;\n        }\n        else\n        {\n            outputFrame[0] = 0;\n            outputFrame[1] = 0;\n        }\n\n        outputFrame[2] = input.frame.width;\n        outputFrame[3] = input.frame.height;\n\n        inputSize[0] = input.source.width;\n        inputSize[1] = input.source.height;\n        inputSize[2] = 1 / inputSize[0];\n        inputSize[3] = 1 / inputSize[1];\n\n        inputPixel[0] = input.source.pixelWidth;\n        inputPixel[1] = input.source.pixelHeight;\n        inputPixel[2] = 1.0 / inputPixel[0];\n        inputPixel[3] = 1.0 / inputPixel[1];\n\n        inputClamp[0] = 0.5 * inputPixel[2];\n        inputClamp[1] = 0.5 * inputPixel[3];\n        inputClamp[2] = (input.frame.width * inputSize[2]) - (0.5 * inputPixel[2]);\n        inputClamp[3] = (input.frame.height * inputSize[3]) - (0.5 * inputPixel[3]);\n\n        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n\n        globalFrame[0] = offset.x * resolution;\n        globalFrame[1] = offset.y * resolution;\n\n        globalFrame[2] = rootTexture.source.width * resolution;\n        globalFrame[3] = rootTexture.source.height * resolution;\n\n        // set the output texture - this is where we are going to render to\n\n        const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n\n        renderer.renderTarget.bind(output, !!clear);\n\n        if (output instanceof Texture)\n        {\n            outputTexture[0] = output.frame.width;\n            outputTexture[1] = output.frame.height;\n        }\n        else\n        {\n            // this means a renderTarget was passed directly\n            outputTexture[0] = renderTarget.width;\n            outputTexture[1] = renderTarget.height;\n        }\n\n        outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n        filterUniforms.update();\n\n        // TODO - should prolly use a adaptor...\n        if ((renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            const batchUniforms = (renderer as WebGPURenderer).renderPipes.uniformBatch\n                .getUboResource(filterUniforms);\n\n            this._globalFilterBindGroup.setResource(batchUniforms, 0);\n        }\n        else\n        {\n            this._globalFilterBindGroup.setResource(filterUniforms, 0);\n        }\n\n        // now lets update the output texture...\n\n        // set bind group..\n        this._globalFilterBindGroup.setResource(input.source, 1);\n        this._globalFilterBindGroup.setResource(input.source.style, 2);\n\n        filter.groups[0] = this._globalFilterBindGroup;\n\n        renderer.encoder.draw({\n            geometry: quadGeometry,\n            shader: filter,\n            state: filter._state,\n            topology: 'triangle-list'\n        });\n\n        // WebGPU blit's automatically, but WebGL does not!\n        if (renderer.type === RendererType.WEBGL)\n        {\n            renderer.renderTarget.finishRenderPass();\n        }\n    }\n\n    private _getFilterData(): FilterData\n    {\n        return {\n            skip: false,\n            inputTexture: null,\n            bounds: new Bounds(),\n            container: null,\n            filterEffect: null,\n            blendRequired: false,\n            previousRenderSurface: null,\n        };\n    }\n\n    /**\n     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n     *\n     * Use `outputMatrix * vTextureCoord` in the shader.\n     * @param outputMatrix - The matrix to output to.\n     * @param {Sprite} sprite - The sprite to map to.\n     * @returns The mapped matrix.\n     */\n    public calculateSpriteMatrix(outputMatrix: Matrix, sprite: Sprite): Matrix\n    {\n        const data = this._activeFilterData;\n\n        const mappedMatrix = outputMatrix.set(\n            data.inputTexture._source.width,\n            0, 0,\n            data.inputTexture._source.height,\n            data.bounds.minX, data.bounds.minY\n        );\n\n        const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n\n        worldTransform.invert();\n        mappedMatrix.prepend(worldTransform);\n        mappedMatrix.scale(\n            1.0 / sprite.texture.frame.width,\n            1.0 / sprite.texture.frame.height\n        );\n\n        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n        return mappedMatrix;\n    }\n\n    public destroy?: () => void;\n}\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { boundsPool } from './utils/matrixAndBoundsPool.mjs';\n\n\"use strict\";\nconst tempMatrix = new Matrix();\nfunction getFastGlobalBounds(target, bounds) {\n  bounds.clear();\n  _getGlobalBoundsRecursive(target, bounds);\n  if (!bounds.isValid) {\n    bounds.set(0, 0, 0, 0);\n  }\n  if (!target.isRenderGroupRoot) {\n    bounds.applyMatrix(target.renderGroup.worldTransform);\n  } else {\n    bounds.applyMatrix(target.renderGroup.localTransform);\n  }\n  return bounds;\n}\nfunction _getGlobalBoundsRecursive(target, bounds) {\n  if (target.localDisplayStatus !== 7 || !target.measurable) {\n    return;\n  }\n  const manageEffects = !!target.effects.length;\n  let localBounds = bounds;\n  if (target.isRenderGroupRoot || manageEffects) {\n    localBounds = boundsPool.get().clear();\n  }\n  if (target.boundsArea) {\n    bounds.addRect(target.boundsArea, target.worldTransform);\n  } else {\n    if (target.renderPipeId) {\n      const viewBounds = target.bounds;\n      localBounds.addFrame(\n        viewBounds.minX,\n        viewBounds.minY,\n        viewBounds.maxX,\n        viewBounds.maxY,\n        target.groupTransform\n      );\n    }\n    const children = target.children;\n    for (let i = 0; i < children.length; i++) {\n      _getGlobalBoundsRecursive(children[i], localBounds);\n    }\n  }\n  if (manageEffects) {\n    let advanced = false;\n    for (let i = 0; i < target.effects.length; i++) {\n      if (target.effects[i].addBounds) {\n        if (!advanced) {\n          advanced = true;\n          localBounds.applyMatrix(target.renderGroup.worldTransform);\n        }\n        target.effects[i].addBounds(localBounds, true);\n      }\n    }\n    if (advanced) {\n      localBounds.applyMatrix(target.renderGroup.worldTransform.copyTo(tempMatrix).invert());\n      bounds.addBounds(localBounds, target.relativeGroupTransform);\n    }\n    bounds.addBounds(localBounds);\n    boundsPool.return(localBounds);\n  } else if (target.isRenderGroupRoot) {\n    bounds.addBounds(localBounds, target.relativeGroupTransform);\n    boundsPool.return(localBounds);\n  }\n}\n\nexport { _getGlobalBoundsRecursive, getFastGlobalBounds };\n//# sourceMappingURL=getFastGlobalBounds.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { boundsPool } from './utils/matrixAndBoundsPool';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Container } from '../Container';\nimport type { Bounds } from './Bounds';\n\n// TODO could we cache local bounds on the render groups?\n\nconst tempMatrix = new Matrix();\n\n/**\n * Does exactly the same as getGlobalBounds, but does instead makes use of transforming AABBs\n * of the various children within the scene graph. This is much faster, but less accurate.\n *\n * the result will never be smaller - only ever slightly larger (in most cases, it will be the same).\n * @param target - The target container to get the bounds from\n * @param bounds - The output bounds object.\n * @returns The bounds.\n */\nexport function getFastGlobalBounds(target: Container, bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    _getGlobalBoundsRecursive(target, bounds);\n\n    if (!bounds.isValid)\n    {\n        bounds.set(0, 0, 0, 0);\n    }\n\n    if (!target.isRenderGroupRoot)\n    {\n        bounds.applyMatrix(target.renderGroup.worldTransform);\n    }\n    else\n    {\n        bounds.applyMatrix(target.renderGroup.localTransform);\n    }\n\n    return bounds;\n}\n\nexport function _getGlobalBoundsRecursive(\n    target: Container,\n    bounds: Bounds,\n)\n{\n    if (target.localDisplayStatus !== 0b111 || !target.measurable)\n    {\n        return;\n    }\n\n    const manageEffects = !!target.effects.length;\n\n    let localBounds = bounds;\n\n    if (target.isRenderGroupRoot || manageEffects)\n    {\n        localBounds = boundsPool.get().clear();\n    }\n\n    if (target.boundsArea)\n    {\n        bounds.addRect(target.boundsArea, target.worldTransform);\n    }\n    else\n    {\n        if (target.renderPipeId)\n        {\n            const viewBounds = (target as Renderable).bounds;\n\n            localBounds.addFrame(\n                viewBounds.minX,\n                viewBounds.minY,\n                viewBounds.maxX,\n                viewBounds.maxY,\n                target.groupTransform\n            );\n        }\n\n        const children = target.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            _getGlobalBoundsRecursive(children[i], localBounds);\n        }\n    }\n\n    if (manageEffects)\n    {\n        let advanced = false;\n\n        for (let i = 0; i < target.effects.length; i++)\n        {\n            if (target.effects[i].addBounds)\n            {\n                if (!advanced)\n                {\n                    advanced = true;\n                    localBounds.applyMatrix(target.renderGroup.worldTransform);\n                }\n\n                target.effects[i].addBounds(localBounds, true);\n            }\n        }\n\n        if (advanced)\n        {\n            localBounds.applyMatrix(target.renderGroup.worldTransform.copyTo(tempMatrix).invert());\n            bounds.addBounds(localBounds, target.relativeGroupTransform);\n        }\n\n        bounds.addBounds(localBounds);\n        boundsPool.return(localBounds);\n    }\n    else if (target.isRenderGroupRoot)\n    {\n        bounds.addBounds(localBounds, target.relativeGroupTransform);\n        boundsPool.return(localBounds);\n    }\n}\n","\"use strict\";\nfunction getGlobalRenderableBounds(renderables, bounds) {\n  bounds.clear();\n  const tempMatrix = bounds.matrix;\n  for (let i = 0; i < renderables.length; i++) {\n    const renderable = renderables[i];\n    if (renderable.globalDisplayStatus < 7) {\n      continue;\n    }\n    bounds.matrix = renderable.worldTransform;\n    renderable.addBounds(bounds);\n  }\n  bounds.matrix = tempMatrix;\n  return bounds;\n}\n\nexport { getGlobalRenderableBounds };\n//# sourceMappingURL=getRenderableBounds.mjs.map\n","import type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Bounds } from './Bounds';\n\nexport function getGlobalRenderableBounds(renderables: Renderable[], bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    // instead of copying the matrix each time we are assigning it in bounds\n    // this is a performance hack :D\n    // so we need to restore the matrix after we are done\n\n    const tempMatrix = bounds.matrix;\n\n    for (let i = 0; i < renderables.length; i++)\n    {\n        const renderable = renderables[i];\n\n        if (renderable.globalDisplayStatus < 0b111)\n        {\n            continue;\n        }\n\n        bounds.matrix = renderable.worldTransform;\n        renderable.addBounds(bounds);\n    }\n\n    bounds.matrix = tempMatrix;\n\n    return bounds;\n}\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$interopDefault","a","__esModule","default","parcelRequire","$parcel$global","globalThis","parcelRegister","register","module","exports","$eVz1R","$c9r7l","$6jyhb","extensions","add","ResizePlugin","TickerPlugin","$c2e7faafdc49eb51$export$6453cd852defe94a","init","options","dom","removeEventListener","queueResize","_resizeTo","addEventListener","resize","_cancelResize","_resizeId","requestAnimationFrame","cancelAnimationFrame","width","height","window","innerWidth","innerHeight","clientWidth","clientHeight","renderer","render","resizeTo","destroy","extension","ExtensionType","Application","$eef91818de7f56f7$export$50c361ceb4e2f4f0","$gu9S0","$1WaK0","assign","autoStart","sharedTicker","ticker","_ticker","remove","UPDATE_PRIORITY","LOW","stop","start","Ticker","shared","oldTicker","$d5fcb0cfb12f95a2$export$688aaf132ba9b379","UPDATE_PRIORITY2","$ec35c199f341d964$export$39c54bcc89dcee11","$aUStc","$ec35c199f341d964$var$_Ticker","_Ticker","constructor","deltaTime","lastTime","speed","started","_requestId","_maxElapsedMS","_minElapsedMS","_protected","_lastFrame","_head","TickerListener","Infinity","deltaMS","targetFPMS","elapsedMS","_tick","time","update","next","_requestIfNeeded","performance","now","_cancelIfNeeded","_startIfPossible","fn","context","priority","NORMAL","_addListener","addOnce","listener","current","previous","connect","match","count","currentTime","delta","head","emit","FPS","minFPS","fps","minFPMS","Math","min","max","maxFPS","round","_shared","system","_system","$d4f3b3eea778246a$export$579021a5759a260f","once","_destroyed","_fn","_context","_once","call","redirect","hard","$bHBRz","spritesheetAsset","$d2e9ea45ca6bce6f$export$46dcda4f1cdd80fe","$kuLtH","$Lmcdo","$kY7V1","$5h88T","$kaDu9","$2v83S","$d2e9ea45ca6bce6f$var$validImages","Asset","cache","test","asset","Spritesheet","getCacheableAssets","keys","$d2e9ea45ca6bce6f$var$getCacheableAssets","ignoreMultiPack","out","forEach","key","textures","basePath","path","dirname","linkedSheets","item","i","data","meta","related_multi_packs","resolver","value","split","tempURL","pop","format","includes","parse","resolution","parseFloat","Resolver","RETINA_PREFIX","exec","length","src","loader","name","type","LoadParser","LoaderParserPriority","Normal","testParse","extname","toLowerCase","frames","texture","imageTexture","imageFilename","lastIndexOf","Texture","imagePath","copySearchParams","image","assets","load","spritesheet","source","multiPacks","Array","isArray","promises","itemUrl","push","res","Promise","all","concat","filter","sp","unload","_resolvedAsset","textureSource","_sourceOrigin","$0734c567d6f21224$export$820ed6348c4f2750","LoaderParserPriority2","$ffe5eb4b246313bd$export$8b4c839865b08288","$8CF4q","$lbclP","$ahHFV","$6BHki","_defaultBundleIdentifierOptions","connector","createBundleAssetId","bundleId","assetId","_bundleIdConnector","extractAssetIdFromBundle","assetBundleId","replace","_createBundleAssetId","_extractAssetIdFromBundle","_assetMap","_preferredOrder","_parsers","_resolverHash","_bundles","setBundleIdentifier","bundleIdentifier","Error","prefer","preferOrders","params","_basePath","rootPath","_rootPath","parsers","reset","_manifest","_defaultSearchParams","setDefaultSearchParams","searchParams","map","encodeURIComponent","queryValues","join","getAlias","alias","convertToList","addManifest","manifest","warn","bundles","bundle","addBundle","assetNames","convertedAssets","entries","ids","srcs","aliases","bundleAssetId","bundleIds","keyCheck","hasKey","assetArray","loadParser","srcsToUse","src2","createStringVariations","aliasesToUse","resolvedAssets","formattedAsset","parser","_buildResolvedAsset","resolveBundle","singleAsset","isSingleItem","results","resolve","resolveUrl","result","preferredOrder","_getPreferredOrder","priorityKey","filteredAssets","hasBundle","preferred","find","preference","_appendDefaultSearchParams","url","paramConnector","assetData","toAbsolute","shift","$71fdf52ee267c3d5$export$bb654e07daaf8c3a","$5m2Qn","$71fdf52ee267c3d5$var$assertPath","path2","TypeError","JSON","stringify","$71fdf52ee267c3d5$var$removeUrlParams","re","toPosix","str","RegExp","string","isUrl","isDataUrl","isBlobUrl","startsWith","hasProtocol","getProtocol","matchFile","matchProtocol","customBaseUrl","customRootUrl","baseUrl","DOMAdapter","getBaseUrl","rootUrl","rootname","slice","isAbsolute","normalize","protocol","trailingSeparator","endsWith","$71fdf52ee267c3d5$var$normalizeStringPosix","allowAboveRoot","lastSegmentLength","lastSlash","dots","code","charCodeAt","lastSlashIndex","segments","joined","arg","prevArg","joinExtensions","hasRoot","end","matchedSlash","proto","origpath","root","index","indexOf","basename","ext","extIdx","firstNonSlashEnd","startDot","startPart","preDotState","ret","dir","base","sep","delimiter","$e2bf4ca911ccb6c4$export$b01be8e180bf3d9b","input","transform","forceTransform","$640f472f529f8d2c$export$738117acc6638004","tags","vars","substring","$640f472f529f8d2c$var$processX","depth","id","$2eda5fd8d2343e44$export$16a80d27953452d4","$d4712b2ff08e6328$export$f57b97ef8be10dda","targetUrl","sourceUrl","$9bc8b71d4eda66ae$export$674d2eb4debbef0c","$soqVu","$9bc8b71d4eda66ae$var$_Spritesheet","_Spritesheet","_texture","animations","metaResolution","scale","_resolution","_frames","_frameKeys","_batchIndex","_callback","BATCH_SIZE","_processFrames","_processAnimations","_parseComplete","_nextBatch","initialFrameIndex","frameIndex","maxFrames","rect","frame","trim","sourceSize","trimmed","orig","Rectangle","floor","w","h","rotated","x","y","spriteSourceSize","rotate","defaultAnchor","anchor","defaultBorders","borders","label","toString","animName","frameName","callback","setTimeout","destroyBase","$jgXaH","$vwyRu","$lcq2f","$i8D1k","$2rfX3","$4XrO5","$c9SSH","AlphaMask","ColorMask","StencilMask","VideoSource","ImageSource","CanvasSource","BufferImageSource","$00f658052eacd8e9$export$3c32667be409917c","$9Qy7u","$kARrF","$kBq1a","pipe","mask","renderMaskToTexture","Sprite","renderable","includeInBuild","measurable","addBounds","bounds","skipUpdateTransform","addMaskBounds","addLocalBounds","localRoot","addMaskLocalBounds","containsPoint","point","hitTestFn","MaskEffect","$7b87da68c49fb137$export$12af48852c6ac574","$ggeMF","$dXx4G","$7b87da68c49fb137$var$tempBounds","Bounds","getGlobalBounds","addBoundsMask","$3fc9498bf56d1000$export$7416ac774b1f1a33","$5pskN","$96ND8","boundsToMask","boundsPool","tempMatrix","matrixPool","identity","relativeMask","$3fc9498bf56d1000$export$1536bde1a0bf3cb9","target","matrix","parent","updateLocalTransform","append","localTransform","getLocalBounds","return","$9d623112a0b61944$export$1e2a2c76374c2542","$f004bf9ee6cb5cde$export$abd85894695764cb","$lR3Ev","Container","$0a4120f708973e3a$export$280e9a68c3ffd919","$9Ur0D","TextureSource","resource","HTMLImageElement","canvas","createCanvas","getContext","drawImage","uploadMethodId","autoGarbageCollect","ImageBitmap","$c255db0163bf6e8b$export$f3a17123d80000c5","$aG1Od","$c255db0163bf6e8b$var$_VideoSource","_VideoSource","isReady","defaultOptions","_autoUpdate","_isConnectedToTicker","_updateFPS","updateFPS","_msToNextUpdate","autoPlay","alphaMode","_videoFrameRequestCallback","bind","_videoFrameRequestCallbackHandle","_load","_resolve","_reject","_onCanPlay","_onCanPlayThrough","_onError","_onPlayStart","_onPlayStop","_onSeeked","autoLoad","updateFrame","destroyed","playbackRate","isValid","requestVideoFrameCallback","videoWidth","videoHeight","readyState","HAVE_ENOUGH_DATA","HAVE_FUTURE_DATA","complete","_isSourceReady","_mediaReady","preload","detectVideoAlphaMode","reject","preloadTimeoutMs","_preloadTimeout","ErrorEvent","event","_isSourcePlaying","paused","ended","_configureAutoUpdate","clearTimeout","play","pause","autoUpdate","cancelVideoFrameCallback","HTMLVideoElement","VideoFrame","crossorigin","loop","muted","playsinline","MIME_TYPES","ogv","mov","m4v","$6b8bedec82fcc4ee$var$promise","$6b8bedec82fcc4ee$export$8df68d58aae31877","gl","document","createElement","video","video2","onloadeddata","onerror","autoplay","crossOrigin","createTexture","bindTexture","TEXTURE_2D","framebuffer","createFramebuffer","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","pixelStorei","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_COLORSPACE_CONVERSION_WEBGL","NONE","texImage2D","RGBA","UNSIGNED_BYTE","pixel","Uint8Array","readPixels","deleteFramebuffer","deleteTexture","getExtension","loseContext","$gYSnF","$917f49679f7aef27$var$sources","handleByList","from","skipCache","Cache","$917f49679f7aef27$export$3b748ed6327ec85b","hasResource","opts","has","$917f49679f7aef27$export$688bcf31fbf7eb15","Source","on","$d254af94afe44123$export$94affb487e701bf2","_cache","Map","_cacheMap","clear","cacheableAssets","cacheableMap","key2","cacheKeys","cachedAssets","val","cacheMap","delete","$bBCDe","$g4d6y","GraphicsPipe","GraphicsContextSystem","$5cda66bda9bb03b4$export$f2f3ca33e4c65172","$h1qkv","$9q6W4","$gC5Pa","$vdXhX","$e98Fy","$03aVk","$5cda66bda9bb03b4$export$e3e348c254036d55","batches","geometryData","vertices","uvs","indices","$5cda66bda9bb03b4$export$9b6a6c5b37fc8f49","geometry","BatchGeometry","instructions","InstructionSet","$5cda66bda9bb03b4$var$_GraphicsContextSystem","_GraphicsContextSystem","_activeBatchers","_gpuContextHash","_graphicsDataContextHash","create","_needsContextNeedsRebuild","bezierSmoothness","prerender","_returnActiveBatchers","getContextRenderData","uid","_initContextRenderData","updateGpuContext","gpuContext","_initContext","dirty","_cleanGraphicsContextData","buildContextBatches","batchMode","customShader","isBatchable","getGpuContext","BigPool","graphicsData","vertexSize","indexSize","applyTransform","batcher","Batcher","ensureAttributeBuffer","ensureIndexBuffer","begin","batch","finish","indexBuffer","setDataWithSize","buffers","attributeBuffer","float32View","attributeSize","drawBatches","bindGroup","getTextureBatchBindGroup","onGraphicsContextUpdate","onGraphicsContextDestroy","off","WebGLSystem","WebGPUSystem","CanvasSystem","$d3159e79409670b7$export$e3c00f31a053d231","$cvBir","$5Mobi","$7bQyz","$lkR0B","$dspZV","$6AePw","$3P3MX","$5gUNA","$7KshX","$d3159e79409670b7$var$buildMap","rectangle","buildRectangle","polygon","buildPolygon","triangle","buildTriangle","circle","buildCircle","ellipse","roundedRectangle","$d3159e79409670b7$var$tempRect","instruction","action","$d3159e79409670b7$var$addTextureToGeometryData","indexOffset","vertOffset","points","build","dx","dy","dw","dh","transformVertices","triangulate","textureUvs","x0","y0","x1","y1","x3","y3","x2","y2","graphicsBatch","BatchableGraphics","vertexOffset","color","style","alpha","isStroke","shapePath","hole","$d3159e79409670b7$var$addShapePathToGeometryData","lastIndex","shapePrimitives","shape","close","closePath","buildLine","console","holeIndices","otherPoints","holeArrays","$d3159e79409670b7$var$getHoleArrays","holePrimitives","k","holePrimitive","holePoints","holeBuilder","triangulateWithHoles","uvsOffset","WHITE","textureMatrix","clone","invert","buildUvs","buildSimpleUvs","$eadc1079aec88a51$export$2027711a0ff70dc2","verticesStride","verticesOffset","uvsStride","size","b","c","d","tx","ty","$eadc1079aec88a51$export$580e3d8462b9fe52","$8e0648d3b196e6db$export$cbe36b8a8d6e3d3","m","offset","stride","$fe2f0279269cf065$export$91d2a08bbf21546b","$bLQN7","roundPixels","blendMode","groupBlendMode","packIndex","indicesOffset","packAttributes","uint32View","textureId","graphics","positions","vertSize","rgb","bgr","argb","mixColors","groupColor","groupAlpha","wt","groupTransform","textureIdAndRound","copyTo","gpuBuffer","$08464aef58e30e75$export$a3541b2d8ecbfcf2","rx","ry","radius","halfWidth","halfHeight","roundedRect","ceil","sqrt","j1","j2","j3","j4","y22","PI","x02","cos","y02","sin","x12","x22","y12","centerX","centerY","centerIndex","$f4ab86a5c05caa8e$export$45986ccf08e93b0b","$2NXni","$3LOun","$4G5QW","$f4ab86a5c05caa8e$var$square","nx","ny","innerWeight","outerWeight","clockwise","verts","exx","eyy","eix","ix","eiy","iy","eox","ox","eoy","oy","$f4ab86a5c05caa8e$var$round","cx","cy","sx","sy","ex","ey","cx2p0x","cy2p0y","angle0","atan2","angle1","startAngle","angleDiff","segCount","abs","angleInc","angle","lineStyle","flipAlignment","closed","_verticesStride","_verticesOffset","_indicesOffset","eps","closePointEps","alignment","orientation","getOrientationOfPoints","firstPoint","Point","lastPoint","closedPath","midPointX","midPointY","unshift","indexCount","indexStart","widthSquared","miterLimitSquared","miterLimit","perpX","perpY","perp1x","perp1y","dist","ratio","cap","dx0","dy0","dx1","dy1","dot","cross","c1","c2","px","py","pDist","imx","imy","omx","omy","insideWeight","smallerInsideSegmentSq","eps2","curveEps","$14339eff216787b9$export$7159a7c43f12984","$14339eff216787b9$export$51a946149243709","$954666132023b6df$export$38856eae80d480e1","area","$5ca58799171465f2$export$4c2d12f7b210f357","$5ca58799171465f2$var$emptyArray","$83f5c12aa1c2b92a$export$5a241bf9c2c3d94b","$eH7tg","holes","triangles","$ab2ae071cd7be4a4$var$earcut","dim","minX","minY","maxX","maxY","invSize","hasHoles","outerLen","outerNode","$ab2ae071cd7be4a4$var$linkedList","prev","$ab2ae071cd7be4a4$var$eliminateHoles","len","list","queue","steiner","$ab2ae071cd7be4a4$var$getLeftmost","p","leftmost","sort","$ab2ae071cd7be4a4$var$compareX","$ab2ae071cd7be4a4$var$eliminateHole","bridge","$ab2ae071cd7be4a4$var$findHoleBridge","hx","hy","qx","tan","mx","my","tanMin","$ab2ae071cd7be4a4$var$pointInTriangle","$ab2ae071cd7be4a4$var$locallyInside","$ab2ae071cd7be4a4$var$area","bridgeReverse","$ab2ae071cd7be4a4$var$splitPolygon","$ab2ae071cd7be4a4$var$filterPoints","$ab2ae071cd7be4a4$var$earcutLinked","ear","pass","$ab2ae071cd7be4a4$var$indexCurve","z","$ab2ae071cd7be4a4$var$zOrder","prevZ","nextZ","$ab2ae071cd7be4a4$var$sortLinked","q","tail","numMerges","pSize","qSize","inSize","$ab2ae071cd7be4a4$var$isEarHashed","ax","bx","ay","by","minZ","maxZ","$ab2ae071cd7be4a4$var$isEar","$ab2ae071cd7be4a4$var$removeNode","$ab2ae071cd7be4a4$var$cureLocalIntersections","$ab2ae071cd7be4a4$var$equals","$ab2ae071cd7be4a4$var$intersects","$ab2ae071cd7be4a4$var$splitEarcut","$ab2ae071cd7be4a4$var$intersectsPolygon","$ab2ae071cd7be4a4$var$middleInside","inside","last","$ab2ae071cd7be4a4$var$signedArea","$ab2ae071cd7be4a4$var$insertNode","again","r","p1","p2","q1","q2","o1","$ab2ae071cd7be4a4$var$sign","o2","o3","o4","$ab2ae071cd7be4a4$var$onSegment","num","a2","$ab2ae071cd7be4a4$var$Node","b2","an","bp","sum","j","deviation","polygonArea","trianglesArea","flatten","dimensions","holeIndex","$a068e7e6351473f8$export$cbe813d11f2192b2","rectData","verticesIndex","$e325eef422fafe85$export$8eb75cb9f614d270","$0aab1cc3669c9573$export$56171ef5563dc803","$4rJn2","$1A6sa","adaptor","state","State","for2d","_graphicsBatchesHash","_adaptor","validateRenderable","wasBatched","graphicsContext","addRenderable","instructionSet","_didGraphicsUpdate","_rebuild","_addToBatcher","renderPipes","break","updateRenderable","updateElement","destroyRenderable","_removeBatchForRenderable","execute","isRenderable","contextSystem","shader","localUniforms","resources","uniforms","uTransformMatrix","uRound","_roundPixels","color32BitToUniform","groupColorAlpha","uColor","_initBatchesForRenderable","batched","batchPipe","_getBatchesForRenderable","addToBatch","batchClone","graphicsUid","WebGLPipes","WebGPUPipes","CanvasPipes","$kpjyU","MeshPipe","$c2a32bb93b0457d5$export$ec121977b4273ffd","$dNaJE","$86NKO","$lJEsO","$bq09x","UniformGroup","Matrix","Float32Array","localUniformsBindGroup","BindGroup","_meshDataHash","_gpuBatchableMeshHash","mesh","meshData","_getMeshData","isBatched","_geometry","batchableMesh","_getBatchableMesh","_source","checkAndUpdateTexture","gpuBatchableMesh","renderPipeId","gpuMesh","_initMeshData","_initBatchableMesh","BatchableMesh","$fb7e6b6dd0e8e83d$export$2fa0f0ec877329e3","_uvUpdateId","_textureMatrixUpdateId","uvBuffer","getBuffer","transformedUvs","isSimple","_transformedUvs","_updateID","multiplyUvs","abgr","$7JqIa","$irQVi","CanvasTextSystem","CanvasTextPipe","$26054a65a4f42ce4$export$ed0d779e44b53050","$1ZKfN","$8PFkM","_gpuText","_renderer","text","gpuText","_getGpuText","newKey","_getKey","currentKey","canvasText","getTextureSize","_style","getReferenceCount","_instructionSet","batchableSprite","_didTextUpdate","_updateText","_destroyRenderableById","textUid","decreaseReferenceCount","_updateGpuText","padding","updateQuadBounds","_anchor","getTexture","initGpuText","gpuTextData","BatchableSprite","$0dc6e34005d06c5e$export$56e4907c2e518abc","$AHTcQ","$domwE","$8zNlV","$7U2uj","$h6sd0","$aq3uI","$ffIGX","$fMjVf","$eHP3T","_activeTextures","measured","CanvasTextMetrics","measureText","nextPow2","textKey","_increaseReferenceCount","canvasAndContext","CanvasPool","getOptimalCanvasAndContext","renderTextToCanvas","getPo2TextureFromSource","getCanvasBoundingBox","copyFrom","updateUvs","usageCount","activeTexture","returnCanvasAndContext","TexturePool","returnTexture","linePositionX","linePositionY","font","fontStringFromTextStyle","lines","lineHeight","lineWidths","maxLineWidth","fontProperties","resetTransform","clearRect","_stroke","strokeStyle","lineWidth","lineJoin","lineCap","passesCount","dropShadow","isShadowPass","dsOffsetText","dsOffsetShadow","fillStyle","shadowOptions","dropShadowColor","dropShadowAlpha","shadowColor","Color","setValue","setAlpha","toRgbaString","dropShadowBlur","blur","dropShadowDistance","distance","shadowBlur","shadowOffsetX","shadowOffsetY","globalAlpha","_fill","getCanvasFillStyle","linePositionYShift","fontSize","strokeWidth","i2","ascent","align","_drawLetterSpacing","letterSpacing","useExperimentalLetterSpacing","experimentalLetterSpacingSupported","experimentalLetterSpacing","textLetterSpacing","strokeText","fillText","currentPosition","stringArray","graphemeSegmenter","previousWidth","currentWidth","currentChar","textStr","$56f0a2690b9dc8b2$export$550eedf6c679837d","$56f0a2690b9dc8b2$var$checkRow","$56f0a2690b9dc8b2$var$checkColumn","top","bottom","willReadFrequently","imageData","getImageData","left","right","EMPTY","$b035aaddaf7b0631$export$80c61c6b7fb407a3","$b035aaddaf7b0631$var$tempBounds","getOptimalTexture","$0a83834d09de39f8$export$b12f6bdc825d944f","$0a83834d09de39f8$var$contextSettings","$0a83834d09de39f8$var$_CanvasTextMetrics","_CanvasTextMetrics","_experimentalLetterSpacingSupported","getCanvasRenderingContext2D","prototype","_canvas","wordWrap","styleKey","_measurementCache","measureFont","__context","outputText","_wordWrap","_measureText","leading","line","whiteSpace","collapseSpaces","_collapseSpaces","collapseNewlines","_collapseNewlines","canPrependSpaces","wordWrapWidth","tokens","_tokenize","token","_isNewline","_addLine","currIsBreakingSpace","isBreakingSpace","lastIsBreakingSpace","tokenWidth","_getFromCache","canBreakWords","breakWords","characters","wordWrapSplit","char","lastChar","nextChar","canBreakChars","characterWidth","isLastToken","newLine","_trimRight","_newlines","_nextChar","_breakingSpaces","_token","_char","_index","_breakWords","_fonts","metrics","METRICS_STRING","BASELINE_SYMBOL","properties","actualBoundingBoxAscent","descent","actualBoundingBoxDescent","clearMetrics","__canvas","OffscreenCanvas","BASELINE_MULTIPLIER","HEIGHT_MULTIPLIER","Intl","Segmenter","segmenter","segment","$a79c0b5192d6420f$export$b7b5edb82ac3fc66","$a79c0b5192d6420f$var$genericFontFamilies","fontSizeString","fontFamilies","fontFamily","fontStyle","fontVariant","fontWeight","$3cff3a2aec2a5913$export$c31af9427fa8602b","$j8pAr","$hZTCO","fill","toHex","FillPattern","fillPattern","pattern","createPattern","setTransform","FillGradient","fillGradient","gradient","createLinearGradient","gradientStops","addColorStop","$d135c51a7b448ab0$export$722a6ea8c60ca86","$l80qL","$d135c51a7b448ab0$var$_FillGradient","_FillGradient","buildLinearGradient","defaultSize","defaultTextureSize","ctx","fillRect","addressModeU","addressModeV","translate","$c2e39672a8752c63$export$3d1378c7410cd8e","$c2e39672a8752c63$var$repetitionMap","repeat","repetition","$1PcaQ","$3SZLI","BitmapTextPipe","loadBitmapFont","bitmapFontCachePlugin","$8c18b5020edeff18$export$778a313228f06f6c","$8c18b5020edeff18$export$402edee29ac8bed4","$7zh1j","$3RsiR","$9m29S","$8c18b5020edeff18$var$validExtensions","CacheParser","BitmapFont","bitmapFontTextParser","bitmapFontXMLStringParser","bitmapFontData","pages","textureUrls","pageFile","file","loadedTextures","_options","response","fetch","bitmapFont","page","$590c071e7d86b569$export$17957a09927cadc7","$gs09t","$1TcZG","AbstractBitmapFont","pageData","parseInt","chars","charData","frameReal","codePointAt","xOffset","yOffset","xAdvance","kerning","baseRenderedFontSize","baseMeasurementFontSize","fontMetrics","baseLineOffset","distanceField","range","install","BitmapFontManager","uninstall","$c82cc5325e5b223b$export$70779aee6e4c1309","$gpXaq","$eX50w","arguments","deprecation","v8_0_0","pageTextures","distanceFieldRange","distanceFieldType","destroyTextures","removeAllListeners","$2163057b3bc5778f$export$d2ee57cdc0e1ed7f","$itLJu","$54k6R","$eGMbi","$7gvRa","ALPHA","NUMERIC","ALPHANUMERIC","ASCII","skipKerning","getFont","fontFamilyKey","overrideFill","fnt","DynamicBitmapFont","overrideSize","dynamicFont","ensureCharacters","getLayout","getBitmapTextLayout","args","textStyle","TextStyle","flatChars","resolveCharacters","cacheKey","$679bde1e0a9776b1$export$1df879243bf2e42d","$hTvsP","$jwZTp","$gSm2a","$679bde1e0a9776b1$var$_TextStyle","_TextStyle","$679bde1e0a9776b1$var$convertV7Tov8Style","oldStyle","defaults","defaultDropShadow","dropShadowAngle","strokeThickness","stroke","gradientFill","fills","toNumber","number","fillGradientStops","fullStyle","defaultTextStyle","_align","_dropShadow","_fontFamily","_fontSize","_fontStyle","_fontVariant","_fontWeight","_leading","_letterSpacing","_lineHeight","_padding","_trim","textBaseline","_textBaseline","_whiteSpace","_wordWrapWidth","_originalFill","convertFillInputToFillStyle","GraphicsContext","defaultFillStyle","_originalStroke","defaultStrokeStyle","_generateKey","_styleKey","generateTextStyleKey","defaultStyle","destroyTextureSource","$f12b5912014640d6$export$cde35afe8b5f985","$awDzm","$hFJzr","$f12b5912014640d6$var$tmpPoint","$f12b5912014640d6$var$tempMatrix","$f12b5912014640d6$var$_GraphicsContext","_GraphicsContext","_activePath","GraphicsPath","_transform","_fillStyle","_strokeStyle","_stateStack","_bounds","_boundsDirty","setFillStyle","setStrokeStyle","tint","onUpdate","beginPath","lastInstruction","_initNextPathLocation","getLastPoint","moveTo","cut","holePath","addPath","arc","endAngle","counterclockwise","t","arcTo","arcToSvg","xAxisRotation","largeArcFlag","sweepFlag","bezierCurveTo","cp1x","cp1y","cp2x","cp2y","smoothness","radiusX","radiusY","lineTo","transformedX","transformedY","quadraticCurveTo","cpx","cpy","roundRect","poly","regularPoly","sides","rotation","roundPoly","corner","roundShape","useQuadratic","filletRect","fillet","chamferRect","chamfer","star","innerRadius","svg","SVGParser","restore","save","getTransform","addFrame","hasHit","shapes","transformedPoint","applyInverse","contains","strokeContains","holeShapes","$efcc084ee73dba51$export$7e54506375634c19","$98ho4","$7rqBZ","_dirty","SVGToGraphicsPath","_shapePath","ShapePath","buildPath","bezierCurveToShort","currentX","currentY","quadraticCurveToShort","cpx1","cpy1","deep","newGraphicsPath2D","isIdentity","cpx2","cpy2","$efcc084ee73dba51$var$adjustTransform","currentMatrix","prepend","$cd83cfe628f68b58$export$14a4a8042d02aa8d","$eJJJX","svgPath","commands","subpaths","currentSubPath","lastX","lastY","command","startX","startY","$aba8bfb3df0db863$var$segment","_","numbers","$aba8bfb3df0db863$var$number","Number","splice","$aba8bfb3df0db863$var$length","l","$883b5996078d1cf3$export$148534a3c727230b","$jaTjj","$asIJc","$67pKq","$guUt8","$67FNK","$hYods","$dMnI7","$1DEaT","$j5RWP","$5fPVY","$883b5996078d1cf3$var$tempRectangle","graphicsPath2D","_currentPoly","_graphicsPath2D","startPoly","_ensurePoly","fromX","fromY","buildArc","buildArcTo","buildArcToSvg","currentPoly","buildAdaptiveBezier","smoothing","buildAdaptiveQuadratic","endPoly","drawShape","Circle","Polygon","internalAngle","a1","roundedShapeQuadraticCurve","roundedShapeArc","maxFillet","inset","Ellipse","RoundedRectangle","lastShape","lx","ly","tempX","shapePrimitive","boundsRect","getBounds","addRect","$10653db1cf8e73c3$export$c89a927ffc67e6fa","r2","w2","$db837e087942ed80$export$80b0269ab108fa11","normx","normy","halfStrokeWidth","innerA","innerB","outerA","outerB","normalizedX","normalizedY","innerEllipse","outerEllipse","$0bf946332d4367d9$export$7d31b617c820d435","$3qFiz","flat","il","xi","yi","xj","yj","halfStrokeWidthSqrd","distanceSqrd","squaredDistanceToLineSegment","reduce","pointsDesc","currentPoint","$fd3b27189267ad33$export$db32ff20ff695a","xx","yy","lenSq","param","$9aaa16b8073529a2$export$d55ab2e3dc5a4263","$9aaa16b8073529a2$var$isCornerWithinStroke","pX","pY","cornerX","cornerY","radius2","innerX","innerY","rightBound","bottomBound","$d2f144dff168992b$export$7dab5eac414ecba2","sX","sY","eX","eY","distanceTolerance","$d2f144dff168992b$var$PATH_DISTANCE_EPSILON","$d2f144dff168992b$var$recursive","x4","y4","level","x23","y23","x34","y34","x123","y123","x234","y234","x1234","y1234","d2","d3","$249f722f6952cd8d$export$d53ce9debfe7a6c2","$249f722f6952cd8d$var$PATH_DISTANCE_EPSILON","$249f722f6952cd8d$var$recursive","$6989b84ced0da47e$export$ed8eebdc6998f0f6","steps","pow","f","cs","sn","$af8dfaaf6c5d82fa$export$d46b7933b415e02f","b1","mm","dd","cc","tt","k1","k2","qy","$8f96af1b23509e17$export$71ccaa6dca53075e","$8f96af1b23509e17$var$TAU","$8f96af1b23509e17$var$out","ang1","ang2","$8f96af1b23509e17$var$mapToEllipse","cosPhi","sinPhi","out2","xp","yp","$8f96af1b23509e17$var$vectorAngle","ux","uy","vx","vy","sign","acos","$8f96af1b23509e17$var$getArcCenter","pxp","pyp","rxSq","rySq","pxpSq","pypSq","radicant","centerXp","centerYp","vx1","vy1","lambda","outCurvePoint","curve","$8f96af1b23509e17$var$approxUnitArc","$c691bb6c363f5133$export$ae1f43bc280f09be","g","vecFrom","pp","sharpCorner","cRadius","pRadius","p3","v1","v2","asin","radDirection","drawDirection","halfAngle","lenOut","cX","cY","$c691bb6c363f5133$export$cf503f371c53af9e","pointLerp","numPoints","thisPoint","nextPoint","lastEdgeLength","lastOffsetDistance","nextEdgeLength","nextOffsetDistance","$0de3ca2e98777172$export$2cc2aaca18109aab","div","innerHTML","querySelector","$0de3ca2e98777172$var$renderChildren","session","graphicsPath","children","f1","s1","$0de3ca2e98777172$var$parseStyle","getAttribute","useFill","useStroke","styleParts","stylePart","$0de3ca2e98777172$var$parseFloatAttribute","nodeName","pointsString","info","defaultValue","$ebc1b92119e4a307$export$816bdeacb94f608f","fillStyleToParse","styleToMerge","isColorLike","temp","sourceStyle","addressMode","$bd4fc7f01fbab292$export$8a3681e2b47964bb","$bd4fc7f01fbab292$var$valuesToIterateForKeys","prop","$bd4fc7f01fbab292$var$addFillStyleKey","$1e992dce2d092f08$export$bce21273d0a2e6c7","_measureCache","_currentChars","_currentX","_currentY","_currentPageIndex","_skipKerning","dynamicOptions","requestedFontSize","charList","self","_nextPage","fontScale","widthScale","maxCharHeight","skipTexture","paddedWidth","paddedHeight","pageData2","_drawGlyph","_applyKerning","newChars","measureCache","first","second","total","amount","textureResolution","_setupContext","toArray","$772414f75058615d$export$221291e5031b03d8","startCode","endCode","String","fromCharCode","$028c474438cf8b60$export$beeb37b3e20d3ee4","layoutData","offsetY","charPositions","spaceWidth","spacesIndex","currentLine","previousChar","firstWord","currentWord","spaceWord","nextWord","word","position","nextLine","adjustedLetterSpacing","adjustedWordWrapWidth","isEnd","isSpace","nextCharWidth","$028c474438cf8b60$var$alignCenter","measurementData","$028c474438cf8b60$var$alignRight","$028c474438cf8b60$var$alignJustify","indy","spaceIndex","totalSpaces","newSpaceWidth","$3043c13693a01c73$export$4c1815a0944ccac0","txt","items","rawData","common","kernings","attributeList","itemData","strValue","floatValue","isNaN","distanceRange","fieldType","face","charNode","letter","xoffset","yoffset","xadvance","$de1ded80582c8f01$export$bfc0a19e2e2cc16","$93yhf","bitmapFontXMLParser","parseXML","$82c0d553a5133ca6$export$7a7adbcafc5cf8e3","xml","getElementsByTagName","$524e8a09c9dd1295$export$83d8b05a29a5f8ed","$C9JRY","$gbb6L","_gpuBitmapText","bitmapText","graphicsRenderable","_getGpuBitmapText","_updateContext","$524e8a09c9dd1295$var$syncWithProxy","_updateDistanceField","_destroyRenderableByUid","renderableUid","proxyGraphics","_sdfShader","SdfShader","bitmapTextLayout","_x","_y","proxyRenderable","Graphics","worldScale","uDistance","container","proxy","globalDisplayStatus","localDisplayStatus","$2ae58bdad7aea42d$export$29d3e417456abdad","rest","canBundle","_ownedContext","onViewUpdate","allowChildren","_didChangeId","didViewUpdate","renderGroup","onChildViewUpdate","_callContextMethod","method","rotateTransform","scaleTransform","translateTransform","beginFill","endFill","drawCircle","drawEllipse","drawPolygon","drawRect","drawRoundedRect","drawStar","$7154b99db6760bb9$export$f19b070f8409d54d","$fIcRj","$1amHU","$6NJrS","$8WJj9","$eJTyi","$gxQKX","$7cNGO","$iEsAD","$hAVGf","Shader","glProgram","compileHighShaderGlProgram","bits","colorBitGl","generateTextureBatchBitGl","MAX_TEXTURES","localUniformMSDFBitGl","mSDFBitGl","roundPixelsBitGl","gpuProgram","compileHighShaderGpuProgram","colorBit","generateTextureBatchBit","localUniformMSDFBit","mSDFBit","roundPixelsBit","batchSamplers","batchSamplersUniformGroup","$c2607a74b5017ccb$export$95191d1d81ffe694","$c2607a74b5017ccb$export$7542046ad25e8068","vertex","header","main","fragment","$865390956a8ffae6$export$382a0eb192cd0a47","$865390956a8ffae6$export$52c5bf2a8ebe1f2a","$2fk0k","$5RICQ","HTMLTextSystem","HTMLTextPipe","$240efd22d51d4bb6$export$ffcef6958193be1c","htmlText","textureNeedsUploading","htmlTextUid","catch","error","generatingTexture","getManagedTexture","$8f99d4c922228ac3$export$f1b82676a746d8e9","$dgEnR","$lX2W5","$fCTRI","$ioRFn","$ima1e","$eITko","$4jNdA","$dN8mg","$4JtMi","$8Aoo3","_createCanvas","RendererType","WEBGPU","_buildTexturePromise","promise","then","htmlTextData","HTMLTextRenderData","extractFontFamilies","fontCSS","getFontCss","HTMLTextStyle","measureHtmlText","svgURL","getSVGUrl","loadSVGImage","isSafari","getTemporaryCanvasFromImage","initSource","_cleanUp","defaultFontOptions","$d7b63cd773b2d56c$export$95df08bae54cb4df","userAgent","getNavigator","$7f6451c7d6b3e38c$export$47ab50939402e24e","$7f6451c7d6b3e38c$export$5211e83ad76beaeb","$7f6451c7d6b3e38c$export$ff15d493b5bfa767","svgRoot","createElementNS","foreignObject","domElement","styleElement","Image","setAttribute","overflow","appendChild","$dd45ef77773e899a$export$a2664b42ece43c6c","$au3DA","_cssOverrides","cssOverrides","tagStyles","_cssStyle","cssStyle","textStyleToCSS","addOverride","toAdd","removeOverride","toRemove","$43dfd7f97fe8e53b$export$8daecfbc002513c1","cssStyleString","$43dfd7f97fe8e53b$var$strokeToCSS","$43dfd7f97fe8e53b$var$dropShadowToCSS","cssStyles","$43dfd7f97fe8e53b$var$tagStyleToCSS","tagStyle","cssTagStyle","$43dfd7f97fe8e53b$var$transform","$43dfd7f97fe8e53b$var$templates","dropShadowStyle","toHexa","$d97dc040521de188$export$464e4dcbf779d16c","dedupe","matches","addFontFamily","fontFamily2","$52f8eba0d0420032$export$634b39f5e6e8534d","$9uPNF","$52f8eba0d0420032$export$9b6075a0351ad0f8","fontPromises","loadFontCSS","$fd9009d6662e5087$export$d5a8e182a5491db2","$67eDB","dataSrc","loadFontAsBase64","$9101e6ed68a6d748$export$21404a5ba2126552","blob","reader","FileReader","onloadend","readAsDataURL","$b575faec2ef0da29$export$98b744dca5b9429f","textContent","XMLSerializer","serializeToString","$3e0486db38f293a4$export$d871fed544c30b4e","$0e67ac1d5a4c17bc$export$31cf685397f1a12a","delay","resolve2","onload","$4ae7f08d3391dc86$var$tempHTMLTextRenderData","$4ae7f08d3391dc86$export$9df7f2a259800030","fontStyleCSS","htmlTextRenderData","body","contentBounds","getBoundingClientRect","descenderPadding","$lBnsB","TilingSpritePipe","$f74dcbc6c5a684c6$export$b56051ebf906ec5d","$egBuP","$6uHq8","$kw4QU","$95QaC","$eFs8Y","$f74dcbc6c5a684c6$var$sharedQuad","QuadGeometry","_tilingSpriteDataHash","tilingSpriteData","_getTilingSpriteData","couldBatch","canBatch","_updateCanBatch","tilingSprite","_didTilingSpriteUpdate","_updateBatchableMesh","TilingSpriteShader","groups","globalUniforms","encoder","draw","default2d","updateUniforms","_tileTransform","_initTilingSpriteData","MeshGeometry","setUvs","setPositions","renderableData","_nonPowOf2wrapping","WEBGL","supports","nonPowOf2wrapping","isPowerOfTwo","$d22d58fb5edad5e0$export$8d075a36a73d54bc","$2qhsM","$cnPar","$kFbJv","$d22d58fb5edad5e0$var$_MeshGeometry","_MeshGeometry","Geometry","Uint32Array","shrinkToFit","shrinkBuffersToFit","attributes","aPosition","buffer","Buffer","usage","BufferUsage","VERTEX","COPY_DST","aUV","INDEX","topology","$8e66c909c6201b01$var$gpuProgram","$8e66c909c6201b01$var$glProgram","$8e66c909c6201b01$export$d1a26cc57b383809","$bwYhl","$lSjtG","localUniformBit","tilingBit","localUniformBitGl","tilingBitGl","tilingUniforms","uMapCoord","uClampFrame","uClampOffset","uTextureTransform","uSizeAnchor","uTexture","uSampler","anchorX","anchorY","textureWidth","textureHeight","mapCoord","$87b0144914f9a241$export$7551c6773b6af70d","$87b0144914f9a241$export$a104558c66046525","$e8f84e9bd56edc52$export$d27e254c8c1b5a0e","$7efff6096e850f81$export$7d390d1e3efa819a","$329c27945ef19020$export$f99a1f47283a6d20","$69HXm","_applyAnchorToTexture","applyMatrix","$a68854535b202106$export$8e14504c3429ee65","array","$7hs4B","NineSliceSpritePipe","$3197407932be8e47$export$69030e8b070eaa80","$jxmLS","_gpuSpriteHash","sprite","gpuSprite","_getGpuSprite","_didSpriteUpdate","_updateBatchableSprite","_initGPUSprite","NineSliceGeometry","$8d665aef35d21487$export$a1f405faf7381142","$ifiML","$8d665aef35d21487$var$_NineSliceGeometry","_NineSliceGeometry","PlaneGeometry","verticesX","verticesY","_originalWidth","originalWidth","_originalHeight","originalHeight","_leftWidth","leftWidth","_rightWidth","rightWidth","_topHeight","topHeight","_bottomHeight","bottomHeight","updatePositions","scaleW","_uvw","_uvh","$fde9f2079ac32f4e$export$967d831af31f69ce","$fde9f2079ac32f4e$var$_PlaneGeometry","_PlaneGeometry","sizeX","sizeY","totalSub","xpos","ypos","value2","value3","value4","$j8qo9","$aicvc","FilterSystem","FilterPipe","$5644f4d93a0a9bb1$export$26a654548ff780c7","filterEffect","_filterEffect","_container","$f28e0c22fb11341c$export$e94225c0dfac29cf","$ljoAU","$7H3Wm","$f28e0c22fb11341c$var$quadGeometry","location","_filterStackIndex","_filterStack","_filterGlobalUniforms","uInputSize","uInputPixel","uInputClamp","uOutputFrame","uGlobalFrame","uOutputTexture","_globalFilterBindGroup","activeBackTexture","_activeFilterData","backTexture","filters","_getFilterData","filterData","skip","renderables","getGlobalRenderableBounds","filterArea","worldTransform","getFastGlobalBounds","colorTextureSource","renderTarget","rootRenderTarget","colorTexture","antialias","blendRequired","enabled","compatibleRenderers","backBuffer","useBackBuffer","viewPort","rootViewPort","fitBounds","pad","isPositive","previousRenderSurface","renderSurface","inputTexture","finishRenderPass","previousBounds","getRenderTarget","getBackTexture","setResource","apply","flip","flop","lastRenderSurface","backgroundResolution","copyToTexture","applyFilter","output","isFinalTarget","currentIndex","filterUniforms","outputFrame","inputSize","inputPixel","inputClamp","globalFrame","outputTexture","filterData2","pixelWidth","pixelHeight","rootTexture","isRoot","uniformBatch","batchUniforms","getUboResource","_state","calculateSpriteMatrix","outputMatrix","mappedMatrix","$10d95b085aa60563$export$ec3cb2102fa5391a","$10d95b085aa60563$var$tempMatrix","$10d95b085aa60563$export$b7169265e2c9b9ba","manageEffects","effects","localBounds","isRenderGroupRoot","boundsArea","viewBounds","advanced","relativeGroupTransform","$8f724647b1119eb0$export$11abb8ef28048394"],"version":3,"file":"browserAll.356f161c.js.map"}