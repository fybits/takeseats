{"mappings":"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","sources":["<anon>","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/extensions/Extensions.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/extensions/Extensions.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/container/Container.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/container/Container.ts","node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.js","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/color/Color.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/color/Color.ts","node_modules/.pnpm/@pixi+colord@2.9.6/node_modules/@pixi/colord/index.mjs","node_modules/.pnpm/@pixi+colord@2.9.6/node_modules/@pixi/colord/plugins/names.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/culling/cullingMixin.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/culling/cullingMixin.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/maths/matrix/Matrix.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/maths/misc/const.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/maths/misc/const.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/maths/point/Point.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/maths/point/Point.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/maths/point/ObservablePoint.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/utils/data/uid.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/utils/data/uid.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/utils/logging/deprecation.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/utils/logging/deprecation.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/container/container-mixins/childrenHelperMixin.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/utils/data/removeItems.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/utils/data/removeItems.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/container/container-mixins/effectsMixin.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/filters/FilterEffect.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/filters/FilterEffect.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/mask/MaskEffectManager.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/utils/pool/PoolGroup.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/utils/pool/Pool.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/utils/pool/Pool.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/container/container-mixins/findMixin.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/container/container-mixins/measureMixin.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/container/bounds/Bounds.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/maths/shapes/Rectangle.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/container/bounds/getGlobalBounds.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/container/bounds/utils/matrixAndBoundsPool.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/container/bounds/getLocalBounds.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/utils/logging/warn.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/utils/logging/warn.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/container/utils/checkChildrenDidChange.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/container/container-mixins/onRenderMixin.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/container/container-mixins/sortMixin.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/container/container-mixins/toLocalGlobalMixin.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/container/RenderGroup.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/container/RenderGroup.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/shared/instructions/InstructionSet.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/container/utils/assignWithIgnore.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/environment/adapter.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/environment/adapter.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/environment-browser/BrowserAdapter.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/shared/texture/Texture.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/maths/matrix/groupD8.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/maths/matrix/groupD8.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/utils/misc/NOOP.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/utils/misc/NOOP.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferSource.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/BufferSource.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/TextureSource.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/maths/misc/pow2.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/maths/misc/pow2.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/container/utils/definedProps.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/shared/texture/TextureStyle.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/shared/texture/TextureMatrix.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/sprite/Sprite.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/sprite/Sprite.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/utils/data/updateQuadBounds.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/CanvasSource.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/batcher/gpu/BatchGeometry.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/batcher/gpu/BatchGeometry.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/shared/buffer/Buffer.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/shared/buffer/const.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/shared/geometry/Geometry.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/ensureIsBuffer.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/getGeometryBounds.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/gpu/shader/BindGroup.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/batcher/shared/const.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/batcher/shared/const.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/batcher/shared/Batcher.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/utils/data/ViewableBuffer.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/shared/buffer/utils/fastCopy.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/shared/state/getAdjustedBlendModeBlend.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/shared/state/const.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/batcher/shared/BatchTextureArray.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/container/utils/mixColors.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/container/utils/mixColors.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/container/utils/mixHexColors.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/container/utils/mixHexColors.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/shared/state/State.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/graphics/gpu/colorToUniform.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/shared/shader/UniformGroup.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/shared/utils/createIdFromString.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/getDefaultUniformValue.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/scene/sprite/BatchableSprite.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/shared/texture/TexturePool.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/high-shader/compileHighShaderToProgram.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/gl/shader/GlProgram.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getTestContext.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/insertVersion.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/setProgramName.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/stripVersion.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/gpu/shader/GpuProgram.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/extractStructAndGroups.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/shared/shader/const.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/generateLayoutHash.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/high-shader/compiler/compileHighShader.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/high-shader/compiler/utils/addBits.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileHooks.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileInputs.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileOutputs.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/high-shader/compiler/utils/injectBits.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/high-shader/defaultProgramTemplate.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/high-shader/shader-bits/globalUniformsBit.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/high-shader/shader-bits/colorBit.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/high-shader/shader-bits/generateTextureBatchBit.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/high-shader/shader-bits/roundPixelsBit.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/shared/shader/Shader.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/renderers/types.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/renderers/types.ts","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs","node_modules/.pnpm/pixi.js@8.0.5/node_modules/pixi.js/src/rendering/high-shader/shader-bits/localUniformBit.ts"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequire4692\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"eVz1R\", function(module, exports) {\n\n$parcel$export(module.exports, \"ExtensionType\", () => $9c78bed6a0e6cb35$export$4f037c6ec2da4eeb);\n$parcel$export(module.exports, \"extensions\", () => $9c78bed6a0e6cb35$export$cc3e2d3244e01b7f);\n\"use strict\";\nvar $9c78bed6a0e6cb35$export$4f037c6ec2da4eeb = /* @__PURE__ */ ((ExtensionType2)=>{\n    ExtensionType2[\"Application\"] = \"application\";\n    ExtensionType2[\"WebGLPipes\"] = \"webgl-pipes\";\n    ExtensionType2[\"WebGLPipesAdaptor\"] = \"webgl-pipes-adaptor\";\n    ExtensionType2[\"WebGLSystem\"] = \"webgl-system\";\n    ExtensionType2[\"WebGPUPipes\"] = \"webgpu-pipes\";\n    ExtensionType2[\"WebGPUPipesAdaptor\"] = \"webgpu-pipes-adaptor\";\n    ExtensionType2[\"WebGPUSystem\"] = \"webgpu-system\";\n    ExtensionType2[\"CanvasSystem\"] = \"canvas-system\";\n    ExtensionType2[\"CanvasPipesAdaptor\"] = \"canvas-pipes-adaptor\";\n    ExtensionType2[\"CanvasPipes\"] = \"canvas-pipes\";\n    ExtensionType2[\"Asset\"] = \"asset\";\n    ExtensionType2[\"LoadParser\"] = \"load-parser\";\n    ExtensionType2[\"ResolveParser\"] = \"resolve-parser\";\n    ExtensionType2[\"CacheParser\"] = \"cache-parser\";\n    ExtensionType2[\"DetectionParser\"] = \"detection-parser\";\n    ExtensionType2[\"MaskEffect\"] = \"mask-effect\";\n    ExtensionType2[\"BlendMode\"] = \"blend-mode\";\n    ExtensionType2[\"TextureSource\"] = \"texture-source\";\n    ExtensionType2[\"Environment\"] = \"environment\";\n    return ExtensionType2;\n})($9c78bed6a0e6cb35$export$4f037c6ec2da4eeb || {});\nconst $9c78bed6a0e6cb35$var$normalizeExtension = (ext)=>{\n    if (typeof ext === \"function\" || typeof ext === \"object\" && ext.extension) {\n        if (!ext.extension) throw new Error(\"Extension class must have an extension object\");\n        const metadata = typeof ext.extension !== \"object\" ? {\n            type: ext.extension\n        } : ext.extension;\n        ext = {\n            ...metadata,\n            ref: ext\n        };\n    }\n    if (typeof ext === \"object\") ext = {\n        ...ext\n    };\n    else throw new Error(\"Invalid extension type\");\n    if (typeof ext.type === \"string\") ext.type = [\n        ext.type\n    ];\n    return ext;\n};\nconst $9c78bed6a0e6cb35$export$ba4241979983e013 = (ext, defaultPriority)=>$9c78bed6a0e6cb35$var$normalizeExtension(ext).priority ?? defaultPriority;\nconst $9c78bed6a0e6cb35$export$cc3e2d3244e01b7f = {\n    /** @ignore */ _addHandlers: {},\n    /** @ignore */ _removeHandlers: {},\n    /** @ignore */ _queue: {},\n    /**\n   * Remove extensions from PixiJS.\n   * @param extensions - Extensions to be removed.\n   * @returns {extensions} For chaining.\n   */ remove (...extensions2) {\n        extensions2.map($9c78bed6a0e6cb35$var$normalizeExtension).forEach((ext)=>{\n            ext.type.forEach((type)=>this._removeHandlers[type]?.(ext));\n        });\n        return this;\n    },\n    /**\n   * Register new extensions with PixiJS.\n   * @param extensions - The spread of extensions to add to PixiJS.\n   * @returns {extensions} For chaining.\n   */ add (...extensions2) {\n        extensions2.map($9c78bed6a0e6cb35$var$normalizeExtension).forEach((ext)=>{\n            ext.type.forEach((type)=>{\n                const handlers = this._addHandlers;\n                const queue = this._queue;\n                if (!handlers[type]) {\n                    queue[type] = queue[type] || [];\n                    queue[type]?.push(ext);\n                } else handlers[type]?.(ext);\n            });\n        });\n        return this;\n    },\n    /**\n   * Internal method to handle extensions by name.\n   * @param type - The extension type.\n   * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.\n   * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.\n   * @returns {extensions} For chaining.\n   */ handle (type, onAdd, onRemove) {\n        const addHandlers = this._addHandlers;\n        const removeHandlers = this._removeHandlers;\n        if (addHandlers[type] || removeHandlers[type]) throw new Error(`Extension type ${type} already has a handler`);\n        addHandlers[type] = onAdd;\n        removeHandlers[type] = onRemove;\n        const queue = this._queue;\n        if (queue[type]) {\n            queue[type]?.forEach((ext)=>onAdd(ext));\n            delete queue[type];\n        }\n        return this;\n    },\n    /**\n   * Handle a type, but using a map by `name` property.\n   * @param type - Type of extension to handle.\n   * @param map - The object map of named extensions.\n   * @returns {extensions} For chaining.\n   */ handleByMap (type, map) {\n        return this.handle(type, (extension)=>{\n            if (extension.name) map[extension.name] = extension.ref;\n        }, (extension)=>{\n            if (extension.name) delete map[extension.name];\n        });\n    },\n    /**\n   * Handle a type, but using a list of extensions with a `name` property.\n   * @param type - Type of extension to handle.\n   * @param map - The array of named extensions.\n   * @param defaultPriority - Fallback priority if none is defined.\n   * @returns {extensions} For chaining.\n   */ handleByNamedList (type, map, defaultPriority = -1) {\n        return this.handle(type, (extension)=>{\n            const index = map.findIndex((item)=>item.name === extension.name);\n            if (index >= 0) return;\n            map.push({\n                name: extension.name,\n                value: extension.ref\n            });\n            map.sort((a, b)=>$9c78bed6a0e6cb35$export$ba4241979983e013(b.value, defaultPriority) - $9c78bed6a0e6cb35$export$ba4241979983e013(a.value, defaultPriority));\n        }, (extension)=>{\n            const index = map.findIndex((item)=>item.name === extension.name);\n            if (index !== -1) map.splice(index, 1);\n        });\n    },\n    /**\n   * Handle a type, but using a list of extensions.\n   * @param type - Type of extension to handle.\n   * @param list - The list of extensions.\n   * @param defaultPriority - The default priority to use if none is specified.\n   * @returns {extensions} For chaining.\n   */ handleByList (type, list, defaultPriority = -1) {\n        return this.handle(type, (extension)=>{\n            if (list.includes(extension.ref)) return;\n            list.push(extension.ref);\n            list.sort((a, b)=>$9c78bed6a0e6cb35$export$ba4241979983e013(b, defaultPriority) - $9c78bed6a0e6cb35$export$ba4241979983e013(a, defaultPriority));\n        }, (extension)=>{\n            const index = list.indexOf(extension.ref);\n            if (index !== -1) list.splice(index, 1);\n        });\n    }\n};\n\n});\n\nparcelRegister(\"lR3Ev\", function(module, exports) {\n\n$parcel$export(module.exports, \"UPDATE_COLOR\", () => $fbe6892413159d67$export$f8ede8d8bf091ab5);\n$parcel$export(module.exports, \"UPDATE_BLEND\", () => $fbe6892413159d67$export$e4801e7edc7582f);\n$parcel$export(module.exports, \"UPDATE_VISIBLE\", () => $fbe6892413159d67$export$83db162b74637ea);\n$parcel$export(module.exports, \"Container\", () => $fbe6892413159d67$export$42a852a2b6b56249);\n\nvar $gpXaq = parcelRequire(\"gpXaq\");\n\nvar $AHTcQ = parcelRequire(\"AHTcQ\");\n\nvar $jorMT = parcelRequire(\"jorMT\");\n\nvar $dNaJE = parcelRequire(\"dNaJE\");\n\nvar $gIu8o = parcelRequire(\"gIu8o\");\n\nvar $ep73P = parcelRequire(\"ep73P\");\n\nvar $l80qL = parcelRequire(\"l80qL\");\n\nvar $eX50w = parcelRequire(\"eX50w\");\n\nvar $1AFlc = parcelRequire(\"1AFlc\");\n\nvar $4u67k = parcelRequire(\"4u67k\");\n\nvar $6UPd0 = parcelRequire(\"6UPd0\");\n\nvar $eHtGW = parcelRequire(\"eHtGW\");\n\nvar $bMTFJ = parcelRequire(\"bMTFJ\");\n\nvar $8Eetq = parcelRequire(\"8Eetq\");\n\nvar $5gOfB = parcelRequire(\"5gOfB\");\n\nvar $hmS23 = parcelRequire(\"hmS23\");\n\nvar $e84qN = parcelRequire(\"e84qN\");\n\"use strict\";\nconst $fbe6892413159d67$var$defaultSkew = new (0, $ep73P.ObservablePoint)(null);\nconst $fbe6892413159d67$var$defaultPivot = new (0, $ep73P.ObservablePoint)(null);\nconst $fbe6892413159d67$var$defaultScale = new (0, $ep73P.ObservablePoint)(null, 1, 1);\nconst $fbe6892413159d67$export$f8ede8d8bf091ab5 = 1;\nconst $fbe6892413159d67$export$e4801e7edc7582f = 2;\nconst $fbe6892413159d67$export$83db162b74637ea = 4;\nconst $fbe6892413159d67$export$8363b5079568fbee = 8;\nclass $fbe6892413159d67$export$42a852a2b6b56249 extends (0, (/*@__PURE__*/$parcel$interopDefault($gpXaq))) {\n    constructor(options = {}){\n        super();\n        /** @private */ this.uid = (0, $l80qL.uid)(\"renderable\");\n        /** @private */ this._updateFlags = 15;\n        // is this container the root of a renderGroup?\n        // TODO implement this in a few more places\n        /** @private */ this.isRenderGroupRoot = false;\n        // the render group this container belongs to OR owns\n        /** @private */ this.renderGroup = null;\n        // set to true if the container has changed. It is reset once the changes have been applied\n        // by the transform system\n        // its here to stop ensure that when things change, only one update gets registers with the transform system\n        /** @private */ this.didChange = false;\n        // same as above, but for the renderable\n        /** @private */ this.didViewUpdate = false;\n        // how deep is the container relative to its render group..\n        // unless the element is the root render group - it will be relative to its parent\n        /** @private */ this.relativeRenderGroupDepth = 0;\n        /**\n     * The array of children of this container.\n     * @readonly\n     */ this.children = [];\n        /** The display object container that contains this display object. */ this.parent = null;\n        // used internally for changing up the render order.. mainly for masks and filters\n        // TODO setting this should cause a rebuild??\n        /** @private */ this.includeInBuild = true;\n        /** @private */ this.measurable = true;\n        /** @private */ this.isSimple = true;\n        // / /////////////Transform related props//////////////\n        // used by the transform system to check if a container needs to be updated that frame\n        // if the tick matches the current transform system tick, it is not updated again\n        /**\n     * @internal\n     * @ignore\n     */ this.updateTick = -1;\n        /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     * @readonly\n     */ this.localTransform = new (0, $dNaJE.Matrix)();\n        /**\n     * The relative group transform is a transform relative to the render group it belongs too. It will include all parent\n     * transforms and up to the render group (think of it as kind of like a stage - but the stage can be nested).\n     * If this container is is self a render group matrix will be relative to its parent render group\n     * @readonly\n     */ this.relativeGroupTransform = new (0, $dNaJE.Matrix)();\n        /**\n     * The group transform is a transform relative to the render group it belongs too.\n     * If this container is render group then this will be an identity matrix. other wise it\n     * will be the same as the relativeGroupTransform.\n     * Use this value when actually rendering things to the screen\n     * @readonly\n     */ this.groupTransform = this.relativeGroupTransform;\n        /** If the object has been destroyed via destroy(). If true, it should not be used. */ this.destroyed = false;\n        // transform data..\n        /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @internal\n     * @ignore\n     */ this._position = new (0, $ep73P.ObservablePoint)(this, 0, 0);\n        /**\n     * The scale factor of the object.\n     * @internal\n     * @ignore\n     */ this._scale = $fbe6892413159d67$var$defaultScale;\n        /**\n     * The pivot point of the container that it rotates around.\n     * @internal\n     * @ignore\n     */ this._pivot = $fbe6892413159d67$var$defaultPivot;\n        /**\n     * The skew amount, on the x and y axis.\n     * @internal\n     * @ignore\n     */ this._skew = $fbe6892413159d67$var$defaultSkew;\n        /**\n     * The X-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */ this._cx = 1;\n        /**\n     * The Y-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */ this._sx = 0;\n        /**\n     * The X-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */ this._cy = 0;\n        /**\n     * The Y-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */ this._sy = 1;\n        /**\n     * The rotation amount.\n     * @internal\n     * @ignore\n     */ this._rotation = 0;\n        // / COLOR related props //////////////\n        // color stored as ABGR\n        this.localColor = 16777215;\n        this.localAlpha = 1;\n        this.groupAlpha = 1;\n        // A\n        this.groupColor = 16777215;\n        // BGR\n        this.groupColorAlpha = 4294967295;\n        // ABGR\n        // / BLEND related props //////////////\n        /**\n     * @internal\n     * @ignore\n     */ this.localBlendMode = \"inherit\";\n        /**\n     * @internal\n     * @ignore\n     */ this.groupBlendMode = \"normal\";\n        // / VISIBILITY related props //////////////\n        // visibility\n        // 0b11\n        // first bit is visible, second bit is renderable\n        /**\n     * This property holds three bits: culled, visible, renderable\n     * the third bit represents culling (0 = culled, 1 = not culled) 0b100\n     * the second bit represents visibility (0 = not visible, 1 = visible) 0b010\n     * the first bit represents renderable (0 = renderable, 1 = not renderable) 0b001\n     * @internal\n     * @ignore\n     */ this.localDisplayStatus = 7;\n        // 0b11 | 0b10 | 0b01 | 0b00\n        /**\n     * @internal\n     * @ignore\n     */ this.globalDisplayStatus = 7;\n        /**\n     * A value that increments each time the container is modified\n     * the first 12 bits represent the container changes (eg transform, alpha, visible etc)\n     * the second 12 bits represent the view changes (eg texture swap, geometry change etc)\n     *\n     *  view          container\n     * [000000000000][00000000000]\n     * @ignore\n     */ this._didChangeId = 0;\n        /**\n     * property that tracks if the container transform has changed\n     * @ignore\n     */ this._didLocalTransformChangeId = -1;\n        (0, $e84qN.assignWithIgnore)(this, options, {\n            children: true,\n            parent: true,\n            effects: true\n        });\n        options.children?.forEach((child)=>this.addChild(child));\n        this.effects = [];\n        options.parent?.addChild(this);\n    }\n    /**\n   * Mixes all enumerable properties and methods from a source object to Container.\n   * @param source - The source of properties and methods to mix in.\n   */ static mixin(source) {\n        Object.defineProperties($fbe6892413159d67$export$42a852a2b6b56249.prototype, Object.getOwnPropertyDescriptors(source));\n    }\n    /**\n   * Adds one or more children to the container.\n   *\n   * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n   * @param {...Container} children - The Container(s) to add to the container\n   * @returns {Container} - The first child that was added.\n   */ addChild(...children) {\n        if (!this.allowChildren) (0, $eX50w.deprecation)((0, $eX50w.v8_0_0), \"addChild: Only Containers will be allowed to add children in v8.0.0\");\n        if (children.length > 1) {\n            for(let i = 0; i < children.length; i++)this.addChild(children[i]);\n            return children[0];\n        }\n        const child = children[0];\n        if (child.parent === this) {\n            this.children.splice(this.children.indexOf(child), 1);\n            this.children.push(child);\n            if (this.renderGroup && !this.isRenderGroupRoot) this.renderGroup.structureDidChange = true;\n            return child;\n        }\n        if (child.parent) child.parent.removeChild(child);\n        this.children.push(child);\n        if (this.sortableChildren) this.sortDirty = true;\n        child.parent = this;\n        child.didChange = true;\n        child.didViewUpdate = false;\n        child._updateFlags = 15;\n        if (this.renderGroup) this.renderGroup.addChild(child);\n        this.emit(\"childAdded\", child, this, this.children.length - 1);\n        child.emit(\"added\", this);\n        if (child._zIndex !== 0) child.depthOfChildModified();\n        return child;\n    }\n    /**\n   * Removes one or more children from the container.\n   * @param {...Container} children - The Container(s) to remove\n   * @returns {Container} The first child that was removed.\n   */ removeChild(...children) {\n        if (children.length > 1) {\n            for(let i = 0; i < children.length; i++)this.removeChild(children[i]);\n            return children[0];\n        }\n        const child = children[0];\n        const index = this.children.indexOf(child);\n        if (index > -1) {\n            this.children.splice(index, 1);\n            if (this.renderGroup) this.renderGroup.removeChild(child);\n            child.parent = null;\n            this.emit(\"childRemoved\", child, this, index);\n            child.emit(\"removed\", this);\n        }\n        return child;\n    }\n    /** @ignore */ _onUpdate(point) {\n        if (point) {\n            if (point === this._skew) this._updateSkew();\n        }\n        this._didChangeId++;\n        if (this.didChange) return;\n        this.didChange = true;\n        if (this.isRenderGroupRoot) {\n            const renderGroupParent = this.renderGroup.renderGroupParent;\n            if (renderGroupParent) renderGroupParent.onChildUpdate(this);\n        } else if (this.renderGroup) this.renderGroup.onChildUpdate(this);\n    }\n    set isRenderGroup(value) {\n        if (this.isRenderGroupRoot && value === false) throw new Error(\"[Pixi] cannot undo a render group just yet\");\n        if (value) this.enableRenderGroup();\n    }\n    /**\n   * Returns true if this container is a render group.\n   * This means that it will be rendered as a separate pass, with its own set of instructions\n   */ get isRenderGroup() {\n        return this.isRenderGroupRoot;\n    }\n    /** This enables the container to be rendered as a render group. */ enableRenderGroup() {\n        if (this.renderGroup && this.renderGroup.root === this) return;\n        this.isRenderGroupRoot = true;\n        const parentRenderGroup = this.renderGroup;\n        if (parentRenderGroup) parentRenderGroup.removeChild(this);\n        this.renderGroup = new (0, $hmS23.RenderGroup)(this);\n        if (parentRenderGroup) {\n            for(let i = 0; i < parentRenderGroup.renderGroupChildren.length; i++){\n                const childRenderGroup = parentRenderGroup.renderGroupChildren[i];\n                let parent = childRenderGroup.root;\n                while(parent){\n                    if (parent === this) {\n                        this.renderGroup.addRenderGroupChild(childRenderGroup);\n                        break;\n                    }\n                    parent = parent.parent;\n                }\n            }\n            parentRenderGroup.addRenderGroupChild(this.renderGroup);\n        }\n        this._updateIsSimple();\n        this.groupTransform = (0, $dNaJE.Matrix).IDENTITY;\n    }\n    /** @ignore */ _updateIsSimple() {\n        this.isSimple = !this.isRenderGroupRoot && this.effects.length === 0;\n    }\n    /**\n   * Current transform of the object based on world (parent) factors.\n   * @readonly\n   */ get worldTransform() {\n        this._worldTransform || (this._worldTransform = new (0, $dNaJE.Matrix)());\n        if (this.renderGroup) {\n            if (this.isRenderGroupRoot) this._worldTransform.copyFrom(this.renderGroup.worldTransform);\n            else this._worldTransform.appendFrom(this.relativeGroupTransform, this.renderGroup.worldTransform);\n        }\n        return this._worldTransform;\n    }\n    // / ////// transform related stuff\n    /**\n   * The position of the container on the x axis relative to the local coordinates of the parent.\n   * An alias to position.x\n   */ get x() {\n        return this._position.x;\n    }\n    set x(value) {\n        this._position.x = value;\n    }\n    /**\n   * The position of the container on the y axis relative to the local coordinates of the parent.\n   * An alias to position.y\n   */ get y() {\n        return this._position.y;\n    }\n    set y(value) {\n        this._position.y = value;\n    }\n    /**\n   * The coordinate of the object relative to the local coordinates of the parent.\n   * @since 4.0.0\n   */ get position() {\n        return this._position;\n    }\n    set position(value) {\n        this._position.copyFrom(value);\n    }\n    /**\n   * The rotation of the object in radians.\n   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n   */ get rotation() {\n        return this._rotation;\n    }\n    set rotation(value) {\n        if (this._rotation !== value) {\n            this._rotation = value;\n            this._onUpdate(this._skew);\n        }\n    }\n    /**\n   * The angle of the object in degrees.\n   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n   */ get angle() {\n        return this.rotation * (0, $gIu8o.RAD_TO_DEG);\n    }\n    set angle(value) {\n        this.rotation = value * (0, $gIu8o.DEG_TO_RAD);\n    }\n    /**\n   * The center of rotation, scaling, and skewing for this display object in its local space. The `position`\n   * is the projection of `pivot` in the parent's local space.\n   *\n   * By default, the pivot is the origin (0, 0).\n   * @since 4.0.0\n   */ get pivot() {\n        if (this._pivot === $fbe6892413159d67$var$defaultPivot) this._pivot = new (0, $ep73P.ObservablePoint)(this, 0, 0);\n        return this._pivot;\n    }\n    set pivot(value) {\n        if (this._pivot === $fbe6892413159d67$var$defaultPivot) this._pivot = new (0, $ep73P.ObservablePoint)(this, 0, 0);\n        typeof value === \"number\" ? this._pivot.set(value) : this._pivot.copyFrom(value);\n    }\n    /**\n   * The skew factor for the object in radians.\n   * @since 4.0.0\n   */ get skew() {\n        if (this._skew === $fbe6892413159d67$var$defaultSkew) this._skew = new (0, $ep73P.ObservablePoint)(this, 0, 0);\n        return this._skew;\n    }\n    set skew(value) {\n        if (this._skew === $fbe6892413159d67$var$defaultSkew) this._skew = new (0, $ep73P.ObservablePoint)(this, 0, 0);\n        this._skew.copyFrom(value);\n    }\n    /**\n   * The scale factors of this object along the local coordinate axes.\n   *\n   * The default scale is (1, 1).\n   * @since 4.0.0\n   */ get scale() {\n        if (this._scale === $fbe6892413159d67$var$defaultScale) this._scale = new (0, $ep73P.ObservablePoint)(this, 1, 1);\n        return this._scale;\n    }\n    set scale(value) {\n        if (this._scale === $fbe6892413159d67$var$defaultScale) this._scale = new (0, $ep73P.ObservablePoint)(this, 0, 0);\n        typeof value === \"number\" ? this._scale.set(value) : this._scale.copyFrom(value);\n    }\n    /**\n   * The width of the Container, setting this will actually modify the scale to achieve the value set.\n   * @memberof scene.Container#\n   */ get width() {\n        return Math.abs(this.scale.x * this.getLocalBounds().width);\n    }\n    set width(value) {\n        const localWidth = this.getLocalBounds().width;\n        this._setWidth(value, localWidth);\n    }\n    /**\n   * The height of the Container, setting this will actually modify the scale to achieve the value set.\n   * @memberof scene.Container#\n   */ get height() {\n        return Math.abs(this.scale.y * this.getLocalBounds().height);\n    }\n    set height(value) {\n        const localHeight = this.getLocalBounds().height;\n        this._setHeight(value, localHeight);\n    }\n    /**\n   * Retrieves the size of the container as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the container.\n   * @memberof scene.Container#\n   */ getSize(out) {\n        if (!out) out = {};\n        const bounds = this.getLocalBounds();\n        out.width = Math.abs(this.scale.x * bounds.width);\n        out.height = Math.abs(this.scale.y * bounds.height);\n        return out;\n    }\n    /**\n   * Sets the size of the container to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   * @memberof scene.Container#\n   */ setSize(value, height) {\n        const size = this.getLocalBounds();\n        let convertedWidth;\n        let convertedHeight;\n        if (typeof value !== \"object\") {\n            convertedWidth = value;\n            convertedHeight = height ?? value;\n        } else {\n            convertedWidth = value.width;\n            convertedHeight = value.height ?? value.width;\n        }\n        if (convertedWidth !== void 0) this._setWidth(convertedWidth, size.width);\n        if (convertedHeight !== void 0) this._setHeight(convertedHeight, size.height);\n    }\n    /** Called when the skew or the rotation changes. */ _updateSkew() {\n        const rotation = this._rotation;\n        const skew = this._skew;\n        this._cx = Math.cos(rotation + skew._y);\n        this._sx = Math.sin(rotation + skew._y);\n        this._cy = -Math.sin(rotation - skew._x);\n        this._sy = Math.cos(rotation - skew._x);\n    }\n    /**\n   * Updates the transform properties of the container (accepts partial values).\n   * @param {object} opts - The options for updating the transform.\n   * @param {number} opts.x - The x position of the container.\n   * @param {number} opts.y - The y position of the container.\n   * @param {number} opts.scaleX - The scale factor on the x-axis.\n   * @param {number} opts.scaleY - The scale factor on the y-axis.\n   * @param {number} opts.rotation - The rotation of the container, in radians.\n   * @param {number} opts.skewX - The skew factor on the x-axis.\n   * @param {number} opts.skewY - The skew factor on the y-axis.\n   * @param {number} opts.pivotX - The x coordinate of the pivot point.\n   * @param {number} opts.pivotY - The y coordinate of the pivot point.\n   */ updateTransform(opts) {\n        this.position.set(typeof opts.x === \"number\" ? opts.x : this.position.x, typeof opts.y === \"number\" ? opts.y : this.position.y);\n        this.scale.set(typeof opts.scaleX === \"number\" ? opts.scaleX || 1 : this.scale.x, typeof opts.scaleY === \"number\" ? opts.scaleY || 1 : this.scale.y);\n        this.rotation = typeof opts.rotation === \"number\" ? opts.rotation : this.rotation;\n        this.skew.set(typeof opts.skewX === \"number\" ? opts.skewX : this.skew.x, typeof opts.skewY === \"number\" ? opts.skewY : this.skew.y);\n        this.pivot.set(typeof opts.pivotX === \"number\" ? opts.pivotX : this.pivot.x, typeof opts.pivotY === \"number\" ? opts.pivotY : this.pivot.y);\n        return this;\n    }\n    /**\n   * Updates the local transform using the given matrix.\n   * @param matrix - The matrix to use for updating the transform.\n   */ setFromMatrix(matrix) {\n        matrix.decompose(this);\n    }\n    /** Updates the local transform. */ updateLocalTransform() {\n        if ((this._didLocalTransformChangeId & 15) === this._didChangeId) return;\n        this._didLocalTransformChangeId = this._didChangeId;\n        const lt = this.localTransform;\n        const scale = this._scale;\n        const pivot = this._pivot;\n        const position = this._position;\n        const sx = scale._x;\n        const sy = scale._y;\n        const px = pivot._x;\n        const py = pivot._y;\n        lt.a = this._cx * sx;\n        lt.b = this._sx * sx;\n        lt.c = this._cy * sy;\n        lt.d = this._sy * sy;\n        lt.tx = position._x - (px * lt.a + py * lt.c);\n        lt.ty = position._y - (px * lt.b + py * lt.d);\n    }\n    // / ///// color related stuff\n    set alpha(value) {\n        if (value === this.localAlpha) return;\n        this.localAlpha = value;\n        this._updateFlags |= $fbe6892413159d67$export$f8ede8d8bf091ab5;\n        this._onUpdate();\n    }\n    /** The opacity of the object. */ get alpha() {\n        return this.localAlpha;\n    }\n    set tint(value) {\n        const tempColor = (0, $AHTcQ.Color).shared.setValue(value ?? 16777215);\n        const bgr = tempColor.toBgrNumber();\n        if (bgr === this.localColor) return;\n        this.localColor = bgr;\n        this._updateFlags |= $fbe6892413159d67$export$f8ede8d8bf091ab5;\n        this._onUpdate();\n    }\n    /**\n   * The tint applied to the sprite. This is a hex value.\n   *\n   * A value of 0xFFFFFF will remove any tint effect.\n   * @default 0xFFFFFF\n   */ get tint() {\n        const bgr = this.localColor;\n        return ((bgr & 255) << 16) + (bgr & 65280) + (bgr >> 16 & 255);\n    }\n    // / //////////////// blend related stuff\n    set blendMode(value) {\n        if (this.localBlendMode === value) return;\n        if (this.renderGroup && !this.isRenderGroupRoot) this.renderGroup.structureDidChange = true;\n        this._updateFlags |= $fbe6892413159d67$export$e4801e7edc7582f;\n        this.localBlendMode = value;\n        this._onUpdate();\n    }\n    /**\n   * The blend mode to be applied to the sprite. Apply a value of `'normal'` to reset the blend mode.\n   * @default 'normal'\n   */ get blendMode() {\n        return this.localBlendMode;\n    }\n    // / ///////// VISIBILITY / RENDERABLE /////////////////\n    /** The visibility of the object. If false the object will not be drawn, and the transform will not be updated. */ get visible() {\n        return !!(this.localDisplayStatus & 2);\n    }\n    set visible(value) {\n        const valueNumber = value ? 1 : 0;\n        if ((this.localDisplayStatus & 2) >> 1 === valueNumber) return;\n        if (this.renderGroup && !this.isRenderGroupRoot) this.renderGroup.structureDidChange = true;\n        this._updateFlags |= $fbe6892413159d67$export$83db162b74637ea;\n        this.localDisplayStatus ^= 2;\n        this._onUpdate();\n    }\n    /** @ignore */ get culled() {\n        return !(this.localDisplayStatus & 4);\n    }\n    /** @ignore */ set culled(value) {\n        const valueNumber = value ? 1 : 0;\n        if ((this.localDisplayStatus & 4) >> 2 === valueNumber) return;\n        if (this.renderGroup && !this.isRenderGroupRoot) this.renderGroup.structureDidChange = true;\n        this._updateFlags |= $fbe6892413159d67$export$83db162b74637ea;\n        this.localDisplayStatus ^= 4;\n        this._onUpdate();\n    }\n    /** Can this object be rendered, if false the object will not be drawn but the transform will still be updated. */ get renderable() {\n        return !!(this.localDisplayStatus & 1);\n    }\n    set renderable(value) {\n        const valueNumber = value ? 1 : 0;\n        if ((this.localDisplayStatus & 1) === valueNumber) return;\n        this._updateFlags |= $fbe6892413159d67$export$83db162b74637ea;\n        this.localDisplayStatus ^= 1;\n        if (this.renderGroup && !this.isRenderGroupRoot) this.renderGroup.structureDidChange = true;\n        this._onUpdate();\n    }\n    /** Whether or not the object should be rendered. */ get isRenderable() {\n        return this.localDisplayStatus === 7 && this.groupAlpha > 0;\n    }\n    /**\n   * Removes all internal references and listeners as well as removes children from the display list.\n   * Do not use a Container after calling `destroy`.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n   *  method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children\n   * is set to true it should destroy the texture of the child sprite\n   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n   * If options.children is set to true it should destroy the texture source of the child sprite\n   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n   * If options.children is set to true it should destroy the context of the child graphics\n   */ destroy(options = false) {\n        if (this.destroyed) return;\n        this.destroyed = true;\n        this.removeFromParent();\n        this.parent = null;\n        this._mask = null;\n        this._filters = null;\n        this.effects = null;\n        this._position = null;\n        this._scale = null;\n        this._pivot = null;\n        this._skew = null;\n        this.emit(\"destroyed\", this);\n        this.removeAllListeners();\n        const destroyChildren = typeof options === \"boolean\" ? options : options?.children;\n        const oldChildren = this.removeChildren(0, this.children.length);\n        if (destroyChildren) for(let i = 0; i < oldChildren.length; ++i)oldChildren[i].destroy(options);\n    }\n}\n$fbe6892413159d67$export$42a852a2b6b56249.mixin((0, $1AFlc.childrenHelperMixin));\n$fbe6892413159d67$export$42a852a2b6b56249.mixin((0, $5gOfB.toLocalGlobalMixin));\n$fbe6892413159d67$export$42a852a2b6b56249.mixin((0, $bMTFJ.onRenderMixin));\n$fbe6892413159d67$export$42a852a2b6b56249.mixin((0, $eHtGW.measureMixin));\n$fbe6892413159d67$export$42a852a2b6b56249.mixin((0, $4u67k.effectsMixin));\n$fbe6892413159d67$export$42a852a2b6b56249.mixin((0, $6UPd0.findMixin));\n$fbe6892413159d67$export$42a852a2b6b56249.mixin((0, $8Eetq.sortMixin));\n$fbe6892413159d67$export$42a852a2b6b56249.mixin((0, $jorMT.cullingMixin));\n\n});\nparcelRegister(\"gpXaq\", function(module, exports) {\n\"use strict\";\nvar $bf3ce0801cd2364b$var$has = Object.prototype.hasOwnProperty, $bf3ce0801cd2364b$var$prefix = \"~\";\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */ function $bf3ce0801cd2364b$var$Events() {}\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n    $bf3ce0801cd2364b$var$Events.prototype = Object.create(null);\n    //\n    // This hack is needed because the `__proto__` property is still inherited in\n    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n    //\n    if (!new $bf3ce0801cd2364b$var$Events().__proto__) $bf3ce0801cd2364b$var$prefix = false;\n}\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */ function $bf3ce0801cd2364b$var$EE(fn, context, once) {\n    this.fn = fn;\n    this.context = context;\n    this.once = once || false;\n}\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */ function $bf3ce0801cd2364b$var$addListener(emitter, event, fn, context, once) {\n    if (typeof fn !== \"function\") throw new TypeError(\"The listener must be a function\");\n    var listener = new $bf3ce0801cd2364b$var$EE(fn, context || emitter, once), evt = $bf3ce0801cd2364b$var$prefix ? $bf3ce0801cd2364b$var$prefix + event : event;\n    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n    else emitter._events[evt] = [\n        emitter._events[evt],\n        listener\n    ];\n    return emitter;\n}\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */ function $bf3ce0801cd2364b$var$clearEvent(emitter, evt) {\n    if (--emitter._eventsCount === 0) emitter._events = new $bf3ce0801cd2364b$var$Events();\n    else delete emitter._events[evt];\n}\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */ function $bf3ce0801cd2364b$var$EventEmitter() {\n    this._events = new $bf3ce0801cd2364b$var$Events();\n    this._eventsCount = 0;\n}\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */ $bf3ce0801cd2364b$var$EventEmitter.prototype.eventNames = function eventNames() {\n    var names = [], events, name;\n    if (this._eventsCount === 0) return names;\n    for(name in events = this._events)if ($bf3ce0801cd2364b$var$has.call(events, name)) names.push($bf3ce0801cd2364b$var$prefix ? name.slice(1) : name);\n    if (Object.getOwnPropertySymbols) return names.concat(Object.getOwnPropertySymbols(events));\n    return names;\n};\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */ $bf3ce0801cd2364b$var$EventEmitter.prototype.listeners = function listeners(event) {\n    var evt = $bf3ce0801cd2364b$var$prefix ? $bf3ce0801cd2364b$var$prefix + event : event, handlers = this._events[evt];\n    if (!handlers) return [];\n    if (handlers.fn) return [\n        handlers.fn\n    ];\n    for(var i = 0, l = handlers.length, ee = new Array(l); i < l; i++)ee[i] = handlers[i].fn;\n    return ee;\n};\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */ $bf3ce0801cd2364b$var$EventEmitter.prototype.listenerCount = function listenerCount(event) {\n    var evt = $bf3ce0801cd2364b$var$prefix ? $bf3ce0801cd2364b$var$prefix + event : event, listeners = this._events[evt];\n    if (!listeners) return 0;\n    if (listeners.fn) return 1;\n    return listeners.length;\n};\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */ $bf3ce0801cd2364b$var$EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n    var evt = $bf3ce0801cd2364b$var$prefix ? $bf3ce0801cd2364b$var$prefix + event : event;\n    if (!this._events[evt]) return false;\n    var listeners = this._events[evt], len = arguments.length, args, i;\n    if (listeners.fn) {\n        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n        switch(len){\n            case 1:\n                return listeners.fn.call(listeners.context), true;\n            case 2:\n                return listeners.fn.call(listeners.context, a1), true;\n            case 3:\n                return listeners.fn.call(listeners.context, a1, a2), true;\n            case 4:\n                return listeners.fn.call(listeners.context, a1, a2, a3), true;\n            case 5:\n                return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n            case 6:\n                return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n        }\n        for(i = 1, args = new Array(len - 1); i < len; i++)args[i - 1] = arguments[i];\n        listeners.fn.apply(listeners.context, args);\n    } else {\n        var length = listeners.length, j;\n        for(i = 0; i < length; i++){\n            if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n            switch(len){\n                case 1:\n                    listeners[i].fn.call(listeners[i].context);\n                    break;\n                case 2:\n                    listeners[i].fn.call(listeners[i].context, a1);\n                    break;\n                case 3:\n                    listeners[i].fn.call(listeners[i].context, a1, a2);\n                    break;\n                case 4:\n                    listeners[i].fn.call(listeners[i].context, a1, a2, a3);\n                    break;\n                default:\n                    if (!args) for(j = 1, args = new Array(len - 1); j < len; j++)args[j - 1] = arguments[j];\n                    listeners[i].fn.apply(listeners[i].context, args);\n            }\n        }\n    }\n    return true;\n};\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */ $bf3ce0801cd2364b$var$EventEmitter.prototype.on = function on(event, fn, context) {\n    return $bf3ce0801cd2364b$var$addListener(this, event, fn, context, false);\n};\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */ $bf3ce0801cd2364b$var$EventEmitter.prototype.once = function once(event, fn, context) {\n    return $bf3ce0801cd2364b$var$addListener(this, event, fn, context, true);\n};\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */ $bf3ce0801cd2364b$var$EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n    var evt = $bf3ce0801cd2364b$var$prefix ? $bf3ce0801cd2364b$var$prefix + event : event;\n    if (!this._events[evt]) return this;\n    if (!fn) {\n        $bf3ce0801cd2364b$var$clearEvent(this, evt);\n        return this;\n    }\n    var listeners = this._events[evt];\n    if (listeners.fn) {\n        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) $bf3ce0801cd2364b$var$clearEvent(this, evt);\n    } else {\n        for(var i = 0, events = [], length = listeners.length; i < length; i++)if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) events.push(listeners[i]);\n        //\n        // Reset the array, or remove it completely if we have no more listeners.\n        //\n        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n        else $bf3ce0801cd2364b$var$clearEvent(this, evt);\n    }\n    return this;\n};\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */ $bf3ce0801cd2364b$var$EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n    var evt;\n    if (event) {\n        evt = $bf3ce0801cd2364b$var$prefix ? $bf3ce0801cd2364b$var$prefix + event : event;\n        if (this._events[evt]) $bf3ce0801cd2364b$var$clearEvent(this, evt);\n    } else {\n        this._events = new $bf3ce0801cd2364b$var$Events();\n        this._eventsCount = 0;\n    }\n    return this;\n};\n//\n// Alias methods names because people roll like that.\n//\n$bf3ce0801cd2364b$var$EventEmitter.prototype.off = $bf3ce0801cd2364b$var$EventEmitter.prototype.removeListener;\n$bf3ce0801cd2364b$var$EventEmitter.prototype.addListener = $bf3ce0801cd2364b$var$EventEmitter.prototype.on;\n//\n// Expose the prefix.\n//\n$bf3ce0801cd2364b$var$EventEmitter.prefixed = $bf3ce0801cd2364b$var$prefix;\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\n$bf3ce0801cd2364b$var$EventEmitter.EventEmitter = $bf3ce0801cd2364b$var$EventEmitter;\nmodule.exports = $bf3ce0801cd2364b$var$EventEmitter;\n\n});\n\nparcelRegister(\"AHTcQ\", function(module, exports) {\n\n$parcel$export(module.exports, \"Color\", () => $fe924fd83efb3dcd$export$892596cec99bc70e);\n\nvar $jyvmC = parcelRequire(\"jyvmC\");\n\nvar $flk9m = parcelRequire(\"flk9m\");\n\"use strict\";\n(0, $jyvmC.extend)([\n    (0, $flk9m.default)\n]);\nconst $fe924fd83efb3dcd$var$_Color = class _Color {\n    /**\n   * @param {ColorSource} value - Optional value to use, if not provided, white is used.\n   */ constructor(value = 16777215){\n        this._value = null;\n        this._components = new Float32Array(4);\n        this._components.fill(1);\n        this._int = 16777215;\n        this.value = value;\n    }\n    /** Get red component (0 - 1) */ get red() {\n        return this._components[0];\n    }\n    /** Get green component (0 - 1) */ get green() {\n        return this._components[1];\n    }\n    /** Get blue component (0 - 1) */ get blue() {\n        return this._components[2];\n    }\n    /** Get alpha component (0 - 1) */ get alpha() {\n        return this._components[3];\n    }\n    /**\n   * Set the value, suitable for chaining\n   * @param value\n   * @see Color.value\n   */ setValue(value) {\n        this.value = value;\n        return this;\n    }\n    /**\n   * The current color source.\n   *\n   * When setting:\n   * - Setting to an instance of `Color` will copy its color source and components.\n   * - Otherwise, `Color` will try to normalize the color source and set the components.\n   *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.\n   *\n   * Note: The `null` in the setter's parameter type is added to match the TypeScript rule: return type of getter\n   * must be assignable to its setter's parameter type. Setting `value` to `null` will throw an `Error`.\n   *\n   * When getting:\n   * - A return value of `null` means the previous value was overridden (e.g., {@link Color.multiply multiply},\n   *   {@link Color.premultiply premultiply} or {@link Color.round round}).\n   * - Otherwise, the color source used when setting is returned.\n   */ set value(value) {\n        if (value instanceof _Color) {\n            this._value = this._cloneSource(value._value);\n            this._int = value._int;\n            this._components.set(value._components);\n        } else if (value === null) throw new Error(\"Cannot set Color#value to null\");\n        else if (this._value === null || !this._isSourceEqual(this._value, value)) {\n            this._normalize(value);\n            this._value = this._cloneSource(value);\n        }\n    }\n    get value() {\n        return this._value;\n    }\n    /**\n   * Copy a color source internally.\n   * @param value - Color source\n   */ _cloneSource(value) {\n        if (typeof value === \"string\" || typeof value === \"number\" || value instanceof Number || value === null) return value;\n        else if (Array.isArray(value) || ArrayBuffer.isView(value)) return value.slice(0);\n        else if (typeof value === \"object\" && value !== null) return {\n            ...value\n        };\n        return value;\n    }\n    /**\n   * Equality check for color sources.\n   * @param value1 - First color source\n   * @param value2 - Second color source\n   * @returns `true` if the color sources are equal, `false` otherwise.\n   */ _isSourceEqual(value1, value2) {\n        const type1 = typeof value1;\n        const type2 = typeof value2;\n        if (type1 !== type2) return false;\n        else if (type1 === \"number\" || type1 === \"string\" || value1 instanceof Number) return value1 === value2;\n        else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {\n            if (value1.length !== value2.length) return false;\n            return value1.every((v, i)=>v === value2[i]);\n        } else if (value1 !== null && value2 !== null) {\n            const keys1 = Object.keys(value1);\n            const keys2 = Object.keys(value2);\n            if (keys1.length !== keys2.length) return false;\n            return keys1.every((key)=>value1[key] === value2[key]);\n        }\n        return value1 === value2;\n    }\n    /**\n   * Convert to a RGBA color object.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }\n   */ toRgba() {\n        const [r, g, b, a] = this._components;\n        return {\n            r: r,\n            g: g,\n            b: b,\n            a: a\n        };\n    }\n    /**\n   * Convert to a RGB color object.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1 }\n   */ toRgb() {\n        const [r, g, b] = this._components;\n        return {\n            r: r,\n            g: g,\n            b: b\n        };\n    }\n    /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */ toRgbaString() {\n        const [r, g, b] = this.toUint8RgbArray();\n        return `rgba(${r},${g},${b},${this.alpha})`;\n    }\n    toUint8RgbArray(out) {\n        const [r, g, b] = this._components;\n        if (!this._arrayRgb) this._arrayRgb = [];\n        out = out || this._arrayRgb;\n        out[0] = Math.round(r * 255);\n        out[1] = Math.round(g * 255);\n        out[2] = Math.round(b * 255);\n        return out;\n    }\n    toArray(out) {\n        if (!this._arrayRgba) this._arrayRgba = [];\n        out = out || this._arrayRgba;\n        const [r, g, b, a] = this._components;\n        out[0] = r;\n        out[1] = g;\n        out[2] = b;\n        out[3] = a;\n        return out;\n    }\n    toRgbArray(out) {\n        if (!this._arrayRgb) this._arrayRgb = [];\n        out = out || this._arrayRgb;\n        const [r, g, b] = this._components;\n        out[0] = r;\n        out[1] = g;\n        out[2] = b;\n        return out;\n    }\n    /**\n   * Convert to a hexadecimal number.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toNumber(); // returns 16777215\n   */ toNumber() {\n        return this._int;\n    }\n    /**\n   * Convert to a BGR number\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff\n   */ toBgrNumber() {\n        const [r, g, b] = this.toUint8RgbArray();\n        return (b << 16) + (g << 8) + r;\n    }\n    /**\n   * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff\n   * @returns {number} - The color as a number in little endian format.\n   */ toLittleEndianNumber() {\n        const value = this._int;\n        return (value >> 16) + (value & 65280) + ((value & 255) << 16);\n    }\n    /**\n   * Multiply with another color. This action is destructive, and will\n   * override the previous `value` property to be `null`.\n   * @param {ColorSource} value - The color to multiply by.\n   */ multiply(value) {\n        const [r, g, b, a] = _Color._temp.setValue(value)._components;\n        this._components[0] *= r;\n        this._components[1] *= g;\n        this._components[2] *= b;\n        this._components[3] *= a;\n        this._refreshInt();\n        this._value = null;\n        return this;\n    }\n    /**\n   * Converts color to a premultiplied alpha format. This action is destructive, and will\n   * override the previous `value` property to be `null`.\n   * @param alpha - The alpha to multiply by.\n   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n   * @returns {Color} - Itself.\n   */ premultiply(alpha, applyToRGB = true) {\n        if (applyToRGB) {\n            this._components[0] *= alpha;\n            this._components[1] *= alpha;\n            this._components[2] *= alpha;\n        }\n        this._components[3] = alpha;\n        this._refreshInt();\n        this._value = null;\n        return this;\n    }\n    /**\n   * Premultiplies alpha with current color.\n   * @param {number} alpha - The alpha to multiply by.\n   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n   * @returns {number} tint multiplied by alpha\n   */ toPremultiplied(alpha, applyToRGB = true) {\n        if (alpha === 1) return -16777216 + this._int;\n        if (alpha === 0) return applyToRGB ? 0 : this._int;\n        let r = this._int >> 16 & 255;\n        let g = this._int >> 8 & 255;\n        let b = this._int & 255;\n        if (applyToRGB) {\n            r = r * alpha + 0.5 | 0;\n            g = g * alpha + 0.5 | 0;\n            b = b * alpha + 0.5 | 0;\n        }\n        return (alpha * 255 << 24) + (r << 16) + (g << 8) + b;\n    }\n    /**\n   * Convert to a hexidecimal string.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toHex(); // returns \"#ffffff\"\n   */ toHex() {\n        const hexString = this._int.toString(16);\n        return `#${\"000000\".substring(0, 6 - hexString.length) + hexString}`;\n    }\n    /**\n   * Convert to a hexidecimal string with alpha.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toHexa(); // returns \"#ffffffff\"\n   */ toHexa() {\n        const alphaValue = Math.round(this._components[3] * 255);\n        const alphaString = alphaValue.toString(16);\n        return this.toHex() + \"00\".substring(0, 2 - alphaString.length) + alphaString;\n    }\n    /**\n   * Set alpha, suitable for chaining.\n   * @param alpha\n   */ setAlpha(alpha) {\n        this._components[3] = this._clamp(alpha);\n        return this;\n    }\n    /**\n   * Normalize the input value into rgba\n   * @param value - Input value\n   */ _normalize(value) {\n        let r;\n        let g;\n        let b;\n        let a;\n        if ((typeof value === \"number\" || value instanceof Number) && value >= 0 && value <= 16777215) {\n            const int = value;\n            r = (int >> 16 & 255) / 255;\n            g = (int >> 8 & 255) / 255;\n            b = (int & 255) / 255;\n            a = 1;\n        } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {\n            value = this._clamp(value);\n            [r, g, b, a = 1] = value;\n        } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {\n            value = this._clamp(value, 0, 255);\n            [r, g, b, a = 255] = value;\n            r /= 255;\n            g /= 255;\n            b /= 255;\n            a /= 255;\n        } else if (typeof value === \"string\" || typeof value === \"object\") {\n            if (typeof value === \"string\") {\n                const match = _Color.HEX_PATTERN.exec(value);\n                if (match) value = `#${match[2]}`;\n            }\n            const color = (0, $jyvmC.colord)(value);\n            if (color.isValid()) {\n                ({ r: r, g: g, b: b, a: a } = color.rgba);\n                r /= 255;\n                g /= 255;\n                b /= 255;\n            }\n        }\n        if (r !== void 0) {\n            this._components[0] = r;\n            this._components[1] = g;\n            this._components[2] = b;\n            this._components[3] = a;\n            this._refreshInt();\n        } else throw new Error(`Unable to convert color ${value}`);\n    }\n    /** Refresh the internal color rgb number */ _refreshInt() {\n        this._clamp(this._components);\n        const [r, g, b] = this._components;\n        this._int = (r * 255 << 16) + (g * 255 << 8) + (b * 255 | 0);\n    }\n    /**\n   * Clamps values to a range. Will override original values\n   * @param value - Value(s) to clamp\n   * @param min - Minimum value\n   * @param max - Maximum value\n   */ _clamp(value, min = 0, max = 1) {\n        if (typeof value === \"number\") return Math.min(Math.max(value, min), max);\n        value.forEach((v, i)=>{\n            value[i] = Math.min(Math.max(v, min), max);\n        });\n        return value;\n    }\n    /**\n   * Check if the value is a color-like object\n   * @param value - Value to check\n   * @returns True if the value is a color-like object\n   * @static\n   * @example\n   * import { Color } from 'pixi.js';\n   * Color.isColorLike('white'); // returns true\n   * Color.isColorLike(0xffffff); // returns true\n   * Color.isColorLike([1, 1, 1]); // returns true\n   */ static isColorLike(value) {\n        return typeof value === \"number\" || typeof value === \"string\" || value instanceof Number || value instanceof _Color || Array.isArray(value) || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Float32Array || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 && value.a !== void 0;\n    }\n};\n/**\n * Default Color object for static uses\n * @example\n * import { Color } from 'pixi.js';\n * Color.shared.setValue(0xffffff).toHex(); // '#ffffff'\n */ $fe924fd83efb3dcd$var$_Color.shared = new $fe924fd83efb3dcd$var$_Color();\n/**\n * Temporary Color object for static uses internally.\n * As to not conflict with Color.shared.\n * @ignore\n */ $fe924fd83efb3dcd$var$_Color._temp = new $fe924fd83efb3dcd$var$_Color();\n/** Pattern for hex strings */ // eslint-disable-next-line @typescript-eslint/naming-convention\n$fe924fd83efb3dcd$var$_Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;\nlet $fe924fd83efb3dcd$export$892596cec99bc70e = $fe924fd83efb3dcd$var$_Color;\n\n});\nparcelRegister(\"jyvmC\", function(module, exports) {\n\n$parcel$export(module.exports, \"colord\", () => $34b99b961acc9a90$export$c8efe09109f9cb9e);\n$parcel$export(module.exports, \"extend\", () => $34b99b961acc9a90$export$8b58be045bf06082);\nvar $34b99b961acc9a90$var$r = {\n    grad: .9,\n    turn: 360,\n    rad: 360 / (2 * Math.PI)\n}, $34b99b961acc9a90$var$t = function(r) {\n    return \"string\" == typeof r ? r.length > 0 : \"number\" == typeof r;\n}, $34b99b961acc9a90$var$n = function(r, t, n) {\n    return void 0 === t && (t = 0), void 0 === n && (n = Math.pow(10, t)), Math.round(n * r) / n + 0;\n}, $34b99b961acc9a90$var$e = function(r, t, n) {\n    return void 0 === t && (t = 0), void 0 === n && (n = 1), r > n ? n : r > t ? r : t;\n}, $34b99b961acc9a90$var$u = function(r) {\n    return (r = isFinite(r) ? r % 360 : 0) > 0 ? r : r + 360;\n}, $34b99b961acc9a90$var$a = function(r) {\n    return {\n        r: $34b99b961acc9a90$var$e(r.r, 0, 255),\n        g: $34b99b961acc9a90$var$e(r.g, 0, 255),\n        b: $34b99b961acc9a90$var$e(r.b, 0, 255),\n        a: $34b99b961acc9a90$var$e(r.a)\n    };\n}, $34b99b961acc9a90$var$o = function(r) {\n    return {\n        r: $34b99b961acc9a90$var$n(r.r),\n        g: $34b99b961acc9a90$var$n(r.g),\n        b: $34b99b961acc9a90$var$n(r.b),\n        a: $34b99b961acc9a90$var$n(r.a, 3)\n    };\n}, $34b99b961acc9a90$var$i = /^#([0-9a-f]{3,8})$/i, $34b99b961acc9a90$var$s = function(r) {\n    var t = r.toString(16);\n    return t.length < 2 ? \"0\" + t : t;\n}, $34b99b961acc9a90$var$h = function(r) {\n    var t = r.r, n = r.g, e = r.b, u = r.a, a = Math.max(t, n, e), o = a - Math.min(t, n, e), i = o ? a === t ? (n - e) / o : a === n ? 2 + (e - t) / o : 4 + (t - n) / o : 0;\n    return {\n        h: 60 * (i < 0 ? i + 6 : i),\n        s: a ? o / a * 100 : 0,\n        v: a / 255 * 100,\n        a: u\n    };\n}, $34b99b961acc9a90$var$b = function(r) {\n    var t = r.h, n = r.s, e = r.v, u = r.a;\n    t = t / 360 * 6, n /= 100, e /= 100;\n    var a = Math.floor(t), o = e * (1 - n), i = e * (1 - (t - a) * n), s = e * (1 - (1 - t + a) * n), h = a % 6;\n    return {\n        r: 255 * [\n            e,\n            i,\n            o,\n            o,\n            s,\n            e\n        ][h],\n        g: 255 * [\n            s,\n            e,\n            e,\n            i,\n            o,\n            o\n        ][h],\n        b: 255 * [\n            o,\n            o,\n            s,\n            e,\n            e,\n            i\n        ][h],\n        a: u\n    };\n}, $34b99b961acc9a90$var$g = function(r) {\n    return {\n        h: $34b99b961acc9a90$var$u(r.h),\n        s: $34b99b961acc9a90$var$e(r.s, 0, 100),\n        l: $34b99b961acc9a90$var$e(r.l, 0, 100),\n        a: $34b99b961acc9a90$var$e(r.a)\n    };\n}, $34b99b961acc9a90$var$d = function(r) {\n    return {\n        h: $34b99b961acc9a90$var$n(r.h),\n        s: $34b99b961acc9a90$var$n(r.s),\n        l: $34b99b961acc9a90$var$n(r.l),\n        a: $34b99b961acc9a90$var$n(r.a, 3)\n    };\n}, $34b99b961acc9a90$var$f = function(r) {\n    var t, n, e;\n    return $34b99b961acc9a90$var$b((n = (t = r).s, {\n        h: t.h,\n        s: (n *= ((e = t.l) < 50 ? e : 100 - e) / 100) > 0 ? 2 * n / (e + n) * 100 : 0,\n        v: e + n,\n        a: t.a\n    }));\n}, $34b99b961acc9a90$var$c = function(r) {\n    var t, n, e, u;\n    return {\n        h: (t = $34b99b961acc9a90$var$h(r)).h,\n        s: (u = (200 - (n = t.s)) * (e = t.v) / 100) > 0 && u < 200 ? n * e / 100 / (u <= 100 ? u : 200 - u) * 100 : 0,\n        l: u / 2,\n        a: t.a\n    };\n}, $34b99b961acc9a90$var$l = /^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i, $34b99b961acc9a90$var$p = /^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s+([+-]?\\d*\\.?\\d+)%\\s+([+-]?\\d*\\.?\\d+)%\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i, $34b99b961acc9a90$var$v = /^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i, $34b99b961acc9a90$var$m = /^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i, $34b99b961acc9a90$var$y = {\n    string: [\n        [\n            function(r) {\n                var t = $34b99b961acc9a90$var$i.exec(r);\n                return t ? (r = t[1]).length <= 4 ? {\n                    r: parseInt(r[0] + r[0], 16),\n                    g: parseInt(r[1] + r[1], 16),\n                    b: parseInt(r[2] + r[2], 16),\n                    a: 4 === r.length ? $34b99b961acc9a90$var$n(parseInt(r[3] + r[3], 16) / 255, 2) : 1\n                } : 6 === r.length || 8 === r.length ? {\n                    r: parseInt(r.substr(0, 2), 16),\n                    g: parseInt(r.substr(2, 2), 16),\n                    b: parseInt(r.substr(4, 2), 16),\n                    a: 8 === r.length ? $34b99b961acc9a90$var$n(parseInt(r.substr(6, 2), 16) / 255, 2) : 1\n                } : null : null;\n            },\n            \"hex\"\n        ],\n        [\n            function(r) {\n                var t = $34b99b961acc9a90$var$v.exec(r) || $34b99b961acc9a90$var$m.exec(r);\n                return t ? t[2] !== t[4] || t[4] !== t[6] ? null : $34b99b961acc9a90$var$a({\n                    r: Number(t[1]) / (t[2] ? 100 / 255 : 1),\n                    g: Number(t[3]) / (t[4] ? 100 / 255 : 1),\n                    b: Number(t[5]) / (t[6] ? 100 / 255 : 1),\n                    a: void 0 === t[7] ? 1 : Number(t[7]) / (t[8] ? 100 : 1)\n                }) : null;\n            },\n            \"rgb\"\n        ],\n        [\n            function(t) {\n                var n = $34b99b961acc9a90$var$l.exec(t) || $34b99b961acc9a90$var$p.exec(t);\n                if (!n) return null;\n                var e, u, a = $34b99b961acc9a90$var$g({\n                    h: (e = n[1], u = n[2], void 0 === u && (u = \"deg\"), Number(e) * ($34b99b961acc9a90$var$r[u] || 1)),\n                    s: Number(n[3]),\n                    l: Number(n[4]),\n                    a: void 0 === n[5] ? 1 : Number(n[5]) / (n[6] ? 100 : 1)\n                });\n                return $34b99b961acc9a90$var$f(a);\n            },\n            \"hsl\"\n        ]\n    ],\n    object: [\n        [\n            function(r) {\n                var n = r.r, e = r.g, u = r.b, o = r.a, i = void 0 === o ? 1 : o;\n                return $34b99b961acc9a90$var$t(n) && $34b99b961acc9a90$var$t(e) && $34b99b961acc9a90$var$t(u) ? $34b99b961acc9a90$var$a({\n                    r: Number(n),\n                    g: Number(e),\n                    b: Number(u),\n                    a: Number(i)\n                }) : null;\n            },\n            \"rgb\"\n        ],\n        [\n            function(r) {\n                var n = r.h, e = r.s, u = r.l, a = r.a, o = void 0 === a ? 1 : a;\n                if (!$34b99b961acc9a90$var$t(n) || !$34b99b961acc9a90$var$t(e) || !$34b99b961acc9a90$var$t(u)) return null;\n                var i = $34b99b961acc9a90$var$g({\n                    h: Number(n),\n                    s: Number(e),\n                    l: Number(u),\n                    a: Number(o)\n                });\n                return $34b99b961acc9a90$var$f(i);\n            },\n            \"hsl\"\n        ],\n        [\n            function(r) {\n                var n = r.h, a = r.s, o = r.v, i = r.a, s = void 0 === i ? 1 : i;\n                if (!$34b99b961acc9a90$var$t(n) || !$34b99b961acc9a90$var$t(a) || !$34b99b961acc9a90$var$t(o)) return null;\n                var h = function(r) {\n                    return {\n                        h: $34b99b961acc9a90$var$u(r.h),\n                        s: $34b99b961acc9a90$var$e(r.s, 0, 100),\n                        v: $34b99b961acc9a90$var$e(r.v, 0, 100),\n                        a: $34b99b961acc9a90$var$e(r.a)\n                    };\n                }({\n                    h: Number(n),\n                    s: Number(a),\n                    v: Number(o),\n                    a: Number(s)\n                });\n                return $34b99b961acc9a90$var$b(h);\n            },\n            \"hsv\"\n        ]\n    ]\n}, $34b99b961acc9a90$var$N = function(r, t) {\n    for(var n = 0; n < t.length; n++){\n        var e = t[n][0](r);\n        if (e) return [\n            e,\n            t[n][1]\n        ];\n    }\n    return [\n        null,\n        void 0\n    ];\n}, $34b99b961acc9a90$var$x = function(r) {\n    return \"string\" == typeof r ? $34b99b961acc9a90$var$N(r.trim(), $34b99b961acc9a90$var$y.string) : \"object\" == typeof r && null !== r ? $34b99b961acc9a90$var$N(r, $34b99b961acc9a90$var$y.object) : [\n        null,\n        void 0\n    ];\n}, $34b99b961acc9a90$export$f61ac8b6f1f46202 = function(r) {\n    return $34b99b961acc9a90$var$x(r)[1];\n}, $34b99b961acc9a90$var$M = function(r, t) {\n    var n = $34b99b961acc9a90$var$c(r);\n    return {\n        h: n.h,\n        s: $34b99b961acc9a90$var$e(n.s + 100 * t, 0, 100),\n        l: n.l,\n        a: n.a\n    };\n}, $34b99b961acc9a90$var$H = function(r) {\n    return (299 * r.r + 587 * r.g + 114 * r.b) / 1e3 / 255;\n}, $34b99b961acc9a90$var$$ = function(r, t) {\n    var n = $34b99b961acc9a90$var$c(r);\n    return {\n        h: n.h,\n        s: n.s,\n        l: $34b99b961acc9a90$var$e(n.l + 100 * t, 0, 100),\n        a: n.a\n    };\n}, $34b99b961acc9a90$export$4d30ed660ff08d0 = function() {\n    function r(r) {\n        this.parsed = $34b99b961acc9a90$var$x(r)[0], this.rgba = this.parsed || {\n            r: 0,\n            g: 0,\n            b: 0,\n            a: 1\n        };\n    }\n    return r.prototype.isValid = function() {\n        return null !== this.parsed;\n    }, r.prototype.brightness = function() {\n        return $34b99b961acc9a90$var$n($34b99b961acc9a90$var$H(this.rgba), 2);\n    }, r.prototype.isDark = function() {\n        return $34b99b961acc9a90$var$H(this.rgba) < .5;\n    }, r.prototype.isLight = function() {\n        return $34b99b961acc9a90$var$H(this.rgba) >= .5;\n    }, r.prototype.toHex = function() {\n        var r, t, e, u, a, i;\n        return r = $34b99b961acc9a90$var$o(this.rgba), t = r.r, e = r.g, u = r.b, i = (a = r.a) < 1 ? $34b99b961acc9a90$var$s($34b99b961acc9a90$var$n(255 * a)) : \"\", \"#\" + $34b99b961acc9a90$var$s(t) + $34b99b961acc9a90$var$s(e) + $34b99b961acc9a90$var$s(u) + i;\n    }, r.prototype.toRgb = function() {\n        return $34b99b961acc9a90$var$o(this.rgba);\n    }, r.prototype.toRgbString = function() {\n        var r, t, n, e, u;\n        return r = $34b99b961acc9a90$var$o(this.rgba), t = r.r, n = r.g, e = r.b, (u = r.a) < 1 ? \"rgba(\" + t + \", \" + n + \", \" + e + \", \" + u + \")\" : \"rgb(\" + t + \", \" + n + \", \" + e + \")\";\n    }, r.prototype.toHsl = function() {\n        return $34b99b961acc9a90$var$d($34b99b961acc9a90$var$c(this.rgba));\n    }, r.prototype.toHslString = function() {\n        var r, t, n, e, u;\n        return r = $34b99b961acc9a90$var$d($34b99b961acc9a90$var$c(this.rgba)), t = r.h, n = r.s, e = r.l, (u = r.a) < 1 ? \"hsla(\" + t + \", \" + n + \"%, \" + e + \"%, \" + u + \")\" : \"hsl(\" + t + \", \" + n + \"%, \" + e + \"%)\";\n    }, r.prototype.toHsv = function() {\n        var r;\n        return r = $34b99b961acc9a90$var$h(this.rgba), {\n            h: $34b99b961acc9a90$var$n(r.h),\n            s: $34b99b961acc9a90$var$n(r.s),\n            v: $34b99b961acc9a90$var$n(r.v),\n            a: $34b99b961acc9a90$var$n(r.a, 3)\n        };\n    }, r.prototype.invert = function() {\n        var r;\n        return $34b99b961acc9a90$export$c8efe09109f9cb9e({\n            r: 255 - (r = this.rgba).r,\n            g: 255 - r.g,\n            b: 255 - r.b,\n            a: r.a\n        });\n    }, r.prototype.saturate = function(r) {\n        return void 0 === r && (r = .1), $34b99b961acc9a90$export$c8efe09109f9cb9e($34b99b961acc9a90$var$M(this.rgba, r));\n    }, r.prototype.desaturate = function(r) {\n        return void 0 === r && (r = .1), $34b99b961acc9a90$export$c8efe09109f9cb9e($34b99b961acc9a90$var$M(this.rgba, -r));\n    }, r.prototype.grayscale = function() {\n        return $34b99b961acc9a90$export$c8efe09109f9cb9e($34b99b961acc9a90$var$M(this.rgba, -1));\n    }, r.prototype.lighten = function(r) {\n        return void 0 === r && (r = .1), $34b99b961acc9a90$export$c8efe09109f9cb9e($34b99b961acc9a90$var$$(this.rgba, r));\n    }, r.prototype.darken = function(r) {\n        return void 0 === r && (r = .1), $34b99b961acc9a90$export$c8efe09109f9cb9e($34b99b961acc9a90$var$$(this.rgba, -r));\n    }, r.prototype.rotate = function(r) {\n        return void 0 === r && (r = 15), this.hue(this.hue() + r);\n    }, r.prototype.alpha = function(r) {\n        var t;\n        return \"number\" == typeof r ? $34b99b961acc9a90$export$c8efe09109f9cb9e({\n            r: (t = this.rgba).r,\n            g: t.g,\n            b: t.b,\n            a: r\n        }) : $34b99b961acc9a90$var$n(this.rgba.a, 3);\n    }, r.prototype.hue = function(r) {\n        var t = $34b99b961acc9a90$var$c(this.rgba);\n        return \"number\" == typeof r ? $34b99b961acc9a90$export$c8efe09109f9cb9e({\n            h: r,\n            s: t.s,\n            l: t.l,\n            a: t.a\n        }) : $34b99b961acc9a90$var$n(t.h);\n    }, r.prototype.isEqual = function(r) {\n        return this.toHex() === $34b99b961acc9a90$export$c8efe09109f9cb9e(r).toHex();\n    }, r;\n}(), $34b99b961acc9a90$export$c8efe09109f9cb9e = function(r) {\n    return r instanceof $34b99b961acc9a90$export$4d30ed660ff08d0 ? r : new $34b99b961acc9a90$export$4d30ed660ff08d0(r);\n}, $34b99b961acc9a90$var$S = [], $34b99b961acc9a90$export$8b58be045bf06082 = function(r) {\n    r.forEach(function(r) {\n        $34b99b961acc9a90$var$S.indexOf(r) < 0 && (r($34b99b961acc9a90$export$4d30ed660ff08d0, $34b99b961acc9a90$var$y), $34b99b961acc9a90$var$S.push(r));\n    });\n}, $34b99b961acc9a90$export$4385e60b38654f68 = function() {\n    return new $34b99b961acc9a90$export$4d30ed660ff08d0({\n        r: 255 * Math.random(),\n        g: 255 * Math.random(),\n        b: 255 * Math.random()\n    });\n};\n\n});\n\nparcelRegister(\"flk9m\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $6d738a730be80407$export$2e2bcd8739ae039);\nfunction $6d738a730be80407$export$2e2bcd8739ae039(e, f) {\n    var a = {\n        white: \"#ffffff\",\n        bisque: \"#ffe4c4\",\n        blue: \"#0000ff\",\n        cadetblue: \"#5f9ea0\",\n        chartreuse: \"#7fff00\",\n        chocolate: \"#d2691e\",\n        coral: \"#ff7f50\",\n        antiquewhite: \"#faebd7\",\n        aqua: \"#00ffff\",\n        azure: \"#f0ffff\",\n        whitesmoke: \"#f5f5f5\",\n        papayawhip: \"#ffefd5\",\n        plum: \"#dda0dd\",\n        blanchedalmond: \"#ffebcd\",\n        black: \"#000000\",\n        gold: \"#ffd700\",\n        goldenrod: \"#daa520\",\n        gainsboro: \"#dcdcdc\",\n        cornsilk: \"#fff8dc\",\n        cornflowerblue: \"#6495ed\",\n        burlywood: \"#deb887\",\n        aquamarine: \"#7fffd4\",\n        beige: \"#f5f5dc\",\n        crimson: \"#dc143c\",\n        cyan: \"#00ffff\",\n        darkblue: \"#00008b\",\n        darkcyan: \"#008b8b\",\n        darkgoldenrod: \"#b8860b\",\n        darkkhaki: \"#bdb76b\",\n        darkgray: \"#a9a9a9\",\n        darkgreen: \"#006400\",\n        darkgrey: \"#a9a9a9\",\n        peachpuff: \"#ffdab9\",\n        darkmagenta: \"#8b008b\",\n        darkred: \"#8b0000\",\n        darkorchid: \"#9932cc\",\n        darkorange: \"#ff8c00\",\n        darkslateblue: \"#483d8b\",\n        gray: \"#808080\",\n        darkslategray: \"#2f4f4f\",\n        darkslategrey: \"#2f4f4f\",\n        deeppink: \"#ff1493\",\n        deepskyblue: \"#00bfff\",\n        wheat: \"#f5deb3\",\n        firebrick: \"#b22222\",\n        floralwhite: \"#fffaf0\",\n        ghostwhite: \"#f8f8ff\",\n        darkviolet: \"#9400d3\",\n        magenta: \"#ff00ff\",\n        green: \"#008000\",\n        dodgerblue: \"#1e90ff\",\n        grey: \"#808080\",\n        honeydew: \"#f0fff0\",\n        hotpink: \"#ff69b4\",\n        blueviolet: \"#8a2be2\",\n        forestgreen: \"#228b22\",\n        lawngreen: \"#7cfc00\",\n        indianred: \"#cd5c5c\",\n        indigo: \"#4b0082\",\n        fuchsia: \"#ff00ff\",\n        brown: \"#a52a2a\",\n        maroon: \"#800000\",\n        mediumblue: \"#0000cd\",\n        lightcoral: \"#f08080\",\n        darkturquoise: \"#00ced1\",\n        lightcyan: \"#e0ffff\",\n        ivory: \"#fffff0\",\n        lightyellow: \"#ffffe0\",\n        lightsalmon: \"#ffa07a\",\n        lightseagreen: \"#20b2aa\",\n        linen: \"#faf0e6\",\n        mediumaquamarine: \"#66cdaa\",\n        lemonchiffon: \"#fffacd\",\n        lime: \"#00ff00\",\n        khaki: \"#f0e68c\",\n        mediumseagreen: \"#3cb371\",\n        limegreen: \"#32cd32\",\n        mediumspringgreen: \"#00fa9a\",\n        lightskyblue: \"#87cefa\",\n        lightblue: \"#add8e6\",\n        midnightblue: \"#191970\",\n        lightpink: \"#ffb6c1\",\n        mistyrose: \"#ffe4e1\",\n        moccasin: \"#ffe4b5\",\n        mintcream: \"#f5fffa\",\n        lightslategray: \"#778899\",\n        lightslategrey: \"#778899\",\n        navajowhite: \"#ffdead\",\n        navy: \"#000080\",\n        mediumvioletred: \"#c71585\",\n        powderblue: \"#b0e0e6\",\n        palegoldenrod: \"#eee8aa\",\n        oldlace: \"#fdf5e6\",\n        paleturquoise: \"#afeeee\",\n        mediumturquoise: \"#48d1cc\",\n        mediumorchid: \"#ba55d3\",\n        rebeccapurple: \"#663399\",\n        lightsteelblue: \"#b0c4de\",\n        mediumslateblue: \"#7b68ee\",\n        thistle: \"#d8bfd8\",\n        tan: \"#d2b48c\",\n        orchid: \"#da70d6\",\n        mediumpurple: \"#9370db\",\n        purple: \"#800080\",\n        pink: \"#ffc0cb\",\n        skyblue: \"#87ceeb\",\n        springgreen: \"#00ff7f\",\n        palegreen: \"#98fb98\",\n        red: \"#ff0000\",\n        yellow: \"#ffff00\",\n        slateblue: \"#6a5acd\",\n        lavenderblush: \"#fff0f5\",\n        peru: \"#cd853f\",\n        palevioletred: \"#db7093\",\n        violet: \"#ee82ee\",\n        teal: \"#008080\",\n        slategray: \"#708090\",\n        slategrey: \"#708090\",\n        aliceblue: \"#f0f8ff\",\n        darkseagreen: \"#8fbc8f\",\n        darkolivegreen: \"#556b2f\",\n        greenyellow: \"#adff2f\",\n        seagreen: \"#2e8b57\",\n        seashell: \"#fff5ee\",\n        tomato: \"#ff6347\",\n        silver: \"#c0c0c0\",\n        sienna: \"#a0522d\",\n        lavender: \"#e6e6fa\",\n        lightgreen: \"#90ee90\",\n        orange: \"#ffa500\",\n        orangered: \"#ff4500\",\n        steelblue: \"#4682b4\",\n        royalblue: \"#4169e1\",\n        turquoise: \"#40e0d0\",\n        yellowgreen: \"#9acd32\",\n        salmon: \"#fa8072\",\n        saddlebrown: \"#8b4513\",\n        sandybrown: \"#f4a460\",\n        rosybrown: \"#bc8f8f\",\n        darksalmon: \"#e9967a\",\n        lightgoldenrodyellow: \"#fafad2\",\n        snow: \"#fffafa\",\n        lightgrey: \"#d3d3d3\",\n        lightgray: \"#d3d3d3\",\n        dimgray: \"#696969\",\n        dimgrey: \"#696969\",\n        olivedrab: \"#6b8e23\",\n        olive: \"#808000\"\n    }, r = {};\n    for(var d in a)r[a[d]] = d;\n    var l = {};\n    e.prototype.toName = function(f) {\n        if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return \"transparent\";\n        var d, i, n = r[this.toHex()];\n        if (n) return n;\n        if (null == f ? void 0 : f.closest) {\n            var o = this.toRgb(), t = 1 / 0, b = \"black\";\n            if (!l.length) for(var c in a)l[c] = new e(a[c]).toRgb();\n            for(var g in a){\n                var u = (d = o, i = l[g], Math.pow(d.r - i.r, 2) + Math.pow(d.g - i.g, 2) + Math.pow(d.b - i.b, 2));\n                u < t && (t = u, b = g);\n            }\n            return b;\n        }\n    };\n    f.string.push([\n        function(f) {\n            var r = f.toLowerCase(), d = \"transparent\" === r ? \"#0000\" : a[r];\n            return d ? new e(d).toRgb() : null;\n        },\n        \"name\"\n    ]);\n}\n\n});\n\n\nparcelRegister(\"jorMT\", function(module, exports) {\n\n$parcel$export(module.exports, \"cullingMixin\", () => $77279937bd81d006$export$dce76d4f0fd249ed);\n\"use strict\";\nconst $77279937bd81d006$export$dce76d4f0fd249ed = {\n    cullArea: null,\n    cullable: false,\n    cullableChildren: true\n};\n\n});\n\nparcelRegister(\"dNaJE\", function(module, exports) {\n\n$parcel$export(module.exports, \"Matrix\", () => $c9bf2754f493888f$export$5b12bf1653c0dd85);\n\nvar $gIu8o = parcelRequire(\"gIu8o\");\n\nvar $2NXni = parcelRequire(\"2NXni\");\n\"use strict\";\nclass $c9bf2754f493888f$export$5b12bf1653c0dd85 {\n    /**\n   * @param a - x scale\n   * @param b - y skew\n   * @param c - x skew\n   * @param d - y scale\n   * @param tx - x translation\n   * @param ty - y translation\n   */ constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0){\n        /** An array of the current matrix. Only populated when `toArray` is called */ this.array = null;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n    }\n    /**\n   * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:\n   *\n   * a = array[0]\n   * b = array[1]\n   * c = array[3]\n   * d = array[4]\n   * tx = array[2]\n   * ty = array[5]\n   * @param array - The array that the matrix will be populated from.\n   */ fromArray(array) {\n        this.a = array[0];\n        this.b = array[1];\n        this.c = array[3];\n        this.d = array[4];\n        this.tx = array[2];\n        this.ty = array[5];\n    }\n    /**\n   * Sets the matrix properties.\n   * @param a - Matrix component\n   * @param b - Matrix component\n   * @param c - Matrix component\n   * @param d - Matrix component\n   * @param tx - Matrix component\n   * @param ty - Matrix component\n   * @returns This matrix. Good for chaining method calls.\n   */ set(a, b, c, d, tx, ty) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n        return this;\n    }\n    /**\n   * Creates an array from the current Matrix object.\n   * @param transpose - Whether we need to transpose the matrix or not\n   * @param [out=new Float32Array(9)] - If provided the array will be assigned to out\n   * @returns The newly created array which contains the matrix\n   */ toArray(transpose, out) {\n        if (!this.array) this.array = new Float32Array(9);\n        const array = out || this.array;\n        if (transpose) {\n            array[0] = this.a;\n            array[1] = this.b;\n            array[2] = 0;\n            array[3] = this.c;\n            array[4] = this.d;\n            array[5] = 0;\n            array[6] = this.tx;\n            array[7] = this.ty;\n            array[8] = 1;\n        } else {\n            array[0] = this.a;\n            array[1] = this.c;\n            array[2] = this.tx;\n            array[3] = this.b;\n            array[4] = this.d;\n            array[5] = this.ty;\n            array[6] = 0;\n            array[7] = 0;\n            array[8] = 1;\n        }\n        return array;\n    }\n    /**\n   * Get a new position with the current transformation applied.\n   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\n   * @param pos - The origin\n   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n   * @returns {Point} The new point, transformed through this matrix\n   */ apply(pos, newPos) {\n        newPos = newPos || new (0, $2NXni.Point)();\n        const x = pos.x;\n        const y = pos.y;\n        newPos.x = this.a * x + this.c * y + this.tx;\n        newPos.y = this.b * x + this.d * y + this.ty;\n        return newPos;\n    }\n    /**\n   * Get a new position with the inverse of the current transformation applied.\n   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\n   * @param pos - The origin\n   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n   * @returns {Point} The new point, inverse-transformed through this matrix\n   */ applyInverse(pos, newPos) {\n        newPos = newPos || new (0, $2NXni.Point)();\n        const a = this.a;\n        const b = this.b;\n        const c = this.c;\n        const d = this.d;\n        const tx = this.tx;\n        const ty = this.ty;\n        const id = 1 / (a * d + c * -b);\n        const x = pos.x;\n        const y = pos.y;\n        newPos.x = d * id * x + -c * id * y + (ty * c - tx * d) * id;\n        newPos.y = a * id * y + -b * id * x + (-ty * a + tx * b) * id;\n        return newPos;\n    }\n    /**\n   * Translates the matrix on the x and y.\n   * @param x - How much to translate x by\n   * @param y - How much to translate y by\n   * @returns This matrix. Good for chaining method calls.\n   */ translate(x, y) {\n        this.tx += x;\n        this.ty += y;\n        return this;\n    }\n    /**\n   * Applies a scale transformation to the matrix.\n   * @param x - The amount to scale horizontally\n   * @param y - The amount to scale vertically\n   * @returns This matrix. Good for chaining method calls.\n   */ scale(x, y) {\n        this.a *= x;\n        this.d *= y;\n        this.c *= x;\n        this.b *= y;\n        this.tx *= x;\n        this.ty *= y;\n        return this;\n    }\n    /**\n   * Applies a rotation transformation to the matrix.\n   * @param angle - The angle in radians.\n   * @returns This matrix. Good for chaining method calls.\n   */ rotate(angle) {\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n        const a1 = this.a;\n        const c1 = this.c;\n        const tx1 = this.tx;\n        this.a = a1 * cos - this.b * sin;\n        this.b = a1 * sin + this.b * cos;\n        this.c = c1 * cos - this.d * sin;\n        this.d = c1 * sin + this.d * cos;\n        this.tx = tx1 * cos - this.ty * sin;\n        this.ty = tx1 * sin + this.ty * cos;\n        return this;\n    }\n    /**\n   * Appends the given Matrix to this Matrix.\n   * @param matrix - The matrix to append.\n   * @returns This matrix. Good for chaining method calls.\n   */ append(matrix) {\n        const a1 = this.a;\n        const b1 = this.b;\n        const c1 = this.c;\n        const d1 = this.d;\n        this.a = matrix.a * a1 + matrix.b * c1;\n        this.b = matrix.a * b1 + matrix.b * d1;\n        this.c = matrix.c * a1 + matrix.d * c1;\n        this.d = matrix.c * b1 + matrix.d * d1;\n        this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;\n        this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;\n        return this;\n    }\n    /**\n   * Appends two matrix's and sets the result to this matrix. AB = A * B\n   * @param a - The matrix to append.\n   * @param b - The matrix to append.\n   * @returns This matrix. Good for chaining method calls.\n   */ appendFrom(a, b) {\n        const a1 = a.a;\n        const b1 = a.b;\n        const c1 = a.c;\n        const d1 = a.d;\n        const tx = a.tx;\n        const ty = a.ty;\n        const a2 = b.a;\n        const b2 = b.b;\n        const c2 = b.c;\n        const d2 = b.d;\n        this.a = a1 * a2 + b1 * c2;\n        this.b = a1 * b2 + b1 * d2;\n        this.c = c1 * a2 + d1 * c2;\n        this.d = c1 * b2 + d1 * d2;\n        this.tx = tx * a2 + ty * c2 + b.tx;\n        this.ty = tx * b2 + ty * d2 + b.ty;\n        return this;\n    }\n    /**\n   * Sets the matrix based on all the available properties\n   * @param x - Position on the x axis\n   * @param y - Position on the y axis\n   * @param pivotX - Pivot on the x axis\n   * @param pivotY - Pivot on the y axis\n   * @param scaleX - Scale on the x axis\n   * @param scaleY - Scale on the y axis\n   * @param rotation - Rotation in radians\n   * @param skewX - Skew on the x axis\n   * @param skewY - Skew on the y axis\n   * @returns This matrix. Good for chaining method calls.\n   */ setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {\n        this.a = Math.cos(rotation + skewY) * scaleX;\n        this.b = Math.sin(rotation + skewY) * scaleX;\n        this.c = -Math.sin(rotation - skewX) * scaleY;\n        this.d = Math.cos(rotation - skewX) * scaleY;\n        this.tx = x - (pivotX * this.a + pivotY * this.c);\n        this.ty = y - (pivotX * this.b + pivotY * this.d);\n        return this;\n    }\n    /**\n   * Prepends the given Matrix to this Matrix.\n   * @param matrix - The matrix to prepend\n   * @returns This matrix. Good for chaining method calls.\n   */ prepend(matrix) {\n        const tx1 = this.tx;\n        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {\n            const a1 = this.a;\n            const c1 = this.c;\n            this.a = a1 * matrix.a + this.b * matrix.c;\n            this.b = a1 * matrix.b + this.b * matrix.d;\n            this.c = c1 * matrix.a + this.d * matrix.c;\n            this.d = c1 * matrix.b + this.d * matrix.d;\n        }\n        this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;\n        this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;\n        return this;\n    }\n    /**\n   * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.\n   * @param transform - The transform to apply the properties to.\n   * @returns The transform with the newly applied properties\n   */ decompose(transform) {\n        const a = this.a;\n        const b = this.b;\n        const c = this.c;\n        const d = this.d;\n        const pivot = transform.pivot;\n        const skewX = -Math.atan2(-c, d);\n        const skewY = Math.atan2(b, a);\n        const delta = Math.abs(skewX + skewY);\n        if (delta < 1e-5 || Math.abs((0, $gIu8o.PI_2) - delta) < 1e-5) {\n            transform.rotation = skewY;\n            transform.skew.x = transform.skew.y = 0;\n        } else {\n            transform.rotation = 0;\n            transform.skew.x = skewX;\n            transform.skew.y = skewY;\n        }\n        transform.scale.x = Math.sqrt(a * a + b * b);\n        transform.scale.y = Math.sqrt(c * c + d * d);\n        transform.position.x = this.tx + (pivot.x * a + pivot.y * c);\n        transform.position.y = this.ty + (pivot.x * b + pivot.y * d);\n        return transform;\n    }\n    /**\n   * Inverts this matrix\n   * @returns This matrix. Good for chaining method calls.\n   */ invert() {\n        const a1 = this.a;\n        const b1 = this.b;\n        const c1 = this.c;\n        const d1 = this.d;\n        const tx1 = this.tx;\n        const n = a1 * d1 - b1 * c1;\n        this.a = d1 / n;\n        this.b = -b1 / n;\n        this.c = -c1 / n;\n        this.d = a1 / n;\n        this.tx = (c1 * this.ty - d1 * tx1) / n;\n        this.ty = -(a1 * this.ty - b1 * tx1) / n;\n        return this;\n    }\n    /** Checks if this matrix is an identity matrix */ isIdentity() {\n        return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;\n    }\n    /**\n   * Resets this Matrix to an identity (default) matrix.\n   * @returns This matrix. Good for chaining method calls.\n   */ identity() {\n        this.a = 1;\n        this.b = 0;\n        this.c = 0;\n        this.d = 1;\n        this.tx = 0;\n        this.ty = 0;\n        return this;\n    }\n    /**\n   * Creates a new Matrix object with the same values as this one.\n   * @returns A copy of this matrix. Good for chaining method calls.\n   */ clone() {\n        const matrix = new $c9bf2754f493888f$export$5b12bf1653c0dd85();\n        matrix.a = this.a;\n        matrix.b = this.b;\n        matrix.c = this.c;\n        matrix.d = this.d;\n        matrix.tx = this.tx;\n        matrix.ty = this.ty;\n        return matrix;\n    }\n    /**\n   * Changes the values of the given matrix to be the same as the ones in this matrix\n   * @param matrix - The matrix to copy to.\n   * @returns The matrix given in parameter with its values updated.\n   */ copyTo(matrix) {\n        matrix.a = this.a;\n        matrix.b = this.b;\n        matrix.c = this.c;\n        matrix.d = this.d;\n        matrix.tx = this.tx;\n        matrix.ty = this.ty;\n        return matrix;\n    }\n    /**\n   * Changes the values of the matrix to be the same as the ones in given matrix\n   * @param matrix - The matrix to copy from.\n   * @returns this\n   */ copyFrom(matrix) {\n        this.a = matrix.a;\n        this.b = matrix.b;\n        this.c = matrix.c;\n        this.d = matrix.d;\n        this.tx = matrix.tx;\n        this.ty = matrix.ty;\n        return this;\n    }\n    /**\n   * check to see if two matrices are the same\n   * @param matrix - The matrix to compare to.\n   */ equals(matrix) {\n        return matrix.a === this.a && matrix.b === this.b && matrix.c === this.c && matrix.d === this.d && matrix.tx === this.tx && matrix.ty === this.ty;\n    }\n    toString() {\n        return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;\n    }\n    /**\n   * A default (identity) matrix.\n   *\n   * This is a shared object, if you want to modify it consider creating a new `Matrix`\n   * @readonly\n   */ static get IDENTITY() {\n        return $c9bf2754f493888f$var$identityMatrix.identity();\n    }\n    /**\n   * A static Matrix that can be used to avoid creating new objects.\n   * Will always ensure the matrix is reset to identity when requested.\n   * Use this object for fast but temporary calculations, as it may be mutated later on.\n   * This is a different object to the `IDENTITY` object and so can be modified without changing `IDENTITY`.\n   * @readonly\n   */ static get shared() {\n        return $c9bf2754f493888f$var$tempMatrix.identity();\n    }\n}\nconst $c9bf2754f493888f$var$tempMatrix = new $c9bf2754f493888f$export$5b12bf1653c0dd85();\nconst $c9bf2754f493888f$var$identityMatrix = new $c9bf2754f493888f$export$5b12bf1653c0dd85();\n\n});\nparcelRegister(\"gIu8o\", function(module, exports) {\n\n$parcel$export(module.exports, \"PI_2\", () => $9854bd3320d54841$export$59ed0a0a5de1084b);\n$parcel$export(module.exports, \"RAD_TO_DEG\", () => $9854bd3320d54841$export$3f91627dc85c5d57);\n$parcel$export(module.exports, \"DEG_TO_RAD\", () => $9854bd3320d54841$export$870617f62e3187f1);\n\"use strict\";\nconst $9854bd3320d54841$export$59ed0a0a5de1084b = Math.PI * 2;\nconst $9854bd3320d54841$export$3f91627dc85c5d57 = 180 / Math.PI;\nconst $9854bd3320d54841$export$870617f62e3187f1 = Math.PI / 180;\n\n});\n\nparcelRegister(\"2NXni\", function(module, exports) {\n\n$parcel$export(module.exports, \"Point\", () => $33ead300f2416b90$export$baf26146a414f24a);\n\"use strict\";\nclass $33ead300f2416b90$export$baf26146a414f24a {\n    /**\n   * Creates a new `Point`\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=0] - position of the point on the y axis\n   */ constructor(x = 0, y = 0){\n        /** Position of the point on the x axis */ this.x = 0;\n        /** Position of the point on the y axis */ this.y = 0;\n        this.x = x;\n        this.y = y;\n    }\n    /**\n   * Creates a clone of this point\n   * @returns A clone of this point\n   */ clone() {\n        return new $33ead300f2416b90$export$baf26146a414f24a(this.x, this.y);\n    }\n    /**\n   * Copies `x` and `y` from the given point into this point\n   * @param p - The point to copy from\n   * @returns The point instance itself\n   */ copyFrom(p) {\n        this.set(p.x, p.y);\n        return this;\n    }\n    /**\n   * Copies this point's x and y into the given point (`p`).\n   * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n   * @returns The point (`p`) with values updated\n   */ copyTo(p) {\n        p.set(this.x, this.y);\n        return p;\n    }\n    /**\n   * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n   * @param p - The point to check\n   * @returns Returns `true` if both `x` and `y` are equal\n   */ equals(p) {\n        return p.x === this.x && p.y === this.y;\n    }\n    /**\n   * Sets the point to a new `x` and `y` position.\n   * If `y` is omitted, both `x` and `y` will be set to `x`.\n   * @param {number} [x=0] - position of the point on the `x` axis\n   * @param {number} [y=x] - position of the point on the `y` axis\n   * @returns The point instance itself\n   */ set(x = 0, y = x) {\n        this.x = x;\n        this.y = y;\n        return this;\n    }\n    toString() {\n        return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;\n    }\n    /**\n   * A static Point object with `x` and `y` values of `0`. Can be used to avoid creating new objects multiple times.\n   * @readonly\n   */ static get shared() {\n        $33ead300f2416b90$var$tempPoint.x = 0;\n        $33ead300f2416b90$var$tempPoint.y = 0;\n        return $33ead300f2416b90$var$tempPoint;\n    }\n}\nconst $33ead300f2416b90$var$tempPoint = new $33ead300f2416b90$export$baf26146a414f24a();\n\n});\n\n\nparcelRegister(\"ep73P\", function(module, exports) {\n\n$parcel$export(module.exports, \"ObservablePoint\", () => $1471e7ddf9463356$export$3755aaad3fd42e52);\n\"use strict\";\nclass $1471e7ddf9463356$export$3755aaad3fd42e52 {\n    /**\n   * Creates a new `ObservablePoint`\n   * @param observer - Observer to pass to listen for change events.\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=0] - position of the point on the y axis\n   */ constructor(observer, x, y){\n        this._x = x || 0;\n        this._y = y || 0;\n        this._observer = observer;\n    }\n    /**\n   * Creates a clone of this point.\n   * @param observer - Optional observer to pass to the new observable point.\n   * @returns a copy of this observable point\n   */ clone(observer) {\n        return new $1471e7ddf9463356$export$3755aaad3fd42e52(observer ?? this._observer, this._x, this._y);\n    }\n    /**\n   * Sets the point to a new `x` and `y` position.\n   * If `y` is omitted, both `x` and `y` will be set to `x`.\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=x] - position of the point on the y axis\n   * @returns The observable point instance itself\n   */ set(x = 0, y = x) {\n        if (this._x !== x || this._y !== y) {\n            this._x = x;\n            this._y = y;\n            this._observer._onUpdate(this);\n        }\n        return this;\n    }\n    /**\n   * Copies x and y from the given point (`p`)\n   * @param p - The point to copy from. Can be any of type that is or extends `PointData`\n   * @returns The observable point instance itself\n   */ copyFrom(p) {\n        if (this._x !== p.x || this._y !== p.y) {\n            this._x = p.x;\n            this._y = p.y;\n            this._observer._onUpdate(this);\n        }\n        return this;\n    }\n    /**\n   * Copies this point's x and y into that of the given point (`p`)\n   * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n   * @returns The point (`p`) with values updated\n   */ copyTo(p) {\n        p.set(this._x, this._y);\n        return p;\n    }\n    /**\n   * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n   * @param p - The point to check\n   * @returns Returns `true` if both `x` and `y` are equal\n   */ equals(p) {\n        return p.x === this._x && p.y === this._y;\n    }\n    toString() {\n        return `[pixi.js/math:ObservablePoint x=${0} y=${0} scope=${this._observer}]`;\n    }\n    /** Position of the observable point on the x axis. */ get x() {\n        return this._x;\n    }\n    set x(value) {\n        if (this._x !== value) {\n            this._x = value;\n            this._observer._onUpdate(this);\n        }\n    }\n    /** Position of the observable point on the y axis. */ get y() {\n        return this._y;\n    }\n    set y(value) {\n        if (this._y !== value) {\n            this._y = value;\n            this._observer._onUpdate(this);\n        }\n    }\n}\n\n});\n\nparcelRegister(\"l80qL\", function(module, exports) {\n\n$parcel$export(module.exports, \"uid\", () => $311c7125449cac6e$export$e2a22331486dcca0);\n\"use strict\";\nconst $311c7125449cac6e$var$uidCache = {\n    default: -1\n};\nfunction $311c7125449cac6e$export$e2a22331486dcca0(name = \"default\") {\n    if ($311c7125449cac6e$var$uidCache[name] === void 0) $311c7125449cac6e$var$uidCache[name] = -1;\n    return ++$311c7125449cac6e$var$uidCache[name];\n}\nfunction $311c7125449cac6e$export$220409b686c277d0() {\n    for(const key in $311c7125449cac6e$var$uidCache)delete $311c7125449cac6e$var$uidCache[key];\n}\n\n});\n\nparcelRegister(\"eX50w\", function(module, exports) {\n\n$parcel$export(module.exports, \"v8_0_0\", () => $b14a3262a951e740$export$dc79da96439604f0);\n$parcel$export(module.exports, \"deprecation\", () => $b14a3262a951e740$export$afd31d834b512e89);\n\"use strict\";\nconst $b14a3262a951e740$var$warnings = {};\nconst $b14a3262a951e740$export$dc79da96439604f0 = \"8.0.0\";\nfunction $b14a3262a951e740$export$afd31d834b512e89(version, message, ignoreDepth = 3) {\n    if ($b14a3262a951e740$var$warnings[message]) return;\n    let stack = new Error().stack;\n    if (typeof stack === \"undefined\") console.warn(\"PixiJS Deprecation Warning: \", `${message}\nDeprecated since v${version}`);\n    else {\n        stack = stack.split(\"\\n\").splice(ignoreDepth).join(\"\\n\");\n        if (console.groupCollapsed) {\n            console.groupCollapsed(\"%cPixiJS Deprecation Warning: %c%s\", \"color:#614108;background:#fffbe6\", \"font-weight:normal;color:#614108;background:#fffbe6\", `${message}\nDeprecated since v${version}`);\n            console.warn(stack);\n            console.groupEnd();\n        } else {\n            console.warn(\"PixiJS Deprecation Warning: \", `${message}\nDeprecated since v${version}`);\n            console.warn(stack);\n        }\n    }\n    $b14a3262a951e740$var$warnings[message] = true;\n}\n\n});\n\nparcelRegister(\"1AFlc\", function(module, exports) {\n\n$parcel$export(module.exports, \"childrenHelperMixin\", () => $72886fd1ec148d9f$export$64cca9f0c2df174a);\n\nvar $hpsHk = parcelRequire(\"hpsHk\");\n\nvar $eX50w = parcelRequire(\"eX50w\");\n\"use strict\";\nconst $72886fd1ec148d9f$export$64cca9f0c2df174a = {\n    allowChildren: true,\n    /**\n   * Removes all children from this container that are within the begin and end indexes.\n   * @param beginIndex - The beginning position.\n   * @param endIndex - The ending position. Default value is size of the container.\n   * @returns - List of removed children\n   * @memberof scene.Container#\n   */ removeChildren (beginIndex = 0, endIndex) {\n        const end = endIndex ?? this.children.length;\n        const range = end - beginIndex;\n        const removed = [];\n        if (range > 0 && range <= end) {\n            for(let i = end - 1; i >= beginIndex; i--){\n                const child = this.children[i];\n                if (!child) continue;\n                if (this.renderGroup) this.renderGroup.removeChild(child);\n                removed.push(child);\n                child.parent = null;\n            }\n            (0, $hpsHk.removeItems)(this.children, beginIndex, end);\n            for(let i = 0; i < removed.length; ++i){\n                this.emit(\"childRemoved\", removed[i], this, i);\n                removed[i].emit(\"removed\", this);\n            }\n            return removed;\n        } else if (range === 0 && this.children.length === 0) return removed;\n        throw new RangeError(\"removeChildren: numeric values are outside the acceptable range.\");\n    },\n    /**\n   * Removes a child from the specified index position.\n   * @param index - The index to get the child from\n   * @returns The child that was removed.\n   * @memberof scene.Container#\n   */ removeChildAt (index) {\n        const child = this.getChildAt(index);\n        return this.removeChild(child);\n    },\n    /**\n   * Returns the child at the specified index\n   * @param index - The index to get the child at\n   * @returns - The child at the given index, if any.\n   * @memberof scene.Container#\n   */ getChildAt (index) {\n        if (index < 0 || index >= this.children.length) throw new Error(`getChildAt: Index (${index}) does not exist.`);\n        return this.children[index];\n    },\n    /**\n   * Changes the position of an existing child in the container container\n   * @param child - The child Container instance for which you want to change the index number\n   * @param index - The resulting index number for the child container\n   * @memberof scene.Container#\n   */ setChildIndex (child, index) {\n        if (index < 0 || index >= this.children.length) throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n        this.getChildIndex(child);\n        this.addChildAt(child, index);\n    },\n    /**\n   * Returns the index position of a child Container instance\n   * @param child - The Container instance to identify\n   * @returns - The index position of the child container to identify\n   * @memberof scene.Container#\n   */ getChildIndex (child) {\n        const index = this.children.indexOf(child);\n        if (index === -1) throw new Error(\"The supplied Container must be a child of the caller\");\n        return index;\n    },\n    /**\n   * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.\n   * If the child is already in this container, it will be moved to the specified index.\n   * @param {Container} child - The child to add.\n   * @param {number} index - The absolute index where the child will be positioned at the end of the operation.\n   * @returns {Container} The child that was added.\n   * @memberof scene.Container#\n   */ addChildAt (child, index) {\n        if (!this.allowChildren) (0, $eX50w.deprecation)((0, $eX50w.v8_0_0), \"addChildAt: Only Containers will be allowed to add children in v8.0.0\");\n        const { children: children } = this;\n        if (index < 0 || index > children.length) throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);\n        if (child.parent) {\n            const currentIndex = child.parent.children.indexOf(child);\n            if (child.parent === this && currentIndex === index) return child;\n            if (currentIndex !== -1) child.parent.children.splice(currentIndex, 1);\n        }\n        if (index === children.length) children.push(child);\n        else children.splice(index, 0, child);\n        child.parent = this;\n        child.didChange = true;\n        child.didViewUpdate = false;\n        child._updateFlags = 15;\n        if (this.renderGroup) this.renderGroup.addChild(child);\n        if (this.sortableChildren) this.sortDirty = true;\n        this.emit(\"childAdded\", child, this, index);\n        child.emit(\"added\", this);\n        return child;\n    },\n    /**\n   * Swaps the position of 2 Containers within this container.\n   * @param child - First container to swap\n   * @param child2 - Second container to swap\n   */ swapChildren (child, child2) {\n        if (child === child2) return;\n        const index1 = this.getChildIndex(child);\n        const index2 = this.getChildIndex(child2);\n        this.children[index1] = child2;\n        this.children[index2] = child;\n    },\n    /**\n   * Remove the Container from its parent Container. If the Container has no parent, do nothing.\n   * @memberof scene.Container#\n   */ removeFromParent () {\n        this.parent?.removeChild(this);\n    }\n};\n\n});\nparcelRegister(\"hpsHk\", function(module, exports) {\n\n$parcel$export(module.exports, \"removeItems\", () => $77be0eb29c39195c$export$8d47c0e1ce445404);\n\"use strict\";\nfunction $77be0eb29c39195c$export$8d47c0e1ce445404(arr, startIdx, removeCount) {\n    const length = arr.length;\n    let i;\n    if (startIdx >= length || removeCount === 0) return;\n    removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;\n    const len = length - removeCount;\n    for(i = startIdx; i < len; ++i)arr[i] = arr[i + removeCount];\n    arr.length = len;\n}\n\n});\n\n\nparcelRegister(\"4u67k\", function(module, exports) {\n\n$parcel$export(module.exports, \"effectsMixin\", () => $2eb61ab66b3b5ffb$export$eec5e288a9d02a7c);\n\nvar $fq91v = parcelRequire(\"fq91v\");\n\nvar $fGBJF = parcelRequire(\"fGBJF\");\n\nvar $e98Fy = parcelRequire(\"e98Fy\");\n\"use strict\";\nconst $2eb61ab66b3b5ffb$export$eec5e288a9d02a7c = {\n    _mask: null,\n    _filters: null,\n    /**\n   * @todo Needs docs.\n   * @memberof scene.Container#\n   * @type {Array<Effect>}\n   */ effects: [],\n    /**\n   * @todo Needs docs.\n   * @param effect - The effect to add.\n   * @memberof scene.Container#\n   * @ignore\n   */ addEffect (effect) {\n        const index = this.effects.indexOf(effect);\n        if (index !== -1) return;\n        this.effects.push(effect);\n        this.effects.sort((a, b)=>a.priority - b.priority);\n        if (this.renderGroup) this.renderGroup.structureDidChange = true;\n        this._updateIsSimple();\n    },\n    /**\n   * @todo Needs docs.\n   * @param effect - The effect to remove.\n   * @memberof scene.Container#\n   * @ignore\n   */ removeEffect (effect) {\n        const index = this.effects.indexOf(effect);\n        if (index === -1) return;\n        this.effects.splice(index, 1);\n        if (!this.isRenderGroupRoot && this.renderGroup) this.renderGroup.structureDidChange = true;\n        this._updateIsSimple();\n    },\n    set mask (value){\n        this._mask || (this._mask = {\n            mask: null,\n            effect: null\n        });\n        if (this._mask.mask === value) return;\n        if (this._mask.effect) {\n            this.removeEffect(this._mask.effect);\n            (0, $fGBJF.MaskEffectManager).returnMaskEffect(this._mask.effect);\n            this._mask.effect = null;\n        }\n        this._mask.mask = value;\n        if (value === null || value === void 0) return;\n        const effect = (0, $fGBJF.MaskEffectManager).getMaskEffect(value);\n        this._mask.effect = effect;\n        this.addEffect(effect);\n    },\n    /**\n   * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n   * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n   * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it\n   * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\n   * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.\n   * To remove a mask, set this property to `null`.\n   *\n   * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n   * @example\n   * import { Graphics, Sprite } from 'pixi.js';\n   *\n   * const graphics = new Graphics();\n   * graphics.beginFill(0xFF3300);\n   * graphics.drawRect(50, 250, 100, 100);\n   * graphics.endFill();\n   *\n   * const sprite = new Sprite(texture);\n   * sprite.mask = graphics;\n   * @memberof scene.Container#\n   */ get mask () {\n        return this._mask?.mask;\n    },\n    set filters (value){\n        if (!Array.isArray(value) && value) value = [\n            value\n        ];\n        value;\n        this._filters || (this._filters = {\n            filters: null,\n            effect: null,\n            filterArea: null\n        });\n        const hasFilters = value?.length > 0;\n        const didChange = this._filters.effect && !hasFilters || !this._filters.effect && hasFilters;\n        value = Array.isArray(value) ? value.slice(0) : value;\n        this._filters.filters = Object.freeze(value);\n        if (didChange) {\n            if (hasFilters) {\n                const effect = (0, $e98Fy.BigPool).get((0, $fq91v.FilterEffect));\n                this._filters.effect = effect;\n                this.addEffect(effect);\n            } else {\n                const effect = this._filters.effect;\n                this.removeEffect(effect);\n                effect.filterArea = null;\n                effect.filters = null;\n                this._filters.effect = null;\n                (0, $e98Fy.BigPool).return(effect);\n            }\n        }\n        if (hasFilters) {\n            this._filters.effect.filters = value;\n            this._filters.effect.filterArea = this.filterArea;\n        }\n    },\n    /**\n   * Sets the filters for the displayObject.\n   * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n   * To remove filters simply set this property to `'null'`.\n   * @memberof scene.Container#\n   */ get filters () {\n        return this._filters?.filters;\n    },\n    set filterArea (value){\n        this._filters || (this._filters = {\n            filters: null,\n            effect: null,\n            filterArea: null\n        });\n        this._filters.filterArea = value;\n    },\n    /**\n   * The area the filter is applied to. This is used as more of an optimization\n   * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n   *\n   * Also works as an interaction mask.\n   * @memberof scene.Container#\n   */ get filterArea () {\n        return this._filters?.filterArea;\n    }\n};\n\n});\nparcelRegister(\"fq91v\", function(module, exports) {\n\n$parcel$export(module.exports, \"FilterEffect\", () => $82803e0d8d097f5f$export$d66c06ffe23037ab);\n\"use strict\";\nclass $82803e0d8d097f5f$export$d66c06ffe23037ab {\n    constructor(options){\n        this.pipe = \"filter\";\n        this.priority = 1;\n        this.filters = options?.filters;\n        this.filterArea = options?.filterArea;\n    }\n    destroy() {\n        for(let i = 0; i < this.filters.length; i++)this.filters[i].destroy();\n        this.filters = null;\n        this.filterArea = null;\n    }\n}\n\n});\n\nparcelRegister(\"fGBJF\", function(module, exports) {\n\n$parcel$export(module.exports, \"MaskEffectManager\", () => $fa986065911c7cb3$export$1eb319167fe02d04);\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $e98Fy = parcelRequire(\"e98Fy\");\n\"use strict\";\nclass $fa986065911c7cb3$export$3b0749bf144d4b29 {\n    constructor(){\n        /**\n     * @private\n     */ this._effectClasses = [];\n        this._tests = [];\n        this._initialized = false;\n    }\n    init() {\n        if (this._initialized) return;\n        this._initialized = true;\n        this._effectClasses.forEach((test)=>{\n            this.add({\n                test: test.test,\n                maskClass: test\n            });\n        });\n    }\n    add(test) {\n        this._tests.push(test);\n    }\n    getMaskEffect(item) {\n        if (!this._initialized) this.init();\n        for(let i = 0; i < this._tests.length; i++){\n            const test = this._tests[i];\n            if (test.test(item)) return (0, $e98Fy.BigPool).get(test.maskClass, item);\n        }\n        return item;\n    }\n    returnMaskEffect(effect) {\n        (0, $e98Fy.BigPool).return(effect);\n    }\n}\nconst $fa986065911c7cb3$export$1eb319167fe02d04 = new $fa986065911c7cb3$export$3b0749bf144d4b29();\n(0, $eVz1R.extensions).handleByList((0, $eVz1R.ExtensionType).MaskEffect, $fa986065911c7cb3$export$1eb319167fe02d04._effectClasses);\n\n});\nparcelRegister(\"e98Fy\", function(module, exports) {\n\n$parcel$export(module.exports, \"BigPool\", () => $6be6cb2942b74e3a$export$8249372279066210);\n\nvar $iYfXR = parcelRequire(\"iYfXR\");\n\"use strict\";\nclass $6be6cb2942b74e3a$export$866836a21808b71c {\n    constructor(){\n        /**\n     * A map to store the pools by their class type.\n     * @private\n     */ this._poolsByClass = /* @__PURE__ */ new Map();\n    }\n    /**\n   * Prepopulates a specific pool with a given number of items.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n   * @param {number} total - The number of items to add to the pool.\n   */ prepopulate(Class, total) {\n        const classPool = this.getPool(Class);\n        classPool.prepopulate(total);\n    }\n    /**\n   * Gets an item from a specific pool.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n   * @param {unknown} [data] - Optional data to pass to the item's constructor.\n   * @returns {T} The item from the pool.\n   */ get(Class, data) {\n        const pool = this.getPool(Class);\n        return pool.get(data);\n    }\n    /**\n   * Returns an item to its respective pool.\n   * @param {PoolItem} item - The item to return to the pool.\n   */ return(item) {\n        const pool = this.getPool(item.constructor);\n        pool.return(item);\n    }\n    /**\n   * Gets a specific pool based on the class type.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.\n   * @returns {Pool<T>} The pool of the given class type.\n   */ getPool(ClassType) {\n        if (!this._poolsByClass.has(ClassType)) this._poolsByClass.set(ClassType, new (0, $iYfXR.Pool)(ClassType));\n        return this._poolsByClass.get(ClassType);\n    }\n    /** gets the usage stats of each pool in the system */ stats() {\n        const stats = {};\n        this._poolsByClass.forEach((pool)=>{\n            const name = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;\n            stats[name] = {\n                free: pool.totalFree,\n                used: pool.totalUsed,\n                size: pool.totalSize\n            };\n        });\n        return stats;\n    }\n}\nconst $6be6cb2942b74e3a$export$8249372279066210 = new $6be6cb2942b74e3a$export$866836a21808b71c();\n\n});\nparcelRegister(\"iYfXR\", function(module, exports) {\n\n$parcel$export(module.exports, \"Pool\", () => $66bdaf1ccfbf3948$export$14963ee5c8637e11);\n\"use strict\";\nclass $66bdaf1ccfbf3948$export$14963ee5c8637e11 {\n    /**\n   * Constructs a new Pool.\n   * @param ClassType - The constructor of the items in the pool.\n   * @param {number} [initialSize] - The initial size of the pool.\n   */ constructor(ClassType, initialSize){\n        this._pool = [];\n        this._count = 0;\n        this._index = 0;\n        this._classType = ClassType;\n        if (initialSize) this.prepopulate(initialSize);\n    }\n    /**\n   * Prepopulates the pool with a given number of items.\n   * @param total - The number of items to add to the pool.\n   */ prepopulate(total) {\n        for(let i = 0; i < total; i++)this._pool[this._index++] = new this._classType();\n        this._count += total;\n    }\n    /**\n   * Gets an item from the pool. Calls the item's `init` method if it exists.\n   * If there are no items left in the pool, a new one will be created.\n   * @param {unknown} [data] - Optional data to pass to the item's constructor.\n   * @returns {T} The item from the pool.\n   */ get(data) {\n        let item;\n        if (this._index > 0) item = this._pool[--this._index];\n        else item = new this._classType();\n        item.init?.(data);\n        return item;\n    }\n    /**\n   * Returns an item to the pool. Calls the item's `reset` method if it exists.\n   * @param {T} item - The item to return to the pool.\n   */ return(item) {\n        item.reset?.();\n        this._pool[this._index++] = item;\n    }\n    /**\n   * Gets the number of items in the pool.\n   * @readonly\n   * @member {number}\n   */ get totalSize() {\n        return this._count;\n    }\n    /**\n   * Gets the number of items in the pool that are free to use without needing to create more.\n   * @readonly\n   * @member {number}\n   */ get totalFree() {\n        return this._index;\n    }\n    /**\n   * Gets the number of items in the pool that are currently in use.\n   * @readonly\n   * @member {number}\n   */ get totalUsed() {\n        return this._count - this._index;\n    }\n}\n\n});\n\n\n\n\nparcelRegister(\"6UPd0\", function(module, exports) {\n\n$parcel$export(module.exports, \"findMixin\", () => $eeec6fee48380987$export$468b0762e1bfbd64);\n\nvar $eX50w = parcelRequire(\"eX50w\");\n\"use strict\";\nconst $eeec6fee48380987$export$468b0762e1bfbd64 = {\n    /**\n   * The instance label of the object.\n   * @memberof scene.Container#\n   * @member {string} label\n   */ label: null,\n    /**\n   * The instance name of the object.\n   * @deprecated since 8.0.0\n   * @see scene.Container#label\n   * @member {string} name\n   * @memberof scene.Container#\n   */ get name () {\n        (0, $eX50w.deprecation)((0, $eX50w.v8_0_0), \"Container.name property has been removed, use Container.label instead\");\n        return this.label;\n    },\n    set name (value){\n        (0, $eX50w.deprecation)((0, $eX50w.v8_0_0), \"Container.name property has been removed, use Container.label instead\");\n        this.label = value;\n    },\n    /**\n   * @method getChildByName\n   * @deprecated since 8.0.0\n   * @param {string} name - Instance name.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @returns {Container} The child with the specified name.\n   * @see scene.Container#getChildByLabel\n   * @memberof scene.Container#\n   */ getChildByName (name, deep = false) {\n        return this.getChildByLabel(name, deep);\n    },\n    /**\n   * Returns the first child in the container with the specified label.\n   *\n   * Recursive searches are done in a pre-order traversal.\n   * @memberof scene.Container#\n   * @param {string|RegExp} label - Instance label.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @returns {Container} The child with the specified label.\n   */ getChildByLabel (label, deep = false) {\n        const children = this.children;\n        for(let i = 0; i < children.length; i++){\n            const child = children[i];\n            if (child.label === label || label instanceof RegExp && label.test(child.label)) return child;\n        }\n        if (deep) for(let i = 0; i < children.length; i++){\n            const child = children[i];\n            const found = child.getChildByLabel(label, true);\n            if (found) return found;\n        }\n        return null;\n    },\n    /**\n   * Returns all children in the container with the specified label.\n   * @memberof scene.Container#\n   * @param {string|RegExp} label - Instance label.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @param {Container[]} [out=[]] - The array to store matching children in.\n   * @returns {Container[]} An array of children with the specified label.\n   */ getChildrenByLabel (label, deep = false, out = []) {\n        const children = this.children;\n        for(let i = 0; i < children.length; i++){\n            const child = children[i];\n            if (child.label === label || label instanceof RegExp && label.test(child.label)) out.push(child);\n        }\n        if (deep) for(let i = 0; i < children.length; i++)children[i].getChildrenByLabel(label, true, out);\n        return out;\n    }\n};\n\n});\n\nparcelRegister(\"eHtGW\", function(module, exports) {\n\n$parcel$export(module.exports, \"measureMixin\", () => $635dbf0ee9aabfac$export$285e6e72e8e62f0);\n\nvar $dNaJE = parcelRequire(\"dNaJE\");\n\nvar $ggeMF = parcelRequire(\"ggeMF\");\n\nvar $dXx4G = parcelRequire(\"dXx4G\");\n\nvar $5pskN = parcelRequire(\"5pskN\");\n\nvar $96kAF = parcelRequire(\"96kAF\");\n\"use strict\";\nconst $635dbf0ee9aabfac$var$tempMatrix = new (0, $dNaJE.Matrix)();\nconst $635dbf0ee9aabfac$export$285e6e72e8e62f0 = {\n    _localBoundsCacheId: -1,\n    _localBoundsCacheData: null,\n    _setWidth (value, localWidth) {\n        const sign = Math.sign(this.scale.x) || 1;\n        if (localWidth !== 0) this.scale.x = value / localWidth * sign;\n        else this.scale.x = sign;\n    },\n    _setHeight (value, localHeight) {\n        const sign = Math.sign(this.scale.y) || 1;\n        if (localHeight !== 0) this.scale.y = value / localHeight * sign;\n        else this.scale.y = sign;\n    },\n    /**\n   * Retrieves the local bounds of the container as a Bounds object.\n   * @returns - The bounding area.\n   * @memberof scene.Container#\n   */ getLocalBounds () {\n        if (!this._localBoundsCacheData) this._localBoundsCacheData = {\n            data: [],\n            index: 1,\n            didChange: false,\n            localBounds: new (0, $ggeMF.Bounds)()\n        };\n        const localBoundsCacheData = this._localBoundsCacheData;\n        localBoundsCacheData.index = 1;\n        localBoundsCacheData.didChange = false;\n        if (localBoundsCacheData.data[0] !== this._didChangeId >> 12) {\n            localBoundsCacheData.didChange = true;\n            localBoundsCacheData.data[0] = this._didChangeId >> 12;\n        }\n        (0, $96kAF.checkChildrenDidChange)(this, localBoundsCacheData);\n        if (localBoundsCacheData.didChange) (0, $5pskN.getLocalBounds)(this, localBoundsCacheData.localBounds, $635dbf0ee9aabfac$var$tempMatrix);\n        return localBoundsCacheData.localBounds;\n    },\n    /**\n   * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.\n   * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from\n   *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n   *  nice performance boost.\n   * @param bounds - Optional bounds to store the result of the bounds calculation.\n   * @returns - The minimum axis-aligned rectangle in world space that fits around this object.\n   * @memberof scene.Container#\n   */ getBounds (skipUpdate, bounds) {\n        return (0, $dXx4G.getGlobalBounds)(this, skipUpdate, bounds || new (0, $ggeMF.Bounds)());\n    }\n};\n\n});\nparcelRegister(\"ggeMF\", function(module, exports) {\n\n$parcel$export(module.exports, \"Bounds\", () => $a12d5e59ca4737b5$export$c4e9d269599ab4b4);\n\nvar $dNaJE = parcelRequire(\"dNaJE\");\n\nvar $soqVu = parcelRequire(\"soqVu\");\n\"use strict\";\nconst $a12d5e59ca4737b5$var$defaultMatrix = new (0, $dNaJE.Matrix)();\nclass $a12d5e59ca4737b5$export$c4e9d269599ab4b4 {\n    constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity){\n        /** @default Infinity */ this.minX = Infinity;\n        /** @default Infinity */ this.minY = Infinity;\n        /** @default -Infinity */ this.maxX = -Infinity;\n        /** @default -Infinity */ this.maxY = -Infinity;\n        this.matrix = $a12d5e59ca4737b5$var$defaultMatrix;\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n    /**\n   * Checks if bounds are empty.\n   * @returns - True if empty.\n   */ isEmpty() {\n        return this.minX > this.maxX || this.minY > this.maxY;\n    }\n    /** The bounding rectangle of the bounds. */ get rectangle() {\n        if (!this._rectangle) this._rectangle = new (0, $soqVu.Rectangle)();\n        const rectangle = this._rectangle;\n        if (this.minX > this.maxX || this.minY > this.maxY) {\n            rectangle.x = 0;\n            rectangle.y = 0;\n            rectangle.width = 0;\n            rectangle.height = 0;\n        } else rectangle.copyFromBounds(this);\n        return rectangle;\n    }\n    /** Clears the bounds and resets. */ clear() {\n        this.minX = Infinity;\n        this.minY = Infinity;\n        this.maxX = -Infinity;\n        this.maxY = -Infinity;\n        this.matrix = $a12d5e59ca4737b5$var$defaultMatrix;\n        return this;\n    }\n    /**\n   * Sets the bounds.\n   * @param x0 - left X of frame\n   * @param y0 - top Y of frame\n   * @param x1 - right X of frame\n   * @param y1 - bottom Y of frame\n   */ set(x0, y0, x1, y1) {\n        this.minX = x0;\n        this.minY = y0;\n        this.maxX = x1;\n        this.maxY = y1;\n    }\n    /**\n   * Adds sprite frame\n   * @param x0 - left X of frame\n   * @param y0 - top Y of frame\n   * @param x1 - right X of frame\n   * @param y1 - bottom Y of frame\n   * @param matrix\n   */ addFrame(x0, y0, x1, y1, matrix) {\n        matrix || (matrix = this.matrix);\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n        let x = a * x0 + c * y0 + tx;\n        let y = b * x0 + d * y0 + ty;\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n        x = a * x1 + c * y0 + tx;\n        y = b * x1 + d * y0 + ty;\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n        x = a * x0 + c * y1 + tx;\n        y = b * x0 + d * y1 + ty;\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n        x = a * x1 + c * y1 + tx;\n        y = b * x1 + d * y1 + ty;\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n    /**\n   * Adds a rectangle to the bounds.\n   * @param rect - The rectangle to be added.\n   * @param matrix - The matrix to apply to the bounds.\n   */ addRect(rect, matrix) {\n        this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);\n    }\n    /**\n   * Adds other {@link Bounds}.\n   * @param bounds - The Bounds to be added\n   * @param matrix\n   */ addBounds(bounds, matrix) {\n        this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);\n    }\n    /**\n   * Adds other Bounds, masked with Bounds.\n   * @param mask - The Bounds to be added.\n   */ addBoundsMask(mask) {\n        this.minX = this.minX > mask.minX ? this.minX : mask.minX;\n        this.minY = this.minY > mask.minY ? this.minY : mask.minY;\n        this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;\n        this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;\n    }\n    /**\n   * Adds other Bounds, multiplied with matrix.\n   * @param matrix - The matrix to apply to the bounds.\n   */ applyMatrix(matrix) {\n        const minX = this.minX;\n        const minY = this.minY;\n        const maxX = this.maxX;\n        const maxY = this.maxY;\n        const { a: a, b: b, c: c, d: d, tx: tx, ty: ty } = matrix;\n        let x = a * minX + c * minY + tx;\n        let y = b * minX + d * minY + ty;\n        this.minX = x;\n        this.minY = y;\n        this.maxX = x;\n        this.maxY = y;\n        x = a * maxX + c * minY + tx;\n        y = b * maxX + d * minY + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n        x = a * minX + c * maxY + tx;\n        y = b * minX + d * maxY + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n        x = a * maxX + c * maxY + tx;\n        y = b * maxX + d * maxY + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n    }\n    /**\n   * Resizes the bounds object to include the given rectangle.\n   * @param rect - The rectangle to be included.\n   */ fit(rect) {\n        if (this.minX < rect.left) this.minX = rect.left;\n        if (this.maxX > rect.right) this.maxX = rect.right;\n        if (this.minY < rect.top) this.minY = rect.top;\n        if (this.maxY > rect.bottom) this.maxY = rect.bottom;\n        return this;\n    }\n    /**\n   * Resizes the bounds object to include the given bounds.\n   * @param left - The left value of the bounds.\n   * @param right - The right value of the bounds.\n   * @param top - The top value of the bounds.\n   * @param bottom - The bottom value of the bounds.\n   */ fitBounds(left, right, top, bottom) {\n        if (this.minX < left) this.minX = left;\n        if (this.maxX > right) this.maxX = right;\n        if (this.minY < top) this.minY = top;\n        if (this.maxY > bottom) this.maxY = bottom;\n        return this;\n    }\n    /**\n   * Pads bounds object, making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   */ pad(paddingX, paddingY = paddingX) {\n        this.minX -= paddingX;\n        this.maxX += paddingX;\n        this.minY -= paddingY;\n        this.maxY += paddingY;\n        return this;\n    }\n    /** Ceils the bounds. */ ceil() {\n        this.minX = Math.floor(this.minX);\n        this.minY = Math.floor(this.minY);\n        this.maxX = Math.ceil(this.maxX);\n        this.maxY = Math.ceil(this.maxY);\n        return this;\n    }\n    /** Clones the bounds. */ clone() {\n        return new $a12d5e59ca4737b5$export$c4e9d269599ab4b4(this.minX, this.minY, this.maxX, this.maxY);\n    }\n    /**\n   * Scales the bounds by the given values\n   * @param x - The X value to scale by.\n   * @param y - The Y value to scale by.\n   */ scale(x, y = x) {\n        this.minX *= x;\n        this.minY *= y;\n        this.maxX *= x;\n        this.maxY *= y;\n        return this;\n    }\n    /** the x value of the bounds. */ get x() {\n        return this.minX;\n    }\n    set x(value) {\n        const width = this.maxX - this.minX;\n        this.minX = value;\n        this.maxX = value + width;\n    }\n    /** the y value of the bounds. */ get y() {\n        return this.minY;\n    }\n    set y(value) {\n        const height = this.maxY - this.minY;\n        this.minY = value;\n        this.maxY = value + height;\n    }\n    /** the width value of the bounds. */ get width() {\n        return this.maxX - this.minX;\n    }\n    set width(value) {\n        this.maxX = this.minX + value;\n    }\n    /** the height value of the bounds. */ get height() {\n        return this.maxY - this.minY;\n    }\n    set height(value) {\n        this.maxY = this.minY + value;\n    }\n    /** the left value of the bounds. */ get left() {\n        return this.minX;\n    }\n    /** the right value of the bounds. */ get right() {\n        return this.maxX;\n    }\n    /** the top value of the bounds. */ get top() {\n        return this.minY;\n    }\n    /** the bottom value of the bounds. */ get bottom() {\n        return this.maxY;\n    }\n    /** Is the bounds positive. */ get isPositive() {\n        return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;\n    }\n    get isValid() {\n        return this.minX + this.minY !== Infinity;\n    }\n    /**\n   * Adds screen vertices from array\n   * @param vertexData - calculated vertices\n   * @param beginOffset - begin offset\n   * @param endOffset - end offset, excluded\n   * @param matrix\n   */ addVertexData(vertexData, beginOffset, endOffset, matrix) {\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n        matrix || (matrix = this.matrix);\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n        for(let i = beginOffset; i < endOffset; i += 2){\n            const localX = vertexData[i];\n            const localY = vertexData[i + 1];\n            const x = a * localX + c * localY + tx;\n            const y = b * localX + d * localY + ty;\n            minX = x < minX ? x : minX;\n            minY = y < minY ? y : minY;\n            maxX = x > maxX ? x : maxX;\n            maxY = y > maxY ? y : maxY;\n        }\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n    /**\n   * Checks if the point is contained within the bounds.\n   * @param x - x coordinate\n   * @param y - y coordinate\n   */ containsPoint(x, y) {\n        if (this.minX <= x && this.minY <= y && this.maxX >= x && this.maxY >= y) return true;\n        return false;\n    }\n    toString() {\n        return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;\n    }\n}\n\n});\nparcelRegister(\"soqVu\", function(module, exports) {\n\n$parcel$export(module.exports, \"Rectangle\", () => $4ba4a3bc6c979a96$export$4617fb02663045ef);\n\nvar $2NXni = parcelRequire(\"2NXni\");\n\"use strict\";\nconst $4ba4a3bc6c979a96$var$tempPoints = [\n    new (0, $2NXni.Point)(),\n    new (0, $2NXni.Point)(),\n    new (0, $2NXni.Point)(),\n    new (0, $2NXni.Point)()\n];\nclass $4ba4a3bc6c979a96$export$4617fb02663045ef {\n    /**\n   * @param x - The X coordinate of the upper-left corner of the rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rectangle\n   * @param width - The overall width of the rectangle\n   * @param height - The overall height of the rectangle\n   */ constructor(x = 0, y = 0, width = 0, height = 0){\n        /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'rectangle'\n     */ this.type = \"rectangle\";\n        this.x = Number(x);\n        this.y = Number(y);\n        this.width = Number(width);\n        this.height = Number(height);\n    }\n    /** Returns the left edge of the rectangle. */ get left() {\n        return this.x;\n    }\n    /** Returns the right edge of the rectangle. */ get right() {\n        return this.x + this.width;\n    }\n    /** Returns the top edge of the rectangle. */ get top() {\n        return this.y;\n    }\n    /** Returns the bottom edge of the rectangle. */ get bottom() {\n        return this.y + this.height;\n    }\n    /** Determines whether the Rectangle is empty. */ isEmpty() {\n        return this.left === this.right || this.top === this.bottom;\n    }\n    /** A constant empty rectangle. This is a new object every time the property is accessed */ static get EMPTY() {\n        return new $4ba4a3bc6c979a96$export$4617fb02663045ef(0, 0, 0, 0);\n    }\n    /**\n   * Creates a clone of this Rectangle\n   * @returns a copy of the rectangle\n   */ clone() {\n        return new $4ba4a3bc6c979a96$export$4617fb02663045ef(this.x, this.y, this.width, this.height);\n    }\n    /**\n   * Converts a Bounds object to a Rectangle object.\n   * @param bounds - The bounds to copy and convert to a rectangle.\n   * @returns Returns itself.\n   */ copyFromBounds(bounds) {\n        this.x = bounds.minX;\n        this.y = bounds.minY;\n        this.width = bounds.maxX - bounds.minX;\n        this.height = bounds.maxY - bounds.minY;\n        return this;\n    }\n    /**\n   * Copies another rectangle to this one.\n   * @param rectangle - The rectangle to copy from.\n   * @returns Returns itself.\n   */ copyFrom(rectangle) {\n        this.x = rectangle.x;\n        this.y = rectangle.y;\n        this.width = rectangle.width;\n        this.height = rectangle.height;\n        return this;\n    }\n    /**\n   * Copies this rectangle to another one.\n   * @param rectangle - The rectangle to copy to.\n   * @returns Returns given parameter.\n   */ copyTo(rectangle) {\n        rectangle.copyFrom(this);\n        return rectangle;\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this Rectangle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Rectangle\n   */ contains(x, y) {\n        if (this.width <= 0 || this.height <= 0) return false;\n        if (x >= this.x && x < this.x + this.width) {\n            if (y >= this.y && y < this.y + this.height) return true;\n        }\n        return false;\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this rectangle\n   */ strokeContains(x, y, strokeWidth) {\n        const { width: width, height: height } = this;\n        if (width <= 0 || height <= 0) return false;\n        const _x = this.x;\n        const _y = this.y;\n        const outerLeft = _x - strokeWidth / 2;\n        const outerRight = _x + width + strokeWidth / 2;\n        const outerTop = _y - strokeWidth / 2;\n        const outerBottom = _y + height + strokeWidth / 2;\n        const innerLeft = _x + strokeWidth / 2;\n        const innerRight = _x + width - strokeWidth / 2;\n        const innerTop = _y + strokeWidth / 2;\n        const innerBottom = _y + height - strokeWidth / 2;\n        return x >= outerLeft && x <= outerRight && y >= outerTop && y <= outerBottom && !(x > innerLeft && x < innerRight && y > innerTop && y < innerBottom);\n    }\n    /**\n   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n   * Returns true only if the area of the intersection is >0, this means that Rectangles\n   * sharing a side are not overlapping. Another side effect is that an arealess rectangle\n   * (width or height equal to zero) can't intersect any other rectangle.\n   * @param {Rectangle} other - The Rectangle to intersect with `this`.\n   * @param {Matrix} transform - The transformation matrix of `other`.\n   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\n   */ intersects(other, transform) {\n        if (!transform) {\n            const x02 = this.x < other.x ? other.x : this.x;\n            const x12 = this.right > other.right ? other.right : this.right;\n            if (x12 <= x02) return false;\n            const y02 = this.y < other.y ? other.y : this.y;\n            const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;\n            return y12 > y02;\n        }\n        const x0 = this.left;\n        const x1 = this.right;\n        const y0 = this.top;\n        const y1 = this.bottom;\n        if (x1 <= x0 || y1 <= y0) return false;\n        const lt = $4ba4a3bc6c979a96$var$tempPoints[0].set(other.left, other.top);\n        const lb = $4ba4a3bc6c979a96$var$tempPoints[1].set(other.left, other.bottom);\n        const rt = $4ba4a3bc6c979a96$var$tempPoints[2].set(other.right, other.top);\n        const rb = $4ba4a3bc6c979a96$var$tempPoints[3].set(other.right, other.bottom);\n        if (rt.x <= lt.x || lb.y <= lt.y) return false;\n        const s = Math.sign(transform.a * transform.d - transform.b * transform.c);\n        if (s === 0) return false;\n        transform.apply(lt, lt);\n        transform.apply(lb, lb);\n        transform.apply(rt, rt);\n        transform.apply(rb, rb);\n        if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) return false;\n        const nx = s * (lb.y - lt.y);\n        const ny = s * (lt.x - lb.x);\n        const n00 = nx * x0 + ny * y0;\n        const n10 = nx * x1 + ny * y0;\n        const n01 = nx * x0 + ny * y1;\n        const n11 = nx * x1 + ny * y1;\n        if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) return false;\n        const mx = s * (lt.y - rt.y);\n        const my = s * (rt.x - lt.x);\n        const m00 = mx * x0 + my * y0;\n        const m10 = mx * x1 + my * y0;\n        const m01 = mx * x0 + my * y1;\n        const m11 = mx * x1 + my * y1;\n        if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) return false;\n        return true;\n    }\n    /**\n   * Pads the rectangle making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   * @returns Returns itself.\n   */ pad(paddingX = 0, paddingY = paddingX) {\n        this.x -= paddingX;\n        this.y -= paddingY;\n        this.width += paddingX * 2;\n        this.height += paddingY * 2;\n        return this;\n    }\n    /**\n   * Fits this rectangle around the passed one.\n   * @param rectangle - The rectangle to fit.\n   * @returns Returns itself.\n   */ fit(rectangle) {\n        const x1 = Math.max(this.x, rectangle.x);\n        const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n        const y1 = Math.max(this.y, rectangle.y);\n        const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n        this.x = x1;\n        this.width = Math.max(x2 - x1, 0);\n        this.y = y1;\n        this.height = Math.max(y2 - y1, 0);\n        return this;\n    }\n    /**\n   * Enlarges rectangle that way its corners lie on grid\n   * @param resolution - resolution\n   * @param eps - precision\n   * @returns Returns itself.\n   */ ceil(resolution = 1, eps = 1e-3) {\n        const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n        const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n        this.x = Math.floor((this.x + eps) * resolution) / resolution;\n        this.y = Math.floor((this.y + eps) * resolution) / resolution;\n        this.width = x2 - this.x;\n        this.height = y2 - this.y;\n        return this;\n    }\n    /**\n   * Enlarges this rectangle to include the passed rectangle.\n   * @param rectangle - The rectangle to include.\n   * @returns Returns itself.\n   */ enlarge(rectangle) {\n        const x1 = Math.min(this.x, rectangle.x);\n        const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n        const y1 = Math.min(this.y, rectangle.y);\n        const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n        this.x = x1;\n        this.width = x2 - x1;\n        this.y = y1;\n        this.height = y2 - y1;\n        return this;\n    }\n    /**\n   * Returns the framing rectangle of the rectangle as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */ getBounds(out) {\n        out = out || new $4ba4a3bc6c979a96$export$4617fb02663045ef();\n        out.copyFrom(this);\n        return out;\n    }\n    toString() {\n        return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n    }\n}\n\n});\n\n\nparcelRegister(\"dXx4G\", function(module, exports) {\n\n$parcel$export(module.exports, \"getGlobalBounds\", () => $8e3ae21db977fba1$export$f4412a6981d97baa);\n$parcel$export(module.exports, \"updateTransformBackwards\", () => $8e3ae21db977fba1$export$2022bc48a49dd6d2);\n\nvar $dNaJE = parcelRequire(\"dNaJE\");\n\nvar $96ND8 = parcelRequire(\"96ND8\");\n\"use strict\";\nfunction $8e3ae21db977fba1$export$f4412a6981d97baa(target, skipUpdateTransform, bounds) {\n    bounds.clear();\n    let parentTransform;\n    let pooledMatrix;\n    if (target.parent) {\n        if (!skipUpdateTransform) {\n            pooledMatrix = (0, $96ND8.matrixPool).get().identity();\n            parentTransform = $8e3ae21db977fba1$export$2022bc48a49dd6d2(target, pooledMatrix);\n        } else parentTransform = target.parent.worldTransform;\n    } else parentTransform = (0, $dNaJE.Matrix).IDENTITY;\n    $8e3ae21db977fba1$export$ca70956e64971628(target, bounds, parentTransform, skipUpdateTransform);\n    if (pooledMatrix) (0, $96ND8.matrixPool).return(pooledMatrix);\n    if (!bounds.isValid) bounds.set(0, 0, 0, 0);\n    return bounds;\n}\nfunction $8e3ae21db977fba1$export$ca70956e64971628(target, bounds, parentTransform, skipUpdateTransform) {\n    if (!target.visible || !target.measurable) return;\n    let worldTransform;\n    if (!skipUpdateTransform) {\n        target.updateLocalTransform();\n        worldTransform = (0, $96ND8.matrixPool).get();\n        worldTransform.appendFrom(target.localTransform, parentTransform);\n    } else worldTransform = target.worldTransform;\n    const parentBounds = bounds;\n    const preserveBounds = !!target.effects.length;\n    if (preserveBounds) bounds = (0, $96ND8.boundsPool).get().clear();\n    if (target.boundsArea) bounds.addRect(target.boundsArea, worldTransform);\n    else {\n        if (target.addBounds) {\n            bounds.matrix = worldTransform;\n            target.addBounds(bounds);\n        }\n        for(let i = 0; i < target.children.length; i++)$8e3ae21db977fba1$export$ca70956e64971628(target.children[i], bounds, worldTransform, skipUpdateTransform);\n    }\n    if (preserveBounds) {\n        for(let i = 0; i < target.effects.length; i++)target.effects[i].addBounds?.(bounds);\n        parentBounds.addBounds(bounds, (0, $dNaJE.Matrix).IDENTITY);\n        (0, $96ND8.boundsPool).return(bounds);\n    }\n    if (!skipUpdateTransform) (0, $96ND8.matrixPool).return(worldTransform);\n}\nfunction $8e3ae21db977fba1$export$2022bc48a49dd6d2(target, parentTransform) {\n    const parent = target.parent;\n    if (parent) {\n        $8e3ae21db977fba1$export$2022bc48a49dd6d2(parent, parentTransform);\n        parent.updateLocalTransform();\n        parentTransform.append(parent.localTransform);\n    }\n    return parentTransform;\n}\n\n});\nparcelRegister(\"96ND8\", function(module, exports) {\n\n$parcel$export(module.exports, \"matrixPool\", () => $826d79d1525243fc$export$3849005ba4dacf72);\n$parcel$export(module.exports, \"boundsPool\", () => $826d79d1525243fc$export$9194656040c1dc42);\n\nvar $dNaJE = parcelRequire(\"dNaJE\");\n\nvar $iYfXR = parcelRequire(\"iYfXR\");\n\nvar $ggeMF = parcelRequire(\"ggeMF\");\n\"use strict\";\nconst $826d79d1525243fc$export$3849005ba4dacf72 = new (0, $iYfXR.Pool)((0, $dNaJE.Matrix));\nconst $826d79d1525243fc$export$9194656040c1dc42 = new (0, $iYfXR.Pool)((0, $ggeMF.Bounds));\n\n});\n\n\nparcelRegister(\"5pskN\", function(module, exports) {\n\n$parcel$export(module.exports, \"getLocalBounds\", () => $e441be710d94e6fb$export$ffaf4f504c4c5c9c);\n\nvar $dNaJE = parcelRequire(\"dNaJE\");\n\nvar $8CF4q = parcelRequire(\"8CF4q\");\n\nvar $96ND8 = parcelRequire(\"96ND8\");\n\"use strict\";\nfunction $e441be710d94e6fb$export$ffaf4f504c4c5c9c(target, bounds, relativeMatrix) {\n    bounds.clear();\n    relativeMatrix || (relativeMatrix = (0, $dNaJE.Matrix).IDENTITY);\n    $e441be710d94e6fb$var$_getLocalBounds(target, bounds, relativeMatrix, target, true);\n    if (!bounds.isValid) bounds.set(0, 0, 0, 0);\n    return bounds;\n}\nfunction $e441be710d94e6fb$var$_getLocalBounds(target, bounds, parentTransform, rootContainer, isRoot) {\n    let relativeTransform;\n    if (!isRoot) {\n        if (!target.visible || !target.measurable) return;\n        target.updateLocalTransform();\n        const localTransform = target.localTransform;\n        relativeTransform = (0, $96ND8.matrixPool).get();\n        relativeTransform.appendFrom(localTransform, parentTransform);\n    } else {\n        relativeTransform = (0, $96ND8.matrixPool).get();\n        relativeTransform = parentTransform.copyTo(relativeTransform);\n    }\n    const parentBounds = bounds;\n    const preserveBounds = !!target.effects.length;\n    if (preserveBounds) bounds = (0, $96ND8.boundsPool).get().clear();\n    if (target.boundsArea) bounds.addRect(target.boundsArea, relativeTransform);\n    else {\n        if (target.renderPipeId) {\n            bounds.matrix = relativeTransform;\n            target.addBounds(bounds);\n        }\n        const children = target.children;\n        for(let i = 0; i < children.length; i++)$e441be710d94e6fb$var$_getLocalBounds(children[i], bounds, relativeTransform, rootContainer, false);\n    }\n    if (preserveBounds) {\n        for(let i = 0; i < target.effects.length; i++)target.effects[i].addLocalBounds?.(bounds, rootContainer);\n        parentBounds.addBounds(bounds, (0, $dNaJE.Matrix).IDENTITY);\n        (0, $96ND8.boundsPool).return(bounds);\n    }\n    (0, $96ND8.matrixPool).return(relativeTransform);\n}\nfunction $e441be710d94e6fb$export$58081aedf094d85b(target, root, matrix) {\n    const parent = target.parent;\n    if (!parent) {\n        (0, $8CF4q.warn)(\"Item is not inside the root container\");\n        return;\n    }\n    if (parent !== root) {\n        $e441be710d94e6fb$export$58081aedf094d85b(parent, root, matrix);\n        parent.updateLocalTransform();\n        matrix.append(parent.localTransform);\n    }\n}\n\n});\nparcelRegister(\"8CF4q\", function(module, exports) {\n\n$parcel$export(module.exports, \"warn\", () => $babafddae46386dc$export$c106dd0671a0fc2d);\n\"use strict\";\nlet $babafddae46386dc$var$warnCount = 0;\nconst $babafddae46386dc$var$maxWarnings = 500;\nfunction $babafddae46386dc$export$c106dd0671a0fc2d(...args) {\n    if ($babafddae46386dc$var$warnCount === $babafddae46386dc$var$maxWarnings) return;\n    $babafddae46386dc$var$warnCount++;\n    if ($babafddae46386dc$var$warnCount === $babafddae46386dc$var$maxWarnings) console.warn(\"PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.\");\n    else console.warn(\"PixiJS Warning: \", ...args);\n}\n\n});\n\n\nparcelRegister(\"96kAF\", function(module, exports) {\n\n$parcel$export(module.exports, \"checkChildrenDidChange\", () => $3c4e83a868f7ed9d$export$fd5aadbd3827bcf1);\n\"use strict\";\nfunction $3c4e83a868f7ed9d$export$fd5aadbd3827bcf1(container, previousData) {\n    const children = container.children;\n    for(let i = 0; i < children.length; i++){\n        const child = children[i];\n        const changeId = (child.uid & 255) << 24 | child._didChangeId & 16777215;\n        if (previousData.data[previousData.index] !== changeId) {\n            previousData.data[previousData.index] = changeId;\n            previousData.didChange = true;\n        }\n        previousData.index++;\n        if (child.children.length) $3c4e83a868f7ed9d$export$fd5aadbd3827bcf1(child, previousData);\n    }\n    return previousData.didChange;\n}\n\n});\n\n\nparcelRegister(\"bMTFJ\", function(module, exports) {\n\n$parcel$export(module.exports, \"onRenderMixin\", () => $4b17ef0f98b62c7c$export$2a5246d1114cb81d);\n\"use strict\";\nconst $4b17ef0f98b62c7c$export$2a5246d1114cb81d = {\n    _onRender: null,\n    set onRender (func){\n        const renderGroup = this.renderGroup;\n        if (!func) {\n            if (this._onRender) renderGroup?.removeOnRender(this);\n            this._onRender = null;\n            return;\n        }\n        if (!this._onRender) renderGroup?.addOnRender(this);\n        this._onRender = func;\n    },\n    /**\n   * This callback is used when the container is rendered. This is where you should add your custom\n   * logic that is needed to be run every frame.\n   *\n   * In v7 many users used `updateTransform` for this, however the way v8 renders objects is different\n   * and \"updateTransform\" is no longer called every frame\n   * @example\n   * const container = new Container();\n   * container.onRender = () => {\n   *    container.rotation += 0.01;\n   * };\n   * @memberof scene.Container#\n   */ get onRender () {\n        return this._onRender;\n    }\n};\n\n});\n\nparcelRegister(\"8Eetq\", function(module, exports) {\n\n$parcel$export(module.exports, \"sortMixin\", () => $b2f06f436f1ee35c$export$eb4acdd9f4781aed);\n\"use strict\";\nconst $b2f06f436f1ee35c$export$eb4acdd9f4781aed = {\n    _zIndex: 0,\n    /**\n   * Should children be sorted by zIndex at the next render call.\n   *\n   * Will get automatically set to true if a new child is added, or if a child's zIndex changes.\n   * @type {boolean}\n   * @memberof scene.Container#\n   */ sortDirty: false,\n    /**\n   * If set to true, the container will sort its children by `zIndex` value\n   * when the next render is called, or manually if `sortChildren()` is called.\n   *\n   * This actually changes the order of elements in the array, so should be treated\n   * as a basic solution that is not performant compared to other solutions,\n   * such as {@link https://github.com/pixijs/layers PixiJS Layers}\n   *\n   * Also be aware of that this may not work nicely with the `addChildAt()` function,\n   * as the `zIndex` sorting may cause the child to automatically sorted to another position.\n   * @type {boolean}\n   * @memberof scene.Container#\n   */ sortableChildren: false,\n    /**\n   * The zIndex of the container.\n   *\n   * Setting this value, will automatically set the parent to be sortable. Children will be automatically\n   * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\n   * and thus rendered on top of other display objects within the same container.\n   * @see scene.Container#sortableChildren\n   * @memberof scene.Container#\n   */ get zIndex () {\n        return this._zIndex;\n    },\n    set zIndex (value){\n        if (this._zIndex === value) return;\n        this._zIndex = value;\n        this.depthOfChildModified();\n    },\n    depthOfChildModified () {\n        if (this.parent) {\n            this.parent.sortableChildren = true;\n            this.parent.sortDirty = true;\n        }\n        if (this.renderGroup && !this.isRenderGroupRoot) this.renderGroup.structureDidChange = true;\n    },\n    /**\n   * Sorts children by zIndex.\n   * @memberof scene.Container#\n   */ sortChildren () {\n        if (!this.sortDirty) return;\n        this.sortDirty = false;\n        this.children.sort($b2f06f436f1ee35c$var$sortChildren);\n    }\n};\nfunction $b2f06f436f1ee35c$var$sortChildren(a, b) {\n    return a._zIndex - b._zIndex;\n}\n\n});\n\nparcelRegister(\"5gOfB\", function(module, exports) {\n\n$parcel$export(module.exports, \"toLocalGlobalMixin\", () => $f817b482336ecb12$export$38fa7a987602e8dd);\n\nvar $dNaJE = parcelRequire(\"dNaJE\");\n\nvar $2NXni = parcelRequire(\"2NXni\");\n\nvar $dXx4G = parcelRequire(\"dXx4G\");\n\"use strict\";\nconst $f817b482336ecb12$export$38fa7a987602e8dd = {\n    /**\n   * Returns the global position of the container.\n   * @param point - The optional point to write the global value to.\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - The updated point.\n   * @memberof scene.Container#\n   */ getGlobalPosition (point = new (0, $2NXni.Point)(), skipUpdate = false) {\n        if (this.parent) this.parent.toGlobal(this._position, point, skipUpdate);\n        else {\n            point.x = this._position.x;\n            point.y = this._position.y;\n        }\n        return point;\n    },\n    /**\n   * Calculates the global position of the container.\n   * @param position - The world origin to calculate from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - A point object representing the position of this object.\n   * @memberof scene.Container#\n   */ toGlobal (position, point, skipUpdate = false) {\n        if (!skipUpdate) {\n            this.updateLocalTransform();\n            const globalMatrix = (0, $dXx4G.updateTransformBackwards)(this, new (0, $dNaJE.Matrix)());\n            globalMatrix.append(this.localTransform);\n            return globalMatrix.apply(position, point);\n        }\n        return this.worldTransform.apply(position, point);\n    },\n    /**\n   * Calculates the local position of the container relative to another point.\n   * @param position - The world origin to calculate from.\n   * @param from - The Container to calculate the global position from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform\n   * @returns - A point object representing the position of this object\n   * @memberof scene.Container#\n   */ toLocal (position, from, point, skipUpdate) {\n        if (from) position = from.toGlobal(position, point, skipUpdate);\n        if (!skipUpdate) {\n            this.updateLocalTransform();\n            const globalMatrix = (0, $dXx4G.updateTransformBackwards)(this, new (0, $dNaJE.Matrix)());\n            globalMatrix.append(this.localTransform);\n            return globalMatrix.applyInverse(position, point);\n        }\n        return this.worldTransform.applyInverse(position, point);\n    }\n};\n\n});\n\nparcelRegister(\"hmS23\", function(module, exports) {\n\n$parcel$export(module.exports, \"RenderGroup\", () => $8ebef99a9f866ab0$export$94d273f8d74f2a5);\n\nvar $dNaJE = parcelRequire(\"dNaJE\");\n\nvar $vdXhX = parcelRequire(\"vdXhX\");\n\"use strict\";\nclass $8ebef99a9f866ab0$export$94d273f8d74f2a5 {\n    constructor(root){\n        this.renderPipeId = \"renderGroup\";\n        this.root = null;\n        this.canBundle = false;\n        this.renderGroupParent = null;\n        this.renderGroupChildren = [];\n        this._children = [];\n        this.worldTransform = new (0, $dNaJE.Matrix)();\n        this.worldColorAlpha = 4294967295;\n        this.worldColor = 16777215;\n        this.worldAlpha = 1;\n        // these updates are transform changes..\n        this.childrenToUpdate = /* @__PURE__ */ Object.create(null);\n        this.updateTick = 0;\n        // these update are renderable changes..\n        this.childrenRenderablesToUpdate = {\n            list: [],\n            index: 0\n        };\n        // other\n        this.structureDidChange = true;\n        this.instructionSet = new (0, $vdXhX.InstructionSet)();\n        this._onRenderContainers = [];\n        this.root = root;\n        this.addChild(root);\n    }\n    get localTransform() {\n        return this.root.localTransform;\n    }\n    addRenderGroupChild(renderGroupChild) {\n        if (renderGroupChild.renderGroupParent) renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);\n        renderGroupChild.renderGroupParent = this;\n        this.onChildUpdate(renderGroupChild.root);\n        this.renderGroupChildren.push(renderGroupChild);\n    }\n    _removeRenderGroupChild(renderGroupChild) {\n        if (renderGroupChild.root.didChange) this._removeChildFromUpdate(renderGroupChild.root);\n        const index = this.renderGroupChildren.indexOf(renderGroupChild);\n        if (index > -1) this.renderGroupChildren.splice(index, 1);\n        renderGroupChild.renderGroupParent = null;\n    }\n    addChild(child) {\n        this.structureDidChange = true;\n        if (child !== this.root) {\n            this._children.push(child);\n            child.updateTick = -1;\n            if (child.parent === this.root) child.relativeRenderGroupDepth = 1;\n            else child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;\n            if (child._onRender) this.addOnRender(child);\n        }\n        if (child.renderGroup) {\n            if (child.renderGroup.root === child) {\n                this.addRenderGroupChild(child.renderGroup);\n                return;\n            }\n        } else {\n            child.renderGroup = this;\n            child.didChange = true;\n        }\n        const children = child.children;\n        if (!child.isRenderGroupRoot) this.onChildUpdate(child);\n        for(let i = 0; i < children.length; i++)this.addChild(children[i]);\n    }\n    removeChild(child) {\n        this.structureDidChange = true;\n        if (child._onRender) this.removeOnRender(child);\n        if (child.renderGroup.root !== child) {\n            const children = child.children;\n            for(let i = 0; i < children.length; i++)this.removeChild(children[i]);\n            if (child.didChange) child.renderGroup._removeChildFromUpdate(child);\n            child.renderGroup = null;\n        } else this._removeRenderGroupChild(child.renderGroup);\n        const index = this._children.indexOf(child);\n        if (index > -1) this._children.splice(index, 1);\n    }\n    onChildUpdate(child) {\n        let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n        if (!childrenToUpdate) childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {\n            index: 0,\n            list: []\n        };\n        childrenToUpdate.list[childrenToUpdate.index++] = child;\n    }\n    // SHOULD THIS BE HERE?\n    updateRenderable(container) {\n        if (container.globalDisplayStatus < 7) return;\n        container.didViewUpdate = false;\n        this.instructionSet.renderPipes[container.renderPipeId].updateRenderable(container);\n    }\n    onChildViewUpdate(child) {\n        this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;\n    }\n    _removeChildFromUpdate(child) {\n        const childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n        if (!childrenToUpdate) return;\n        const index = childrenToUpdate.list.indexOf(child);\n        if (index > -1) childrenToUpdate.list.splice(index, 1);\n        childrenToUpdate.index--;\n    }\n    get isRenderable() {\n        return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;\n    }\n    /**\n   * adding a container to the onRender list will make sure the user function\n   * passed in to the user defined 'onRender` callBack\n   * @param container - the container to add to the onRender list\n   */ addOnRender(container) {\n        this._onRenderContainers.push(container);\n    }\n    removeOnRender(container) {\n        this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);\n    }\n    runOnRender() {\n        for(let i = 0; i < this._onRenderContainers.length; i++)this._onRenderContainers[i]._onRender();\n    }\n}\n\n});\nparcelRegister(\"vdXhX\", function(module, exports) {\n\n$parcel$export(module.exports, \"InstructionSet\", () => $d18e82f308ef3932$export$2946bd01f10dd922);\n\nvar $l80qL = parcelRequire(\"l80qL\");\n\"use strict\";\nclass $d18e82f308ef3932$export$2946bd01f10dd922 {\n    constructor(){\n        /** a unique id for this instruction set used through the renderer */ this.uid = (0, $l80qL.uid)(\"instructionSet\");\n        /** the array of instructions */ this.instructions = [];\n        /** the actual size of the array (any instructions passed this should be ignored) */ this.instructionSize = 0;\n    }\n    /** reset the instruction set so it can be reused set size back to 0 */ reset() {\n        this.instructionSize = 0;\n    }\n    /**\n   * Add an instruction to the set\n   * @param instruction - add an instruction to the set\n   */ add(instruction) {\n        this.instructions[this.instructionSize++] = instruction;\n    }\n    /**\n   * Log the instructions to the console (for debugging)\n   * @internal\n   * @ignore\n   */ log() {\n        this.instructions.length = this.instructionSize;\n        console.table(this.instructions, [\n            \"type\",\n            \"action\"\n        ]);\n    }\n}\n\n});\n\n\nparcelRegister(\"e84qN\", function(module, exports) {\n\n$parcel$export(module.exports, \"assignWithIgnore\", () => $5070b2a9c014252d$export$59d0441a278e5935);\n\"use strict\";\nfunction $5070b2a9c014252d$export$59d0441a278e5935(target, options, ignore = {}) {\n    for(const key in options)if (!ignore[key] && options[key] !== void 0) target[key] = options[key];\n}\n\n});\n\n\nparcelRegister(\"5m2Qn\", function(module, exports) {\n\n$parcel$export(module.exports, \"DOMAdapter\", () => $c2653834eabf3044$export$d988306fa84f7b44);\n\nvar $1pH92 = parcelRequire(\"1pH92\");\n\"use strict\";\nlet $c2653834eabf3044$var$currentAdapter = (0, $1pH92.BrowserAdapter);\nconst $c2653834eabf3044$export$d988306fa84f7b44 = {\n    /**\n   * Returns the current adapter.\n   * @returns {environment.Adapter} The current adapter.\n   */ get () {\n        return $c2653834eabf3044$var$currentAdapter;\n    },\n    /**\n   * Sets the current adapter.\n   * @param adapter - The new adapter.\n   */ set (adapter) {\n        $c2653834eabf3044$var$currentAdapter = adapter;\n    }\n};\n\n});\nparcelRegister(\"1pH92\", function(module, exports) {\n\n$parcel$export(module.exports, \"BrowserAdapter\", () => $ef74a33612e9f67a$export$e467cc3399500025);\n\"use strict\";\nconst $ef74a33612e9f67a$export$e467cc3399500025 = {\n    createCanvas: (width, height)=>{\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = width;\n        canvas.height = height;\n        return canvas;\n    },\n    getCanvasRenderingContext2D: ()=>CanvasRenderingContext2D,\n    getWebGLRenderingContext: ()=>WebGLRenderingContext,\n    getWebGL2RenderingContext: ()=>WebGL2RenderingContext,\n    getNavigator: ()=>navigator,\n    getBaseUrl: ()=>document.baseURI ?? window.location.href,\n    getFontFaceSet: ()=>document.fonts,\n    fetch: (url, options)=>fetch(url, options),\n    parseXML: (xml)=>{\n        const parser = new DOMParser();\n        return parser.parseFromString(xml, \"text/xml\");\n    }\n};\n\n});\n\n\nparcelRegister(\"5h88T\", function(module, exports) {\n\n$parcel$export(module.exports, \"Texture\", () => $bc4f7b0a8cd1dc50$export$5431306cf43de24a);\n\nvar $gpXaq = parcelRequire(\"gpXaq\");\n\nvar $dhBBn = parcelRequire(\"dhBBn\");\n\nvar $soqVu = parcelRequire(\"soqVu\");\n\nvar $l80qL = parcelRequire(\"l80qL\");\n\nvar $eX50w = parcelRequire(\"eX50w\");\n\nvar $EqaNP = parcelRequire(\"EqaNP\");\n\nvar $i8D1k = parcelRequire(\"i8D1k\");\n\nvar $9Ur0D = parcelRequire(\"9Ur0D\");\n\nvar $iKeK4 = parcelRequire(\"iKeK4\");\n\"use strict\";\nclass $bc4f7b0a8cd1dc50$export$5431306cf43de24a extends (0, (/*@__PURE__*/$parcel$interopDefault($gpXaq))) {\n    /**\n   * @param {TextureOptions} param0 - Options for the texture\n   */ constructor({ source: source, label: label, frame: frame, orig: orig, trim: trim, defaultAnchor: defaultAnchor, defaultBorders: defaultBorders, rotate: rotate, dynamic: dynamic } = {}){\n        super();\n        /** unique id for this texture */ this.uid = (0, $l80qL.uid)(\"texture\");\n        /** A uvs object based on the given frame and the texture source */ this.uvs = {\n            x0: 0,\n            y0: 0,\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            x3: 0,\n            y3: 0\n        };\n        /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     */ this.frame = new (0, $soqVu.Rectangle)();\n        /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * This mode is enabled automatically if no frame was passed inside constructor.\n     *\n     * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.\n     *\n     * Beware, after loading or resize of baseTexture event can fired two times!\n     * If you want more control, subscribe on baseTexture itself.\n     * @example\n     * texture.on('update', () => {});\n     */ this.noFrame = false;\n        /**\n     * Set to true if you plan on modifying the uvs of this texture.\n     * When this is the case, sprites and other objects using the texture will\n     * make sure to listen for changes to the uvs and update their vertices accordingly.\n     */ this.dynamic = false;\n        /** is it a texture? yes! used for type checking */ this.isTexture = true;\n        this.label = label;\n        this.source = source?.source ?? new (0, $9Ur0D.TextureSource)();\n        this.noFrame = !frame;\n        if (frame) this.frame.copyFrom(frame);\n        else {\n            const { width: width, height: height } = this._source;\n            this.frame.width = width;\n            this.frame.height = height;\n        }\n        this.orig = orig || this.frame;\n        this.trim = trim;\n        this.rotate = rotate ?? 0;\n        this.defaultAnchor = defaultAnchor;\n        this.defaultBorders = defaultBorders;\n        this.destroyed = false;\n        this.dynamic = dynamic || false;\n        this.updateUvs();\n    }\n    set source(value) {\n        if (this._source) this._source.off(\"resize\", this.update, this);\n        this._source = value;\n        value.on(\"resize\", this.update, this);\n        this.emit(\"update\", this);\n    }\n    /** the underlying source of the texture (equivalent of baseTexture in v7) */ get source() {\n        return this._source;\n    }\n    /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */ get textureMatrix() {\n        if (!this._textureMatrix) this._textureMatrix = new (0, $iKeK4.TextureMatrix)(this);\n        return this._textureMatrix;\n    }\n    /** The width of the Texture in pixels. */ get width() {\n        return this.orig.width;\n    }\n    /** The height of the Texture in pixels. */ get height() {\n        return this.orig.height;\n    }\n    /** Call this function when you have modified the frame of this texture. */ updateUvs() {\n        const { uvs: uvs, frame: frame } = this;\n        const { width: width, height: height } = this._source;\n        const nX = frame.x / width;\n        const nY = frame.y / height;\n        const nW = frame.width / width;\n        const nH = frame.height / height;\n        let rotate = this.rotate;\n        if (rotate) {\n            const w2 = nW / 2;\n            const h2 = nH / 2;\n            const cX = nX + w2;\n            const cY = nY + h2;\n            rotate = (0, $dhBBn.groupD8).add(rotate, (0, $dhBBn.groupD8).NW);\n            uvs.x0 = cX + w2 * (0, $dhBBn.groupD8).uX(rotate);\n            uvs.y0 = cY + h2 * (0, $dhBBn.groupD8).uY(rotate);\n            rotate = (0, $dhBBn.groupD8).add(rotate, 2);\n            uvs.x1 = cX + w2 * (0, $dhBBn.groupD8).uX(rotate);\n            uvs.y1 = cY + h2 * (0, $dhBBn.groupD8).uY(rotate);\n            rotate = (0, $dhBBn.groupD8).add(rotate, 2);\n            uvs.x2 = cX + w2 * (0, $dhBBn.groupD8).uX(rotate);\n            uvs.y2 = cY + h2 * (0, $dhBBn.groupD8).uY(rotate);\n            rotate = (0, $dhBBn.groupD8).add(rotate, 2);\n            uvs.x3 = cX + w2 * (0, $dhBBn.groupD8).uX(rotate);\n            uvs.y3 = cY + h2 * (0, $dhBBn.groupD8).uY(rotate);\n        } else {\n            uvs.x0 = nX;\n            uvs.y0 = nY;\n            uvs.x1 = nX + nW;\n            uvs.y1 = nY;\n            uvs.x2 = nX + nW;\n            uvs.y2 = nY + nH;\n            uvs.x3 = nX;\n            uvs.y3 = nY + nH;\n        }\n    }\n    /**\n   * Destroys this texture\n   * @param destroySource - Destroy the source when the texture is destroyed.\n   */ destroy(destroySource = false) {\n        if (this._source) {\n            if (destroySource) {\n                this._source.destroy();\n                this._source = null;\n            }\n        }\n        this._textureMatrix = null;\n        this.destroyed = true;\n        this.emit(\"destroy\", this);\n        this.removeAllListeners();\n    }\n    /** call this if you have modified the `texture outside` of the constructor */ update() {\n        if (this.noFrame) {\n            this.frame.width = this._source.width;\n            this.frame.height = this._source.height;\n        }\n        this.updateUvs();\n        this.emit(\"update\", this);\n    }\n    /** @deprecated since 8.0.0 */ get baseTexture() {\n        (0, $eX50w.deprecation)((0, $eX50w.v8_0_0), \"Texture.baseTexture is now Texture.source\");\n        return this._source;\n    }\n}\n$bc4f7b0a8cd1dc50$export$5431306cf43de24a.EMPTY = new $bc4f7b0a8cd1dc50$export$5431306cf43de24a({\n    label: \"EMPTY\",\n    source: new (0, $9Ur0D.TextureSource)({\n        label: \"EMPTY\"\n    })\n});\n$bc4f7b0a8cd1dc50$export$5431306cf43de24a.EMPTY.destroy = (0, $EqaNP.NOOP);\n$bc4f7b0a8cd1dc50$export$5431306cf43de24a.WHITE = new $bc4f7b0a8cd1dc50$export$5431306cf43de24a({\n    source: new (0, $i8D1k.BufferImageSource)({\n        resource: new Uint8Array([\n            255,\n            255,\n            255,\n            255\n        ]),\n        width: 1,\n        height: 1,\n        alphaMode: \"premultiply-alpha-on-upload\",\n        label: \"WHITE\"\n    }),\n    label: \"WHITE\"\n});\n$bc4f7b0a8cd1dc50$export$5431306cf43de24a.WHITE.destroy = (0, $EqaNP.NOOP);\n\n});\nparcelRegister(\"dhBBn\", function(module, exports) {\n\n$parcel$export(module.exports, \"groupD8\", () => $bd40f80fb18d9e32$export$b7bb6a2a8d203102);\n\nvar $dNaJE = parcelRequire(\"dNaJE\");\n\"use strict\";\nconst $bd40f80fb18d9e32$var$ux = [\n    1,\n    1,\n    0,\n    -1,\n    -1,\n    -1,\n    0,\n    1,\n    1,\n    1,\n    0,\n    -1,\n    -1,\n    -1,\n    0,\n    1\n];\nconst $bd40f80fb18d9e32$var$uy = [\n    0,\n    1,\n    1,\n    1,\n    0,\n    -1,\n    -1,\n    -1,\n    0,\n    1,\n    1,\n    1,\n    0,\n    -1,\n    -1,\n    -1\n];\nconst $bd40f80fb18d9e32$var$vx = [\n    0,\n    -1,\n    -1,\n    -1,\n    0,\n    1,\n    1,\n    1,\n    0,\n    1,\n    1,\n    1,\n    0,\n    -1,\n    -1,\n    -1\n];\nconst $bd40f80fb18d9e32$var$vy = [\n    1,\n    1,\n    0,\n    -1,\n    -1,\n    -1,\n    0,\n    1,\n    -1,\n    -1,\n    0,\n    1,\n    1,\n    1,\n    0,\n    -1\n];\nconst $bd40f80fb18d9e32$var$rotationCayley = [];\nconst $bd40f80fb18d9e32$var$rotationMatrices = [];\nconst $bd40f80fb18d9e32$var$signum = Math.sign;\nfunction $bd40f80fb18d9e32$var$init() {\n    for(let i = 0; i < 16; i++){\n        const row = [];\n        $bd40f80fb18d9e32$var$rotationCayley.push(row);\n        for(let j = 0; j < 16; j++){\n            const _ux = $bd40f80fb18d9e32$var$signum($bd40f80fb18d9e32$var$ux[i] * $bd40f80fb18d9e32$var$ux[j] + $bd40f80fb18d9e32$var$vx[i] * $bd40f80fb18d9e32$var$uy[j]);\n            const _uy = $bd40f80fb18d9e32$var$signum($bd40f80fb18d9e32$var$uy[i] * $bd40f80fb18d9e32$var$ux[j] + $bd40f80fb18d9e32$var$vy[i] * $bd40f80fb18d9e32$var$uy[j]);\n            const _vx = $bd40f80fb18d9e32$var$signum($bd40f80fb18d9e32$var$ux[i] * $bd40f80fb18d9e32$var$vx[j] + $bd40f80fb18d9e32$var$vx[i] * $bd40f80fb18d9e32$var$vy[j]);\n            const _vy = $bd40f80fb18d9e32$var$signum($bd40f80fb18d9e32$var$uy[i] * $bd40f80fb18d9e32$var$vx[j] + $bd40f80fb18d9e32$var$vy[i] * $bd40f80fb18d9e32$var$vy[j]);\n            for(let k = 0; k < 16; k++)if ($bd40f80fb18d9e32$var$ux[k] === _ux && $bd40f80fb18d9e32$var$uy[k] === _uy && $bd40f80fb18d9e32$var$vx[k] === _vx && $bd40f80fb18d9e32$var$vy[k] === _vy) {\n                row.push(k);\n                break;\n            }\n        }\n    }\n    for(let i = 0; i < 16; i++){\n        const mat = new (0, $dNaJE.Matrix)();\n        mat.set($bd40f80fb18d9e32$var$ux[i], $bd40f80fb18d9e32$var$uy[i], $bd40f80fb18d9e32$var$vx[i], $bd40f80fb18d9e32$var$vy[i], 0, 0);\n        $bd40f80fb18d9e32$var$rotationMatrices.push(mat);\n    }\n}\n$bd40f80fb18d9e32$var$init();\nconst $bd40f80fb18d9e32$export$b7bb6a2a8d203102 = {\n    /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 0°       | East      |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ E: 0,\n    /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 45°↻     | Southeast |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ SE: 1,\n    /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 90°↻     | South     |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ S: 2,\n    /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 135°↻    | Southwest |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ SW: 3,\n    /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 180°     | West      |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ W: 4,\n    /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -135°/225°↻ | Northwest    |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ NW: 5,\n    /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -90°/270°↻  | North        |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ N: 6,\n    /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -45°/315°↻  | Northeast    |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ NE: 7,\n    /**\n   * Reflection about Y-axis.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ MIRROR_VERTICAL: 8,\n    /**\n   * Reflection about the main diagonal.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ MAIN_DIAGONAL: 10,\n    /**\n   * Reflection about X-axis.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ MIRROR_HORIZONTAL: 12,\n    /**\n   * Reflection about reverse diagonal.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ REVERSE_DIAGONAL: 14,\n    /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The X-component of the U-axis\n   *    after rotating the axes.\n   */ uX: (ind)=>$bd40f80fb18d9e32$var$ux[ind],\n    /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The Y-component of the U-axis\n   *    after rotating the axes.\n   */ uY: (ind)=>$bd40f80fb18d9e32$var$uy[ind],\n    /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The X-component of the V-axis\n   *    after rotating the axes.\n   */ vX: (ind)=>$bd40f80fb18d9e32$var$vx[ind],\n    /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The Y-component of the V-axis\n   *    after rotating the axes.\n   */ vY: (ind)=>$bd40f80fb18d9e32$var$vy[ind],\n    /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotation - symmetry whose opposite\n   *   is needed. Only rotations have opposite symmetries while\n   *   reflections don't.\n   * @returns {GD8Symmetry} The opposite symmetry of `rotation`\n   */ inv: (rotation)=>{\n        if (rotation & 8) return rotation & 15;\n        return -rotation & 7;\n    },\n    /**\n   * Composes the two D8 operations.\n   *\n   * Taking `^` as reflection:\n   *\n   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |\n   * |-------|-----|-----|-----|-----|------|-------|-------|-------|\n   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |\n   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |\n   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |\n   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |\n   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |\n   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |\n   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |\n   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |\n   *\n   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotationSecond - Second operation, which\n   *   is the row in the above cayley table.\n   * @param {GD8Symmetry} rotationFirst - First operation, which\n   *   is the column in the above cayley table.\n   * @returns {GD8Symmetry} Composed operation\n   */ add: (rotationSecond, rotationFirst)=>$bd40f80fb18d9e32$var$rotationCayley[rotationSecond][rotationFirst],\n    /**\n   * Reverse of `add`.\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotationSecond - Second operation\n   * @param {GD8Symmetry} rotationFirst - First operation\n   * @returns {GD8Symmetry} Result\n   */ sub: (rotationSecond, rotationFirst)=>$bd40f80fb18d9e32$var$rotationCayley[rotationSecond][$bd40f80fb18d9e32$export$b7bb6a2a8d203102.inv(rotationFirst)],\n    /**\n   * Adds 180 degrees to rotation, which is a commutative\n   * operation.\n   * @memberof maths.groupD8\n   * @param {number} rotation - The number to rotate.\n   * @returns {number} Rotated number\n   */ rotate180: (rotation)=>rotation ^ 4,\n    /**\n   * Checks if the rotation angle is vertical, i.e. south\n   * or north. It doesn't work for reflections.\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotation - The number to check.\n   * @returns {boolean} Whether or not the direction is vertical\n   */ isVertical: (rotation)=>(rotation & 3) === 2,\n    // rotation % 4 === 2\n    /**\n   * Approximates the vector `V(dx,dy)` into one of the\n   * eight directions provided by `groupD8`.\n   * @memberof maths.groupD8\n   * @param {number} dx - X-component of the vector\n   * @param {number} dy - Y-component of the vector\n   * @returns {GD8Symmetry} Approximation of the vector into\n   *  one of the eight symmetries.\n   */ byDirection: (dx, dy)=>{\n        if (Math.abs(dx) * 2 <= Math.abs(dy)) {\n            if (dy >= 0) return $bd40f80fb18d9e32$export$b7bb6a2a8d203102.S;\n            return $bd40f80fb18d9e32$export$b7bb6a2a8d203102.N;\n        } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {\n            if (dx > 0) return $bd40f80fb18d9e32$export$b7bb6a2a8d203102.E;\n            return $bd40f80fb18d9e32$export$b7bb6a2a8d203102.W;\n        } else if (dy > 0) {\n            if (dx > 0) return $bd40f80fb18d9e32$export$b7bb6a2a8d203102.SE;\n            return $bd40f80fb18d9e32$export$b7bb6a2a8d203102.SW;\n        } else if (dx > 0) return $bd40f80fb18d9e32$export$b7bb6a2a8d203102.NE;\n        return $bd40f80fb18d9e32$export$b7bb6a2a8d203102.NW;\n    },\n    /**\n   * Helps sprite to compensate texture packer rotation.\n   * @memberof maths.groupD8\n   * @param {Matrix} matrix - sprite world matrix\n   * @param {GD8Symmetry} rotation - The rotation factor to use.\n   * @param {number} tx - sprite anchoring\n   * @param {number} ty - sprite anchoring\n   */ matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0)=>{\n        const mat = $bd40f80fb18d9e32$var$rotationMatrices[$bd40f80fb18d9e32$export$b7bb6a2a8d203102.inv(rotation)];\n        mat.tx = tx;\n        mat.ty = ty;\n        matrix.append(mat);\n    }\n};\n\n});\n\nparcelRegister(\"EqaNP\", function(module, exports) {\n\n$parcel$export(module.exports, \"NOOP\", () => $34de18656af55afd$export$5702a91a6f42969f);\n\"use strict\";\nconst $34de18656af55afd$export$5702a91a6f42969f = ()=>{};\n\n});\n\nparcelRegister(\"i8D1k\", function(module, exports) {\n\n$parcel$export(module.exports, \"BufferImageSource\", () => $afe0f8a97373316e$export$1872462350fcb7cd);\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $9Ur0D = parcelRequire(\"9Ur0D\");\n\"use strict\";\nclass $afe0f8a97373316e$export$1872462350fcb7cd extends (0, $9Ur0D.TextureSource) {\n    constructor(options){\n        const buffer = options.resource || new Float32Array(options.width * options.height * 4);\n        let format = options.format;\n        if (!format) {\n            if (buffer instanceof Float32Array) format = \"rgba32float\";\n            else if (buffer instanceof Int32Array) format = \"rgba32uint\";\n            else if (buffer instanceof Uint32Array) format = \"rgba32uint\";\n            else if (buffer instanceof Int16Array) format = \"rgba16uint\";\n            else if (buffer instanceof Uint16Array) format = \"rgba16uint\";\n            else if (buffer instanceof Int8Array) format = \"bgra8unorm\";\n            else format = \"bgra8unorm\";\n        }\n        super({\n            ...options,\n            resource: buffer,\n            format: format\n        });\n        this.uploadMethodId = \"buffer\";\n    }\n    static test(resource) {\n        return resource instanceof Int8Array || resource instanceof Uint8Array || resource instanceof Uint8ClampedArray || resource instanceof Int16Array || resource instanceof Uint16Array || resource instanceof Int32Array || resource instanceof Uint32Array || resource instanceof Float32Array;\n    }\n}\n$afe0f8a97373316e$export$1872462350fcb7cd.extension = (0, $eVz1R.ExtensionType).TextureSource;\n\n});\nparcelRegister(\"9Ur0D\", function(module, exports) {\n\n$parcel$export(module.exports, \"TextureSource\", () => $e85e2e39710bed0b$export$8498e6a2e655d3d8);\n\nvar $gpXaq = parcelRequire(\"gpXaq\");\n\nvar $domwE = parcelRequire(\"domwE\");\n\nvar $5d1vV = parcelRequire(\"5d1vV\");\n\nvar $l80qL = parcelRequire(\"l80qL\");\n\nvar $2mVLe = parcelRequire(\"2mVLe\");\n\"use strict\";\nconst $e85e2e39710bed0b$var$_TextureSource = class _TextureSource extends (0, (/*@__PURE__*/$parcel$interopDefault($gpXaq))) {\n    /**\n   * @param options - options for creating a new TextureSource\n   */ constructor(options = {}){\n        super();\n        this.options = options;\n        /** unique id for this Texture source */ this.uid = (0, $l80qL.uid)(\"textureSource\");\n        /**\n     * The resource type used by this TextureSource. This is used by the bind groups to determine\n     * how to handle this resource.\n     * @ignore\n     * @internal\n     */ this._resourceType = \"textureSource\";\n        /**\n     * i unique resource id, used by the bind group systems.\n     * This can change if the texture is resized or its resource changes\n     */ this._resourceId = (0, $l80qL.uid)(\"resource\");\n        /**\n     * this is how the backends know how to upload this texture to the GPU\n     * It changes depending on the resource type. Classes that extend TextureSource\n     * should override this property.\n     * @ignore\n     * @internal\n     */ this.uploadMethodId = \"unknown\";\n        // dimensions\n        this._resolution = 1;\n        /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */ this.pixelWidth = 1;\n        /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */ this.pixelHeight = 1;\n        /**\n     * the width of this texture source, accounting for resolution\n     * eg pixelWidth 200, resolution 2, then width will be 100\n     */ this.width = 1;\n        /**\n     * the height of this texture source, accounting for resolution\n     * eg pixelHeight 200, resolution 2, then height will be 100\n     */ this.height = 1;\n        /**\n     * The number of samples of a multisample texture. This is always 1 for non-multisample textures.\n     * To enable multisample for a texture, set antialias to true\n     * @internal\n     * @ignore\n     */ this.sampleCount = 1;\n        /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */ this.mipLevelCount = 1;\n        /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */ this.autoGenerateMipmaps = false;\n        /** the format that the texture data has */ this.format = \"rgba8unorm\";\n        /** how many dimensions does this texture have? currently v8 only supports 2d */ this.dimension = \"2d\";\n        /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */ this.antialias = false;\n        /**\n     * Used by automatic texture Garbage Collection, stores last GC tick when it was bound\n     * @protected\n     */ this._touched = 0;\n        /**\n     * Used by the batcher to build texture batches. faster to have the variable here!\n     * @protected\n     */ this._batchTick = -1;\n        /**\n     * A temporary batch location for the texture batching. Here for performance reasons only!\n     * @protected\n     */ this._textureBindLocation = -1;\n        options = {\n            ..._TextureSource.defaultOptions,\n            ...options\n        };\n        this.label = options.label ?? \"\";\n        this.resource = options.resource;\n        this.autoGarbageCollect = options.autoGarbageCollect;\n        this._resolution = options.resolution;\n        if (options.width) this.pixelWidth = options.width * this._resolution;\n        else this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1;\n        if (options.height) this.pixelHeight = options.height * this._resolution;\n        else this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1;\n        this.width = this.pixelWidth / this._resolution;\n        this.height = this.pixelHeight / this._resolution;\n        this.format = options.format;\n        this.dimension = options.dimensions;\n        this.mipLevelCount = options.mipLevelCount;\n        this.autoGenerateMipmaps = options.autoGenerateMipmaps;\n        this.sampleCount = options.sampleCount;\n        this.antialias = options.antialias;\n        this.alphaMode = options.alphaMode;\n        this.style = new (0, $2mVLe.TextureStyle)((0, $5d1vV.definedProps)(options));\n        this.destroyed = false;\n        this._refreshPOT();\n    }\n    /** returns itself */ get source() {\n        return this;\n    }\n    /** the style of the texture */ get style() {\n        return this._style;\n    }\n    set style(value) {\n        if (this.style === value) return;\n        this._style?.off(\"change\", this._onStyleChange, this);\n        this._style = value;\n        this._style?.on(\"change\", this._onStyleChange, this);\n        this._onStyleChange();\n    }\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */ get addressMode() {\n        return this._style.addressMode;\n    }\n    set addressMode(value) {\n        this._style.addressMode = value;\n    }\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */ get repeatMode() {\n        return this._style.addressMode;\n    }\n    set repeatMode(value) {\n        this._style.addressMode = value;\n    }\n    /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */ get magFilter() {\n        return this._style.magFilter;\n    }\n    set magFilter(value) {\n        this._style.magFilter = value;\n    }\n    /** Specifies the sampling behavior when the sample footprint is larger than one texel. */ get minFilter() {\n        return this._style.minFilter;\n    }\n    set minFilter(value) {\n        this._style.minFilter = value;\n    }\n    /** Specifies behavior for sampling between mipmap levels. */ get mipmapFilter() {\n        return this._style.mipmapFilter;\n    }\n    set mipmapFilter(value) {\n        this._style.mipmapFilter = value;\n    }\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */ get lodMinClamp() {\n        return this._style.lodMinClamp;\n    }\n    set lodMinClamp(value) {\n        this._style.lodMinClamp = value;\n    }\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */ get lodMaxClamp() {\n        return this._style.lodMaxClamp;\n    }\n    set lodMaxClamp(value) {\n        this._style.lodMaxClamp = value;\n    }\n    _onStyleChange() {\n        this.emit(\"styleChange\", this);\n    }\n    /** call this if you have modified the texture outside of the constructor */ update() {\n        if (this.resource) {\n            const resolution = this._resolution;\n            const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);\n            if (didResize) return;\n        }\n        this.emit(\"update\", this);\n    }\n    /** Destroys this texture source */ destroy() {\n        this.destroyed = true;\n        this.emit(\"destroy\", this);\n        if (this._style) {\n            this._style.destroy();\n            this._style = null;\n        }\n        this.uploadMethodId = null;\n        this.resource = null;\n        this.removeAllListeners();\n    }\n    /**\n   * This will unload the Texture source from the GPU. This will free up the GPU memory\n   * As soon as it is required fore rendering, it will be re-uploaded.\n   */ unload() {\n        this._resourceId = (0, $l80qL.uid)(\"resource\");\n        this.emit(\"change\", this);\n        this.emit(\"unload\", this);\n    }\n    /** the width of the resource. This is the REAL pure number, not accounting resolution   */ get resourceWidth() {\n        const { resource: resource } = this;\n        return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;\n    }\n    /** the height of the resource. This is the REAL pure number, not accounting resolution */ get resourceHeight() {\n        const { resource: resource } = this;\n        return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;\n    }\n    /**\n   * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture\n   * but will the size of the texture when rendered.\n   *\n   * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel\n   * density will have increased)\n   */ get resolution() {\n        return this._resolution;\n    }\n    set resolution(resolution) {\n        if (this._resolution === resolution) return;\n        this._resolution = resolution;\n        this.width = this.pixelWidth / resolution;\n        this.height = this.pixelHeight / resolution;\n    }\n    /**\n   * Resize the texture, this is handy if you want to use the texture as a render texture\n   * @param width - the new width of the texture\n   * @param height - the new height of the texture\n   * @param resolution - the new resolution of the texture\n   * @returns - if the texture was resized\n   */ resize(width, height, resolution) {\n        resolution = resolution || this._resolution;\n        width = width || this.width;\n        height = height || this.height;\n        const newPixelWidth = Math.round(width * resolution);\n        const newPixelHeight = Math.round(height * resolution);\n        this.width = newPixelWidth / resolution;\n        this.height = newPixelHeight / resolution;\n        this._resolution = resolution;\n        if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) return false;\n        this._refreshPOT();\n        this.pixelWidth = newPixelWidth;\n        this.pixelHeight = newPixelHeight;\n        this.emit(\"resize\", this);\n        this._resourceId = (0, $l80qL.uid)(\"resource\");\n        this.emit(\"change\", this);\n        return true;\n    }\n    /**\n   * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.\n   * This is only important for RenderTexture instances, as standard Texture instances will have their\n   * mipmaps generated on upload. You should call this method after you make any change to the texture\n   *\n   * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,\n   * We want you, the developer to specify when this action should happen.\n   *\n   * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,\n   */ updateMipmaps() {\n        if (this.autoGenerateMipmaps && this.mipLevelCount > 1) this.emit(\"updateMipmaps\", this);\n    }\n    set wrapMode(value) {\n        this._style.wrapMode = value;\n    }\n    get wrapMode() {\n        return this._style.wrapMode;\n    }\n    set scaleMode(value) {\n        this._style.scaleMode = value;\n    }\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */ get scaleMode() {\n        return this._style.scaleMode;\n    }\n    /**\n   * Refresh check for isPowerOfTwo texture based on size\n   * @private\n   */ _refreshPOT() {\n        this.isPowerOfTwo = (0, $domwE.isPow2)(this.pixelWidth) && (0, $domwE.isPow2)(this.pixelHeight);\n    }\n    static test(_resource) {\n        throw new Error(\"Unimplemented\");\n    }\n};\n/** The default options used when creating a new TextureSource. override these to add your own defaults */ $e85e2e39710bed0b$var$_TextureSource.defaultOptions = {\n    resolution: 1,\n    format: \"bgra8unorm\",\n    alphaMode: \"premultiply-alpha-on-upload\",\n    dimensions: \"2d\",\n    mipLevelCount: 1,\n    autoGenerateMipmaps: false,\n    sampleCount: 1,\n    antialias: false,\n    autoGarbageCollect: false\n};\nlet $e85e2e39710bed0b$export$8498e6a2e655d3d8 = $e85e2e39710bed0b$var$_TextureSource;\n\n});\nparcelRegister(\"domwE\", function(module, exports) {\n\n$parcel$export(module.exports, \"nextPow2\", () => $c53d88fff3c2b5cd$export$f0d90cf68bd426eb);\n$parcel$export(module.exports, \"isPow2\", () => $c53d88fff3c2b5cd$export$eb50b9c078eb6ae7);\n\"use strict\";\nfunction $c53d88fff3c2b5cd$export$f0d90cf68bd426eb(v) {\n    v += v === 0 ? 1 : 0;\n    --v;\n    v |= v >>> 1;\n    v |= v >>> 2;\n    v |= v >>> 4;\n    v |= v >>> 8;\n    v |= v >>> 16;\n    return v + 1;\n}\nfunction $c53d88fff3c2b5cd$export$eb50b9c078eb6ae7(v) {\n    return !(v & v - 1) && !!v;\n}\nfunction $c53d88fff3c2b5cd$export$b9fae0bba9d9094d(v) {\n    let r = (v > 65535 ? 1 : 0) << 4;\n    v >>>= r;\n    let shift = (v > 255 ? 1 : 0) << 3;\n    v >>>= shift;\n    r |= shift;\n    shift = (v > 15 ? 1 : 0) << 2;\n    v >>>= shift;\n    r |= shift;\n    shift = (v > 3 ? 1 : 0) << 1;\n    v >>>= shift;\n    r |= shift;\n    return r | v >> 1;\n}\n\n});\n\nparcelRegister(\"5d1vV\", function(module, exports) {\n\n$parcel$export(module.exports, \"definedProps\", () => $a2e0819df772f5e5$export$801feaffb936a09d);\n\"use strict\";\nfunction $a2e0819df772f5e5$export$801feaffb936a09d(obj) {\n    const result = {};\n    for(const key in obj)if (obj[key] !== void 0) result[key] = obj[key];\n    return result;\n}\n\n});\n\nparcelRegister(\"2mVLe\", function(module, exports) {\n\n$parcel$export(module.exports, \"TextureStyle\", () => $d157fdece7dbd785$export$1ce1d0c10d3de5d5);\n\nvar $gpXaq = parcelRequire(\"gpXaq\");\n\nvar $l80qL = parcelRequire(\"l80qL\");\n\nvar $eX50w = parcelRequire(\"eX50w\");\n\"use strict\";\nconst $d157fdece7dbd785$var$idHash = /* @__PURE__ */ Object.create(null);\nfunction $d157fdece7dbd785$var$createResourceIdFromString(value) {\n    const id = $d157fdece7dbd785$var$idHash[value];\n    if (id === void 0) $d157fdece7dbd785$var$idHash[value] = (0, $l80qL.uid)(\"resource\");\n    return id;\n}\nconst $d157fdece7dbd785$var$_TextureStyle = class _TextureStyle extends (0, (/*@__PURE__*/$parcel$interopDefault($gpXaq))) {\n    /**\n   * @param options - options for the style\n   */ constructor(options = {}){\n        super();\n        this._resourceType = \"textureSampler\";\n        this._touched = 0;\n        /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link GPUSamplerDescriptor#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     * @internal\n     * @ignore\n     */ this._maxAnisotropy = 1;\n        options = {\n            ..._TextureStyle.defaultOptions,\n            ...options\n        };\n        this.addressMode = options.addressMode;\n        this.addressModeU = options.addressModeU ?? this.addressModeU;\n        this.addressModeV = options.addressModeV ?? this.addressModeV;\n        this.addressModeW = options.addressModeW ?? this.addressModeW;\n        this.scaleMode = options.scaleMode;\n        this.magFilter = options.magFilter ?? this.magFilter;\n        this.minFilter = options.minFilter ?? this.minFilter;\n        this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;\n        this.lodMinClamp = options.lodMinClamp;\n        this.lodMaxClamp = options.lodMaxClamp;\n        this.compare = options.compare;\n        this.maxAnisotropy = options.maxAnisotropy ?? 1;\n    }\n    set addressMode(value) {\n        this.addressModeU = value;\n        this.addressModeV = value;\n        this.addressModeW = value;\n    }\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */ get addressMode() {\n        return this.addressModeU;\n    }\n    set wrapMode(value) {\n        (0, $eX50w.deprecation)((0, $eX50w.v8_0_0), \"TextureStyle.wrapMode is now TextureStyle.addressMode\");\n        this.addressMode = value;\n    }\n    get wrapMode() {\n        return this.addressMode;\n    }\n    set scaleMode(value) {\n        this.magFilter = value;\n        this.minFilter = value;\n        this.mipmapFilter = value;\n    }\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */ get scaleMode() {\n        return this.magFilter;\n    }\n    /** Specifies the maximum anisotropy value clamp used by the sampler. */ set maxAnisotropy(value) {\n        this._maxAnisotropy = Math.min(value, 16);\n        if (this._maxAnisotropy > 1) this.scaleMode = \"linear\";\n    }\n    get maxAnisotropy() {\n        return this._maxAnisotropy;\n    }\n    // TODO - move this to WebGL?\n    get _resourceId() {\n        return this._sharedResourceId || this._generateResourceId();\n    }\n    update() {\n        this.emit(\"change\", this);\n        this._sharedResourceId = null;\n    }\n    _generateResourceId() {\n        const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;\n        this._sharedResourceId = $d157fdece7dbd785$var$createResourceIdFromString(bigKey);\n        return this._resourceId;\n    }\n    /** Destroys the style */ destroy() {\n        this.emit(\"destroy\", this);\n        this.removeAllListeners();\n    }\n};\n/** default options for the style */ $d157fdece7dbd785$var$_TextureStyle.defaultOptions = {\n    addressMode: \"clamp-to-edge\",\n    scaleMode: \"linear\"\n};\nlet $d157fdece7dbd785$export$1ce1d0c10d3de5d5 = $d157fdece7dbd785$var$_TextureStyle;\n\n});\n\n\n\nparcelRegister(\"iKeK4\", function(module, exports) {\n\n$parcel$export(module.exports, \"TextureMatrix\", () => $ab4f62e2624c4c4f$export$dbea3135e9da48cb);\n\nvar $dNaJE = parcelRequire(\"dNaJE\");\n\"use strict\";\nconst $ab4f62e2624c4c4f$var$tempMat = new (0, $dNaJE.Matrix)();\nclass $ab4f62e2624c4c4f$export$dbea3135e9da48cb {\n    /**\n   * @param texture - observed texture\n   * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n   */ constructor(texture, clampMargin){\n        this.mapCoord = new (0, $dNaJE.Matrix)();\n        this.uClampFrame = new Float32Array(4);\n        this.uClampOffset = new Float32Array(2);\n        this._textureID = -1;\n        this._updateID = 0;\n        this.clampOffset = 0;\n        if (typeof clampMargin === \"undefined\") this.clampMargin = texture.width < 10 ? 0 : 0.5;\n        else this.clampMargin = clampMargin;\n        this.isSimple = false;\n        this.texture = texture;\n    }\n    /** Texture property. */ get texture() {\n        return this._texture;\n    }\n    set texture(value) {\n        if (this.texture === value) return;\n        this._texture?.removeListener(\"update\", this.update, this);\n        this._texture = value;\n        this._texture.addListener(\"update\", this.update, this);\n        this.update();\n    }\n    /**\n   * Multiplies uvs array to transform\n   * @param uvs - mesh uvs\n   * @param [out=uvs] - output\n   * @returns - output\n   */ multiplyUvs(uvs, out) {\n        if (out === void 0) out = uvs;\n        const mat = this.mapCoord;\n        for(let i = 0; i < uvs.length; i += 2){\n            const x = uvs[i];\n            const y = uvs[i + 1];\n            out[i] = x * mat.a + y * mat.c + mat.tx;\n            out[i + 1] = x * mat.b + y * mat.d + mat.ty;\n        }\n        return out;\n    }\n    /**\n   * Updates matrices if texture was changed\n   * @returns - whether or not it was updated\n   */ update() {\n        const tex = this._texture;\n        this._updateID++;\n        const uvs = tex.uvs;\n        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n        const orig = tex.orig;\n        const trim = tex.trim;\n        if (trim) {\n            $ab4f62e2624c4c4f$var$tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);\n            this.mapCoord.append($ab4f62e2624c4c4f$var$tempMat);\n        }\n        const texBase = tex.source;\n        const frame = this.uClampFrame;\n        const margin = this.clampMargin / texBase._resolution;\n        const offset = this.clampOffset;\n        frame[0] = (tex.frame.x + margin + offset) / texBase.width;\n        frame[1] = (tex.frame.y + margin + offset) / texBase.height;\n        frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;\n        frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;\n        this.uClampOffset[0] = offset / texBase.pixelWidth;\n        this.uClampOffset[1] = offset / texBase.pixelHeight;\n        this.isSimple = tex.frame.width === texBase.width && tex.frame.height === texBase.height && tex.rotate === 0;\n        return true;\n    }\n}\n\n});\n\n\nparcelRegister(\"9Qy7u\", function(module, exports) {\n\n$parcel$export(module.exports, \"Sprite\", () => $f036b574519dd81d$export$3075603db8e6204c);\n\nvar $ep73P = parcelRequire(\"ep73P\");\n\nvar $5h88T = parcelRequire(\"5h88T\");\n\nvar $1ZKfN = parcelRequire(\"1ZKfN\");\n\nvar $lR3Ev = parcelRequire(\"lR3Ev\");\n\"use strict\";\nclass $f036b574519dd81d$export$3075603db8e6204c extends (0, $lR3Ev.Container) {\n    /**\n   * @param options - The options for creating the sprite.\n   */ constructor(options = (0, $5h88T.Texture).EMPTY){\n        if (options instanceof (0, $5h88T.Texture)) options = {\n            texture: options\n        };\n        const { texture: texture, anchor: anchor, roundPixels: roundPixels, width: width, height: height, ...rest } = options;\n        super({\n            label: \"Sprite\",\n            ...rest\n        });\n        this.renderPipeId = \"sprite\";\n        this.batched = true;\n        this._didSpriteUpdate = false;\n        this._bounds = {\n            minX: 0,\n            maxX: 1,\n            minY: 0,\n            maxY: 0\n        };\n        this._sourceBounds = {\n            minX: 0,\n            maxX: 1,\n            minY: 0,\n            maxY: 0\n        };\n        this._boundsDirty = true;\n        this._sourceBoundsDirty = true;\n        this._roundPixels = 0;\n        this._anchor = new (0, $ep73P.ObservablePoint)({\n            _onUpdate: ()=>{\n                this.onViewUpdate();\n            }\n        });\n        if (anchor) this.anchor = anchor;\n        this.texture = texture;\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n        if (width) this.width = width;\n        if (height) this.height = height;\n    }\n    /**\n   * Helper function that creates a new sprite based on the source you provide.\n   * The source can be - frame id, image, video, canvas element, video element, texture\n   * @param source - Source to create texture from\n   * @param [skipCache] - Whether to skip the cache or not\n   * @returns The newly created sprite\n   */ static from(source, skipCache = false) {\n        if (source instanceof (0, $5h88T.Texture)) return new $f036b574519dd81d$export$3075603db8e6204c(source);\n        return new $f036b574519dd81d$export$3075603db8e6204c((0, $5h88T.Texture).from(source, skipCache));\n    }\n    set texture(value) {\n        value || (value = (0, $5h88T.Texture).EMPTY);\n        const currentTexture = this._texture;\n        if (currentTexture === value) return;\n        if (currentTexture && currentTexture.dynamic) currentTexture.off(\"update\", this.onViewUpdate, this);\n        if (value.dynamic) value.on(\"update\", this.onViewUpdate, this);\n        this._texture = value;\n        this.onViewUpdate();\n    }\n    /** The texture that the sprite is using. */ get texture() {\n        return this._texture;\n    }\n    /**\n   * The local bounds of the sprite.\n   * @type {rendering.Bounds}\n   */ get bounds() {\n        if (this._boundsDirty) {\n            this._updateBounds();\n            this._boundsDirty = false;\n        }\n        return this._bounds;\n    }\n    /**\n   * The bounds of the sprite, taking the texture's trim into account.\n   * @type {rendering.Bounds}\n   */ get sourceBounds() {\n        if (this._sourceBoundsDirty) {\n            this._updateSourceBounds();\n            this._sourceBoundsDirty = false;\n        }\n        return this._sourceBounds;\n    }\n    /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */ containsPoint(point) {\n        const bounds = this.sourceBounds;\n        if (point.x >= bounds.maxX && point.x <= bounds.minX) {\n            if (point.y >= bounds.maxY && point.y <= bounds.minY) return true;\n        }\n        return false;\n    }\n    /**\n   * Adds the bounds of this object to the bounds object.\n   * @param bounds - The output bounds object.\n   */ addBounds(bounds) {\n        const _bounds = this._texture.trim ? this.sourceBounds : this.bounds;\n        bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);\n    }\n    onViewUpdate() {\n        this._didChangeId += 4096;\n        this._didSpriteUpdate = true;\n        this._sourceBoundsDirty = this._boundsDirty = true;\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n        if (this.renderGroup) this.renderGroup.onChildViewUpdate(this);\n    }\n    _updateBounds() {\n        (0, $1ZKfN.updateQuadBounds)(this._bounds, this._anchor, this._texture, 0);\n    }\n    _updateSourceBounds() {\n        const anchor = this._anchor;\n        const texture = this._texture;\n        const sourceBounds = this._sourceBounds;\n        const { width: width, height: height } = texture.orig;\n        sourceBounds.maxX = -anchor._x * width;\n        sourceBounds.minX = sourceBounds.maxX + width;\n        sourceBounds.maxY = -anchor._y * height;\n        sourceBounds.minY = sourceBounds.maxY + height;\n    }\n    /**\n   * Destroys this sprite renderable and optionally its texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n   */ destroy(options = false) {\n        super.destroy(options);\n        const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n        if (destroyTexture) {\n            const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n            this._texture.destroy(destroyTextureSource);\n        }\n        this._texture = null;\n        this._bounds = null;\n        this._sourceBounds = null;\n        this._anchor = null;\n    }\n    /**\n   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n   * and passed to the constructor.\n   *\n   * The default is `(0,0)`, this means the sprite's origin is the top left.\n   *\n   * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n   *\n   * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * import { Sprite } from 'pixi.js';\n   *\n   * const sprite = new Sprite({texture: Texture.WHITE});\n   * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n   */ get anchor() {\n        return this._anchor;\n    }\n    set anchor(value) {\n        typeof value === \"number\" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n    /**\n   *  Whether or not to round the x/y position of the sprite.\n   * @type {boolean}\n   */ get roundPixels() {\n        return !!this._roundPixels;\n    }\n    set roundPixels(value) {\n        this._roundPixels = value ? 1 : 0;\n    }\n    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */ get width() {\n        return Math.abs(this.scale.x) * this._texture.orig.width;\n    }\n    set width(value) {\n        this._setWidth(value, this._texture.orig.width);\n    }\n    /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */ get height() {\n        return Math.abs(this.scale.y) * this._texture.orig.height;\n    }\n    set height(value) {\n        this._setHeight(value, this._texture.orig.height);\n    }\n    /**\n   * Retrieves the size of the Sprite as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the Sprite.\n   */ getSize(out) {\n        if (!out) out = {};\n        out.width = Math.abs(this.scale.x) * this._texture.orig.width;\n        out.height = Math.abs(this.scale.y) * this._texture.orig.height;\n        return out;\n    }\n    /**\n   * Sets the size of the Sprite to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   */ setSize(value, height) {\n        let convertedWidth;\n        let convertedHeight;\n        if (typeof value !== \"object\") {\n            convertedWidth = value;\n            convertedHeight = height ?? value;\n        } else {\n            convertedWidth = value.width;\n            convertedHeight = value.height ?? value.width;\n        }\n        if (convertedWidth !== void 0) this._setWidth(convertedWidth, this._texture.orig.width);\n        if (convertedHeight !== void 0) this._setHeight(convertedHeight, this._texture.orig.height);\n    }\n}\n\n});\nparcelRegister(\"1ZKfN\", function(module, exports) {\n\n$parcel$export(module.exports, \"updateQuadBounds\", () => $16e40cd364463874$export$558ce66aa5723f1d);\n\"use strict\";\nfunction $16e40cd364463874$export$558ce66aa5723f1d(bounds, anchor, texture, padding) {\n    const { width: width, height: height } = texture.orig;\n    const trim = texture.trim;\n    if (trim) {\n        const sourceWidth = trim.width;\n        const sourceHeight = trim.height;\n        bounds.minX = trim.x - anchor._x * width - padding;\n        bounds.maxX = bounds.minX + sourceWidth;\n        bounds.minY = trim.y - anchor._y * height - padding;\n        bounds.maxY = bounds.minY + sourceHeight;\n    } else {\n        bounds.minX = -anchor._x * width - padding;\n        bounds.maxX = bounds.minX + width;\n        bounds.minY = -anchor._y * height - padding;\n        bounds.maxY = bounds.minY + height;\n    }\n    return;\n}\n\n});\n\n\nparcelRegister(\"2rfX3\", function(module, exports) {\n\n$parcel$export(module.exports, \"CanvasSource\", () => $7d034785613a03fe$export$ca65ccf5708c6a0c);\n\nvar $5m2Qn = parcelRequire(\"5m2Qn\");\n\nvar $eVz1R = parcelRequire(\"eVz1R\");\n\nvar $9Ur0D = parcelRequire(\"9Ur0D\");\n\"use strict\";\nclass $7d034785613a03fe$export$ca65ccf5708c6a0c extends (0, $9Ur0D.TextureSource) {\n    constructor(options){\n        if (!options.resource) options.resource = (0, $5m2Qn.DOMAdapter).get().createCanvas();\n        if (!options.width) {\n            options.width = options.resource.width;\n            if (!options.autoDensity) options.width /= options.resolution;\n        }\n        if (!options.height) {\n            options.height = options.resource.height;\n            if (!options.autoDensity) options.height /= options.resolution;\n        }\n        super(options);\n        this.uploadMethodId = \"image\";\n        this.autoDensity = options.autoDensity;\n        const canvas = options.resource;\n        if (this.pixelWidth !== canvas.width || this.pixelWidth !== canvas.height) this.resizeCanvas();\n        this.transparent = !!options.transparent;\n    }\n    resizeCanvas() {\n        if (this.autoDensity) {\n            this.resource.style.width = `${this.width}px`;\n            this.resource.style.height = `${this.height}px`;\n        }\n        if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) {\n            this.resource.width = this.pixelWidth;\n            this.resource.height = this.pixelHeight;\n        }\n    }\n    resize(width = this.width, height = this.height, resolution = this._resolution) {\n        const didResize = super.resize(width, height, resolution);\n        if (didResize) this.resizeCanvas();\n        return didResize;\n    }\n    static test(resource) {\n        return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas;\n    }\n}\n$7d034785613a03fe$export$ca65ccf5708c6a0c.extension = (0, $eVz1R.ExtensionType).TextureSource;\n\n});\n\nparcelRegister(\"h1qkv\", function(module, exports) {\n\n$parcel$export(module.exports, \"BatchGeometry\", () => $6387a2f1cd429ccd$export$449e8d355fd68e43);\n\nvar $2qhsM = parcelRequire(\"2qhsM\");\n\nvar $cnPar = parcelRequire(\"cnPar\");\n\nvar $kFbJv = parcelRequire(\"kFbJv\");\n\"use strict\";\nconst $6387a2f1cd429ccd$var$placeHolderBufferData = new Float32Array(1);\nconst $6387a2f1cd429ccd$var$placeHolderIndexData = new Uint32Array(1);\nclass $6387a2f1cd429ccd$export$449e8d355fd68e43 extends (0, $kFbJv.Geometry) {\n    constructor(){\n        const vertexSize = 6;\n        const attributeBuffer = new (0, $2qhsM.Buffer)({\n            data: $6387a2f1cd429ccd$var$placeHolderBufferData,\n            label: \"attribute-batch-buffer\",\n            usage: (0, $cnPar.BufferUsage).VERTEX | (0, $cnPar.BufferUsage).COPY_DST,\n            shrinkToFit: false\n        });\n        const indexBuffer = new (0, $2qhsM.Buffer)({\n            data: $6387a2f1cd429ccd$var$placeHolderIndexData,\n            label: \"index-batch-buffer\",\n            usage: (0, $cnPar.BufferUsage).INDEX | (0, $cnPar.BufferUsage).COPY_DST,\n            // | BufferUsage.STATIC,\n            shrinkToFit: false\n        });\n        const stride = vertexSize * 4;\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: attributeBuffer,\n                    format: \"float32x2\",\n                    stride: stride,\n                    offset: 0,\n                    location: 1\n                },\n                aUV: {\n                    buffer: attributeBuffer,\n                    format: \"float32x2\",\n                    stride: stride,\n                    offset: 8,\n                    location: 3\n                },\n                aColor: {\n                    buffer: attributeBuffer,\n                    format: \"unorm8x4\",\n                    stride: stride,\n                    offset: 16,\n                    location: 0\n                },\n                aTextureIdAndRound: {\n                    buffer: attributeBuffer,\n                    format: \"uint16x2\",\n                    stride: stride,\n                    offset: 20,\n                    location: 2\n                }\n            },\n            indexBuffer: indexBuffer\n        });\n    }\n}\n\n});\nparcelRegister(\"2qhsM\", function(module, exports) {\n\n$parcel$export(module.exports, \"Buffer\", () => $b7e882ef59b860cf$export$a143d493d941bafc);\n\nvar $gpXaq = parcelRequire(\"gpXaq\");\n\nvar $l80qL = parcelRequire(\"l80qL\");\n\nvar $cnPar = parcelRequire(\"cnPar\");\n\"use strict\";\nclass $b7e882ef59b860cf$export$a143d493d941bafc extends (0, (/*@__PURE__*/$parcel$interopDefault($gpXaq))) {\n    /**\n   * Creates a new Buffer with the given options\n   * @param options - the options for the buffer\n   */ constructor(options){\n        let { data: data, size: size } = options;\n        const { usage: usage, label: label, shrinkToFit: shrinkToFit } = options;\n        super();\n        /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */ /**\n     * emits when the underlying buffer data has been updated. letting the renderer know\n     * that it needs to update the buffer on the GPU\n     * @event update\n     */ /**\n     * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU\n     * @event destroy\n     */ /**\n     * a unique id for this uniform group used through the renderer\n     * @internal\n     * @ignore\n     */ this.uid = (0, $l80qL.uid)(\"buffer\");\n        /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */ this._resourceType = \"buffer\";\n        /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */ this._resourceId = (0, $l80qL.uid)(\"resource\");\n        /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */ this._touched = 0;\n        /**\n     * @internal\n     * @ignore\n     */ this._updateID = 1;\n        /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */ this.shrinkToFit = true;\n        if (data instanceof Array) data = new Float32Array(data);\n        this._data = data;\n        size = size ?? data?.byteLength;\n        const mappedAtCreation = !!data;\n        this.descriptor = {\n            size: size,\n            usage: usage,\n            mappedAtCreation: mappedAtCreation,\n            label: label\n        };\n        this.shrinkToFit = shrinkToFit ?? true;\n    }\n    /** the data in the buffer */ get data() {\n        return this._data;\n    }\n    set data(value) {\n        this.setDataWithSize(value, value.length, true);\n    }\n    /** whether the buffer is static or not */ get static() {\n        return !!(this.descriptor.usage & (0, $cnPar.BufferUsage).STATIC);\n    }\n    set static(value) {\n        if (value) this.descriptor.usage |= (0, $cnPar.BufferUsage).STATIC;\n        else this.descriptor.usage &= ~(0, $cnPar.BufferUsage).STATIC;\n    }\n    /**\n   * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.\n   * If you only want to update a subset of the buffer, you can pass in the size of the data.\n   * @param value - the data to set\n   * @param size - the size of the data in bytes\n   * @param syncGPU - should the buffer be updated on the GPU immediately?\n   */ setDataWithSize(value, size, syncGPU) {\n        this._updateID++;\n        this._updateSize = size * value.BYTES_PER_ELEMENT;\n        if (this._data === value) {\n            if (syncGPU) this.emit(\"update\", this);\n            return;\n        }\n        const oldData = this._data;\n        this._data = value;\n        if (oldData.length !== value.length) {\n            if (!this.shrinkToFit && value.byteLength < oldData.byteLength) {\n                if (syncGPU) this.emit(\"update\", this);\n            } else {\n                this.descriptor.size = value.byteLength;\n                this._resourceId = (0, $l80qL.uid)(\"resource\");\n                this.emit(\"change\", this);\n            }\n            return;\n        }\n        if (syncGPU) this.emit(\"update\", this);\n    }\n    /**\n   * updates the buffer on the GPU to reflect the data in the buffer.\n   * By default it will update the entire buffer. If you only want to update a subset of the buffer,\n   * you can pass in the size of the buffer to update.\n   * @param sizeInBytes - the new size of the buffer in bytes\n   */ update(sizeInBytes) {\n        this._updateSize = sizeInBytes ?? this._updateSize;\n        this._updateID++;\n        this.emit(\"update\", this);\n    }\n    /** Destroys the buffer */ destroy() {\n        this.emit(\"destroy\", this);\n        this._data = null;\n        this.descriptor = null;\n        this.removeAllListeners();\n    }\n}\n\n});\nparcelRegister(\"cnPar\", function(module, exports) {\n\n$parcel$export(module.exports, \"BufferUsage\", () => $f342a3bbf89638f5$export$f8deb2be8632fd10);\n\"use strict\";\nvar $f342a3bbf89638f5$export$f8deb2be8632fd10 = /* @__PURE__ */ ((BufferUsage2)=>{\n    BufferUsage2[BufferUsage2[\"MAP_READ\"] = 1] = \"MAP_READ\";\n    BufferUsage2[BufferUsage2[\"MAP_WRITE\"] = 2] = \"MAP_WRITE\";\n    BufferUsage2[BufferUsage2[\"COPY_SRC\"] = 4] = \"COPY_SRC\";\n    BufferUsage2[BufferUsage2[\"COPY_DST\"] = 8] = \"COPY_DST\";\n    BufferUsage2[BufferUsage2[\"INDEX\"] = 16] = \"INDEX\";\n    BufferUsage2[BufferUsage2[\"VERTEX\"] = 32] = \"VERTEX\";\n    BufferUsage2[BufferUsage2[\"UNIFORM\"] = 64] = \"UNIFORM\";\n    BufferUsage2[BufferUsage2[\"STORAGE\"] = 128] = \"STORAGE\";\n    BufferUsage2[BufferUsage2[\"INDIRECT\"] = 256] = \"INDIRECT\";\n    BufferUsage2[BufferUsage2[\"QUERY_RESOLVE\"] = 512] = \"QUERY_RESOLVE\";\n    BufferUsage2[BufferUsage2[\"STATIC\"] = 1024] = \"STATIC\";\n    return BufferUsage2;\n})($f342a3bbf89638f5$export$f8deb2be8632fd10 || {});\n\n});\n\n\nparcelRegister(\"kFbJv\", function(module, exports) {\n\n$parcel$export(module.exports, \"Geometry\", () => $2e3c8c2d71c2725b$export$2db6c17465f94a2);\n\nvar $gpXaq = parcelRequire(\"gpXaq\");\n\nvar $ggeMF = parcelRequire(\"ggeMF\");\n\nvar $l80qL = parcelRequire(\"l80qL\");\n\nvar $2qhsM = parcelRequire(\"2qhsM\");\n\nvar $h4RvW = parcelRequire(\"h4RvW\");\n\nvar $6RtYG = parcelRequire(\"6RtYG\");\n\"use strict\";\nfunction $2e3c8c2d71c2725b$var$ensureIsAttribute(attribute) {\n    if (attribute instanceof (0, $2qhsM.Buffer) || Array.isArray(attribute) || attribute.BYTES_PER_ELEMENT) attribute = {\n        buffer: attribute\n    };\n    attribute.buffer = (0, $h4RvW.ensureIsBuffer)(attribute.buffer, false);\n    return attribute;\n}\nclass $2e3c8c2d71c2725b$export$2db6c17465f94a2 extends (0, (/*@__PURE__*/$parcel$interopDefault($gpXaq))) {\n    /**\n   * Create a new instance of a geometry\n   * @param options - The options for the geometry.\n   */ constructor(options){\n        const { attributes: attributes, indexBuffer: indexBuffer, topology: topology } = options;\n        super();\n        /** The unique id of the geometry. */ this.uid = (0, $l80qL.uid)(\"geometry\");\n        /**\n     * the layout key will be generated by WebGPU all geometries that have the same structure\n     * will have the same layout key. This is used to cache the pipeline layout\n     * @internal\n     * @ignore\n     */ this._layoutKey = 0;\n        /** the instance count of the geometry to draw */ this.instanceCount = 1;\n        this._bounds = new (0, $ggeMF.Bounds)();\n        this._boundsDirty = true;\n        this.attributes = attributes;\n        this.buffers = [];\n        this.instanceCount = options.instanceCount || 1;\n        for(const i in attributes){\n            const attribute = attributes[i] = $2e3c8c2d71c2725b$var$ensureIsAttribute(attributes[i]);\n            const bufferIndex = this.buffers.indexOf(attribute.buffer);\n            if (bufferIndex === -1) {\n                this.buffers.push(attribute.buffer);\n                attribute.buffer.on(\"update\", this.onBufferUpdate, this);\n                attribute.buffer.on(\"change\", this.onBufferUpdate, this);\n            }\n        }\n        if (indexBuffer) {\n            this.indexBuffer = (0, $h4RvW.ensureIsBuffer)(indexBuffer, true);\n            this.buffers.push(this.indexBuffer);\n        }\n        this.topology = topology || \"triangle-list\";\n    }\n    onBufferUpdate() {\n        this._boundsDirty = true;\n        this.emit(\"update\", this);\n    }\n    /**\n   * Returns the requested attribute.\n   * @param id - The name of the attribute required\n   * @returns - The attribute requested.\n   */ getAttribute(id) {\n        return this.attributes[id];\n    }\n    /**\n   * Returns the index buffer\n   * @returns - The index buffer.\n   */ getIndex() {\n        return this.indexBuffer;\n    }\n    /**\n   * Returns the requested buffer.\n   * @param id - The name of the buffer required.\n   * @returns - The buffer requested.\n   */ getBuffer(id) {\n        return this.getAttribute(id).buffer;\n    }\n    /**\n   * Used to figure out how many vertices there are in this geometry\n   * @returns the number of vertices in the geometry\n   */ getSize() {\n        for(const i in this.attributes){\n            const attribute = this.attributes[i];\n            const buffer = attribute.buffer;\n            return buffer.data.length / (attribute.stride / 4 || attribute.size);\n        }\n        return 0;\n    }\n    /** Returns the bounds of the geometry. */ get bounds() {\n        if (!this._boundsDirty) return this._bounds;\n        this._boundsDirty = false;\n        return (0, $6RtYG.getGeometryBounds)(this, \"aPosition\", this._bounds);\n    }\n    /**\n   * destroys the geometry.\n   * @param destroyBuffers - destroy the buffers associated with this geometry\n   */ destroy(destroyBuffers = false) {\n        this.emit(\"destroy\", this);\n        this.removeAllListeners();\n        if (destroyBuffers) this.buffers.forEach((buffer)=>buffer.destroy());\n        this.attributes = null;\n        this.buffers = null;\n        this.indexBuffer = null;\n        this._bounds = null;\n    }\n}\n\n});\nparcelRegister(\"h4RvW\", function(module, exports) {\n\n$parcel$export(module.exports, \"ensureIsBuffer\", () => $0e45541d190bc801$export$e02adcb3cf335e03);\n\nvar $2qhsM = parcelRequire(\"2qhsM\");\n\nvar $cnPar = parcelRequire(\"cnPar\");\n\"use strict\";\nfunction $0e45541d190bc801$export$e02adcb3cf335e03(buffer, index) {\n    if (!(buffer instanceof (0, $2qhsM.Buffer))) {\n        let usage = index ? (0, $cnPar.BufferUsage).INDEX : (0, $cnPar.BufferUsage).VERTEX;\n        if (buffer instanceof Array) {\n            if (index) {\n                buffer = new Uint32Array(buffer);\n                usage = (0, $cnPar.BufferUsage).INDEX | (0, $cnPar.BufferUsage).COPY_DST;\n            } else {\n                buffer = new Float32Array(buffer);\n                usage = (0, $cnPar.BufferUsage).VERTEX | (0, $cnPar.BufferUsage).COPY_DST;\n            }\n        }\n        buffer = new (0, $2qhsM.Buffer)({\n            data: buffer,\n            label: index ? \"index-mesh-buffer\" : \"vertex-mesh-buffer\",\n            usage: usage\n        });\n    }\n    return buffer;\n}\n\n});\n\nparcelRegister(\"6RtYG\", function(module, exports) {\n\n$parcel$export(module.exports, \"getGeometryBounds\", () => $a66388f56b469ccf$export$ca8be28ec6402f29);\n\"use strict\";\nfunction $a66388f56b469ccf$export$ca8be28ec6402f29(geometry, attributeId, bounds) {\n    const attribute = geometry.getAttribute(attributeId);\n    if (!attribute) {\n        bounds.minX = 0;\n        bounds.minY = 0;\n        bounds.maxX = 0;\n        bounds.maxY = 0;\n        return bounds;\n    }\n    const data = attribute.buffer.data;\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    const byteSize = data.BYTES_PER_ELEMENT;\n    const offset = (attribute.offset || 0) / byteSize;\n    const stride = (attribute.stride || 8) / byteSize;\n    for(let i = offset; i < data.length; i += stride){\n        const x = data[i];\n        const y = data[i + 1];\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n    }\n    bounds.minX = minX;\n    bounds.minY = minY;\n    bounds.maxX = maxX;\n    bounds.maxY = maxY;\n    return bounds;\n}\n\n});\n\n\n\nparcelRegister(\"86NKO\", function(module, exports) {\n\n$parcel$export(module.exports, \"BindGroup\", () => $a67f34b5a8404015$export$6f452ee382def63c);\n\"use strict\";\nclass $a67f34b5a8404015$export$6f452ee382def63c {\n    /**\n   * Create a new instance eof the Bind Group.\n   * @param resources - The resources that are bound together for use by a shader.\n   */ constructor(resources){\n        /** The resources that are bound together for use by a shader. */ this.resources = /* @__PURE__ */ Object.create(null);\n        this._dirty = true;\n        let index = 0;\n        for(const i in resources){\n            const resource = resources[i];\n            this.setResource(resource, index++);\n        }\n        this._updateKey();\n    }\n    /**\n   * Updates the key if its flagged as dirty. This is used internally to\n   * match this bind group to a WebGPU BindGroup.\n   * @internal\n   * @ignore\n   */ _updateKey() {\n        if (!this._dirty) return;\n        this._dirty = false;\n        const keyParts = [];\n        let index = 0;\n        for(const i in this.resources)keyParts[index++] = this.resources[i]._resourceId;\n        this._key = keyParts.join(\"|\");\n    }\n    /**\n   * Set a resource at a given index. this function will\n   * ensure that listeners will be removed from the current resource\n   * and added to the new resource.\n   * @param resource - The resource to set.\n   * @param index - The index to set the resource at.\n   */ setResource(resource, index) {\n        const currentResource = this.resources[index];\n        if (resource === currentResource) return;\n        if (currentResource) resource.off?.(\"change\", this.onResourceChange, this);\n        resource.on?.(\"change\", this.onResourceChange, this);\n        this.resources[index] = resource;\n        this._dirty = true;\n    }\n    /**\n   * Returns the resource at the current specified index.\n   * @param index - The index of the resource to get.\n   * @returns - The resource at the specified index.\n   */ getResource(index) {\n        return this.resources[index];\n    }\n    /**\n   * Used internally to 'touch' each resource, to ensure that the GC\n   * knows that all resources in this bind group are still being used.\n   * @param tick - The current tick.\n   * @internal\n   * @ignore\n   */ _touch(tick) {\n        const resources = this.resources;\n        for(const i in resources)resources[i]._touched = tick;\n    }\n    /** Destroys this bind group and removes all listeners. */ destroy() {\n        const resources = this.resources;\n        for(const i in resources){\n            const resource = resources[i];\n            resource.off?.(\"change\", this.onResourceChange, this);\n        }\n        this.resources = null;\n    }\n    onResourceChange() {\n        this._dirty = true;\n        this._updateKey();\n    }\n}\n\n});\n\nparcelRegister(\"fIcRj\", function(module, exports) {\n\n$parcel$export(module.exports, \"MAX_TEXTURES\", () => $47da8e5c51bb3312$export$e09e7788b3f0275e);\n\"use strict\";\nconst $47da8e5c51bb3312$export$e09e7788b3f0275e = 16;\n\n});\n\nparcelRegister(\"gC5Pa\", function(module, exports) {\n\n$parcel$export(module.exports, \"Batcher\", () => $3a37d26fd5247abe$export$704b12ddc1dacdd2);\n\nvar $l80qL = parcelRequire(\"l80qL\");\n\nvar $1bOZ3 = parcelRequire(\"1bOZ3\");\n\nvar $yT1Ie = parcelRequire(\"yT1Ie\");\n\nvar $gNQm7 = parcelRequire(\"gNQm7\");\n\nvar $68TF0 = parcelRequire(\"68TF0\");\n\nvar $fIcRj = parcelRequire(\"fIcRj\");\n\"use strict\";\nclass $3a37d26fd5247abe$export$33b107562567fc47 {\n    constructor(){\n        this.renderPipeId = \"batch\";\n        this.action = \"startBatch\";\n        // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n        // public elementStart = 0;\n        // public elementSize = 0;\n        // for drawing..\n        this.start = 0;\n        this.size = 0;\n        this.blendMode = \"normal\";\n        this.canBundle = true;\n    }\n    destroy() {\n        this.textures = null;\n        this.gpuBindGroup = null;\n        this.bindGroup = null;\n        this.batcher = null;\n    }\n}\nlet $3a37d26fd5247abe$var$BATCH_TICK = 0;\nconst $3a37d26fd5247abe$var$_Batcher = class _Batcher {\n    constructor(options = {}){\n        this.uid = (0, $l80qL.uid)(\"batcher\");\n        this.dirty = true;\n        this.batchIndex = 0;\n        this.batches = [];\n        // specifics.\n        this._vertexSize = 6;\n        this._elements = [];\n        this._batchPool = [];\n        this._batchPoolIndex = 0;\n        this._textureBatchPool = [];\n        this._textureBatchPoolIndex = 0;\n        options = {\n            ..._Batcher.defaultOptions,\n            ...options\n        };\n        const { vertexSize: vertexSize, indexSize: indexSize } = options;\n        this.attributeBuffer = new (0, $1bOZ3.ViewableBuffer)(vertexSize * this._vertexSize * 4);\n        this.indexBuffer = new Uint16Array(indexSize);\n    }\n    begin() {\n        this.batchIndex = 0;\n        this.elementSize = 0;\n        this.elementStart = 0;\n        this.indexSize = 0;\n        this.attributeSize = 0;\n        this._batchPoolIndex = 0;\n        this._textureBatchPoolIndex = 0;\n        this._batchIndexStart = 0;\n        this._batchIndexSize = 0;\n        this.dirty = true;\n    }\n    add(batchableObject) {\n        this._elements[this.elementSize++] = batchableObject;\n        batchableObject.indexStart = this.indexSize;\n        batchableObject.location = this.attributeSize;\n        batchableObject.batcher = this;\n        this.indexSize += batchableObject.indexSize;\n        this.attributeSize += batchableObject.vertexSize * this._vertexSize;\n    }\n    checkAndUpdateTexture(batchableObject, texture) {\n        const textureId = batchableObject.batch.textures.ids[texture._source.uid];\n        if (!textureId && textureId !== 0) return false;\n        batchableObject.textureId = textureId;\n        batchableObject.texture = texture;\n        return true;\n    }\n    updateElement(batchableObject) {\n        this.dirty = true;\n        batchableObject.packAttributes(this.attributeBuffer.float32View, this.attributeBuffer.uint32View, batchableObject.location, batchableObject.textureId);\n    }\n    /**\n   * breaks the batcher. This happens when a batch gets too big,\n   * or we need to switch to a different type of rendering (a filter for example)\n   * @param instructionSet\n   */ break(instructionSet) {\n        const elements = this._elements;\n        let textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new (0, $68TF0.BatchTextureArray)();\n        textureBatch.clear();\n        if (!elements[this.elementStart]) return;\n        const firstElement = elements[this.elementStart];\n        let blendMode = (0, $gNQm7.getAdjustedBlendModeBlend)(firstElement.blendMode, firstElement.texture._source);\n        if (this.attributeSize * 4 > this.attributeBuffer.size) this._resizeAttributeBuffer(this.attributeSize * 4);\n        if (this.indexSize > this.indexBuffer.length) this._resizeIndexBuffer(this.indexSize);\n        const f32 = this.attributeBuffer.float32View;\n        const u32 = this.attributeBuffer.uint32View;\n        const iBuffer = this.indexBuffer;\n        let size = this._batchIndexSize;\n        let start = this._batchIndexStart;\n        let action = \"startBatch\";\n        let batch = this._batchPool[this._batchPoolIndex++] || new $3a37d26fd5247abe$export$33b107562567fc47();\n        for(let i = this.elementStart; i < this.elementSize; ++i){\n            const element = elements[i];\n            elements[i] = null;\n            const texture = element.texture;\n            const source = texture._source;\n            const adjustedBlendMode = (0, $gNQm7.getAdjustedBlendModeBlend)(element.blendMode, source);\n            const blendModeChange = blendMode !== adjustedBlendMode;\n            if (source._batchTick === $3a37d26fd5247abe$var$BATCH_TICK && !blendModeChange) {\n                element.textureId = source._textureBindLocation;\n                size += element.indexSize;\n                element.packAttributes(f32, u32, element.location, element.textureId);\n                element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n                element.batch = batch;\n                continue;\n            }\n            source._batchTick = $3a37d26fd5247abe$var$BATCH_TICK;\n            if (textureBatch.count >= (0, $fIcRj.MAX_TEXTURES) || blendModeChange) {\n                this._finishBatch(batch, start, size - start, textureBatch, blendMode, instructionSet, action);\n                action = \"renderBatch\";\n                start = size;\n                blendMode = adjustedBlendMode;\n                textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new (0, $68TF0.BatchTextureArray)();\n                textureBatch.clear();\n                batch = this._batchPool[this._batchPoolIndex++] || new $3a37d26fd5247abe$export$33b107562567fc47();\n                ++$3a37d26fd5247abe$var$BATCH_TICK;\n            }\n            element.textureId = source._textureBindLocation = textureBatch.count;\n            textureBatch.ids[source.uid] = textureBatch.count;\n            textureBatch.textures[textureBatch.count++] = source;\n            element.batch = batch;\n            size += element.indexSize;\n            element.packAttributes(f32, u32, element.location, element.textureId);\n            element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n        }\n        if (textureBatch.count > 0) {\n            this._finishBatch(batch, start, size - start, textureBatch, blendMode, instructionSet, action);\n            start = size;\n            ++$3a37d26fd5247abe$var$BATCH_TICK;\n        }\n        this.elementStart = this.elementSize;\n        this._batchIndexStart = start;\n        this._batchIndexSize = size;\n    }\n    _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, instructionSet, action) {\n        batch.gpuBindGroup = null;\n        batch.action = action;\n        batch.batcher = this;\n        batch.textures = textureBatch;\n        batch.blendMode = blendMode;\n        batch.start = indexStart;\n        batch.size = indexSize;\n        ++$3a37d26fd5247abe$var$BATCH_TICK;\n        instructionSet.add(batch);\n    }\n    finish(instructionSet) {\n        this.break(instructionSet);\n    }\n    /**\n   * Resizes the attribute buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */ ensureAttributeBuffer(size) {\n        if (size * 4 <= this.attributeBuffer.size) return;\n        this._resizeAttributeBuffer(size * 4);\n    }\n    /**\n   * Resizes the index buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */ ensureIndexBuffer(size) {\n        if (size <= this.indexBuffer.length) return;\n        this._resizeIndexBuffer(size);\n    }\n    _resizeAttributeBuffer(size) {\n        const newSize = Math.max(size, this.attributeBuffer.size * 2);\n        const newArrayBuffer = new (0, $1bOZ3.ViewableBuffer)(newSize);\n        (0, $yT1Ie.fastCopy)(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n        this.attributeBuffer = newArrayBuffer;\n    }\n    _resizeIndexBuffer(size) {\n        const indexBuffer = this.indexBuffer;\n        let newSize = Math.max(size, indexBuffer.length * 1.5);\n        newSize += newSize % 2;\n        const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);\n        if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) for(let i = 0; i < indexBuffer.length; i++)newIndexBuffer[i] = indexBuffer[i];\n        else (0, $yT1Ie.fastCopy)(indexBuffer.buffer, newIndexBuffer.buffer);\n        this.indexBuffer = newIndexBuffer;\n    }\n    destroy() {\n        for(let i = 0; i < this.batches.length; i++)this.batches[i].destroy();\n        this.batches = null;\n        for(let i = 0; i < this._elements.length; i++)this._elements[i].batch = null;\n        this._elements = null;\n        this.indexBuffer = null;\n        this.attributeBuffer.destroy();\n        this.attributeBuffer = null;\n    }\n};\n$3a37d26fd5247abe$var$_Batcher.defaultOptions = {\n    vertexSize: 4,\n    indexSize: 6\n};\nlet $3a37d26fd5247abe$export$704b12ddc1dacdd2 = $3a37d26fd5247abe$var$_Batcher;\n\n});\nparcelRegister(\"1bOZ3\", function(module, exports) {\n\n$parcel$export(module.exports, \"ViewableBuffer\", () => $091eabba1be7ffdf$export$4fdbf0662aa3047a);\n\"use strict\";\nclass $091eabba1be7ffdf$export$4fdbf0662aa3047a {\n    constructor(sizeOrBuffer){\n        if (typeof sizeOrBuffer === \"number\") this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);\n        else if (sizeOrBuffer instanceof Uint8Array) this.rawBinaryData = sizeOrBuffer.buffer;\n        else this.rawBinaryData = sizeOrBuffer;\n        this.uint32View = new Uint32Array(this.rawBinaryData);\n        this.float32View = new Float32Array(this.rawBinaryData);\n        this.size = this.rawBinaryData.byteLength;\n    }\n    /** View on the raw binary data as a `Int8Array`. */ get int8View() {\n        if (!this._int8View) this._int8View = new Int8Array(this.rawBinaryData);\n        return this._int8View;\n    }\n    /** View on the raw binary data as a `Uint8Array`. */ get uint8View() {\n        if (!this._uint8View) this._uint8View = new Uint8Array(this.rawBinaryData);\n        return this._uint8View;\n    }\n    /**  View on the raw binary data as a `Int16Array`. */ get int16View() {\n        if (!this._int16View) this._int16View = new Int16Array(this.rawBinaryData);\n        return this._int16View;\n    }\n    /** View on the raw binary data as a `Int32Array`. */ get int32View() {\n        if (!this._int32View) this._int32View = new Int32Array(this.rawBinaryData);\n        return this._int32View;\n    }\n    /** View on the raw binary data as a `Float64Array`. */ get float64View() {\n        if (!this._float64Array) this._float64Array = new Float64Array(this.rawBinaryData);\n        return this._float64Array;\n    }\n    /** View on the raw binary data as a `BigUint64Array`. */ get bigUint64View() {\n        if (!this._bigUint64Array) this._bigUint64Array = new BigUint64Array(this.rawBinaryData);\n        return this._bigUint64Array;\n    }\n    /**\n   * Returns the view of the given type.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *    `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - typed array of given type\n   */ view(type) {\n        return this[`${type}View`];\n    }\n    /** Destroys all buffer references. Do not use after calling this. */ destroy() {\n        this.rawBinaryData = null;\n        this._int8View = null;\n        this._uint8View = null;\n        this._int16View = null;\n        this.uint16View = null;\n        this._int32View = null;\n        this.uint32View = null;\n        this.float32View = null;\n    }\n    /**\n   * Returns the size of the given type in bytes.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *   `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - size of the type in bytes\n   */ static sizeOf(type) {\n        switch(type){\n            case \"int8\":\n            case \"uint8\":\n                return 1;\n            case \"int16\":\n            case \"uint16\":\n                return 2;\n            case \"int32\":\n            case \"uint32\":\n            case \"float32\":\n                return 4;\n            default:\n                throw new Error(`${type} isn't a valid view type`);\n        }\n    }\n}\n\n});\n\nparcelRegister(\"yT1Ie\", function(module, exports) {\n\n$parcel$export(module.exports, \"fastCopy\", () => $dc9e07f111dd75c7$export$c691b0c42debe682);\n\"use strict\";\nfunction $dc9e07f111dd75c7$export$c691b0c42debe682(sourceBuffer, destinationBuffer) {\n    const lengthDouble = sourceBuffer.byteLength / 8 | 0;\n    const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);\n    const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);\n    destinationFloat64View.set(sourceFloat64View);\n    const remainingBytes = sourceBuffer.byteLength - lengthDouble * 8;\n    if (remainingBytes > 0) {\n        const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);\n        const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);\n        destinationUint8View.set(sourceUint8View);\n    }\n}\n\n});\n\nparcelRegister(\"gNQm7\", function(module, exports) {\n\n$parcel$export(module.exports, \"getAdjustedBlendModeBlend\", () => $4c271e6d234c7a46$export$ab2fc5cf3fe899fe);\n\nvar $8Jr8b = parcelRequire(\"8Jr8b\");\n\"use strict\";\nfunction $4c271e6d234c7a46$export$ab2fc5cf3fe899fe(blendMode, textureSource) {\n    if (textureSource.alphaMode === \"no-premultiply-alpha\") return (0, $8Jr8b.BLEND_TO_NPM)[blendMode] || blendMode;\n    return blendMode;\n}\n\n});\nparcelRegister(\"8Jr8b\", function(module, exports) {\n\n$parcel$export(module.exports, \"BLEND_TO_NPM\", () => $2fd2df46cfd69161$export$8c0bd2ccaa4a8d5e);\n$parcel$export(module.exports, \"STENCIL_MODES\", () => $2fd2df46cfd69161$export$c250b85d73a91bdf);\n\"use strict\";\nconst $2fd2df46cfd69161$export$8c0bd2ccaa4a8d5e = {\n    normal: \"normal-npm\",\n    add: \"add-npm\",\n    screen: \"screen-npm\"\n};\nvar $2fd2df46cfd69161$export$c250b85d73a91bdf = /* @__PURE__ */ ((STENCIL_MODES2)=>{\n    STENCIL_MODES2[STENCIL_MODES2[\"DISABLED\"] = 0] = \"DISABLED\";\n    STENCIL_MODES2[STENCIL_MODES2[\"RENDERING_MASK_ADD\"] = 1] = \"RENDERING_MASK_ADD\";\n    STENCIL_MODES2[STENCIL_MODES2[\"MASK_ACTIVE\"] = 2] = \"MASK_ACTIVE\";\n    STENCIL_MODES2[STENCIL_MODES2[\"RENDERING_MASK_REMOVE\"] = 3] = \"RENDERING_MASK_REMOVE\";\n    STENCIL_MODES2[STENCIL_MODES2[\"NONE\"] = 4] = \"NONE\";\n    return STENCIL_MODES2;\n})($2fd2df46cfd69161$export$c250b85d73a91bdf || {});\n\n});\n\n\nparcelRegister(\"68TF0\", function(module, exports) {\n\n$parcel$export(module.exports, \"BatchTextureArray\", () => $b1ecee865cb8c960$export$aa760e0febf1a758);\n\"use strict\";\nclass $b1ecee865cb8c960$export$aa760e0febf1a758 {\n    constructor(){\n        /** Respective locations for textures. */ this.ids = /* @__PURE__ */ Object.create(null);\n        this.textures = [];\n        this.count = 0;\n    }\n    /** Clear the textures and their locations. */ clear() {\n        for(let i = 0; i < this.count; i++){\n            const t = this.textures[i];\n            this.textures[i] = null;\n            this.ids[t.uid] = null;\n        }\n        this.count = 0;\n    }\n}\n\n});\n\n\nparcelRegister(\"bLQN7\", function(module, exports) {\n\n$parcel$export(module.exports, \"mixColors\", () => $32363f0670dd5e82$export$72a85c3a80ccc403);\n\nvar $knTXf = parcelRequire(\"knTXf\");\n\"use strict\";\nconst $32363f0670dd5e82$var$WHITE_BGR = 16777215;\nfunction $32363f0670dd5e82$export$72a85c3a80ccc403(localBGRColor, parentBGRColor) {\n    if (localBGRColor === $32363f0670dd5e82$var$WHITE_BGR || parentBGRColor === $32363f0670dd5e82$var$WHITE_BGR) return localBGRColor + parentBGRColor - $32363f0670dd5e82$var$WHITE_BGR;\n    return (0, $knTXf.mixHexColors)(localBGRColor, parentBGRColor, 0.5);\n}\nfunction $32363f0670dd5e82$export$2c7842eb56139270(localColorRGB, localAlpha, parentColor) {\n    const parentAlpha = (parentColor >> 24 & 255) / 255;\n    const globalAlpha = localAlpha * parentAlpha * 255;\n    const localBGRColor = ((localColorRGB & 255) << 16) + (localColorRGB & 65280) + (localColorRGB >> 16 & 255);\n    const parentBGRColor = parentColor & 16777215;\n    let sharedBGRColor;\n    if (localBGRColor === $32363f0670dd5e82$var$WHITE_BGR || parentBGRColor === $32363f0670dd5e82$var$WHITE_BGR) sharedBGRColor = localBGRColor + parentBGRColor - $32363f0670dd5e82$var$WHITE_BGR;\n    else sharedBGRColor = (0, $knTXf.mixHexColors)(localBGRColor, parentBGRColor, 0.5);\n    return sharedBGRColor + (globalAlpha << 24);\n}\n\n});\nparcelRegister(\"knTXf\", function(module, exports) {\n\n$parcel$export(module.exports, \"mixHexColors\", () => $be486dafd58220da$export$ff72adc46f6bc63c);\n\"use strict\";\nfunction $be486dafd58220da$export$ff72adc46f6bc63c(color1, color2, ratio) {\n    const r1 = color1 >> 16 & 255;\n    const g1 = color1 >> 8 & 255;\n    const b1 = color1 & 255;\n    const r2 = color2 >> 16 & 255;\n    const g2 = color2 >> 8 & 255;\n    const b2 = color2 & 255;\n    const r = r1 + (r2 - r1) * ratio;\n    const g = g1 + (g2 - g1) * ratio;\n    const b = b1 + (b2 - b1) * ratio;\n    return (r << 16) + (g << 8) + b;\n}\n\n});\n\n\nparcelRegister(\"4rJn2\", function(module, exports) {\n\n$parcel$export(module.exports, \"State\", () => $9f149295c176ee7a$export$7254cc27399e90bd);\n\"use strict\";\nconst $9f149295c176ee7a$var$blendModeIds = {\n    normal: 0,\n    add: 1,\n    multiply: 2,\n    screen: 3,\n    overlay: 4,\n    erase: 5,\n    \"normal-npm\": 6,\n    \"add-npm\": 7,\n    \"screen-npm\": 8\n};\nconst $9f149295c176ee7a$var$BLEND = 0;\nconst $9f149295c176ee7a$var$OFFSET = 1;\nconst $9f149295c176ee7a$var$CULLING = 2;\nconst $9f149295c176ee7a$var$DEPTH_TEST = 3;\nconst $9f149295c176ee7a$var$WINDING = 4;\nconst $9f149295c176ee7a$var$DEPTH_MASK = 5;\nconst $9f149295c176ee7a$var$_State = class _State {\n    constructor(){\n        this.data = 0;\n        this.blendMode = \"normal\";\n        this.polygonOffset = 0;\n        this.blend = true;\n        this.depthMask = true;\n    }\n    /**\n   * Activates blending of the computed fragment color values.\n   * @default true\n   */ get blend() {\n        return !!(this.data & 1 << $9f149295c176ee7a$var$BLEND);\n    }\n    set blend(value) {\n        if (!!(this.data & 1 << $9f149295c176ee7a$var$BLEND) !== value) this.data ^= 1 << $9f149295c176ee7a$var$BLEND;\n    }\n    /**\n   * Activates adding an offset to depth values of polygon's fragments\n   * @default false\n   */ get offsets() {\n        return !!(this.data & 1 << $9f149295c176ee7a$var$OFFSET);\n    }\n    set offsets(value) {\n        if (!!(this.data & 1 << $9f149295c176ee7a$var$OFFSET) !== value) this.data ^= 1 << $9f149295c176ee7a$var$OFFSET;\n    }\n    /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */ set cullMode(value) {\n        if (value === \"none\") {\n            this.culling = false;\n            return;\n        }\n        this.culling = true;\n        this.clockwiseFrontFace = value === \"front\";\n    }\n    get cullMode() {\n        if (!this.culling) return \"none\";\n        return this.clockwiseFrontFace ? \"front\" : \"back\";\n    }\n    /**\n   * Activates culling of polygons.\n   * @default false\n   */ get culling() {\n        return !!(this.data & 1 << $9f149295c176ee7a$var$CULLING);\n    }\n    set culling(value) {\n        if (!!(this.data & 1 << $9f149295c176ee7a$var$CULLING) !== value) this.data ^= 1 << $9f149295c176ee7a$var$CULLING;\n    }\n    /**\n   * Activates depth comparisons and updates to the depth buffer.\n   * @default false\n   */ get depthTest() {\n        return !!(this.data & 1 << $9f149295c176ee7a$var$DEPTH_TEST);\n    }\n    set depthTest(value) {\n        if (!!(this.data & 1 << $9f149295c176ee7a$var$DEPTH_TEST) !== value) this.data ^= 1 << $9f149295c176ee7a$var$DEPTH_TEST;\n    }\n    /**\n   * Enables or disables writing to the depth buffer.\n   * @default true\n   */ get depthMask() {\n        return !!(this.data & 1 << $9f149295c176ee7a$var$DEPTH_MASK);\n    }\n    set depthMask(value) {\n        if (!!(this.data & 1 << $9f149295c176ee7a$var$DEPTH_MASK) !== value) this.data ^= 1 << $9f149295c176ee7a$var$DEPTH_MASK;\n    }\n    /**\n   * Specifies whether or not front or back-facing polygons can be culled.\n   * @default false\n   */ get clockwiseFrontFace() {\n        return !!(this.data & 1 << $9f149295c176ee7a$var$WINDING);\n    }\n    set clockwiseFrontFace(value) {\n        if (!!(this.data & 1 << $9f149295c176ee7a$var$WINDING) !== value) this.data ^= 1 << $9f149295c176ee7a$var$WINDING;\n    }\n    /**\n   * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n   * @default 'normal'\n   */ get blendMode() {\n        return this._blendMode;\n    }\n    set blendMode(value) {\n        this.blend = value !== \"none\";\n        this._blendMode = value;\n        this._blendModeId = $9f149295c176ee7a$var$blendModeIds[value] || 0;\n    }\n    /**\n   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n   * @default 0\n   */ get polygonOffset() {\n        return this._polygonOffset;\n    }\n    set polygonOffset(value) {\n        this.offsets = !!value;\n        this._polygonOffset = value;\n    }\n    toString() {\n        return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;\n    }\n    /**\n   * A quickly getting an instance of a State that is configured for 2d rendering.\n   * @returns a new State with values set for 2d rendering\n   */ static for2d() {\n        const state = new _State();\n        state.depthTest = false;\n        state.blend = true;\n        return state;\n    }\n};\n$9f149295c176ee7a$var$_State.default2d = $9f149295c176ee7a$var$_State.for2d();\nlet $9f149295c176ee7a$export$7254cc27399e90bd = $9f149295c176ee7a$var$_State;\n\n});\n\nparcelRegister(\"1A6sa\", function(module, exports) {\n\n$parcel$export(module.exports, \"color32BitToUniform\", () => $9e041d6e84ac0a03$export$2c68e848c5b81f5);\n\"use strict\";\nfunction $9e041d6e84ac0a03$export$d13a52631f102a23(rgb, alpha, out, offset) {\n    out[offset++] = (rgb >> 16 & 255) / 255;\n    out[offset++] = (rgb >> 8 & 255) / 255;\n    out[offset++] = (rgb & 255) / 255;\n    out[offset++] = alpha;\n}\nfunction $9e041d6e84ac0a03$export$2c68e848c5b81f5(abgr, out, offset) {\n    const alpha = (abgr >> 24 & 255) / 255;\n    out[offset++] = (abgr & 255) / 255 * alpha;\n    out[offset++] = (abgr >> 8 & 255) / 255 * alpha;\n    out[offset++] = (abgr >> 16 & 255) / 255 * alpha;\n    out[offset++] = alpha;\n}\n\n});\n\nparcelRegister(\"lJEsO\", function(module, exports) {\n\n$parcel$export(module.exports, \"UniformGroup\", () => $3672bd6e6c923f1d$export$6601a7a2dcf79bf5);\n\nvar $l80qL = parcelRequire(\"l80qL\");\n\nvar $2aTkI = parcelRequire(\"2aTkI\");\n\nvar $kJ1OQ = parcelRequire(\"kJ1OQ\");\n\"use strict\";\nconst $3672bd6e6c923f1d$var$_UniformGroup = class _UniformGroup {\n    /**\n   * Create a new Uniform group\n   * @param uniformStructures - The structures of the uniform group\n   * @param options - The optional parameters of this uniform group\n   */ constructor(uniformStructures, options){\n        /** used internally to know if a uniform group was used in the last render pass */ this._touched = 0;\n        /** a unique id for this uniform group used through the renderer */ this.uid = (0, $l80qL.uid)(\"uniform\");\n        /** a resource type, used to identify how to handle it when its in a bind group / shader resource */ this._resourceType = \"uniformGroup\";\n        /** the resource id used internally by the renderer to build bind group keys */ this._resourceId = (0, $l80qL.uid)(\"resource\");\n        /** used ito identify if this is a uniform group */ this.isUniformGroup = true;\n        /**\n     * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU\n     * @internal\n     * @ignore\n     */ this._dirtyId = 0;\n        options = {\n            ..._UniformGroup.defaultOptions,\n            ...options\n        };\n        this.uniformStructures = uniformStructures;\n        const uniforms = {};\n        for(const i in uniformStructures){\n            const uniformData = uniformStructures[i];\n            uniformData.name = i;\n            uniformData.size = uniformData.size ?? 1;\n            uniformData.value ?? (uniformData.value = (0, $kJ1OQ.getDefaultUniformValue)(uniformData.type, uniformData.size));\n            uniforms[i] = uniformData.value;\n        }\n        this.uniforms = uniforms;\n        this._dirtyId = 1;\n        this.ubo = options.ubo;\n        this.isStatic = options.isStatic;\n        this._signature = (0, $2aTkI.createIdFromString)(Object.keys(uniforms).map((i)=>`${i}-${uniformStructures[i].type}`).join(\"-\"), \"uniform-group\");\n    }\n    /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */ update() {\n        this._dirtyId++;\n    }\n};\n/** The default options used by the uniform group. */ $3672bd6e6c923f1d$var$_UniformGroup.defaultOptions = {\n    /** if true the UniformGroup is handled as an Uniform buffer object. */ ubo: false,\n    /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */ isStatic: false\n};\nlet $3672bd6e6c923f1d$export$6601a7a2dcf79bf5 = $3672bd6e6c923f1d$var$_UniformGroup;\n\n});\nparcelRegister(\"2aTkI\", function(module, exports) {\n\n$parcel$export(module.exports, \"createIdFromString\", () => $20f496f4898984f0$export$1e452c36dfe36a93);\n\"use strict\";\nconst $20f496f4898984f0$var$idCounts = /* @__PURE__ */ Object.create(null);\nconst $20f496f4898984f0$var$idHash = /* @__PURE__ */ Object.create(null);\nfunction $20f496f4898984f0$export$1e452c36dfe36a93(value, groupId) {\n    let id = $20f496f4898984f0$var$idHash[value];\n    if (id === void 0) {\n        if ($20f496f4898984f0$var$idCounts[groupId] === void 0) $20f496f4898984f0$var$idCounts[groupId] = 1;\n        $20f496f4898984f0$var$idHash[value] = id = $20f496f4898984f0$var$idCounts[groupId]++;\n    }\n    return id;\n}\n\n});\n\nparcelRegister(\"kJ1OQ\", function(module, exports) {\n\n$parcel$export(module.exports, \"getDefaultUniformValue\", () => $8cd1a200cd417966$export$7febdb6905805c3d);\n\"use strict\";\nfunction $8cd1a200cd417966$export$7febdb6905805c3d(type, size) {\n    switch(type){\n        case \"f32\":\n            return 0;\n        case \"vec2<f32>\":\n            return new Float32Array(2 * size);\n        case \"vec3<f32>\":\n            return new Float32Array(3 * size);\n        case \"vec4<f32>\":\n            return new Float32Array(4 * size);\n        case \"mat2x2<f32>\":\n            return new Float32Array([\n                1,\n                0,\n                0,\n                1\n            ]);\n        case \"mat3x3<f32>\":\n            return new Float32Array([\n                1,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                1\n            ]);\n        case \"mat4x4<f32>\":\n            return new Float32Array([\n                1,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                1\n            ]);\n    }\n    return null;\n}\n\n});\n\n\nparcelRegister(\"8PFkM\", function(module, exports) {\n\n$parcel$export(module.exports, \"BatchableSprite\", () => $36f92037bd2a44c6$export$fe4bdc7069ee0b9c);\n\"use strict\";\nclass $36f92037bd2a44c6$export$fe4bdc7069ee0b9c {\n    constructor(){\n        // batch specific..\n        this.vertexSize = 4;\n        this.indexSize = 6;\n        this.location = 0;\n        // location in the buffer\n        this.batcher = null;\n        this.batch = null;\n        this.roundPixels = 0;\n    }\n    get blendMode() {\n        return this.renderable.groupBlendMode;\n    }\n    packAttributes(float32View, uint32View, index, textureId) {\n        const sprite = this.renderable;\n        const texture = this.texture;\n        const wt = sprite.groupTransform;\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n        const bounds = this.bounds;\n        const w0 = bounds.maxX;\n        const w1 = bounds.minX;\n        const h0 = bounds.maxY;\n        const h1 = bounds.minY;\n        const uvs = texture.uvs;\n        const argb = sprite.groupColorAlpha;\n        const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;\n        float32View[index + 0] = a * w1 + c * h1 + tx;\n        float32View[index + 1] = d * h1 + b * w1 + ty;\n        float32View[index + 2] = uvs.x0;\n        float32View[index + 3] = uvs.y0;\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureIdAndRound;\n        float32View[index + 6] = a * w0 + c * h1 + tx;\n        float32View[index + 7] = d * h1 + b * w0 + ty;\n        float32View[index + 8] = uvs.x1;\n        float32View[index + 9] = uvs.y1;\n        uint32View[index + 10] = argb;\n        uint32View[index + 11] = textureIdAndRound;\n        float32View[index + 12] = a * w0 + c * h0 + tx;\n        float32View[index + 13] = d * h0 + b * w0 + ty;\n        float32View[index + 14] = uvs.x2;\n        float32View[index + 15] = uvs.y2;\n        uint32View[index + 16] = argb;\n        uint32View[index + 17] = textureIdAndRound;\n        float32View[index + 18] = a * w1 + c * h0 + tx;\n        float32View[index + 19] = d * h0 + b * w1 + ty;\n        float32View[index + 20] = uvs.x3;\n        float32View[index + 21] = uvs.y3;\n        uint32View[index + 22] = argb;\n        uint32View[index + 23] = textureIdAndRound;\n    }\n    packIndex(indexBuffer, index, indicesOffset) {\n        indexBuffer[index] = indicesOffset + 0;\n        indexBuffer[index + 1] = indicesOffset + 1;\n        indexBuffer[index + 2] = indicesOffset + 2;\n        indexBuffer[index + 3] = indicesOffset + 0;\n        indexBuffer[index + 4] = indicesOffset + 2;\n        indexBuffer[index + 5] = indicesOffset + 3;\n    }\n    reset() {\n        this.renderable = null;\n        this.texture = null;\n        this.batcher = null;\n        this.batch = null;\n        this.bounds = null;\n    }\n}\n\n});\n\nparcelRegister(\"7U2uj\", function(module, exports) {\n\n$parcel$export(module.exports, \"TexturePool\", () => $24b29c011bc4c5b6$export$686d8ddcd5ee6cd2);\n\nvar $domwE = parcelRequire(\"domwE\");\n\nvar $9Ur0D = parcelRequire(\"9Ur0D\");\n\nvar $5h88T = parcelRequire(\"5h88T\");\n\"use strict\";\nlet $24b29c011bc4c5b6$var$count = 0;\nclass $24b29c011bc4c5b6$export$f5c6a2d8ed21d1d {\n    /**\n   * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n   * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.\n   */ constructor(textureOptions){\n        this._poolKeyHash = /* @__PURE__ */ Object.create(null);\n        this._texturePool = {};\n        this.textureOptions = textureOptions || {};\n        this.enableFullScreen = false;\n    }\n    /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param pixelWidth - Width of texture in pixels.\n   * @param pixelHeight - Height of texture in pixels.\n   * @param antialias\n   */ createTexture(pixelWidth, pixelHeight, antialias) {\n        const textureSource = new (0, $9Ur0D.TextureSource)({\n            ...this.textureOptions,\n            width: pixelWidth,\n            height: pixelHeight,\n            resolution: 1,\n            antialias: antialias,\n            autoGarbageCollect: true\n        });\n        return new (0, $5h88T.Texture)({\n            source: textureSource,\n            label: `texturePool_${$24b29c011bc4c5b6$var$count++}`\n        });\n    }\n    /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param frameWidth - The minimum width of the render texture.\n   * @param frameHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @param antialias\n   * @returns The new render texture.\n   */ getOptimalTexture(frameWidth, frameHeight, resolution = 1, antialias) {\n        let po2Width = Math.ceil(frameWidth * resolution - 1e-6);\n        let po2Height = Math.ceil(frameHeight * resolution - 1e-6);\n        po2Width = (0, $domwE.nextPow2)(po2Width);\n        po2Height = (0, $domwE.nextPow2)(po2Height);\n        const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);\n        if (!this._texturePool[key]) this._texturePool[key] = [];\n        let texture = this._texturePool[key].pop();\n        if (!texture) texture = this.createTexture(po2Width, po2Height, antialias);\n        texture.source._resolution = resolution;\n        texture.source.width = po2Width / resolution;\n        texture.source.height = po2Height / resolution;\n        texture.source.pixelWidth = po2Width;\n        texture.source.pixelHeight = po2Height;\n        texture.frame.x = 0;\n        texture.frame.y = 0;\n        texture.frame.width = frameWidth;\n        texture.frame.height = frameHeight;\n        texture.updateUvs();\n        this._poolKeyHash[texture.uid] = key;\n        return texture;\n    }\n    /**\n   * Gets extra texture of the same size as input renderTexture\n   * @param texture - The texture to check what size it is.\n   * @param antialias - Whether to use antialias.\n   * @returns A texture that is a power of two\n   */ getSameSizeTexture(texture, antialias = false) {\n        const source = texture.source;\n        return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);\n    }\n    /**\n   * Place a render texture back into the pool.\n   * @param renderTexture - The renderTexture to free\n   */ returnTexture(renderTexture) {\n        const key = this._poolKeyHash[renderTexture.uid];\n        this._texturePool[key].push(renderTexture);\n    }\n    /**\n   * Clears the pool.\n   * @param destroyTextures - Destroy all stored textures.\n   */ clear(destroyTextures) {\n        destroyTextures = destroyTextures !== false;\n        if (destroyTextures) for(const i in this._texturePool){\n            const textures = this._texturePool[i];\n            if (textures) for(let j = 0; j < textures.length; j++)textures[j].destroy(true);\n        }\n        this._texturePool = {};\n    }\n}\nconst $24b29c011bc4c5b6$export$686d8ddcd5ee6cd2 = new $24b29c011bc4c5b6$export$f5c6a2d8ed21d1d();\n\n});\n\nparcelRegister(\"1amHU\", function(module, exports) {\n\n$parcel$export(module.exports, \"compileHighShaderGpuProgram\", () => $9be65aec2342e1ab$export$af9d352c01aa9018);\n$parcel$export(module.exports, \"compileHighShaderGlProgram\", () => $9be65aec2342e1ab$export$477b8252c7ecdf2);\n\nvar $2AaNu = parcelRequire(\"2AaNu\");\n\nvar $9IRF4 = parcelRequire(\"9IRF4\");\n\nvar $2umnT = parcelRequire(\"2umnT\");\n\nvar $9tj2y = parcelRequire(\"9tj2y\");\n\nvar $bgSqr = parcelRequire(\"bgSqr\");\n\"use strict\";\nfunction $9be65aec2342e1ab$export$af9d352c01aa9018({ bits: bits, name: name }) {\n    const source = (0, $2umnT.compileHighShader)({\n        template: {\n            fragment: (0, $9tj2y.fragmentGPUTemplate),\n            vertex: (0, $9tj2y.vertexGPUTemplate)\n        },\n        bits: [\n            (0, $bgSqr.globalUniformsBit),\n            ...bits\n        ]\n    });\n    return (0, $9IRF4.GpuProgram).from({\n        name: name,\n        vertex: {\n            source: source.vertex,\n            entryPoint: \"main\"\n        },\n        fragment: {\n            source: source.fragment,\n            entryPoint: \"main\"\n        }\n    });\n}\nfunction $9be65aec2342e1ab$export$477b8252c7ecdf2({ bits: bits, name: name }) {\n    return new (0, $2AaNu.GlProgram)({\n        name: name,\n        ...(0, $2umnT.compileHighShaderGl)({\n            template: {\n                vertex: (0, $9tj2y.vertexGlTemplate),\n                fragment: (0, $9tj2y.fragmentGlTemplate)\n            },\n            bits: [\n                (0, $bgSqr.globalUniformsBitGl),\n                ...bits\n            ]\n        })\n    });\n}\n\n});\nparcelRegister(\"2AaNu\", function(module, exports) {\n\n$parcel$export(module.exports, \"GlProgram\", () => $3e4928f628b169ba$export$64881d9ea0a969d7);\n\nvar $2aTkI = parcelRequire(\"2aTkI\");\n\nvar $76Gha = parcelRequire(\"76Gha\");\n\nvar $6chrV = parcelRequire(\"6chrV\");\n\nvar $9uh5G = parcelRequire(\"9uh5G\");\n\nvar $5ThHq = parcelRequire(\"5ThHq\");\n\nvar $2smQn = parcelRequire(\"2smQn\");\n\nvar $cuCqf = parcelRequire(\"cuCqf\");\n\"use strict\";\nconst $3e4928f628b169ba$var$processes = {\n    stripVersion: // strips any version headers..\n    $cuCqf.stripVersion,\n    ensurePrecision: // adds precision string if not already present\n    $9uh5G.ensurePrecision,\n    addProgramDefines: // add some defines if WebGL1 to make it more compatible with WebGL2 shaders\n    $6chrV.addProgramDefines,\n    setProgramName: // add the program name to the shader\n    $2smQn.setProgramName,\n    insertVersion: // add the version string to the shader header\n    $5ThHq.insertVersion\n};\nconst $3e4928f628b169ba$var$programCache = /* @__PURE__ */ Object.create(null);\nconst $3e4928f628b169ba$var$_GlProgram = class _GlProgram {\n    /**\n   * Creates a shiny new GlProgram. Used by WebGL renderer.\n   * @param options - The options for the program.\n   */ constructor(options){\n        options = {\n            ..._GlProgram.defaultOptions,\n            ...options\n        };\n        const isES300 = options.fragment.indexOf(\"#version 300 es\") !== -1;\n        const preprocessorOptions = {\n            stripVersion: isES300,\n            ensurePrecision: {\n                requestedFragmentPrecision: options.preferredFragmentPrecision,\n                requestedVertexPrecision: options.preferredVertexPrecision,\n                maxSupportedVertexPrecision: \"highp\",\n                maxSupportedFragmentPrecision: (0, $76Gha.getMaxFragmentPrecision)()\n            },\n            setProgramName: {\n                name: options.name\n            },\n            addProgramDefines: isES300,\n            insertVersion: isES300\n        };\n        let fragment = options.fragment;\n        let vertex = options.vertex;\n        Object.keys($3e4928f628b169ba$var$processes).forEach((processKey)=>{\n            const processOptions = preprocessorOptions[processKey];\n            fragment = $3e4928f628b169ba$var$processes[processKey](fragment, processOptions, true);\n            vertex = $3e4928f628b169ba$var$processes[processKey](vertex, processOptions, false);\n        });\n        this.fragment = fragment;\n        this.vertex = vertex;\n        this._key = (0, $2aTkI.createIdFromString)(`${this.vertex}:${this.fragment}`, \"gl-program\");\n    }\n    /** destroys the program */ destroy() {\n        this.fragment = null;\n        this.vertex = null;\n        this._attributeData = null;\n        this._uniformData = null;\n        this._uniformBlockData = null;\n        this.transformFeedbackVaryings = null;\n    }\n    /**\n   * Helper function that creates a program for a given source.\n   * It will check the program cache if the program has already been created.\n   * If it has that one will be returned, if not a new one will be created and cached.\n   * @param options - The options for the program.\n   * @returns A program using the same source\n   */ static from(options) {\n        const key = `${options.vertex}:${options.fragment}`;\n        if (!$3e4928f628b169ba$var$programCache[key]) $3e4928f628b169ba$var$programCache[key] = new _GlProgram(options);\n        return $3e4928f628b169ba$var$programCache[key];\n    }\n};\n/** The default options used by the program. */ $3e4928f628b169ba$var$_GlProgram.defaultOptions = {\n    preferredVertexPrecision: \"highp\",\n    preferredFragmentPrecision: \"mediump\"\n};\nlet $3e4928f628b169ba$export$64881d9ea0a969d7 = $3e4928f628b169ba$var$_GlProgram;\n\n});\nparcelRegister(\"76Gha\", function(module, exports) {\n\n$parcel$export(module.exports, \"getMaxFragmentPrecision\", () => $3314ddd978d8f610$export$428c38e64838140);\n\nvar $towXg = parcelRequire(\"towXg\");\n\"use strict\";\nlet $3314ddd978d8f610$var$maxFragmentPrecision;\nfunction $3314ddd978d8f610$export$428c38e64838140() {\n    if (!$3314ddd978d8f610$var$maxFragmentPrecision) {\n        $3314ddd978d8f610$var$maxFragmentPrecision = \"mediump\";\n        const gl = (0, $towXg.getTestContext)();\n        if (gl) {\n            if (gl.getShaderPrecisionFormat) {\n                const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n                $3314ddd978d8f610$var$maxFragmentPrecision = shaderFragment.precision ? \"highp\" : \"mediump\";\n            }\n        }\n    }\n    return $3314ddd978d8f610$var$maxFragmentPrecision;\n}\n\n});\nparcelRegister(\"towXg\", function(module, exports) {\n\n$parcel$export(module.exports, \"getTestContext\", () => $706e2ddb38efa68c$export$f034b2d55f8df08b);\n\nvar $5m2Qn = parcelRequire(\"5m2Qn\");\n\"use strict\";\nlet $706e2ddb38efa68c$var$context;\nfunction $706e2ddb38efa68c$export$f034b2d55f8df08b() {\n    if (!$706e2ddb38efa68c$var$context || $706e2ddb38efa68c$var$context?.isContextLost()) {\n        const canvas = (0, $5m2Qn.DOMAdapter).get().createCanvas();\n        $706e2ddb38efa68c$var$context = canvas.getContext(\"webgl\", {});\n    }\n    return $706e2ddb38efa68c$var$context;\n}\n\n});\n\n\nparcelRegister(\"6chrV\", function(module, exports) {\n\n$parcel$export(module.exports, \"addProgramDefines\", () => $b1b65f75cf795082$export$fba00ea8bc676dd1);\n\"use strict\";\nfunction $b1b65f75cf795082$export$fba00ea8bc676dd1(src, isES300, isFragment) {\n    if (isES300) return src;\n    if (isFragment) {\n        src = src.replace(\"out vec4 finalColor;\", \"\");\n        return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${src}\n        `;\n    }\n    return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${src}\n        `;\n}\n\n});\n\nparcelRegister(\"9uh5G\", function(module, exports) {\n\n$parcel$export(module.exports, \"ensurePrecision\", () => $62185500478be9a1$export$899bdffb1b617f8b);\n\"use strict\";\nfunction $62185500478be9a1$export$899bdffb1b617f8b(src, options, isFragment) {\n    const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;\n    if (src.substring(0, 9) !== \"precision\") {\n        let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;\n        if (precision === \"highp\" && maxSupportedPrecision !== \"highp\") precision = \"mediump\";\n        return `precision ${precision} float;\n${src}`;\n    } else if (maxSupportedPrecision !== \"highp\" && src.substring(0, 15) === \"precision highp\") return src.replace(\"precision highp\", \"precision mediump\");\n    return src;\n}\n\n});\n\nparcelRegister(\"5ThHq\", function(module, exports) {\n\n$parcel$export(module.exports, \"insertVersion\", () => $a383d746f12b3c11$export$df5409633d2e06a0);\n\"use strict\";\nfunction $a383d746f12b3c11$export$df5409633d2e06a0(src, isES300) {\n    if (!isES300) return src;\n    return `#version 300 es\n${src}`;\n}\n\n});\n\nparcelRegister(\"2smQn\", function(module, exports) {\n\n$parcel$export(module.exports, \"setProgramName\", () => $b4c893c1192ca086$export$fcd35f5a80d5e29b);\n\"use strict\";\nconst $b4c893c1192ca086$var$fragmentNameCache = {};\nconst $b4c893c1192ca086$var$VertexNameCache = {};\nfunction $b4c893c1192ca086$export$fcd35f5a80d5e29b(src, { name: name = `pixi-program` }, isFragment = true) {\n    name = name.replace(/\\s+/g, \"-\");\n    name += isFragment ? \"-fragment\" : \"-vertex\";\n    const nameCache = isFragment ? $b4c893c1192ca086$var$fragmentNameCache : $b4c893c1192ca086$var$VertexNameCache;\n    if (nameCache[name]) {\n        nameCache[name]++;\n        name += `-${nameCache[name]}`;\n    } else nameCache[name] = 1;\n    if (src.indexOf(\"#define SHADER_NAME\") !== -1) return src;\n    const shaderName = `#define SHADER_NAME ${name}`;\n    return `${shaderName}\n${src}`;\n}\n\n});\n\nparcelRegister(\"cuCqf\", function(module, exports) {\n\n$parcel$export(module.exports, \"stripVersion\", () => $f751430174b741b8$export$f71406e7a553e9e5);\n\"use strict\";\nfunction $f751430174b741b8$export$f71406e7a553e9e5(src, isES300) {\n    if (!isES300) return src;\n    return src.replace(\"#version 300 es\", \"\");\n}\n\n});\n\n\nparcelRegister(\"9IRF4\", function(module, exports) {\n\n$parcel$export(module.exports, \"GpuProgram\", () => $7eafa2827bb311cd$export$b7a31a3cdd61870);\n\nvar $2aTkI = parcelRequire(\"2aTkI\");\n\nvar $2liBL = parcelRequire(\"2liBL\");\n\nvar $fPdyx = parcelRequire(\"fPdyx\");\n\nvar $9BwwY = parcelRequire(\"9BwwY\");\n\nvar $iHjNs = parcelRequire(\"iHjNs\");\n\nvar $4ZXFu = parcelRequire(\"4ZXFu\");\n\"use strict\";\nconst $7eafa2827bb311cd$var$programCache = /* @__PURE__ */ Object.create(null);\nclass $7eafa2827bb311cd$export$b7a31a3cdd61870 {\n    /**\n   * Create a new GpuProgram\n   * @param options - The options for the gpu program\n   */ constructor(options){\n        /**\n     * @internal\n     * @ignore\n     */ this._layoutKey = 0;\n        const { fragment: fragment, vertex: vertex, layout: layout, gpuLayout: gpuLayout, name: name } = options;\n        this.name = name;\n        this.fragment = fragment;\n        this.vertex = vertex;\n        if (fragment.source === vertex.source) {\n            const structsAndGroups = (0, $fPdyx.extractStructAndGroups)(fragment.source);\n            this.structsAndGroups = structsAndGroups;\n        } else {\n            const vertexStructsAndGroups = (0, $fPdyx.extractStructAndGroups)(vertex.source);\n            const fragmentStructsAndGroups = (0, $fPdyx.extractStructAndGroups)(fragment.source);\n            this.structsAndGroups = (0, $4ZXFu.removeStructAndGroupDuplicates)(vertexStructsAndGroups, fragmentStructsAndGroups);\n        }\n        this.layout = layout ?? (0, $iHjNs.generateLayoutHash)(this.structsAndGroups);\n        this.gpuLayout = gpuLayout ?? (0, $9BwwY.generateGpuLayoutGroups)(this.structsAndGroups);\n        this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== void 0);\n        this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== void 0);\n        this._generateProgramKey();\n    }\n    // TODO maker this pure\n    _generateProgramKey() {\n        const { vertex: vertex, fragment: fragment } = this;\n        const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;\n        this._layoutKey = (0, $2aTkI.createIdFromString)(bigKey, \"program\");\n    }\n    get attributeData() {\n        this._attributeData ?? (this._attributeData = (0, $2liBL.extractAttributesFromGpuProgram)(this.vertex));\n        return this._attributeData;\n    }\n    /** destroys the program */ destroy() {\n        this.gpuLayout = null;\n        this.layout = null;\n        this.structsAndGroups = null;\n        this.fragment = null;\n        this.vertex = null;\n    }\n    /**\n   * Helper function that creates a program for a given source.\n   * It will check the program cache if the program has already been created.\n   * If it has that one will be returned, if not a new one will be created and cached.\n   * @param options - The options for the program.\n   * @returns A program using the same source\n   */ static from(options) {\n        const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;\n        if (!$7eafa2827bb311cd$var$programCache[key]) $7eafa2827bb311cd$var$programCache[key] = new $7eafa2827bb311cd$export$b7a31a3cdd61870(options);\n        return $7eafa2827bb311cd$var$programCache[key];\n    }\n}\n\n});\nparcelRegister(\"2liBL\", function(module, exports) {\n\n$parcel$export(module.exports, \"extractAttributesFromGpuProgram\", () => $1347c7101bdc3d4b$export$b0efe5f01c53f69f);\n\nvar $97JA6 = parcelRequire(\"97JA6\");\n\"use strict\";\nconst $1347c7101bdc3d4b$var$WGSL_TO_VERTEX_TYPES = {\n    f32: \"float32\",\n    \"vec2<f32>\": \"float32x2\",\n    \"vec3<f32>\": \"float32x3\",\n    \"vec4<f32>\": \"float32x4\",\n    vec2f: \"float32x2\",\n    vec3f: \"float32x3\",\n    vec4f: \"float32x4\",\n    i32: \"sint32\",\n    \"vec2<i32>\": \"sint32x2\",\n    \"vec3<i32>\": \"sint32x3\",\n    \"vec4<i32>\": \"sint32x4\",\n    u32: \"uint32\",\n    \"vec2<u32>\": \"uint32x2\",\n    \"vec3<u32>\": \"uint32x3\",\n    \"vec4<u32>\": \"uint32x4\",\n    bool: \"uint32\",\n    \"vec2<bool>\": \"uint32x2\",\n    \"vec3<bool>\": \"uint32x3\",\n    \"vec4<bool>\": \"uint32x4\"\n};\nfunction $1347c7101bdc3d4b$export$b0efe5f01c53f69f({ source: source, entryPoint: entryPoint }) {\n    const results = {};\n    const mainVertStart = source.indexOf(`fn ${entryPoint}`);\n    if (mainVertStart !== -1) {\n        const arrowFunctionStart = source.indexOf(\"->\", mainVertStart);\n        if (arrowFunctionStart !== -1) {\n            const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);\n            const inputsRegex = /@location\\((\\d+)\\)\\s+([a-zA-Z0-9_]+)\\s*:\\s*([a-zA-Z0-9_<>]+)(?:,|\\s|$)/g;\n            let match;\n            while((match = inputsRegex.exec(functionArgsSubstring)) !== null){\n                const format = $1347c7101bdc3d4b$var$WGSL_TO_VERTEX_TYPES[match[3]] ?? \"float32\";\n                results[match[2]] = {\n                    location: parseInt(match[1], 10),\n                    format: format,\n                    stride: (0, $97JA6.getAttributeInfoFromFormat)(format).stride,\n                    offset: 0,\n                    instance: false,\n                    start: 0\n                };\n            }\n        }\n    }\n    return results;\n}\n\n});\nparcelRegister(\"97JA6\", function(module, exports) {\n\n$parcel$export(module.exports, \"getAttributeInfoFromFormat\", () => $323edfeef0d2ad2f$export$4da509c30cc6be33);\n\"use strict\";\nconst $323edfeef0d2ad2f$var$attributeFormatData = {\n    uint8x2: {\n        size: 2,\n        stride: 2,\n        normalised: false\n    },\n    uint8x4: {\n        size: 4,\n        stride: 4,\n        normalised: false\n    },\n    sint8x2: {\n        size: 2,\n        stride: 2,\n        normalised: false\n    },\n    sint8x4: {\n        size: 4,\n        stride: 4,\n        normalised: false\n    },\n    unorm8x2: {\n        size: 2,\n        stride: 2,\n        normalised: true\n    },\n    unorm8x4: {\n        size: 4,\n        stride: 4,\n        normalised: true\n    },\n    snorm8x2: {\n        size: 2,\n        stride: 2,\n        normalised: true\n    },\n    snorm8x4: {\n        size: 4,\n        stride: 4,\n        normalised: true\n    },\n    uint16x2: {\n        size: 2,\n        stride: 4,\n        normalised: false\n    },\n    uint16x4: {\n        size: 4,\n        stride: 8,\n        normalised: false\n    },\n    sint16x2: {\n        size: 2,\n        stride: 4,\n        normalised: false\n    },\n    sint16x4: {\n        size: 4,\n        stride: 8,\n        normalised: false\n    },\n    unorm16x2: {\n        size: 2,\n        stride: 4,\n        normalised: true\n    },\n    unorm16x4: {\n        size: 4,\n        stride: 8,\n        normalised: true\n    },\n    snorm16x2: {\n        size: 2,\n        stride: 4,\n        normalised: true\n    },\n    snorm16x4: {\n        size: 4,\n        stride: 8,\n        normalised: true\n    },\n    float16x2: {\n        size: 2,\n        stride: 4,\n        normalised: false\n    },\n    float16x4: {\n        size: 4,\n        stride: 8,\n        normalised: false\n    },\n    float32: {\n        size: 1,\n        stride: 4,\n        normalised: false\n    },\n    float32x2: {\n        size: 2,\n        stride: 8,\n        normalised: false\n    },\n    float32x3: {\n        size: 3,\n        stride: 12,\n        normalised: false\n    },\n    float32x4: {\n        size: 4,\n        stride: 16,\n        normalised: false\n    },\n    uint32: {\n        size: 1,\n        stride: 4,\n        normalised: false\n    },\n    uint32x2: {\n        size: 2,\n        stride: 8,\n        normalised: false\n    },\n    uint32x3: {\n        size: 3,\n        stride: 12,\n        normalised: false\n    },\n    uint32x4: {\n        size: 4,\n        stride: 16,\n        normalised: false\n    },\n    sint32: {\n        size: 1,\n        stride: 4,\n        normalised: false\n    },\n    sint32x2: {\n        size: 2,\n        stride: 8,\n        normalised: false\n    },\n    sint32x3: {\n        size: 3,\n        stride: 12,\n        normalised: false\n    },\n    sint32x4: {\n        size: 4,\n        stride: 16,\n        normalised: false\n    }\n};\nfunction $323edfeef0d2ad2f$export$4da509c30cc6be33(format) {\n    return $323edfeef0d2ad2f$var$attributeFormatData[format] ?? $323edfeef0d2ad2f$var$attributeFormatData.float32;\n}\n\n});\n\n\nparcelRegister(\"fPdyx\", function(module, exports) {\n\n$parcel$export(module.exports, \"extractStructAndGroups\", () => $a773d036452fda49$export$368e99a200562975);\n\"use strict\";\nfunction $a773d036452fda49$export$368e99a200562975(wgsl) {\n    const linePattern = /(^|[^/])@(group|binding)\\(\\d+\\)[^;]+;/g;\n    const groupPattern = /@group\\((\\d+)\\)/;\n    const bindingPattern = /@binding\\((\\d+)\\)/;\n    const namePattern = /var(<[^>]+>)? (\\w+)/;\n    const typePattern = /:\\s*(\\w+)/;\n    const structPattern = /struct\\s+(\\w+)\\s*{([^}]+)}/g;\n    const structMemberPattern = /(\\w+)\\s*:\\s*([\\w\\<\\>]+)/g;\n    const structName = /struct\\s+(\\w+)/;\n    const groups = wgsl.match(linePattern)?.map((item)=>({\n            group: parseInt(item.match(groupPattern)[1], 10),\n            binding: parseInt(item.match(bindingPattern)[1], 10),\n            name: item.match(namePattern)[2],\n            isUniform: item.match(namePattern)[1] === \"<uniform>\",\n            type: item.match(typePattern)[1]\n        }));\n    if (!groups) return {\n        groups: [],\n        structs: []\n    };\n    const structs = wgsl.match(structPattern)?.map((struct)=>{\n        const name = struct.match(structName)[1];\n        const members = struct.match(structMemberPattern).reduce((acc, member)=>{\n            const [name2, type] = member.split(\":\");\n            acc[name2.trim()] = type.trim();\n            return acc;\n        }, {});\n        if (!members) return null;\n        return {\n            name: name,\n            members: members\n        };\n    }).filter(({ name: name })=>groups.some((group)=>group.type === name)) ?? [];\n    return {\n        groups: groups,\n        structs: structs\n    };\n}\n\n});\n\nparcelRegister(\"9BwwY\", function(module, exports) {\n\n$parcel$export(module.exports, \"generateGpuLayoutGroups\", () => $cd3b18489a63a192$export$950011c0dc347495);\n\nvar $6ONS2 = parcelRequire(\"6ONS2\");\n\"use strict\";\nfunction $cd3b18489a63a192$export$950011c0dc347495({ groups: groups }) {\n    const layout = [];\n    for(let i = 0; i < groups.length; i++){\n        const group = groups[i];\n        if (!layout[group.group]) layout[group.group] = [];\n        if (group.isUniform) layout[group.group].push({\n            binding: group.binding,\n            visibility: (0, $6ONS2.ShaderStage).VERTEX | (0, $6ONS2.ShaderStage).FRAGMENT,\n            buffer: {\n                type: \"uniform\"\n            }\n        });\n        else if (group.type === \"sampler\") layout[group.group].push({\n            binding: group.binding,\n            visibility: (0, $6ONS2.ShaderStage).FRAGMENT,\n            sampler: {\n                type: \"filtering\"\n            }\n        });\n        else if (group.type === \"texture_2d\") layout[group.group].push({\n            binding: group.binding,\n            visibility: (0, $6ONS2.ShaderStage).FRAGMENT,\n            texture: {\n                sampleType: \"float\",\n                viewDimension: \"2d\",\n                multisampled: false\n            }\n        });\n    }\n    return layout;\n}\n\n});\nparcelRegister(\"6ONS2\", function(module, exports) {\n\n$parcel$export(module.exports, \"ShaderStage\", () => $f39c1ac9ce80191b$export$34a0cafc5a97ef31);\n\"use strict\";\nvar $f39c1ac9ce80191b$export$34a0cafc5a97ef31 = /* @__PURE__ */ ((ShaderStage2)=>{\n    ShaderStage2[ShaderStage2[\"VERTEX\"] = 1] = \"VERTEX\";\n    ShaderStage2[ShaderStage2[\"FRAGMENT\"] = 2] = \"FRAGMENT\";\n    ShaderStage2[ShaderStage2[\"COMPUTE\"] = 4] = \"COMPUTE\";\n    return ShaderStage2;\n})($f39c1ac9ce80191b$export$34a0cafc5a97ef31 || {});\n\n});\n\n\nparcelRegister(\"iHjNs\", function(module, exports) {\n\n$parcel$export(module.exports, \"generateLayoutHash\", () => $7c0fb19c18bf77fd$export$6a0f9650f9d4f875);\n\"use strict\";\nfunction $7c0fb19c18bf77fd$export$6a0f9650f9d4f875({ groups: groups }) {\n    const layout = [];\n    for(let i = 0; i < groups.length; i++){\n        const group = groups[i];\n        if (!layout[group.group]) layout[group.group] = {};\n        layout[group.group][group.name] = group.binding;\n    }\n    return layout;\n}\n\n});\n\nparcelRegister(\"4ZXFu\", function(module, exports) {\n\n$parcel$export(module.exports, \"removeStructAndGroupDuplicates\", () => $abd17b3222aab333$export$5f344e20ddfaa2d6);\n\"use strict\";\nfunction $abd17b3222aab333$export$5f344e20ddfaa2d6(vertexStructsAndGroups, fragmentStructsAndGroups) {\n    const structNameSet = /* @__PURE__ */ new Set();\n    const dupeGroupKeySet = /* @__PURE__ */ new Set();\n    const structs = [\n        ...vertexStructsAndGroups.structs,\n        ...fragmentStructsAndGroups.structs\n    ].filter((struct)=>{\n        if (structNameSet.has(struct.name)) return false;\n        structNameSet.add(struct.name);\n        return true;\n    });\n    const groups = [\n        ...vertexStructsAndGroups.groups,\n        ...fragmentStructsAndGroups.groups\n    ].filter((group)=>{\n        const key = `${group.name}-${group.binding}`;\n        if (dupeGroupKeySet.has(key)) return false;\n        dupeGroupKeySet.add(key);\n        return true;\n    });\n    return {\n        structs: structs,\n        groups: groups\n    };\n}\n\n});\n\n\nparcelRegister(\"2umnT\", function(module, exports) {\n\n$parcel$export(module.exports, \"compileHighShader\", () => $f0d2795437b8c8e6$export$86219fd7a1c584d2);\n$parcel$export(module.exports, \"compileHighShaderGl\", () => $f0d2795437b8c8e6$export$ff7039b165d48f97);\n\nvar $hcREI = parcelRequire(\"hcREI\");\n\nvar $gFFZS = parcelRequire(\"gFFZS\");\n\nvar $ltnz8 = parcelRequire(\"ltnz8\");\n\nvar $3smY9 = parcelRequire(\"3smY9\");\n\nvar $3mQzs = parcelRequire(\"3mQzs\");\n\"use strict\";\nconst $f0d2795437b8c8e6$var$cacheMap = /* @__PURE__ */ Object.create(null);\nconst $f0d2795437b8c8e6$var$bitCacheMap = /* @__PURE__ */ new Map();\nlet $f0d2795437b8c8e6$var$CACHE_UID = 0;\nfunction $f0d2795437b8c8e6$export$86219fd7a1c584d2({ template: template, bits: bits }) {\n    const cacheId = $f0d2795437b8c8e6$var$generateCacheId(template, bits);\n    if ($f0d2795437b8c8e6$var$cacheMap[cacheId]) return $f0d2795437b8c8e6$var$cacheMap[cacheId];\n    const { vertex: vertex, fragment: fragment } = $f0d2795437b8c8e6$var$compileInputsAndOutputs(template, bits);\n    $f0d2795437b8c8e6$var$cacheMap[cacheId] = $f0d2795437b8c8e6$var$compileBits(vertex, fragment, bits);\n    return $f0d2795437b8c8e6$var$cacheMap[cacheId];\n}\nfunction $f0d2795437b8c8e6$export$ff7039b165d48f97({ template: template, bits: bits }) {\n    const cacheId = $f0d2795437b8c8e6$var$generateCacheId(template, bits);\n    if ($f0d2795437b8c8e6$var$cacheMap[cacheId]) return $f0d2795437b8c8e6$var$cacheMap[cacheId];\n    $f0d2795437b8c8e6$var$cacheMap[cacheId] = $f0d2795437b8c8e6$var$compileBits(template.vertex, template.fragment, bits);\n    return $f0d2795437b8c8e6$var$cacheMap[cacheId];\n}\nfunction $f0d2795437b8c8e6$var$compileInputsAndOutputs(template, bits) {\n    const vertexFragments = bits.map((shaderBit)=>shaderBit.vertex).filter((v)=>!!v);\n    const fragmentFragments = bits.map((shaderBit)=>shaderBit.fragment).filter((v)=>!!v);\n    let compiledVertex = (0, $ltnz8.compileInputs)(vertexFragments, template.vertex, true);\n    compiledVertex = (0, $3smY9.compileOutputs)(vertexFragments, compiledVertex);\n    const compiledFragment = (0, $ltnz8.compileInputs)(fragmentFragments, template.fragment, true);\n    return {\n        vertex: compiledVertex,\n        fragment: compiledFragment\n    };\n}\nfunction $f0d2795437b8c8e6$var$generateCacheId(template, bits) {\n    return bits.map((highFragment)=>{\n        if (!$f0d2795437b8c8e6$var$bitCacheMap.has(highFragment)) $f0d2795437b8c8e6$var$bitCacheMap.set(highFragment, $f0d2795437b8c8e6$var$CACHE_UID++);\n        return $f0d2795437b8c8e6$var$bitCacheMap.get(highFragment);\n    }).sort((a, b)=>a - b).join(\"-\") + template.vertex + template.fragment;\n}\nfunction $f0d2795437b8c8e6$var$compileBits(vertex, fragment, bits) {\n    const vertexParts = (0, $gFFZS.compileHooks)(vertex);\n    const fragmentParts = (0, $gFFZS.compileHooks)(fragment);\n    bits.forEach((shaderBit)=>{\n        (0, $hcREI.addBits)(shaderBit.vertex, vertexParts, shaderBit.name);\n        (0, $hcREI.addBits)(shaderBit.fragment, fragmentParts, shaderBit.name);\n    });\n    return {\n        vertex: (0, $3mQzs.injectBits)(vertex, vertexParts),\n        fragment: (0, $3mQzs.injectBits)(fragment, fragmentParts)\n    };\n}\n\n});\nparcelRegister(\"hcREI\", function(module, exports) {\n\n$parcel$export(module.exports, \"addBits\", () => $783d512ed9109c4e$export$38c21fb192fe3d9);\n\nvar $8CF4q = parcelRequire(\"8CF4q\");\n\"use strict\";\nfunction $783d512ed9109c4e$export$38c21fb192fe3d9(srcParts, parts, name) {\n    if (srcParts) for(const i in srcParts){\n        const id = i.toLocaleLowerCase();\n        const part = parts[id];\n        if (part) {\n            let sanitisedPart = srcParts[i];\n            if (i === \"header\") sanitisedPart = sanitisedPart.replace(/@in\\s+[^;]+;\\s*/g, \"\").replace(/@out\\s+[^;]+;\\s*/g, \"\");\n            if (name) part.push(`//----${name}----//`);\n            part.push(sanitisedPart);\n        } else (0, $8CF4q.warn)(`${i} placement hook does not exist in shader`);\n    }\n}\n\n});\n\nparcelRegister(\"gFFZS\", function(module, exports) {\n\n$parcel$export(module.exports, \"compileHooks\", () => $7b8dc76672cc3e6f$export$17705ba43ca63936);\n\"use strict\";\nconst $7b8dc76672cc3e6f$export$a564a4c9984eee7d = /\\{\\{(.*?)\\}\\}/g;\nfunction $7b8dc76672cc3e6f$export$17705ba43ca63936(programSrc) {\n    const parts = {};\n    const partMatches = programSrc.match($7b8dc76672cc3e6f$export$a564a4c9984eee7d)?.map((hook)=>hook.replace(/[{()}]/g, \"\")) ?? [];\n    partMatches.forEach((hook)=>{\n        parts[hook] = [];\n    });\n    return parts;\n}\n\n});\n\nparcelRegister(\"ltnz8\", function(module, exports) {\n\n$parcel$export(module.exports, \"compileInputs\", () => $9de63faf17acebfa$export$aa47df9391ef0455);\n\"use strict\";\nfunction $9de63faf17acebfa$var$extractInputs(fragmentSource, out) {\n    let match;\n    const regex = /@in\\s+([^;]+);/g;\n    while((match = regex.exec(fragmentSource)) !== null)out.push(match[1]);\n}\nfunction $9de63faf17acebfa$export$aa47df9391ef0455(fragments, template, sort = false) {\n    const results = [];\n    $9de63faf17acebfa$var$extractInputs(template, results);\n    fragments.forEach((fragment)=>{\n        if (fragment.header) $9de63faf17acebfa$var$extractInputs(fragment.header, results);\n    });\n    const mainInput = results;\n    if (sort) mainInput.sort();\n    const finalString = mainInput.map((inValue, i)=>`       @location(${i}) ${inValue},`).join(\"\\n\");\n    let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, \"\");\n    cleanedString = cleanedString.replace(\"{{in}}\", `\n${finalString}\n`);\n    return cleanedString;\n}\n\n});\n\nparcelRegister(\"3smY9\", function(module, exports) {\n\n$parcel$export(module.exports, \"compileOutputs\", () => $21523912be22cf2a$export$ae19cc473c7ab18);\n\"use strict\";\nfunction $21523912be22cf2a$var$extractOutputs(fragmentSource, out) {\n    let match;\n    const regex = /@out\\s+([^;]+);/g;\n    while((match = regex.exec(fragmentSource)) !== null)out.push(match[1]);\n}\nfunction $21523912be22cf2a$var$extractVariableName(value) {\n    const regex = /\\b(\\w+)\\s*:/g;\n    const match = regex.exec(value);\n    return match ? match[1] : \"\";\n}\nfunction $21523912be22cf2a$var$stripVariable(value) {\n    const regex = /@.*?\\s+/g;\n    return value.replace(regex, \"\");\n}\nfunction $21523912be22cf2a$export$ae19cc473c7ab18(fragments, template) {\n    const results = [];\n    $21523912be22cf2a$var$extractOutputs(template, results);\n    fragments.forEach((fragment)=>{\n        if (fragment.header) $21523912be22cf2a$var$extractOutputs(fragment.header, results);\n    });\n    let index = 0;\n    const mainStruct = results.sort().map((inValue)=>{\n        if (inValue.indexOf(\"builtin\") > -1) return inValue;\n        return `@location(${index++}) ${inValue}`;\n    }).join(\",\\n\");\n    const mainStart = results.sort().map((inValue)=>`       var ${$21523912be22cf2a$var$stripVariable(inValue)};`).join(\"\\n\");\n    const mainEnd = `return VSOutput(\n                ${results.sort().map((inValue)=>` ${$21523912be22cf2a$var$extractVariableName(inValue)}`).join(\",\\n\")});`;\n    let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, \"\");\n    compiledCode = compiledCode.replace(\"{{struct}}\", `\n${mainStruct}\n`);\n    compiledCode = compiledCode.replace(\"{{start}}\", `\n${mainStart}\n`);\n    compiledCode = compiledCode.replace(\"{{return}}\", `\n${mainEnd}\n`);\n    return compiledCode;\n}\n\n});\n\nparcelRegister(\"3mQzs\", function(module, exports) {\n\n$parcel$export(module.exports, \"injectBits\", () => $9220e691b142b050$export$83c47c7340456c75);\n\"use strict\";\nfunction $9220e691b142b050$export$83c47c7340456c75(templateSrc, fragmentParts) {\n    let out = templateSrc;\n    for(const i in fragmentParts){\n        const parts = fragmentParts[i];\n        const toInject = parts.join(\"\\n\");\n        if (toInject.length) out = out.replace(`{{${i}}}`, `//-----${i} START-----//\n${parts.join(\"\\n\")}\n//----${i} FINISH----//`);\n        else out = out.replace(`{{${i}}}`, \"\");\n    }\n    return out;\n}\n\n});\n\n\nparcelRegister(\"9tj2y\", function(module, exports) {\n\n$parcel$export(module.exports, \"vertexGPUTemplate\", () => $7b7a87a63a893098$export$61ecfa8d2718163a);\n$parcel$export(module.exports, \"fragmentGPUTemplate\", () => $7b7a87a63a893098$export$922d1073ee2ef930);\n$parcel$export(module.exports, \"vertexGlTemplate\", () => $7b7a87a63a893098$export$99b0f79e15be8ede);\n$parcel$export(module.exports, \"fragmentGlTemplate\", () => $7b7a87a63a893098$export$3f7784dd6a13ff5a);\n\"use strict\";\nconst $7b7a87a63a893098$export$61ecfa8d2718163a = /* wgsl */ `\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`;\nconst $7b7a87a63a893098$export$922d1073ee2ef930 = /* wgsl */ `\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        return outColor * vColor;\n      };\n`;\nconst $7b7a87a63a893098$export$99b0f79e15be8ede = /* glsl */ `\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`;\nconst $7b7a87a63a893098$export$3f7784dd6a13ff5a = /* glsl */ `\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n    }\n`;\n\n});\n\nparcelRegister(\"bgSqr\", function(module, exports) {\n\n$parcel$export(module.exports, \"globalUniformsBit\", () => $65883fe23256fd04$export$435d64b3a14c5a51);\n$parcel$export(module.exports, \"globalUniformsBitGl\", () => $65883fe23256fd04$export$38608853d4735d51);\n\"use strict\";\nconst $65883fe23256fd04$export$435d64b3a14c5a51 = {\n    name: \"global-uniforms-bit\",\n    vertex: {\n        header: /* wgsl */ `\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    }\n};\nconst $65883fe23256fd04$export$320b7a2ae65b2f3a = {\n    name: \"global-uniforms-ubo-bit\",\n    vertex: {\n        header: /* glsl */ `\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    }\n};\nconst $65883fe23256fd04$export$38608853d4735d51 = {\n    name: \"global-uniforms-bit\",\n    vertex: {\n        header: /* glsl */ `\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    }\n};\n\n});\n\n\nparcelRegister(\"6NJrS\", function(module, exports) {\n\n$parcel$export(module.exports, \"colorBit\", () => $2daf77c5269b0d26$export$a62becfe5fe4ad2);\n$parcel$export(module.exports, \"colorBitGl\", () => $2daf77c5269b0d26$export$93189e9821cf4459);\n\"use strict\";\nconst $2daf77c5269b0d26$export$a62becfe5fe4ad2 = {\n    name: \"color-bit\",\n    vertex: {\n        header: /* wgsl */ `\n            @in aColor: vec4<f32>;\n        `,\n        main: /* wgsl */ `\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\nconst $2daf77c5269b0d26$export$93189e9821cf4459 = {\n    name: \"color-bit\",\n    vertex: {\n        header: /* glsl */ `\n            in vec4 aColor;\n        `,\n        main: /* glsl */ `\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n\n});\n\nparcelRegister(\"8WJj9\", function(module, exports) {\n\n$parcel$export(module.exports, \"generateTextureBatchBit\", () => $bef51538f7a1ee9b$export$aff2d36945cda647);\n$parcel$export(module.exports, \"generateTextureBatchBitGl\", () => $bef51538f7a1ee9b$export$204e46d9a7a4f835);\n\"use strict\";\nconst $bef51538f7a1ee9b$var$textureBatchBitGpuCache = {};\nfunction $bef51538f7a1ee9b$var$generateBindingSrc(maxTextures) {\n    const src = [];\n    if (maxTextures === 1) {\n        src.push(\"@group(1) @binding(0) var textureSource1: texture_2d<f32>;\");\n        src.push(\"@group(1) @binding(1) var textureSampler1: sampler;\");\n    } else {\n        let bindingIndex = 0;\n        for(let i = 0; i < maxTextures; i++){\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n        }\n    }\n    return src.join(\"\\n\");\n}\nfunction $bef51538f7a1ee9b$var$generateSampleSrc(maxTextures) {\n    const src = [];\n    if (maxTextures === 1) src.push(\"outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);\");\n    else {\n        src.push(\"switch vTextureId {\");\n        for(let i = 0; i < maxTextures; i++){\n            if (i === maxTextures - 1) src.push(`  default:{`);\n            else src.push(`  case ${i}:{`);\n            src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n            src.push(`      break;}`);\n        }\n        src.push(`}`);\n    }\n    return src.join(\"\\n\");\n}\nfunction $bef51538f7a1ee9b$export$aff2d36945cda647(maxTextures) {\n    if (!$bef51538f7a1ee9b$var$textureBatchBitGpuCache[maxTextures]) $bef51538f7a1ee9b$var$textureBatchBitGpuCache[maxTextures] = {\n        name: \"texture-batch-bit\",\n        vertex: {\n            header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n            main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n            end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n        },\n        fragment: {\n            header: `\n                @in @interpolate(flat) vTextureId: u32;\n    \n                ${$bef51538f7a1ee9b$var$generateBindingSrc(16)}\n            `,\n            main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n    \n                ${$bef51538f7a1ee9b$var$generateSampleSrc(16)}\n            `\n        }\n    };\n    return $bef51538f7a1ee9b$var$textureBatchBitGpuCache[maxTextures];\n}\nconst $bef51538f7a1ee9b$var$textureBatchBitGlCache = {};\nfunction $bef51538f7a1ee9b$var$generateSampleGlSrc(maxTextures) {\n    const src = [];\n    for(let i = 0; i < maxTextures; i++){\n        if (i > 0) src.push(\"else\");\n        if (i < maxTextures - 1) src.push(`if(vTextureId < ${i}.5)`);\n        src.push(\"{\");\n        src.push(`\toutColor = texture(uTextures[${i}], vUV);`);\n        src.push(\"}\");\n    }\n    return src.join(\"\\n\");\n}\nfunction $bef51538f7a1ee9b$export$204e46d9a7a4f835(maxTextures) {\n    if (!$bef51538f7a1ee9b$var$textureBatchBitGlCache[maxTextures]) $bef51538f7a1ee9b$var$textureBatchBitGlCache[maxTextures] = {\n        name: \"texture-batch-bit\",\n        vertex: {\n            header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n              \n            `,\n            main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n            end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n        },\n        fragment: {\n            header: `\n                in float vTextureId;\n    \n                uniform sampler2D uTextures[${maxTextures}];\n              \n            `,\n            main: `\n    \n                ${$bef51538f7a1ee9b$var$generateSampleGlSrc(16)}\n            `\n        }\n    };\n    return $bef51538f7a1ee9b$var$textureBatchBitGlCache[maxTextures];\n}\n\n});\n\nparcelRegister(\"eJTyi\", function(module, exports) {\n\n$parcel$export(module.exports, \"roundPixelsBit\", () => $924b6a6b1952fa30$export$22150169726f7b1);\n$parcel$export(module.exports, \"roundPixelsBitGl\", () => $924b6a6b1952fa30$export$222909710f39cc5);\n\"use strict\";\nconst $924b6a6b1952fa30$export$22150169726f7b1 = {\n    name: \"round-pixels-bit\",\n    vertex: {\n        header: /* wgsl */ `\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor((position * 0.5 + 0.5) * targetSize) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\nconst $924b6a6b1952fa30$export$222909710f39cc5 = {\n    name: \"round-pixels-bit\",\n    vertex: {\n        header: /* glsl */ `   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor((position * 0.5 + 0.5) * targetSize) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\n});\n\nparcelRegister(\"7cNGO\", function(module, exports) {\n\n$parcel$export(module.exports, \"Shader\", () => $c2c6fdb6cde61fa5$export$462bb059fed9d9e5);\n\nvar $gpXaq = parcelRequire(\"gpXaq\");\n\nvar $2AaNu = parcelRequire(\"2AaNu\");\n\nvar $86NKO = parcelRequire(\"86NKO\");\n\nvar $9IRF4 = parcelRequire(\"9IRF4\");\n\nvar $dgEnR = parcelRequire(\"dgEnR\");\n\nvar $lJEsO = parcelRequire(\"lJEsO\");\n\"use strict\";\nclass $c2c6fdb6cde61fa5$export$462bb059fed9d9e5 extends (0, (/*@__PURE__*/$parcel$interopDefault($gpXaq))) {\n    constructor(options){\n        super();\n        /**\n     * A record of the uniform groups and resources used by the shader.\n     * This is used by WebGL renderer to sync uniform data.\n     * @internal\n     * @ignore\n     */ this._uniformBindMap = /* @__PURE__ */ Object.create(null);\n        this._ownedBindGroups = [];\n        let { gpuProgram: gpuProgram, glProgram: glProgram, groups: groups, resources: resources, compatibleRenderers: compatibleRenderers, groupMap: groupMap } = options;\n        this.gpuProgram = gpuProgram;\n        this.glProgram = glProgram;\n        if (compatibleRenderers === void 0) {\n            compatibleRenderers = 0;\n            if (gpuProgram) compatibleRenderers |= (0, $dgEnR.RendererType).WEBGPU;\n            if (glProgram) compatibleRenderers |= (0, $dgEnR.RendererType).WEBGL;\n        }\n        this.compatibleRenderers = compatibleRenderers;\n        const nameHash = {};\n        if (!resources && !groups) resources = {};\n        if (resources && groups) throw new Error(\"[Shader] Cannot have both resources and groups\");\n        else if (!gpuProgram && groups && !groupMap) throw new Error(\"[Shader] No group map or WebGPU shader provided - consider using resources instead.\");\n        else if (!gpuProgram && groups && groupMap) {\n            for(const i in groupMap)for(const j in groupMap[i]){\n                const uniformName = groupMap[i][j];\n                nameHash[uniformName] = {\n                    group: i,\n                    binding: j,\n                    name: uniformName\n                };\n            }\n        } else if (gpuProgram && groups && !groupMap) {\n            const groupData = gpuProgram.structsAndGroups.groups;\n            groupMap = {};\n            groupData.forEach((data)=>{\n                groupMap[data.group] = groupMap[data.group] || {};\n                groupMap[data.group][data.binding] = data.name;\n                nameHash[data.name] = data;\n            });\n        } else if (resources) {\n            if (!gpuProgram) {\n                groupMap = {};\n                groups = {\n                    99: new (0, $86NKO.BindGroup)()\n                };\n                this._ownedBindGroups.push(groups[99]);\n                let bindTick = 0;\n                for(const i in resources){\n                    nameHash[i] = {\n                        group: 99,\n                        binding: bindTick,\n                        name: i\n                    };\n                    groupMap[99] = groupMap[99] || {};\n                    groupMap[99][bindTick] = i;\n                    bindTick++;\n                }\n            } else {\n                const groupData = gpuProgram.structsAndGroups.groups;\n                groupMap = {};\n                groupData.forEach((data)=>{\n                    groupMap[data.group] = groupMap[data.group] || {};\n                    groupMap[data.group][data.binding] = data.name;\n                    nameHash[data.name] = data;\n                });\n            }\n            groups = {};\n            for(const i in resources){\n                const name = i;\n                let value = resources[i];\n                if (!value.source && !value._resourceType) value = new (0, $lJEsO.UniformGroup)(value);\n                const data = nameHash[name];\n                if (data) {\n                    if (!groups[data.group]) {\n                        groups[data.group] = new (0, $86NKO.BindGroup)();\n                        this._ownedBindGroups.push(groups[data.group]);\n                    }\n                    groups[data.group].setResource(value, data.binding);\n                }\n            }\n        }\n        this.groups = groups;\n        this._uniformBindMap = groupMap;\n        this.resources = this._buildResourceAccessor(groups, nameHash);\n    }\n    /**\n   * Sometimes a resource group will be provided later (for example global uniforms)\n   * In such cases, this method can be used to let the shader know about the group.\n   * @param name - the name of the resource group\n   * @param groupIndex - the index of the group (should match the webGPU shader group location)\n   * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)\n   */ addResource(name, groupIndex, bindIndex) {\n        var _a, _b;\n        (_a = this._uniformBindMap)[groupIndex] || (_a[groupIndex] = {});\n        (_b = this._uniformBindMap[groupIndex])[bindIndex] || (_b[bindIndex] = name);\n        if (!this.groups[groupIndex]) {\n            this.groups[groupIndex] = new (0, $86NKO.BindGroup)();\n            this._ownedBindGroups.push(this.groups[groupIndex]);\n        }\n    }\n    _buildResourceAccessor(groups, nameHash) {\n        const uniformsOut = {};\n        for(const i in nameHash){\n            const data = nameHash[i];\n            Object.defineProperty(uniformsOut, data.name, {\n                get () {\n                    return groups[data.group].getResource(data.binding);\n                },\n                set (value) {\n                    groups[data.group].setResource(value, data.binding);\n                }\n            });\n        }\n        return uniformsOut;\n    }\n    /**\n   * Use to destroy the shader when its not longer needed.\n   * It will destroy the resources and remove listeners.\n   * @param destroyPrograms - if the programs should be destroyed as well.\n   * Make sure its not being used by other shaders!\n   */ destroy(destroyPrograms = false) {\n        this.emit(\"destroy\", this);\n        if (destroyPrograms) {\n            this.gpuProgram?.destroy();\n            this.glProgram?.destroy();\n        }\n        this.gpuProgram = null;\n        this.glProgram = null;\n        this.removeAllListeners();\n        this._uniformBindMap = null;\n        this._ownedBindGroups.forEach((bindGroup)=>{\n            bindGroup.destroy();\n        });\n        this._ownedBindGroups = null;\n        this.resources = null;\n        this.groups = null;\n    }\n    static from(options) {\n        const { gpu: gpu, gl: gl, ...rest } = options;\n        let gpuProgram;\n        let glProgram;\n        if (gpu) gpuProgram = (0, $9IRF4.GpuProgram).from(gpu);\n        if (gl) glProgram = (0, $2AaNu.GlProgram).from(gl);\n        return new $c2c6fdb6cde61fa5$export$462bb059fed9d9e5({\n            gpuProgram: gpuProgram,\n            glProgram: glProgram,\n            ...rest\n        });\n    }\n}\n\n});\nparcelRegister(\"dgEnR\", function(module, exports) {\n\n$parcel$export(module.exports, \"RendererType\", () => $ab7aed2a9e5fdd71$export$2ca8315eebe81c3d);\n\"use strict\";\nvar $ab7aed2a9e5fdd71$export$2ca8315eebe81c3d = /* @__PURE__ */ ((RendererType2)=>{\n    RendererType2[RendererType2[\"WEBGL\"] = 1] = \"WEBGL\";\n    RendererType2[RendererType2[\"WEBGPU\"] = 2] = \"WEBGPU\";\n    RendererType2[RendererType2[\"BOTH\"] = 3] = \"BOTH\";\n    return RendererType2;\n})($ab7aed2a9e5fdd71$export$2ca8315eebe81c3d || {});\n\n});\n\n\nparcelRegister(\"bwYhl\", function(module, exports) {\n\n$parcel$export(module.exports, \"localUniformBit\", () => $d2a24386d8923024$export$1723ac05bd5e9336);\n$parcel$export(module.exports, \"localUniformBitGroup2\", () => $d2a24386d8923024$export$adb0f80794f644d9);\n$parcel$export(module.exports, \"localUniformBitGl\", () => $d2a24386d8923024$export$36099520d0a716a);\n\"use strict\";\nconst $d2a24386d8923024$export$1723ac05bd5e9336 = {\n    name: \"local-uniform-bit\",\n    vertex: {\n        header: /* wgsl */ `\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */ `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */ `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    }\n};\nconst $d2a24386d8923024$export$adb0f80794f644d9 = {\n    ...$d2a24386d8923024$export$1723ac05bd5e9336,\n    vertex: {\n        ...$d2a24386d8923024$export$1723ac05bd5e9336.vertex,\n        // replace the group!\n        header: $d2a24386d8923024$export$1723ac05bd5e9336.vertex.header.replace(\"group(1)\", \"group(2)\")\n    }\n};\nconst $d2a24386d8923024$export$36099520d0a716a = {\n    name: \"local-uniform-bit\",\n    vertex: {\n        header: /* glsl */ `\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */ `\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */ `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    }\n};\n\n});\n\n\n//# sourceMappingURL=browserAll.929a84d1.js.map\n","\"use strict\";\nvar ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {\n  ExtensionType2[\"Application\"] = \"application\";\n  ExtensionType2[\"WebGLPipes\"] = \"webgl-pipes\";\n  ExtensionType2[\"WebGLPipesAdaptor\"] = \"webgl-pipes-adaptor\";\n  ExtensionType2[\"WebGLSystem\"] = \"webgl-system\";\n  ExtensionType2[\"WebGPUPipes\"] = \"webgpu-pipes\";\n  ExtensionType2[\"WebGPUPipesAdaptor\"] = \"webgpu-pipes-adaptor\";\n  ExtensionType2[\"WebGPUSystem\"] = \"webgpu-system\";\n  ExtensionType2[\"CanvasSystem\"] = \"canvas-system\";\n  ExtensionType2[\"CanvasPipesAdaptor\"] = \"canvas-pipes-adaptor\";\n  ExtensionType2[\"CanvasPipes\"] = \"canvas-pipes\";\n  ExtensionType2[\"Asset\"] = \"asset\";\n  ExtensionType2[\"LoadParser\"] = \"load-parser\";\n  ExtensionType2[\"ResolveParser\"] = \"resolve-parser\";\n  ExtensionType2[\"CacheParser\"] = \"cache-parser\";\n  ExtensionType2[\"DetectionParser\"] = \"detection-parser\";\n  ExtensionType2[\"MaskEffect\"] = \"mask-effect\";\n  ExtensionType2[\"BlendMode\"] = \"blend-mode\";\n  ExtensionType2[\"TextureSource\"] = \"texture-source\";\n  ExtensionType2[\"Environment\"] = \"environment\";\n  return ExtensionType2;\n})(ExtensionType || {});\nconst normalizeExtension = (ext) => {\n  if (typeof ext === \"function\" || typeof ext === \"object\" && ext.extension) {\n    if (!ext.extension) {\n      throw new Error(\"Extension class must have an extension object\");\n    }\n    const metadata = typeof ext.extension !== \"object\" ? { type: ext.extension } : ext.extension;\n    ext = { ...metadata, ref: ext };\n  }\n  if (typeof ext === \"object\") {\n    ext = { ...ext };\n  } else {\n    throw new Error(\"Invalid extension type\");\n  }\n  if (typeof ext.type === \"string\") {\n    ext.type = [ext.type];\n  }\n  return ext;\n};\nconst normalizeExtensionPriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;\nconst extensions = {\n  /** @ignore */\n  _addHandlers: {},\n  /** @ignore */\n  _removeHandlers: {},\n  /** @ignore */\n  _queue: {},\n  /**\n   * Remove extensions from PixiJS.\n   * @param extensions - Extensions to be removed.\n   * @returns {extensions} For chaining.\n   */\n  remove(...extensions2) {\n    extensions2.map(normalizeExtension).forEach((ext) => {\n      ext.type.forEach((type) => this._removeHandlers[type]?.(ext));\n    });\n    return this;\n  },\n  /**\n   * Register new extensions with PixiJS.\n   * @param extensions - The spread of extensions to add to PixiJS.\n   * @returns {extensions} For chaining.\n   */\n  add(...extensions2) {\n    extensions2.map(normalizeExtension).forEach((ext) => {\n      ext.type.forEach((type) => {\n        const handlers = this._addHandlers;\n        const queue = this._queue;\n        if (!handlers[type]) {\n          queue[type] = queue[type] || [];\n          queue[type]?.push(ext);\n        } else {\n          handlers[type]?.(ext);\n        }\n      });\n    });\n    return this;\n  },\n  /**\n   * Internal method to handle extensions by name.\n   * @param type - The extension type.\n   * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.\n   * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.\n   * @returns {extensions} For chaining.\n   */\n  handle(type, onAdd, onRemove) {\n    const addHandlers = this._addHandlers;\n    const removeHandlers = this._removeHandlers;\n    if (addHandlers[type] || removeHandlers[type]) {\n      throw new Error(`Extension type ${type} already has a handler`);\n    }\n    addHandlers[type] = onAdd;\n    removeHandlers[type] = onRemove;\n    const queue = this._queue;\n    if (queue[type]) {\n      queue[type]?.forEach((ext) => onAdd(ext));\n      delete queue[type];\n    }\n    return this;\n  },\n  /**\n   * Handle a type, but using a map by `name` property.\n   * @param type - Type of extension to handle.\n   * @param map - The object map of named extensions.\n   * @returns {extensions} For chaining.\n   */\n  handleByMap(type, map) {\n    return this.handle(\n      type,\n      (extension) => {\n        if (extension.name) {\n          map[extension.name] = extension.ref;\n        }\n      },\n      (extension) => {\n        if (extension.name) {\n          delete map[extension.name];\n        }\n      }\n    );\n  },\n  /**\n   * Handle a type, but using a list of extensions with a `name` property.\n   * @param type - Type of extension to handle.\n   * @param map - The array of named extensions.\n   * @param defaultPriority - Fallback priority if none is defined.\n   * @returns {extensions} For chaining.\n   */\n  handleByNamedList(type, map, defaultPriority = -1) {\n    return this.handle(\n      type,\n      (extension) => {\n        const index = map.findIndex((item) => item.name === extension.name);\n        if (index >= 0)\n          return;\n        map.push({ name: extension.name, value: extension.ref });\n        map.sort((a, b) => normalizeExtensionPriority(b.value, defaultPriority) - normalizeExtensionPriority(a.value, defaultPriority));\n      },\n      (extension) => {\n        const index = map.findIndex((item) => item.name === extension.name);\n        if (index !== -1) {\n          map.splice(index, 1);\n        }\n      }\n    );\n  },\n  /**\n   * Handle a type, but using a list of extensions.\n   * @param type - Type of extension to handle.\n   * @param list - The list of extensions.\n   * @param defaultPriority - The default priority to use if none is specified.\n   * @returns {extensions} For chaining.\n   */\n  handleByList(type, list, defaultPriority = -1) {\n    return this.handle(\n      type,\n      (extension) => {\n        if (list.includes(extension.ref)) {\n          return;\n        }\n        list.push(extension.ref);\n        list.sort((a, b) => normalizeExtensionPriority(b, defaultPriority) - normalizeExtensionPriority(a, defaultPriority));\n      },\n      (extension) => {\n        const index = list.indexOf(extension.ref);\n        if (index !== -1) {\n          list.splice(index, 1);\n        }\n      }\n    );\n  }\n};\n\nexport { ExtensionType, extensions, normalizeExtensionPriority };\n//# sourceMappingURL=Extensions.mjs.map\n","/**\n * `extensions` is a global object that holds all the extensions registered with PixiJS.\n * PixiJS uses a this extensions architecture a lot to make the library more modular and\n * flexible.\n *\n * For example, if you want to add load a new type of asset, you can register a new\n * {@link assets.LoaderParser} with the `extensions` object.\n *\n * ```js\n * import { extensions, ExtensionType } from 'pixi.js';\n *\n * // create a custom asset loader\n * const customAssetLoader = {\n *    extension: {\n *        type: ExtensionType.LoadParser,\n *        name: 'custom-asset-loader',\n *    },\n *    test(url) {\n *       // check if this new loader should be used...\n *    },\n *    load(url) {\n *        // load the asset...\n *    },\n * };\n *\n * // add the custom asset loader to pixi\n * extensions.add(customAssetLoader);\n * ```\n *\n * This would add the `customAssetLoader` to the list of available loaders that PixiJS can use.\n *\n * There are many different types of extensions, which are listed in {@link extensions.ExtensionType}.\n * @namespace extensions\n */\n\n/**\n * Collection of valid extension types.\n * @memberof extensions\n */\nenum ExtensionType\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    /** extensions that are registered as Application plugins */\n    Application = 'application',\n\n    /** extensions that are registered as WebGL render pipes */\n    WebGLPipes = 'webgl-pipes',\n    /** extensions that are registered as WebGL render pipes adaptors */\n    WebGLPipesAdaptor = 'webgl-pipes-adaptor',\n    /** extensions that are registered as WebGL render systems */\n    WebGLSystem = 'webgl-system',\n\n    /** extensions that are registered as WebGPU render pipes */\n    WebGPUPipes = 'webgpu-pipes',\n    /** extensions that are registered as WebGPU render pipes adaptors */\n    WebGPUPipesAdaptor = 'webgpu-pipes-adaptor',\n    /** extensions that are registered as WebGPU render systems */\n    WebGPUSystem = 'webgpu-system',\n\n    /** extensions that are registered as Canvas render pipes */\n    CanvasSystem = 'canvas-system',\n    /** extensions that are registered as Canvas render pipes adaptors */\n    CanvasPipesAdaptor = 'canvas-pipes-adaptor',\n    /** extensions that are registered as Canvas render systems */\n    CanvasPipes = 'canvas-pipes',\n\n    /** extensions that combine the other Asset extensions */\n    Asset = 'asset',\n    /** extensions that are used to load assets through Assets */\n    LoadParser = 'load-parser',\n    /** extensions that are used to resolve asset urls through Assets */\n    ResolveParser = 'resolve-parser',\n    /** extensions that are used to handle how urls are cached by Assets */\n    CacheParser = 'cache-parser',\n    /** extensions that are used to add/remove available resources from Assets */\n    DetectionParser = 'detection-parser',\n\n    /** extensions that are registered with the MaskEffectManager */\n    MaskEffect = 'mask-effect',\n\n    /** A type of extension for creating a new advanced blend mode */\n    BlendMode = 'blend-mode',\n\n    /** A type of extension that will be used to auto detect a resource type */\n    TextureSource = 'texture-source',\n\n    /** A type of extension that will be used to auto detect an environment */\n    Environment = 'environment',\n}\n\n/**\n * The metadata for an extension.\n * @memberof extensions\n * @ignore\n */\ninterface ExtensionMetadataDetails\n{\n    /** The extension type, can be multiple types */\n    type: ExtensionType | ExtensionType[];\n    /** Optional. Some plugins provide an API name/property, to make them more easily accessible */\n    name?: string;\n    /** Optional, used for sorting the plugins in a particular order */\n    priority?: number;\n}\n\n/**\n * The metadata for an extension.\n * @memberof extensions\n */\ntype ExtensionMetadata = ExtensionType | ExtensionMetadataDetails;\n\n/**\n * Format when registering an extension. Generally, the extension\n * should have these values as `extension` static property,\n * but you can override name or type by providing an object.\n * @memberof extensions\n */\ninterface ExtensionFormat\n{\n    /** The extension type, can be multiple types */\n    type: ExtensionType | ExtensionType[];\n    /** Optional. Some plugins provide an API name/property, such as Renderer plugins */\n    name?: string;\n    /** Optional, used for sorting the plugins in a particular order */\n    priority?: number;\n    /** Reference to the plugin object/class */\n    ref: any;\n}\n\n/**\n * Extension format that is used internally for registrations.\n * @memberof extensions\n * @ignore\n */\ninterface StrictExtensionFormat extends ExtensionFormat\n{\n    /** The extension type, always expressed as multiple, even if a single */\n    type: ExtensionType[];\n}\n\ntype ExtensionHandler = (extension: StrictExtensionFormat) => void;\n\n/**\n * Convert input into extension format data.\n * @ignore\n */\nconst normalizeExtension = (ext: ExtensionFormat | any): StrictExtensionFormat =>\n{\n    // Class/Object submission, use extension object\n    if (typeof ext === 'function' || (typeof ext === 'object' && ext.extension))\n    {\n        // #if _DEBUG\n        if (!ext.extension)\n        {\n            throw new Error('Extension class must have an extension object');\n        }\n        // #endif\n        const metadata: ExtensionMetadataDetails = (typeof ext.extension !== 'object')\n            ? { type: ext.extension }\n            : ext.extension;\n\n        ext = { ...metadata, ref: ext };\n    }\n    if (typeof ext === 'object')\n    {\n        ext = { ...ext };\n    }\n    else\n    {\n        throw new Error('Invalid extension type');\n    }\n\n    if (typeof ext.type === 'string')\n    {\n        ext.type = [ext.type];\n    }\n\n    return ext;\n};\n\n/**\n * Get the priority for an extension.\n * @ignore\n * @param ext - Any extension\n * @param defaultPriority - Fallback priority if none is defined.\n * @returns The priority for the extension.\n * @memberof extensions\n */\nexport const normalizeExtensionPriority = (ext: ExtensionFormat | any, defaultPriority: number): number =>\n    normalizeExtension(ext).priority ?? defaultPriority;\n\n/**\n * Global registration of all PixiJS extensions. One-stop-shop for extensibility.\n *\n * Import the `extensions` object and use it to register new functionality via the described methods below.\n * ```js\n * import { extensions } from 'pixi.js';\n *\n * // register a new extension\n * extensions.add(myExtension);\n * ```\n * @property {Function} remove - Remove extensions from PixiJS.\n * @property {Function} add - Register new extensions with PixiJS.\n * @property {Function} handle - Internal method to handle extensions by name.\n * @property {Function} handleByMap - Handle a type, but using a map by `name` property.\n * @property {Function} handleByNamedList - Handle a type, but using a list of extensions with a `name` property.\n * @property {Function} handleByList - Handle a type, but using a list of extensions.\n * @memberof extensions\n */\nconst extensions = {\n\n    /** @ignore */\n    _addHandlers: {} as Partial<Record<ExtensionType, ExtensionHandler>>,\n\n    /** @ignore */\n    _removeHandlers: {} as Partial<Record<ExtensionType, ExtensionHandler>>,\n\n    /** @ignore */\n    _queue: {} as Partial<Record<ExtensionType, StrictExtensionFormat[]>>,\n\n    /**\n     * Remove extensions from PixiJS.\n     * @param extensions - Extensions to be removed.\n     * @returns {extensions} For chaining.\n     */\n    remove(...extensions: Array<ExtensionFormat | any>)\n    {\n        extensions.map(normalizeExtension).forEach((ext) =>\n        {\n            ext.type.forEach((type) => this._removeHandlers[type]?.(ext));\n        });\n\n        return this;\n    },\n\n    /**\n     * Register new extensions with PixiJS.\n     * @param extensions - The spread of extensions to add to PixiJS.\n     * @returns {extensions} For chaining.\n     */\n    add(...extensions: Array<ExtensionFormat | any>)\n    {\n        // Handle any extensions either passed as class w/ data or as data\n        extensions.map(normalizeExtension).forEach((ext) =>\n        {\n            ext.type.forEach((type) =>\n            {\n                const handlers = this._addHandlers;\n                const queue = this._queue;\n\n                if (!handlers[type])\n                {\n                    queue[type] = queue[type] || [];\n                    queue[type]?.push(ext);\n                }\n                else\n                {\n                    handlers[type]?.(ext);\n                }\n            });\n        });\n\n        return this;\n    },\n\n    /**\n     * Internal method to handle extensions by name.\n     * @param type - The extension type.\n     * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.\n     * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.\n     * @returns {extensions} For chaining.\n     */\n    handle(type: ExtensionType, onAdd: ExtensionHandler, onRemove: ExtensionHandler)\n    {\n        const addHandlers = this._addHandlers;\n        const removeHandlers = this._removeHandlers;\n\n        // #if _DEBUG\n        if (addHandlers[type] || removeHandlers[type])\n        {\n            throw new Error(`Extension type ${type} already has a handler`);\n        }\n        // #endif\n\n        addHandlers[type] = onAdd;\n        removeHandlers[type] = onRemove;\n\n        // Process the queue\n        const queue = this._queue;\n\n        // Process any plugins that have been registered before the handler\n        if (queue[type])\n        {\n            queue[type]?.forEach((ext) => onAdd(ext));\n            delete queue[type];\n        }\n\n        return this;\n    },\n\n    /**\n     * Handle a type, but using a map by `name` property.\n     * @param type - Type of extension to handle.\n     * @param map - The object map of named extensions.\n     * @returns {extensions} For chaining.\n     */\n    handleByMap(type: ExtensionType, map: Record<string, any>)\n    {\n        return this.handle(type,\n            (extension) =>\n            {\n                if (extension.name)\n                {\n                    map[extension.name] = extension.ref;\n                }\n            },\n            (extension) =>\n            {\n                if (extension.name)\n                {\n                    delete map[extension.name];\n                }\n            }\n        );\n    },\n\n    /**\n     * Handle a type, but using a list of extensions with a `name` property.\n     * @param type - Type of extension to handle.\n     * @param map - The array of named extensions.\n     * @param defaultPriority - Fallback priority if none is defined.\n     * @returns {extensions} For chaining.\n     */\n    handleByNamedList(type: ExtensionType, map: {name: string, value: any}[], defaultPriority = -1)\n    {\n        return this.handle(\n            type,\n            (extension) =>\n            {\n                const index = map.findIndex((item) => item.name === extension.name);\n\n                if (index >= 0) return;\n\n                map.push({ name: extension.name, value: extension.ref });\n                map.sort((a, b) =>\n                    normalizeExtensionPriority(b.value, defaultPriority)\n                    - normalizeExtensionPriority(a.value, defaultPriority));\n            },\n            (extension) =>\n            {\n                const index = map.findIndex((item) => item.name === extension.name);\n\n                if (index !== -1)\n                {\n                    map.splice(index, 1);\n                }\n            }\n        );\n    },\n\n    /**\n     * Handle a type, but using a list of extensions.\n     * @param type - Type of extension to handle.\n     * @param list - The list of extensions.\n     * @param defaultPriority - The default priority to use if none is specified.\n     * @returns {extensions} For chaining.\n     */\n    handleByList(type: ExtensionType, list: any[], defaultPriority = -1)\n    {\n        return this.handle(\n            type,\n            (extension) =>\n            {\n                if (list.includes(extension.ref))\n                {\n                    return;\n                }\n\n                list.push(extension.ref);\n                list.sort((a, b) =>\n                    normalizeExtensionPriority(b, defaultPriority) - normalizeExtensionPriority(a, defaultPriority));\n            },\n            (extension) =>\n            {\n                const index = list.indexOf(extension.ref);\n\n                if (index !== -1)\n                {\n                    list.splice(index, 1);\n                }\n            }\n        );\n    },\n};\n\nexport {\n    extensions,\n    ExtensionType,\n};\nexport type {\n    StrictExtensionFormat as ExtensionFormat,\n    ExtensionFormat as ExtensionFormatLoose,\n    ExtensionHandler,\n    ExtensionMetadata,\n};\n","import EventEmitter from 'eventemitter3';\nimport { Color } from '../../color/Color.mjs';\nimport { cullingMixin } from '../../culling/cullingMixin.mjs';\nimport { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { RAD_TO_DEG, DEG_TO_RAD } from '../../maths/misc/const.mjs';\nimport { ObservablePoint } from '../../maths/point/ObservablePoint.mjs';\nimport { uid } from '../../utils/data/uid.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { childrenHelperMixin } from './container-mixins/childrenHelperMixin.mjs';\nimport { effectsMixin } from './container-mixins/effectsMixin.mjs';\nimport { findMixin } from './container-mixins/findMixin.mjs';\nimport { measureMixin } from './container-mixins/measureMixin.mjs';\nimport { onRenderMixin } from './container-mixins/onRenderMixin.mjs';\nimport { sortMixin } from './container-mixins/sortMixin.mjs';\nimport { toLocalGlobalMixin } from './container-mixins/toLocalGlobalMixin.mjs';\nimport { RenderGroup } from './RenderGroup.mjs';\nimport { assignWithIgnore } from './utils/assignWithIgnore.mjs';\n\n\"use strict\";\nconst defaultSkew = new ObservablePoint(null);\nconst defaultPivot = new ObservablePoint(null);\nconst defaultScale = new ObservablePoint(null, 1, 1);\nconst UPDATE_COLOR = 1;\nconst UPDATE_BLEND = 2;\nconst UPDATE_VISIBLE = 4;\nconst UPDATE_TRANSFORM = 8;\nclass Container extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    /** @private */\n    this.uid = uid(\"renderable\");\n    /** @private */\n    this._updateFlags = 15;\n    // is this container the root of a renderGroup?\n    // TODO implement this in a few more places\n    /** @private */\n    this.isRenderGroupRoot = false;\n    // the render group this container belongs to OR owns\n    /** @private */\n    this.renderGroup = null;\n    // set to true if the container has changed. It is reset once the changes have been applied\n    // by the transform system\n    // its here to stop ensure that when things change, only one update gets registers with the transform system\n    /** @private */\n    this.didChange = false;\n    // same as above, but for the renderable\n    /** @private */\n    this.didViewUpdate = false;\n    // how deep is the container relative to its render group..\n    // unless the element is the root render group - it will be relative to its parent\n    /** @private */\n    this.relativeRenderGroupDepth = 0;\n    /**\n     * The array of children of this container.\n     * @readonly\n     */\n    this.children = [];\n    /** The display object container that contains this display object. */\n    this.parent = null;\n    // used internally for changing up the render order.. mainly for masks and filters\n    // TODO setting this should cause a rebuild??\n    /** @private */\n    this.includeInBuild = true;\n    /** @private */\n    this.measurable = true;\n    /** @private */\n    this.isSimple = true;\n    // / /////////////Transform related props//////////////\n    // used by the transform system to check if a container needs to be updated that frame\n    // if the tick matches the current transform system tick, it is not updated again\n    /**\n     * @internal\n     * @ignore\n     */\n    this.updateTick = -1;\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     * @readonly\n     */\n    this.localTransform = new Matrix();\n    /**\n     * The relative group transform is a transform relative to the render group it belongs too. It will include all parent\n     * transforms and up to the render group (think of it as kind of like a stage - but the stage can be nested).\n     * If this container is is self a render group matrix will be relative to its parent render group\n     * @readonly\n     */\n    this.relativeGroupTransform = new Matrix();\n    /**\n     * The group transform is a transform relative to the render group it belongs too.\n     * If this container is render group then this will be an identity matrix. other wise it\n     * will be the same as the relativeGroupTransform.\n     * Use this value when actually rendering things to the screen\n     * @readonly\n     */\n    this.groupTransform = this.relativeGroupTransform;\n    /** If the object has been destroyed via destroy(). If true, it should not be used. */\n    this.destroyed = false;\n    // transform data..\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @internal\n     * @ignore\n     */\n    this._position = new ObservablePoint(this, 0, 0);\n    /**\n     * The scale factor of the object.\n     * @internal\n     * @ignore\n     */\n    this._scale = defaultScale;\n    /**\n     * The pivot point of the container that it rotates around.\n     * @internal\n     * @ignore\n     */\n    this._pivot = defaultPivot;\n    /**\n     * The skew amount, on the x and y axis.\n     * @internal\n     * @ignore\n     */\n    this._skew = defaultSkew;\n    /**\n     * The X-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._cx = 1;\n    /**\n     * The Y-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._sx = 0;\n    /**\n     * The X-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._cy = 0;\n    /**\n     * The Y-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._sy = 1;\n    /**\n     * The rotation amount.\n     * @internal\n     * @ignore\n     */\n    this._rotation = 0;\n    // / COLOR related props //////////////\n    // color stored as ABGR\n    this.localColor = 16777215;\n    this.localAlpha = 1;\n    this.groupAlpha = 1;\n    // A\n    this.groupColor = 16777215;\n    // BGR\n    this.groupColorAlpha = 4294967295;\n    // ABGR\n    // / BLEND related props //////////////\n    /**\n     * @internal\n     * @ignore\n     */\n    this.localBlendMode = \"inherit\";\n    /**\n     * @internal\n     * @ignore\n     */\n    this.groupBlendMode = \"normal\";\n    // / VISIBILITY related props //////////////\n    // visibility\n    // 0b11\n    // first bit is visible, second bit is renderable\n    /**\n     * This property holds three bits: culled, visible, renderable\n     * the third bit represents culling (0 = culled, 1 = not culled) 0b100\n     * the second bit represents visibility (0 = not visible, 1 = visible) 0b010\n     * the first bit represents renderable (0 = renderable, 1 = not renderable) 0b001\n     * @internal\n     * @ignore\n     */\n    this.localDisplayStatus = 7;\n    // 0b11 | 0b10 | 0b01 | 0b00\n    /**\n     * @internal\n     * @ignore\n     */\n    this.globalDisplayStatus = 7;\n    /**\n     * A value that increments each time the container is modified\n     * the first 12 bits represent the container changes (eg transform, alpha, visible etc)\n     * the second 12 bits represent the view changes (eg texture swap, geometry change etc)\n     *\n     *  view          container\n     * [000000000000][00000000000]\n     * @ignore\n     */\n    this._didChangeId = 0;\n    /**\n     * property that tracks if the container transform has changed\n     * @ignore\n     */\n    this._didLocalTransformChangeId = -1;\n    assignWithIgnore(this, options, {\n      children: true,\n      parent: true,\n      effects: true\n    });\n    options.children?.forEach((child) => this.addChild(child));\n    this.effects = [];\n    options.parent?.addChild(this);\n  }\n  /**\n   * Mixes all enumerable properties and methods from a source object to Container.\n   * @param source - The source of properties and methods to mix in.\n   */\n  static mixin(source) {\n    Object.defineProperties(Container.prototype, Object.getOwnPropertyDescriptors(source));\n  }\n  /**\n   * Adds one or more children to the container.\n   *\n   * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n   * @param {...Container} children - The Container(s) to add to the container\n   * @returns {Container} - The first child that was added.\n   */\n  addChild(...children) {\n    if (!this.allowChildren) {\n      deprecation(v8_0_0, \"addChild: Only Containers will be allowed to add children in v8.0.0\");\n    }\n    if (children.length > 1) {\n      for (let i = 0; i < children.length; i++) {\n        this.addChild(children[i]);\n      }\n      return children[0];\n    }\n    const child = children[0];\n    if (child.parent === this) {\n      this.children.splice(this.children.indexOf(child), 1);\n      this.children.push(child);\n      if (this.renderGroup && !this.isRenderGroupRoot) {\n        this.renderGroup.structureDidChange = true;\n      }\n      return child;\n    }\n    if (child.parent) {\n      child.parent.removeChild(child);\n    }\n    this.children.push(child);\n    if (this.sortableChildren)\n      this.sortDirty = true;\n    child.parent = this;\n    child.didChange = true;\n    child.didViewUpdate = false;\n    child._updateFlags = 15;\n    if (this.renderGroup) {\n      this.renderGroup.addChild(child);\n    }\n    this.emit(\"childAdded\", child, this, this.children.length - 1);\n    child.emit(\"added\", this);\n    if (child._zIndex !== 0) {\n      child.depthOfChildModified();\n    }\n    return child;\n  }\n  /**\n   * Removes one or more children from the container.\n   * @param {...Container} children - The Container(s) to remove\n   * @returns {Container} The first child that was removed.\n   */\n  removeChild(...children) {\n    if (children.length > 1) {\n      for (let i = 0; i < children.length; i++) {\n        this.removeChild(children[i]);\n      }\n      return children[0];\n    }\n    const child = children[0];\n    const index = this.children.indexOf(child);\n    if (index > -1) {\n      this.children.splice(index, 1);\n      if (this.renderGroup) {\n        this.renderGroup.removeChild(child);\n      }\n      child.parent = null;\n      this.emit(\"childRemoved\", child, this, index);\n      child.emit(\"removed\", this);\n    }\n    return child;\n  }\n  /** @ignore */\n  _onUpdate(point) {\n    if (point) {\n      if (point === this._skew) {\n        this._updateSkew();\n      }\n    }\n    this._didChangeId++;\n    if (this.didChange)\n      return;\n    this.didChange = true;\n    if (this.isRenderGroupRoot) {\n      const renderGroupParent = this.renderGroup.renderGroupParent;\n      if (renderGroupParent) {\n        renderGroupParent.onChildUpdate(this);\n      }\n    } else if (this.renderGroup) {\n      this.renderGroup.onChildUpdate(this);\n    }\n  }\n  set isRenderGroup(value) {\n    if (this.isRenderGroupRoot && value === false) {\n      throw new Error(\"[Pixi] cannot undo a render group just yet\");\n    }\n    if (value) {\n      this.enableRenderGroup();\n    }\n  }\n  /**\n   * Returns true if this container is a render group.\n   * This means that it will be rendered as a separate pass, with its own set of instructions\n   */\n  get isRenderGroup() {\n    return this.isRenderGroupRoot;\n  }\n  /** This enables the container to be rendered as a render group. */\n  enableRenderGroup() {\n    if (this.renderGroup && this.renderGroup.root === this)\n      return;\n    this.isRenderGroupRoot = true;\n    const parentRenderGroup = this.renderGroup;\n    if (parentRenderGroup) {\n      parentRenderGroup.removeChild(this);\n    }\n    this.renderGroup = new RenderGroup(this);\n    if (parentRenderGroup) {\n      for (let i = 0; i < parentRenderGroup.renderGroupChildren.length; i++) {\n        const childRenderGroup = parentRenderGroup.renderGroupChildren[i];\n        let parent = childRenderGroup.root;\n        while (parent) {\n          if (parent === this) {\n            this.renderGroup.addRenderGroupChild(childRenderGroup);\n            break;\n          }\n          parent = parent.parent;\n        }\n      }\n      parentRenderGroup.addRenderGroupChild(this.renderGroup);\n    }\n    this._updateIsSimple();\n    this.groupTransform = Matrix.IDENTITY;\n  }\n  /** @ignore */\n  _updateIsSimple() {\n    this.isSimple = !this.isRenderGroupRoot && this.effects.length === 0;\n  }\n  /**\n   * Current transform of the object based on world (parent) factors.\n   * @readonly\n   */\n  get worldTransform() {\n    this._worldTransform || (this._worldTransform = new Matrix());\n    if (this.renderGroup) {\n      if (this.isRenderGroupRoot) {\n        this._worldTransform.copyFrom(this.renderGroup.worldTransform);\n      } else {\n        this._worldTransform.appendFrom(this.relativeGroupTransform, this.renderGroup.worldTransform);\n      }\n    }\n    return this._worldTransform;\n  }\n  // / ////// transform related stuff\n  /**\n   * The position of the container on the x axis relative to the local coordinates of the parent.\n   * An alias to position.x\n   */\n  get x() {\n    return this._position.x;\n  }\n  set x(value) {\n    this._position.x = value;\n  }\n  /**\n   * The position of the container on the y axis relative to the local coordinates of the parent.\n   * An alias to position.y\n   */\n  get y() {\n    return this._position.y;\n  }\n  set y(value) {\n    this._position.y = value;\n  }\n  /**\n   * The coordinate of the object relative to the local coordinates of the parent.\n   * @since 4.0.0\n   */\n  get position() {\n    return this._position;\n  }\n  set position(value) {\n    this._position.copyFrom(value);\n  }\n  /**\n   * The rotation of the object in radians.\n   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n   */\n  get rotation() {\n    return this._rotation;\n  }\n  set rotation(value) {\n    if (this._rotation !== value) {\n      this._rotation = value;\n      this._onUpdate(this._skew);\n    }\n  }\n  /**\n   * The angle of the object in degrees.\n   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n   */\n  get angle() {\n    return this.rotation * RAD_TO_DEG;\n  }\n  set angle(value) {\n    this.rotation = value * DEG_TO_RAD;\n  }\n  /**\n   * The center of rotation, scaling, and skewing for this display object in its local space. The `position`\n   * is the projection of `pivot` in the parent's local space.\n   *\n   * By default, the pivot is the origin (0, 0).\n   * @since 4.0.0\n   */\n  get pivot() {\n    if (this._pivot === defaultPivot) {\n      this._pivot = new ObservablePoint(this, 0, 0);\n    }\n    return this._pivot;\n  }\n  set pivot(value) {\n    if (this._pivot === defaultPivot) {\n      this._pivot = new ObservablePoint(this, 0, 0);\n    }\n    typeof value === \"number\" ? this._pivot.set(value) : this._pivot.copyFrom(value);\n  }\n  /**\n   * The skew factor for the object in radians.\n   * @since 4.0.0\n   */\n  get skew() {\n    if (this._skew === defaultSkew) {\n      this._skew = new ObservablePoint(this, 0, 0);\n    }\n    return this._skew;\n  }\n  set skew(value) {\n    if (this._skew === defaultSkew) {\n      this._skew = new ObservablePoint(this, 0, 0);\n    }\n    this._skew.copyFrom(value);\n  }\n  /**\n   * The scale factors of this object along the local coordinate axes.\n   *\n   * The default scale is (1, 1).\n   * @since 4.0.0\n   */\n  get scale() {\n    if (this._scale === defaultScale) {\n      this._scale = new ObservablePoint(this, 1, 1);\n    }\n    return this._scale;\n  }\n  set scale(value) {\n    if (this._scale === defaultScale) {\n      this._scale = new ObservablePoint(this, 0, 0);\n    }\n    typeof value === \"number\" ? this._scale.set(value) : this._scale.copyFrom(value);\n  }\n  /**\n   * The width of the Container, setting this will actually modify the scale to achieve the value set.\n   * @memberof scene.Container#\n   */\n  get width() {\n    return Math.abs(this.scale.x * this.getLocalBounds().width);\n  }\n  set width(value) {\n    const localWidth = this.getLocalBounds().width;\n    this._setWidth(value, localWidth);\n  }\n  /**\n   * The height of the Container, setting this will actually modify the scale to achieve the value set.\n   * @memberof scene.Container#\n   */\n  get height() {\n    return Math.abs(this.scale.y * this.getLocalBounds().height);\n  }\n  set height(value) {\n    const localHeight = this.getLocalBounds().height;\n    this._setHeight(value, localHeight);\n  }\n  /**\n   * Retrieves the size of the container as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the container.\n   * @memberof scene.Container#\n   */\n  getSize(out) {\n    if (!out) {\n      out = {};\n    }\n    const bounds = this.getLocalBounds();\n    out.width = Math.abs(this.scale.x * bounds.width);\n    out.height = Math.abs(this.scale.y * bounds.height);\n    return out;\n  }\n  /**\n   * Sets the size of the container to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   * @memberof scene.Container#\n   */\n  setSize(value, height) {\n    const size = this.getLocalBounds();\n    let convertedWidth;\n    let convertedHeight;\n    if (typeof value !== \"object\") {\n      convertedWidth = value;\n      convertedHeight = height ?? value;\n    } else {\n      convertedWidth = value.width;\n      convertedHeight = value.height ?? value.width;\n    }\n    if (convertedWidth !== void 0) {\n      this._setWidth(convertedWidth, size.width);\n    }\n    if (convertedHeight !== void 0) {\n      this._setHeight(convertedHeight, size.height);\n    }\n  }\n  /** Called when the skew or the rotation changes. */\n  _updateSkew() {\n    const rotation = this._rotation;\n    const skew = this._skew;\n    this._cx = Math.cos(rotation + skew._y);\n    this._sx = Math.sin(rotation + skew._y);\n    this._cy = -Math.sin(rotation - skew._x);\n    this._sy = Math.cos(rotation - skew._x);\n  }\n  /**\n   * Updates the transform properties of the container (accepts partial values).\n   * @param {object} opts - The options for updating the transform.\n   * @param {number} opts.x - The x position of the container.\n   * @param {number} opts.y - The y position of the container.\n   * @param {number} opts.scaleX - The scale factor on the x-axis.\n   * @param {number} opts.scaleY - The scale factor on the y-axis.\n   * @param {number} opts.rotation - The rotation of the container, in radians.\n   * @param {number} opts.skewX - The skew factor on the x-axis.\n   * @param {number} opts.skewY - The skew factor on the y-axis.\n   * @param {number} opts.pivotX - The x coordinate of the pivot point.\n   * @param {number} opts.pivotY - The y coordinate of the pivot point.\n   */\n  updateTransform(opts) {\n    this.position.set(\n      typeof opts.x === \"number\" ? opts.x : this.position.x,\n      typeof opts.y === \"number\" ? opts.y : this.position.y\n    );\n    this.scale.set(\n      typeof opts.scaleX === \"number\" ? opts.scaleX || 1 : this.scale.x,\n      typeof opts.scaleY === \"number\" ? opts.scaleY || 1 : this.scale.y\n    );\n    this.rotation = typeof opts.rotation === \"number\" ? opts.rotation : this.rotation;\n    this.skew.set(\n      typeof opts.skewX === \"number\" ? opts.skewX : this.skew.x,\n      typeof opts.skewY === \"number\" ? opts.skewY : this.skew.y\n    );\n    this.pivot.set(\n      typeof opts.pivotX === \"number\" ? opts.pivotX : this.pivot.x,\n      typeof opts.pivotY === \"number\" ? opts.pivotY : this.pivot.y\n    );\n    return this;\n  }\n  /**\n   * Updates the local transform using the given matrix.\n   * @param matrix - The matrix to use for updating the transform.\n   */\n  setFromMatrix(matrix) {\n    matrix.decompose(this);\n  }\n  /** Updates the local transform. */\n  updateLocalTransform() {\n    if ((this._didLocalTransformChangeId & 15) === this._didChangeId)\n      return;\n    this._didLocalTransformChangeId = this._didChangeId;\n    const lt = this.localTransform;\n    const scale = this._scale;\n    const pivot = this._pivot;\n    const position = this._position;\n    const sx = scale._x;\n    const sy = scale._y;\n    const px = pivot._x;\n    const py = pivot._y;\n    lt.a = this._cx * sx;\n    lt.b = this._sx * sx;\n    lt.c = this._cy * sy;\n    lt.d = this._sy * sy;\n    lt.tx = position._x - (px * lt.a + py * lt.c);\n    lt.ty = position._y - (px * lt.b + py * lt.d);\n  }\n  // / ///// color related stuff\n  set alpha(value) {\n    if (value === this.localAlpha)\n      return;\n    this.localAlpha = value;\n    this._updateFlags |= UPDATE_COLOR;\n    this._onUpdate();\n  }\n  /** The opacity of the object. */\n  get alpha() {\n    return this.localAlpha;\n  }\n  set tint(value) {\n    const tempColor = Color.shared.setValue(value ?? 16777215);\n    const bgr = tempColor.toBgrNumber();\n    if (bgr === this.localColor)\n      return;\n    this.localColor = bgr;\n    this._updateFlags |= UPDATE_COLOR;\n    this._onUpdate();\n  }\n  /**\n   * The tint applied to the sprite. This is a hex value.\n   *\n   * A value of 0xFFFFFF will remove any tint effect.\n   * @default 0xFFFFFF\n   */\n  get tint() {\n    const bgr = this.localColor;\n    return ((bgr & 255) << 16) + (bgr & 65280) + (bgr >> 16 & 255);\n  }\n  // / //////////////// blend related stuff\n  set blendMode(value) {\n    if (this.localBlendMode === value)\n      return;\n    if (this.renderGroup && !this.isRenderGroupRoot) {\n      this.renderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_BLEND;\n    this.localBlendMode = value;\n    this._onUpdate();\n  }\n  /**\n   * The blend mode to be applied to the sprite. Apply a value of `'normal'` to reset the blend mode.\n   * @default 'normal'\n   */\n  get blendMode() {\n    return this.localBlendMode;\n  }\n  // / ///////// VISIBILITY / RENDERABLE /////////////////\n  /** The visibility of the object. If false the object will not be drawn, and the transform will not be updated. */\n  get visible() {\n    return !!(this.localDisplayStatus & 2);\n  }\n  set visible(value) {\n    const valueNumber = value ? 1 : 0;\n    if ((this.localDisplayStatus & 2) >> 1 === valueNumber)\n      return;\n    if (this.renderGroup && !this.isRenderGroupRoot) {\n      this.renderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 2;\n    this._onUpdate();\n  }\n  /** @ignore */\n  get culled() {\n    return !(this.localDisplayStatus & 4);\n  }\n  /** @ignore */\n  set culled(value) {\n    const valueNumber = value ? 1 : 0;\n    if ((this.localDisplayStatus & 4) >> 2 === valueNumber)\n      return;\n    if (this.renderGroup && !this.isRenderGroupRoot) {\n      this.renderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 4;\n    this._onUpdate();\n  }\n  /** Can this object be rendered, if false the object will not be drawn but the transform will still be updated. */\n  get renderable() {\n    return !!(this.localDisplayStatus & 1);\n  }\n  set renderable(value) {\n    const valueNumber = value ? 1 : 0;\n    if ((this.localDisplayStatus & 1) === valueNumber)\n      return;\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 1;\n    if (this.renderGroup && !this.isRenderGroupRoot) {\n      this.renderGroup.structureDidChange = true;\n    }\n    this._onUpdate();\n  }\n  /** Whether or not the object should be rendered. */\n  get isRenderable() {\n    return this.localDisplayStatus === 7 && this.groupAlpha > 0;\n  }\n  /**\n   * Removes all internal references and listeners as well as removes children from the display list.\n   * Do not use a Container after calling `destroy`.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n   *  method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children\n   * is set to true it should destroy the texture of the child sprite\n   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n   * If options.children is set to true it should destroy the texture source of the child sprite\n   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n   * If options.children is set to true it should destroy the context of the child graphics\n   */\n  destroy(options = false) {\n    if (this.destroyed)\n      return;\n    this.destroyed = true;\n    this.removeFromParent();\n    this.parent = null;\n    this._mask = null;\n    this._filters = null;\n    this.effects = null;\n    this._position = null;\n    this._scale = null;\n    this._pivot = null;\n    this._skew = null;\n    this.emit(\"destroyed\", this);\n    this.removeAllListeners();\n    const destroyChildren = typeof options === \"boolean\" ? options : options?.children;\n    const oldChildren = this.removeChildren(0, this.children.length);\n    if (destroyChildren) {\n      for (let i = 0; i < oldChildren.length; ++i) {\n        oldChildren[i].destroy(options);\n      }\n    }\n  }\n}\nContainer.mixin(childrenHelperMixin);\nContainer.mixin(toLocalGlobalMixin);\nContainer.mixin(onRenderMixin);\nContainer.mixin(measureMixin);\nContainer.mixin(effectsMixin);\nContainer.mixin(findMixin);\nContainer.mixin(sortMixin);\nContainer.mixin(cullingMixin);\n\nexport { Container, UPDATE_BLEND, UPDATE_COLOR, UPDATE_TRANSFORM, UPDATE_VISIBLE };\n//# sourceMappingURL=Container.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../color/Color';\nimport { cullingMixin } from '../../culling/cullingMixin';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { DEG_TO_RAD, RAD_TO_DEG } from '../../maths/misc/const';\nimport { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { uid } from '../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { childrenHelperMixin } from './container-mixins/childrenHelperMixin';\nimport { effectsMixin } from './container-mixins/effectsMixin';\nimport { findMixin } from './container-mixins/findMixin';\nimport { measureMixin } from './container-mixins/measureMixin';\nimport { onRenderMixin } from './container-mixins/onRenderMixin';\nimport { sortMixin } from './container-mixins/sortMixin';\nimport { toLocalGlobalMixin } from './container-mixins/toLocalGlobalMixin';\nimport { RenderGroup } from './RenderGroup';\nimport { assignWithIgnore } from './utils/assignWithIgnore';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { Rectangle } from '../../maths/shapes/Rectangle';\nimport type { BLEND_MODES } from '../../rendering/renderers/shared/state/const';\nimport type { Dict } from '../../utils/types';\nimport type { Optional } from './container-mixins/measureMixin';\nimport type { DestroyOptions } from './destroyTypes';\n\n/**\n * This is where you'll find all the display objects available in Pixi.\n *\n * All display objects inherit from the {@link scene.Container} class. You can use a `Container` for simple grouping of\n * other display objects. Here's all the available display object classes.\n *\n * - {@link scene.Container} is the base class for all display objects that act as a container for other objects.\n *   - {@link scene.Sprite} is a display object that uses a texture\n *      - {@link scene.AnimatedSprite} is a sprite that can play animations\n *   - {@link scene.TilingSprite} a fast way of rendering a tiling image\n *   - {@link scene.NineSliceSprite} allows you to stretch a texture using 9-slice scaling\n *   - {@link scene.Graphics} is a graphic object that can be drawn to the screen.\n *   - {@link scene.Mesh} empowers you to have maximum flexibility to render any kind of visuals you can think of\n *      - {@link scene.MeshSimple} mimics Mesh, providing easy-to-use constructor arguments\n *      - {@link scene.MeshPlane} allows you to draw a texture across several points and then manipulate these points\n *      - {@link scene.MeshRope} allows you to draw a texture across several points and then manipulate these points\n *   - {@link scene.Text} render text using custom fonts\n *      - {@link scene.BitmapText} render text using a bitmap font\n *      - {@link scene.HTMLText} render text using HTML and CSS\n * @namespace scene\n */\n\n// as pivot and skew are the least used properties of a container, we can use this optimisation\n// to avoid allocating lots of unnecessary objects for them.\nconst defaultSkew = new ObservablePoint(null);\nconst defaultPivot = new ObservablePoint(null);\nconst defaultScale = new ObservablePoint(null, 1, 1);\n\nexport interface ContainerEvents extends PixiMixins.ContainerEvents\n{\n    added: [container: Container];\n    childAdded: [child: Container, container: Container, index: number];\n    removed: [container: Container];\n    childRemoved: [child: Container, container: Container, index: number];\n    destroyed: [container: Container];\n}\n\ntype AnyEvent = {\n    // The following is a hack to allow any custom event while maintaining type safety.\n    // For some reason, the tsc compiler gets angry about error TS1023\n    // \"An index signature parameter type must be either 'string' or 'number'.\"\n    // This is really odd since ({}&string) should interpret as string, but then again\n    // there is some black magic behind why this works in the first place.\n    // Closest thing to an explanation:\n    // https://stackoverflow.com/questions/70144348/why-does-a-union-of-type-literals-and-string-cause-ide-code-completion-wh\n    //\n    // Side note, we disable @typescript-eslint/ban-types since {}&string is the only syntax that works.\n    // Nor of the Record/unknown/never alternatives work.\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    [K: ({} & string) | ({} & symbol)]: any;\n};\n\nexport const UPDATE_COLOR = 0b0001;\nexport const UPDATE_BLEND = 0b0010;\nexport const UPDATE_VISIBLE = 0b0100;\nexport const UPDATE_TRANSFORM = 0b1000;\n\nexport interface UpdateTransformOptions\n{\n    x: number;\n    y: number;\n    scaleX: number;\n    scaleY: number;\n    rotation: number;\n    skewX: number;\n    skewY: number;\n    pivotX: number;\n    pivotY: number;\n}\n\n/**\n * Constructor options used for `Container` instances.\n * ```js\n * const container = new Container({\n *    position: new Point(100, 200),\n *    scale: new Point(2, 2),\n *    rotation: Math.PI / 2,\n * });\n * ```\n * @memberof scene\n * @see scene.Container\n */\nexport interface ContainerOptions extends PixiMixins.ContainerOptions\n{\n    /** @see scene.Container#isRenderGroup */\n    isRenderGroup?: boolean;\n\n    /** @see scene.Container#blendMode */\n    blendMode?: BLEND_MODES;\n    /** @see scene.Container#tint */\n    tint?: ColorSource;\n\n    /** @see scene.Container#alpha */\n    alpha?: number;\n    /** @see scene.Container#angle */\n    angle?: number;\n    /** @see scene.Container#children */\n    children?: Container[];\n    /** @see scene.Container#parent */\n    parent?: Container;\n    /** @see scene.Container#renderable */\n    renderable?: boolean;\n    /** @see scene.Container#rotation */\n    rotation?: number;\n    /** @see scene.Container#scale */\n    scale?: PointData | number;\n    /** @see scene.Container#pivot */\n    pivot?: PointData | number;\n    /** @see scene.Container#position */\n    position?: PointData;\n    /** @see scene.Container#skew */\n    skew?: PointData;\n    /** @see scene.Container#visible */\n    visible?: boolean;\n    /** @see scene.Container#culled */\n    culled?: boolean;\n    /** @see scene.Container#x */\n    x?: number;\n    /** @see scene.Container#y */\n    y?: number;\n    /** @see scene.Container#boundArea */\n    boundsArea?: Rectangle;\n}\n\nexport interface Container\n    extends Omit<PixiMixins.Container, keyof EventEmitter<ContainerEvents & AnyEvent>>,\n    EventEmitter<ContainerEvents & AnyEvent> { }\n\n/**\n * Container is a general-purpose display object that holds children. It also adds built-in support for advanced\n * rendering features like masking and filtering.\n *\n * It is the base class of all display objects that act as a container for other objects, including Graphics\n * and Sprite.\n *\n * <details id=\"transforms\">\n *\n * <summary>Transforms</summary>\n *\n * The [transform]{@link scene.Container#transform} of a display object describes the projection from its\n * local coordinate space to its parent's local coordinate space. The following properties are derived\n * from the transform:\n *\n * <table>\n *   <thead>\n *     <tr>\n *       <th>Property</th>\n *       <th>Description</th>\n *     </tr>\n *   </thead>\n *   <tbody>\n *     <tr>\n *       <td>[pivot]{@link scene.Container#pivot}</td>\n *       <td>\n *         Invariant under rotation, scaling, and skewing. The projection of into the parent's space of the pivot\n *         is equal to position, regardless of the other three transformations. In other words, It is the center of\n *         rotation, scaling, and skewing.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[position]{@link scene.Container#position}</td>\n *       <td>\n *         Translation. This is the position of the [pivot]{@link scene.Container#pivot} in the parent's local\n *         space. The default value of the pivot is the origin (0,0). If the top-left corner of your display object\n *         is (0,0) in its local space, then the position will be its top-left corner in the parent's local space.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[scale]{@link scene.Container#scale}</td>\n *       <td>\n *         Scaling. This will stretch (or compress) the display object's projection. The scale factors are along the\n *         local coordinate axes. In other words, the display object is scaled before rotated or skewed. The center\n *         of scaling is the [pivot]{@link scene.Container#pivot}.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[rotation]{@link scene.Container#rotation}</td>\n *       <td>\n *          Rotation. This will rotate the display object's projection by this angle (in radians).\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[skew]{@link scene.Container#skew}</td>\n *       <td>\n *         <p>Skewing. This can be used to deform a rectangular display object into a parallelogram.</p>\n *         <p>\n *         In PixiJS, skew has a slightly different behaviour than the conventional meaning. It can be\n *         thought of the net rotation applied to the coordinate axes (separately). For example, if \"skew.x\" is\n *         ⍺ and \"skew.y\" is β, then the line x = 0 will be rotated by ⍺ (y = -x*cot⍺) and the line y = 0 will be\n *         rotated by β (y = x*tanβ). A line y = x*tanϴ (i.e. a line at angle ϴ to the x-axis in local-space) will\n *         be rotated by an angle between ⍺ and β.\n *         </p>\n *         <p>\n *         It can be observed that if skew is applied equally to both axes, then it will be equivalent to applying\n *         a rotation. Indeed, if \"skew.x\" = -ϴ and \"skew.y\" = ϴ, it will produce an equivalent of \"rotation\" = ϴ.\n *         </p>\n *         <p>\n *         Another quite interesting observation is that \"skew.x\", \"skew.y\", rotation are commutative operations. Indeed,\n *         because rotation is essentially a careful combination of the two.\n *         </p>\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[angle]{@link scene.Container#angle}</td>\n *       <td>Rotation. This is an alias for [rotation]{@link scene.Container#rotation}, but in degrees.</td>\n *     </tr>\n *     <tr>\n *       <td>[x]{@link scene.Container#x}</td>\n *       <td>Translation. This is an alias for position.x!</td>\n *     </tr>\n *     <tr>\n *       <td>[y]{@link scene.Container#y}</td>\n *       <td>Translation. This is an alias for position.y!</td>\n *     </tr>\n *     <tr>\n *       <td>[width]{@link scene.Container#width}</td>\n *       <td>\n *         Implemented in [Container]{@link scene.Container}. Scaling. The width property calculates scale.x by dividing\n *         the \"requested\" width by the local bounding box width. It is indirectly an abstraction over scale.x, and there\n *         is no concept of user-defined width.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[height]{@link scene.Container#height}</td>\n *       <td>\n *         Implemented in [Container]{@link scene.Container}. Scaling. The height property calculates scale.y by dividing\n *         the \"requested\" height by the local bounding box height. It is indirectly an abstraction over scale.y, and there\n *         is no concept of user-defined height.\n *       </td>\n *     </tr>\n *   </tbody>\n * </table>\n * </details>\n *\n * <details id=\"alpha\">\n * <summary>Alpha</summary>\n *\n * This alpha sets a display object's **relative opacity** w.r.t its parent. For example, if the alpha of a display\n * object is 0.5 and its parent's alpha is 0.5, then it will be rendered with 25% opacity (assuming alpha is not\n * applied on any ancestor further up the chain).\n * </details>\n *\n * <details id=\"visible\">\n * <summary>Renderable vs Visible</summary>\n *\n * The `renderable` and `visible` properties can be used to prevent a display object from being rendered to the\n * screen. However, there is a subtle difference between the two. When using `renderable`, the transforms  of the display\n * object (and its children subtree) will continue to be calculated. When using `visible`, the transforms will not\n * be calculated.\n * ```ts\n * import { BlurFilter, Container, Graphics, Sprite } from 'pixi.js';\n *\n * const container = new Container();\n * const sprite = Sprite.from('https://s3-us-west-2.amazonaws.com/s.cdpn.io/693612/IaUrttj.png');\n *\n * sprite.width = 512;\n * sprite.height = 512;\n *\n * // Adds a sprite as a child to this container. As a result, the sprite will be rendered whenever the container\n * // is rendered.\n * container.addChild(sprite);\n *\n * // Blurs whatever is rendered by the container\n * container.filters = [new BlurFilter()];\n *\n * // Only the contents within a circle at the center should be rendered onto the screen.\n * container.mask = new Graphics()\n *     .beginFill(0xffffff)\n *     .drawCircle(sprite.width / 2, sprite.height / 2, Math.min(sprite.width, sprite.height) / 2)\n *     .endFill();\n * ```\n *\n * </details>\n *\n * <details id=\"renderGroup\">\n * <summary>RenderGroup</summary>\n *\n * In PixiJS v8, containers can be set to operate in 'render group mode',\n * transforming them into entities akin to a stage in traditional rendering paradigms.\n * A render group is a root renderable entity, similar to a container,\n * but it's rendered in a separate pass with its own unique set of rendering instructions.\n * This approach enhances rendering efficiency and organization, particularly in complex scenes.\n *\n * You can enable render group mode on any container using container.enableRenderGroup()\n * or by initializing a new container with the render group property set to true (new Container({isRenderGroup: true})).\n *  The method you choose depends on your specific use case and setup requirements.\n *\n * An important aspect of PixiJS’s rendering process is the automatic treatment of rendered scenes as render groups.\n * This conversion streamlines the rendering process, but understanding when and how this happens is crucial\n * to fully leverage its benefits.\n *\n * One of the key advantages of using render groups is the performance efficiency in moving them. Since transformations\n *  are applied at the GPU level, moving a render group, even one with complex and numerous children,\n * doesn't require recalculating the rendering instructions or performing transformations on each child.\n * This makes operations like panning a large game world incredibly efficient.\n *\n * However, it's crucial to note that render groups do not batch together.\n * This means that turning every container into a render group could actually slow things down,\n * as each render group is processed separately. It's best to use render groups judiciously, at a broader level,\n * rather than on a per-child basis.\n * This approach ensures you get the performance benefits without overburdening the rendering process.\n *\n * RenderGroups maintain their own set of rendering instructions,\n * ensuring that changes or updates within a render group don't affect the rendering\n * instructions of its parent or other render groups.\n *  This isolation ensures more stable and predictable rendering behavior.\n *\n * Additionally, renderGroups can be nested, allowing for powerful options in organizing different aspects of your scene.\n * This feature is particularly beneficial for separating complex game graphics from UI elements,\n * enabling intricate and efficient scene management in complex applications.\n *\n * This means that Containers have 3 levels of matrix to be mindful of:\n *\n * 1. localTransform, this is the transform of the container based on its own properties\n * 2. groupTransform, this it the transform of the container relative to the renderGroup it belongs too\n * 3. worldTransform, this is the transform of the container relative to the Scene being rendered\n * </details>\n * @memberof scene\n */\nexport class Container extends EventEmitter<ContainerEvents & AnyEvent>\n{\n    /**\n     * Mixes all enumerable properties and methods from a source object to Container.\n     * @param source - The source of properties and methods to mix in.\n     */\n    public static mixin(source: Dict<any>): void\n    {\n        Object.defineProperties(Container.prototype, Object.getOwnPropertyDescriptors(source));\n    }\n\n    /** @private */\n    public uid: number = uid('renderable');\n\n    /** @private */\n    public _updateFlags = 0b1111;\n\n    // is this container the root of a renderGroup?\n    // TODO implement this in a few more places\n    /** @private */\n    public isRenderGroupRoot = false;\n    // the render group this container belongs to OR owns\n    /** @private */\n    public renderGroup: RenderGroup = null;\n\n    // set to true if the container has changed. It is reset once the changes have been applied\n    // by the transform system\n    // its here to stop ensure that when things change, only one update gets registers with the transform system\n    /** @private */\n    public didChange = false;\n    // same as above, but for the renderable\n    /** @private */\n    public didViewUpdate = false;\n    // how deep is the container relative to its render group..\n    // unless the element is the root render group - it will be relative to its parent\n    /** @private */\n    public relativeRenderGroupDepth = 0;\n\n    /**\n     * The array of children of this container.\n     * @readonly\n     */\n    public children: Container[] = [];\n    /** The display object container that contains this display object. */\n    public parent: Container = null;\n\n    // used internally for changing up the render order.. mainly for masks and filters\n    // TODO setting this should cause a rebuild??\n    /** @private */\n    public includeInBuild = true;\n    /** @private */\n    public measurable = true;\n    /** @private */\n    public isSimple = true;\n\n    // / /////////////Transform related props//////////////\n\n    // used by the transform system to check if a container needs to be updated that frame\n    // if the tick matches the current transform system tick, it is not updated again\n    /**\n     * @internal\n     * @ignore\n     */\n    public updateTick = -1;\n\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     * @readonly\n     */\n    public localTransform: Matrix = new Matrix();\n    /**\n     * The relative group transform is a transform relative to the render group it belongs too. It will include all parent\n     * transforms and up to the render group (think of it as kind of like a stage - but the stage can be nested).\n     * If this container is is self a render group matrix will be relative to its parent render group\n     * @readonly\n     */\n    public relativeGroupTransform: Matrix = new Matrix();\n    /**\n     * The group transform is a transform relative to the render group it belongs too.\n     * If this container is render group then this will be an identity matrix. other wise it\n     * will be the same as the relativeGroupTransform.\n     * Use this value when actually rendering things to the screen\n     * @readonly\n     */\n    public groupTransform: Matrix = this.relativeGroupTransform;\n\n    // the global transform taking into account the render group and all parents\n    private _worldTransform: Matrix;\n\n    /** If the object has been destroyed via destroy(). If true, it should not be used. */\n    public destroyed = false;\n\n    // transform data..\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @internal\n     * @ignore\n     */\n    public _position: ObservablePoint = new ObservablePoint(this, 0, 0);\n\n    /**\n     * The scale factor of the object.\n     * @internal\n     * @ignore\n     */\n    public _scale: ObservablePoint = defaultScale;\n\n    /**\n     * The pivot point of the container that it rotates around.\n     * @internal\n     * @ignore\n     */\n    public _pivot: ObservablePoint = defaultPivot;\n\n    /**\n     * The skew amount, on the x and y axis.\n     * @internal\n     * @ignore\n     */\n    public _skew: ObservablePoint = defaultSkew;\n\n    /**\n     * The X-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    public _cx = 1;\n\n    /**\n     * The Y-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    public _sx = 0;\n\n    /**\n     * The X-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    public _cy = 0;\n\n    /**\n     * The Y-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    public _sy = 1;\n\n    /**\n     * The rotation amount.\n     * @internal\n     * @ignore\n     */\n    private _rotation = 0;\n\n    // / COLOR related props //////////////\n\n    // color stored as ABGR\n    public localColor = 0xFFFFFF;\n    public localAlpha = 1;\n\n    public groupAlpha = 1; // A\n    public groupColor = 0xFFFFFF; // BGR\n    public groupColorAlpha = 0xFFFFFFFF; // ABGR\n\n    // / BLEND related props //////////////\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public localBlendMode: BLEND_MODES = 'inherit';\n    /**\n     * @internal\n     * @ignore\n     */\n    public groupBlendMode: BLEND_MODES = 'normal';\n\n    // / VISIBILITY related props //////////////\n\n    // visibility\n    // 0b11\n    // first bit is visible, second bit is renderable\n    /**\n     * This property holds three bits: culled, visible, renderable\n     * the third bit represents culling (0 = culled, 1 = not culled) 0b100\n     * the second bit represents visibility (0 = not visible, 1 = visible) 0b010\n     * the first bit represents renderable (0 = renderable, 1 = not renderable) 0b001\n     * @internal\n     * @ignore\n     */\n    public localDisplayStatus = 0b111; // 0b11 | 0b10 | 0b01 | 0b00\n    /**\n     * @internal\n     * @ignore\n     */\n    public globalDisplayStatus = 0b111; // 0b11 | 0b10 | 0b01 | 0b00\n\n    public renderPipeId: string;\n\n    /**\n     * An optional bounds area for this container. Setting this rectangle will stop the renderer\n     * from recursively measuring the bounds of each children and instead use this single boundArea.\n     * This is great for optimisation! If for example you have a 1000 spinning particles and you know they all sit\n     * within a specific bounds, then setting it will mean the renderer will not need to measure the\n     * 1000 children to find the bounds. Instead it will just use the bounds you set.\n     */\n    public boundsArea: Rectangle;\n\n    /**\n     * A value that increments each time the container is modified\n     * the first 12 bits represent the container changes (eg transform, alpha, visible etc)\n     * the second 12 bits represent the view changes (eg texture swap, geometry change etc)\n     *\n     *  view          container\n     * [000000000000][00000000000]\n     * @ignore\n     */\n    public _didChangeId = 0;\n    /**\n     * property that tracks if the container transform has changed\n     * @ignore\n     */\n    private _didLocalTransformChangeId = -1;\n\n    constructor(options: ContainerOptions = {})\n    {\n        super();\n\n        assignWithIgnore(this, options, {\n            children: true,\n            parent: true,\n            effects: true,\n        });\n\n        options.children?.forEach((child) => this.addChild(child));\n        this.effects = [];\n        options.parent?.addChild(this);\n    }\n\n    /**\n     * Adds one or more children to the container.\n     *\n     * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n     * @param {...Container} children - The Container(s) to add to the container\n     * @returns {Container} - The first child that was added.\n     */\n    public addChild<U extends Container[]>(...children: U): U[0]\n    {\n        // #if _DEBUG\n        if (!this.allowChildren)\n        {\n            deprecation(v8_0_0, 'addChild: Only Containers will be allowed to add children in v8.0.0');\n        }\n        // #endif\n\n        if (children.length > 1)\n        {\n            // loop through the array and add all children\n            for (let i = 0; i < children.length; i++)\n            {\n                this.addChild(children[i]);\n            }\n\n            return children[0];\n        }\n\n        const child = children[0];\n\n        if (child.parent === this)\n        {\n            this.children.splice(this.children.indexOf(child), 1);\n            this.children.push(child);\n\n            if (this.renderGroup && !this.isRenderGroupRoot)\n            {\n                this.renderGroup.structureDidChange = true;\n            }\n\n            return child;\n        }\n\n        if (child.parent)\n        {\n            // TODO Optimisation...if the parent has the same render group, this does not need to change!\n            child.parent.removeChild(child);\n        }\n\n        this.children.push(child);\n\n        if (this.sortableChildren) this.sortDirty = true;\n\n        child.parent = this;\n\n        child.didChange = true;\n        child.didViewUpdate = false;\n\n        // TODO - OPtimise this? could check what the parent has set?\n        child._updateFlags = 0b1111;\n\n        if (this.renderGroup)\n        {\n            this.renderGroup.addChild(child);\n        }\n\n        this.emit('childAdded', child, this, this.children.length - 1);\n        child.emit('added', this);\n\n        if (child._zIndex !== 0)\n        {\n            child.depthOfChildModified();\n        }\n\n        return child;\n    }\n\n    /**\n     * Removes one or more children from the container.\n     * @param {...Container} children - The Container(s) to remove\n     * @returns {Container} The first child that was removed.\n     */\n    public removeChild<U extends Container[]>(...children: U): U[0]\n    {\n        // if there is only one argument we can bypass looping through the them\n        if (children.length > 1)\n        {\n            // loop through the arguments property and remove all children\n            for (let i = 0; i < children.length; i++)\n            {\n                this.removeChild(children[i]);\n            }\n\n            return children[0];\n        }\n\n        const child = children[0];\n\n        const index = this.children.indexOf(child);\n\n        if (index > -1)\n        {\n            this.children.splice(index, 1);\n\n            if (this.renderGroup)\n            {\n                this.renderGroup.removeChild(child);\n            }\n\n            child.parent = null;\n            this.emit('childRemoved', child, this, index);\n            child.emit('removed', this);\n        }\n\n        return child;\n    }\n\n    /** @ignore */\n    public _onUpdate(point?: ObservablePoint)\n    {\n        if (point)\n        {\n            //   this.updateFlags |= UPDATE_TRANSFORM;\n\n            if (point === this._skew)\n            {\n                this._updateSkew();\n            }\n        }\n\n        this._didChangeId++;\n\n        if (this.didChange) return;\n        this.didChange = true;\n\n        if (this.isRenderGroupRoot)\n        {\n            const renderGroupParent = this.renderGroup.renderGroupParent;\n            // lets update its parent..\n\n            if (renderGroupParent)\n            {\n                renderGroupParent.onChildUpdate(this);\n            }\n        }\n        else if (this.renderGroup)\n        {\n            this.renderGroup.onChildUpdate(this);\n        }\n    }\n\n    set isRenderGroup(value: boolean)\n    {\n        if (this.isRenderGroupRoot && value === false)\n        {\n            throw new Error('[Pixi] cannot undo a render group just yet');\n        }\n\n        if (value)\n        {\n            this.enableRenderGroup();\n        }\n    }\n\n    /**\n     * Returns true if this container is a render group.\n     * This means that it will be rendered as a separate pass, with its own set of instructions\n     */\n    get isRenderGroup(): boolean\n    {\n        return this.isRenderGroupRoot;\n    }\n\n    /** This enables the container to be rendered as a render group. */\n    public enableRenderGroup()\n    {\n        // does it OWN the render group..\n        if (this.renderGroup && this.renderGroup.root === this) return;\n\n        this.isRenderGroupRoot = true;\n\n        const parentRenderGroup = this.renderGroup;\n\n        if (parentRenderGroup)\n        {\n            parentRenderGroup.removeChild(this);\n        }\n\n        this.renderGroup = new RenderGroup(this);\n\n        // find children render groups and move them out..\n        if (parentRenderGroup)\n        {\n            for (let i = 0; i < parentRenderGroup.renderGroupChildren.length; i++)\n            {\n                const childRenderGroup = parentRenderGroup.renderGroupChildren[i];\n                let parent = childRenderGroup.root;\n\n                while (parent)\n                {\n                    if (parent === this)\n                    {\n                        this.renderGroup.addRenderGroupChild(childRenderGroup);\n\n                        break;\n                    }\n                    parent = parent.parent;\n                }\n            }\n\n            parentRenderGroup.addRenderGroupChild(this.renderGroup);\n        }\n\n        this._updateIsSimple();\n\n        // this group matrix will now forever be an identity matrix,\n        // as its own transform will be passed to the GPU\n        this.groupTransform = Matrix.IDENTITY;\n    }\n\n    /** @ignore */\n    public _updateIsSimple()\n    {\n        this.isSimple = !(this.isRenderGroupRoot) && (this.effects.length === 0);\n    }\n\n    /**\n     * Current transform of the object based on world (parent) factors.\n     * @readonly\n     */\n    get worldTransform()\n    {\n        this._worldTransform ||= new Matrix();\n\n        if (this.renderGroup)\n        {\n            if (this.isRenderGroupRoot)\n            {\n                this._worldTransform.copyFrom(this.renderGroup.worldTransform);\n            }\n            else\n            {\n                this._worldTransform.appendFrom(this.relativeGroupTransform, this.renderGroup.worldTransform);\n            }\n        }\n\n        return this._worldTransform;\n    }\n\n    // / ////// transform related stuff\n\n    /**\n     * The position of the container on the x axis relative to the local coordinates of the parent.\n     * An alias to position.x\n     */\n    get x(): number\n    {\n        return this._position.x;\n    }\n\n    set x(value: number)\n    {\n        this._position.x = value;\n    }\n\n    /**\n     * The position of the container on the y axis relative to the local coordinates of the parent.\n     * An alias to position.y\n     */\n    get y(): number\n    {\n        return this._position.y;\n    }\n\n    set y(value: number)\n    {\n        this._position.y = value;\n    }\n\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @since 4.0.0\n     */\n    get position(): ObservablePoint\n    {\n        return this._position;\n    }\n\n    set position(value: PointData)\n    {\n        this._position.copyFrom(value);\n    }\n\n    /**\n     * The rotation of the object in radians.\n     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n     */\n    get rotation(): number\n    {\n        return this._rotation;\n    }\n\n    set rotation(value: number)\n    {\n        if (this._rotation !== value)\n        {\n            this._rotation = value;\n            this._onUpdate(this._skew);\n        }\n    }\n\n    /**\n     * The angle of the object in degrees.\n     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n     */\n    get angle(): number\n    {\n        return this.rotation * RAD_TO_DEG;\n    }\n\n    set angle(value: number)\n    {\n        this.rotation = value * DEG_TO_RAD;\n    }\n\n    /**\n     * The center of rotation, scaling, and skewing for this display object in its local space. The `position`\n     * is the projection of `pivot` in the parent's local space.\n     *\n     * By default, the pivot is the origin (0, 0).\n     * @since 4.0.0\n     */\n    get pivot(): ObservablePoint\n    {\n        if (this._pivot === defaultPivot)\n        {\n            this._pivot = new ObservablePoint(this, 0, 0);\n        }\n\n        return this._pivot;\n    }\n\n    set pivot(value: PointData | number)\n    {\n        if (this._pivot === defaultPivot)\n        {\n            this._pivot = new ObservablePoint(this, 0, 0);\n        }\n\n        typeof value === 'number' ? this._pivot.set(value) : this._pivot.copyFrom(value);\n    }\n\n    /**\n     * The skew factor for the object in radians.\n     * @since 4.0.0\n     */\n    get skew(): ObservablePoint\n    {\n        if (this._skew === defaultSkew)\n        {\n            this._skew = new ObservablePoint(this, 0, 0);\n        }\n\n        return this._skew;\n    }\n\n    set skew(value: PointData)\n    {\n        if (this._skew === defaultSkew)\n        {\n            this._skew = new ObservablePoint(this, 0, 0);\n        }\n\n        this._skew.copyFrom(value);\n    }\n\n    /**\n     * The scale factors of this object along the local coordinate axes.\n     *\n     * The default scale is (1, 1).\n     * @since 4.0.0\n     */\n    get scale(): ObservablePoint\n    {\n        if (this._scale === defaultScale)\n        {\n            this._scale = new ObservablePoint(this, 1, 1);\n        }\n\n        return this._scale;\n    }\n\n    set scale(value: PointData | number)\n    {\n        if (this._scale === defaultScale)\n        {\n            this._scale = new ObservablePoint(this, 0, 0);\n        }\n\n        typeof value === 'number' ? this._scale.set(value) : this._scale.copyFrom(value);\n    }\n\n    /**\n     * The width of the Container, setting this will actually modify the scale to achieve the value set.\n     * @memberof scene.Container#\n     */\n    get width(): number\n    {\n        return Math.abs(this.scale.x * this.getLocalBounds().width);\n    }\n\n    set width(value: number)\n    {\n        const localWidth = this.getLocalBounds().width;\n\n        this._setWidth(value, localWidth);\n    }\n\n    /**\n     * The height of the Container, setting this will actually modify the scale to achieve the value set.\n     * @memberof scene.Container#\n     */\n    get height(): number\n    {\n        return Math.abs(this.scale.y * this.getLocalBounds().height);\n    }\n\n    set height(value: number)\n    {\n        const localHeight = this.getLocalBounds().height;\n\n        this._setHeight(value, localHeight);\n    }\n\n    /**\n     * Retrieves the size of the container as a [Size]{@link Size} object.\n     * This is faster than get the width and height separately.\n     * @param out - Optional object to store the size in.\n     * @returns - The size of the container.\n     * @memberof scene.Container#\n     */\n    public getSize(out?: Size): Size\n    {\n        if (!out)\n        {\n            out = {} as Size;\n        }\n\n        const bounds = this.getLocalBounds();\n\n        out.width = Math.abs(this.scale.x * bounds.width);\n        out.height = Math.abs(this.scale.y * bounds.height);\n\n        return out;\n    }\n\n    /**\n     * Sets the size of the container to the specified width and height.\n     * This is faster than setting the width and height separately.\n     * @param value - This can be either a number or a [Size]{@link Size} object.\n     * @param height - The height to set. Defaults to the value of `width` if not provided.\n     * @memberof scene.Container#\n     */\n    public setSize(value: number | Optional<Size, 'height'>, height?: number)\n    {\n        const size = this.getLocalBounds();\n        let convertedWidth: number;\n        let convertedHeight: number;\n\n        if (typeof value !== 'object')\n        {\n            convertedWidth = value;\n            convertedHeight = height ?? value;\n        }\n        else\n        {\n            convertedWidth = value.width;\n            convertedHeight = value.height ?? value.width;\n        }\n\n        if (convertedWidth !== undefined)\n        {\n            this._setWidth(convertedWidth, size.width);\n        }\n\n        if (convertedHeight !== undefined)\n        {\n            this._setHeight(convertedHeight, size.height);\n        }\n    }\n\n    /** Called when the skew or the rotation changes. */\n    private _updateSkew(): void\n    {\n        const rotation = this._rotation;\n        const skew = this._skew;\n\n        this._cx = Math.cos(rotation + skew._y);\n        this._sx = Math.sin(rotation + skew._y);\n        this._cy = -Math.sin(rotation - skew._x); // cos, added PI/2\n        this._sy = Math.cos(rotation - skew._x); // sin, added PI/2\n    }\n\n    /**\n     * Updates the transform properties of the container (accepts partial values).\n     * @param {object} opts - The options for updating the transform.\n     * @param {number} opts.x - The x position of the container.\n     * @param {number} opts.y - The y position of the container.\n     * @param {number} opts.scaleX - The scale factor on the x-axis.\n     * @param {number} opts.scaleY - The scale factor on the y-axis.\n     * @param {number} opts.rotation - The rotation of the container, in radians.\n     * @param {number} opts.skewX - The skew factor on the x-axis.\n     * @param {number} opts.skewY - The skew factor on the y-axis.\n     * @param {number} opts.pivotX - The x coordinate of the pivot point.\n     * @param {number} opts.pivotY - The y coordinate of the pivot point.\n     */\n    public updateTransform(opts: Partial<UpdateTransformOptions>): this\n    {\n        this.position.set(\n            typeof opts.x === 'number' ? opts.x : this.position.x,\n            typeof opts.y === 'number' ? opts.y : this.position.y\n        );\n        this.scale.set(\n            typeof opts.scaleX === 'number' ? opts.scaleX || 1 : this.scale.x,\n            typeof opts.scaleY === 'number' ? opts.scaleY || 1 : this.scale.y\n        );\n        this.rotation = typeof opts.rotation === 'number' ? opts.rotation : this.rotation;\n        this.skew.set(\n            typeof opts.skewX === 'number' ? opts.skewX : this.skew.x,\n            typeof opts.skewY === 'number' ? opts.skewY : this.skew.y\n        );\n        this.pivot.set(\n            typeof opts.pivotX === 'number' ? opts.pivotX : this.pivot.x,\n            typeof opts.pivotY === 'number' ? opts.pivotY : this.pivot.y\n        );\n\n        return this;\n    }\n\n    /**\n     * Updates the local transform using the given matrix.\n     * @param matrix - The matrix to use for updating the transform.\n     */\n    public setFromMatrix(matrix: Matrix): void\n    {\n        matrix.decompose(this);\n    }\n\n    /** Updates the local transform. */\n    public updateLocalTransform(): void\n    {\n        if ((this._didLocalTransformChangeId & 0b1111) === this._didChangeId) return;\n\n        this._didLocalTransformChangeId = this._didChangeId;\n        //   this.didChange = false;\n\n        const lt = this.localTransform;\n        const scale = this._scale;\n        const pivot = this._pivot;\n        const position = this._position;\n\n        const sx = scale._x;\n        const sy = scale._y;\n\n        const px = pivot._x;\n        const py = pivot._y;\n\n        // get the matrix values of the container based on its this properties..\n        lt.a = this._cx * sx;\n        lt.b = this._sx * sx;\n        lt.c = this._cy * sy;\n        lt.d = this._sy * sy;\n\n        lt.tx = position._x - ((px * lt.a) + (py * lt.c));\n        lt.ty = position._y - ((px * lt.b) + (py * lt.d));\n    }\n\n    // / ///// color related stuff\n\n    set alpha(value: number)\n    {\n        if (value === this.localAlpha) return;\n\n        this.localAlpha = value;\n\n        this._updateFlags |= UPDATE_COLOR;\n\n        this._onUpdate();\n    }\n\n    /** The opacity of the object. */\n    get alpha(): number\n    {\n        return this.localAlpha;\n    }\n\n    set tint(value: ColorSource)\n    {\n        const tempColor = Color.shared.setValue(value ?? 0xFFFFFF);\n        const bgr = tempColor.toBgrNumber();\n\n        if (bgr === this.localColor) return;\n\n        this.localColor = bgr;\n\n        this._updateFlags |= UPDATE_COLOR;\n\n        this._onUpdate();\n    }\n\n    /**\n     * The tint applied to the sprite. This is a hex value.\n     *\n     * A value of 0xFFFFFF will remove any tint effect.\n     * @default 0xFFFFFF\n     */\n    get tint(): number\n    {\n        const bgr = this.localColor;\n        // convert bgr to rgb..\n\n        return ((bgr & 0xFF) << 16) + (bgr & 0xFF00) + ((bgr >> 16) & 0xFF);\n    }\n\n    // / //////////////// blend related stuff\n\n    set blendMode(value: BLEND_MODES)\n    {\n        if (this.localBlendMode === value) return;\n        if (this.renderGroup && !this.isRenderGroupRoot)\n        {\n            this.renderGroup.structureDidChange = true;\n        }\n\n        this._updateFlags |= UPDATE_BLEND;\n\n        this.localBlendMode = value;\n\n        this._onUpdate();\n    }\n\n    /**\n     * The blend mode to be applied to the sprite. Apply a value of `'normal'` to reset the blend mode.\n     * @default 'normal'\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this.localBlendMode;\n    }\n\n    // / ///////// VISIBILITY / RENDERABLE /////////////////\n\n    /** The visibility of the object. If false the object will not be drawn, and the transform will not be updated. */\n    get visible()\n    {\n        return !!(this.localDisplayStatus & 0b010);\n    }\n\n    set visible(value: boolean)\n    {\n        const valueNumber = value ? 1 : 0;\n\n        if ((this.localDisplayStatus & 0b010) >> 1 === valueNumber) return;\n\n        if (this.renderGroup && !this.isRenderGroupRoot)\n        {\n            this.renderGroup.structureDidChange = true;\n        }\n\n        this._updateFlags |= UPDATE_VISIBLE;\n\n        this.localDisplayStatus ^= 0b010;\n\n        this._onUpdate();\n    }\n\n    /** @ignore */\n    get culled()\n    {\n        return !(this.localDisplayStatus & 0b100);\n    }\n\n    /** @ignore */\n    set culled(value: boolean)\n    {\n        const valueNumber = value ? 1 : 0;\n\n        if ((this.localDisplayStatus & 0b100) >> 2 === valueNumber) return;\n\n        if (this.renderGroup && !this.isRenderGroupRoot)\n        {\n            this.renderGroup.structureDidChange = true;\n        }\n\n        this._updateFlags |= UPDATE_VISIBLE;\n        this.localDisplayStatus ^= 0b100;\n\n        this._onUpdate();\n    }\n\n    /** Can this object be rendered, if false the object will not be drawn but the transform will still be updated. */\n    get renderable()\n    {\n        return !!(this.localDisplayStatus & 0b001);\n    }\n\n    set renderable(value: boolean)\n    {\n        const valueNumber = value ? 1 : 0;\n\n        if ((this.localDisplayStatus & 0b001) === valueNumber) return;\n\n        this._updateFlags |= UPDATE_VISIBLE;\n        this.localDisplayStatus ^= 0b001;\n\n        if (this.renderGroup && !this.isRenderGroupRoot)\n        {\n            this.renderGroup.structureDidChange = true;\n        }\n\n        this._onUpdate();\n    }\n\n    /** Whether or not the object should be rendered. */\n    get isRenderable(): boolean\n    {\n        return (this.localDisplayStatus === 0b111 && this.groupAlpha > 0);\n    }\n\n    /**\n     * Removes all internal references and listeners as well as removes children from the display list.\n     * Do not use a Container after calling `destroy`.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n     *  method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children\n     * is set to true it should destroy the texture of the child sprite\n     * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n     * If options.children is set to true it should destroy the texture source of the child sprite\n     * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n     * If options.children is set to true it should destroy the context of the child graphics\n     */\n    public destroy(options: DestroyOptions = false): void\n    {\n        if (this.destroyed) return;\n        this.destroyed = true;\n\n        this.removeFromParent();\n        this.parent = null;\n        this._mask = null;\n        this._filters = null;\n        this.effects = null;\n        this._position = null;\n        this._scale = null;\n        this._pivot = null;\n        this._skew = null;\n\n        this.emit('destroyed', this);\n\n        this.removeAllListeners();\n\n        const destroyChildren = typeof options === 'boolean' ? options : options?.children;\n\n        const oldChildren = this.removeChildren(0, this.children.length);\n\n        if (destroyChildren)\n        {\n            for (let i = 0; i < oldChildren.length; ++i)\n            {\n                oldChildren[i].destroy(options);\n            }\n        }\n    }\n}\n\nContainer.mixin(childrenHelperMixin);\nContainer.mixin(toLocalGlobalMixin);\nContainer.mixin(onRenderMixin);\nContainer.mixin(measureMixin);\nContainer.mixin(effectsMixin);\nContainer.mixin(findMixin);\nContainer.mixin(sortMixin);\nContainer.mixin(cullingMixin);\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","import { extend, colord } from '@pixi/colord';\nimport namesPlugin from '@pixi/colord/plugins/names';\n\n\"use strict\";\nextend([namesPlugin]);\nconst _Color = class _Color {\n  /**\n   * @param {ColorSource} value - Optional value to use, if not provided, white is used.\n   */\n  constructor(value = 16777215) {\n    this._value = null;\n    this._components = new Float32Array(4);\n    this._components.fill(1);\n    this._int = 16777215;\n    this.value = value;\n  }\n  /** Get red component (0 - 1) */\n  get red() {\n    return this._components[0];\n  }\n  /** Get green component (0 - 1) */\n  get green() {\n    return this._components[1];\n  }\n  /** Get blue component (0 - 1) */\n  get blue() {\n    return this._components[2];\n  }\n  /** Get alpha component (0 - 1) */\n  get alpha() {\n    return this._components[3];\n  }\n  /**\n   * Set the value, suitable for chaining\n   * @param value\n   * @see Color.value\n   */\n  setValue(value) {\n    this.value = value;\n    return this;\n  }\n  /**\n   * The current color source.\n   *\n   * When setting:\n   * - Setting to an instance of `Color` will copy its color source and components.\n   * - Otherwise, `Color` will try to normalize the color source and set the components.\n   *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.\n   *\n   * Note: The `null` in the setter's parameter type is added to match the TypeScript rule: return type of getter\n   * must be assignable to its setter's parameter type. Setting `value` to `null` will throw an `Error`.\n   *\n   * When getting:\n   * - A return value of `null` means the previous value was overridden (e.g., {@link Color.multiply multiply},\n   *   {@link Color.premultiply premultiply} or {@link Color.round round}).\n   * - Otherwise, the color source used when setting is returned.\n   */\n  set value(value) {\n    if (value instanceof _Color) {\n      this._value = this._cloneSource(value._value);\n      this._int = value._int;\n      this._components.set(value._components);\n    } else if (value === null) {\n      throw new Error(\"Cannot set Color#value to null\");\n    } else if (this._value === null || !this._isSourceEqual(this._value, value)) {\n      this._normalize(value);\n      this._value = this._cloneSource(value);\n    }\n  }\n  get value() {\n    return this._value;\n  }\n  /**\n   * Copy a color source internally.\n   * @param value - Color source\n   */\n  _cloneSource(value) {\n    if (typeof value === \"string\" || typeof value === \"number\" || value instanceof Number || value === null) {\n      return value;\n    } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n      return value.slice(0);\n    } else if (typeof value === \"object\" && value !== null) {\n      return { ...value };\n    }\n    return value;\n  }\n  /**\n   * Equality check for color sources.\n   * @param value1 - First color source\n   * @param value2 - Second color source\n   * @returns `true` if the color sources are equal, `false` otherwise.\n   */\n  _isSourceEqual(value1, value2) {\n    const type1 = typeof value1;\n    const type2 = typeof value2;\n    if (type1 !== type2) {\n      return false;\n    } else if (type1 === \"number\" || type1 === \"string\" || value1 instanceof Number) {\n      return value1 === value2;\n    } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {\n      if (value1.length !== value2.length) {\n        return false;\n      }\n      return value1.every((v, i) => v === value2[i]);\n    } else if (value1 !== null && value2 !== null) {\n      const keys1 = Object.keys(value1);\n      const keys2 = Object.keys(value2);\n      if (keys1.length !== keys2.length) {\n        return false;\n      }\n      return keys1.every((key) => value1[key] === value2[key]);\n    }\n    return value1 === value2;\n  }\n  /**\n   * Convert to a RGBA color object.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }\n   */\n  toRgba() {\n    const [r, g, b, a] = this._components;\n    return { r, g, b, a };\n  }\n  /**\n   * Convert to a RGB color object.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1 }\n   */\n  toRgb() {\n    const [r, g, b] = this._components;\n    return { r, g, b };\n  }\n  /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */\n  toRgbaString() {\n    const [r, g, b] = this.toUint8RgbArray();\n    return `rgba(${r},${g},${b},${this.alpha})`;\n  }\n  toUint8RgbArray(out) {\n    const [r, g, b] = this._components;\n    if (!this._arrayRgb) {\n      this._arrayRgb = [];\n    }\n    out = out || this._arrayRgb;\n    out[0] = Math.round(r * 255);\n    out[1] = Math.round(g * 255);\n    out[2] = Math.round(b * 255);\n    return out;\n  }\n  toArray(out) {\n    if (!this._arrayRgba) {\n      this._arrayRgba = [];\n    }\n    out = out || this._arrayRgba;\n    const [r, g, b, a] = this._components;\n    out[0] = r;\n    out[1] = g;\n    out[2] = b;\n    out[3] = a;\n    return out;\n  }\n  toRgbArray(out) {\n    if (!this._arrayRgb) {\n      this._arrayRgb = [];\n    }\n    out = out || this._arrayRgb;\n    const [r, g, b] = this._components;\n    out[0] = r;\n    out[1] = g;\n    out[2] = b;\n    return out;\n  }\n  /**\n   * Convert to a hexadecimal number.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toNumber(); // returns 16777215\n   */\n  toNumber() {\n    return this._int;\n  }\n  /**\n   * Convert to a BGR number\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff\n   */\n  toBgrNumber() {\n    const [r, g, b] = this.toUint8RgbArray();\n    return (b << 16) + (g << 8) + r;\n  }\n  /**\n   * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff\n   * @returns {number} - The color as a number in little endian format.\n   */\n  toLittleEndianNumber() {\n    const value = this._int;\n    return (value >> 16) + (value & 65280) + ((value & 255) << 16);\n  }\n  /**\n   * Multiply with another color. This action is destructive, and will\n   * override the previous `value` property to be `null`.\n   * @param {ColorSource} value - The color to multiply by.\n   */\n  multiply(value) {\n    const [r, g, b, a] = _Color._temp.setValue(value)._components;\n    this._components[0] *= r;\n    this._components[1] *= g;\n    this._components[2] *= b;\n    this._components[3] *= a;\n    this._refreshInt();\n    this._value = null;\n    return this;\n  }\n  /**\n   * Converts color to a premultiplied alpha format. This action is destructive, and will\n   * override the previous `value` property to be `null`.\n   * @param alpha - The alpha to multiply by.\n   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n   * @returns {Color} - Itself.\n   */\n  premultiply(alpha, applyToRGB = true) {\n    if (applyToRGB) {\n      this._components[0] *= alpha;\n      this._components[1] *= alpha;\n      this._components[2] *= alpha;\n    }\n    this._components[3] = alpha;\n    this._refreshInt();\n    this._value = null;\n    return this;\n  }\n  /**\n   * Premultiplies alpha with current color.\n   * @param {number} alpha - The alpha to multiply by.\n   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n   * @returns {number} tint multiplied by alpha\n   */\n  toPremultiplied(alpha, applyToRGB = true) {\n    if (alpha === 1) {\n      return (255 << 24) + this._int;\n    }\n    if (alpha === 0) {\n      return applyToRGB ? 0 : this._int;\n    }\n    let r = this._int >> 16 & 255;\n    let g = this._int >> 8 & 255;\n    let b = this._int & 255;\n    if (applyToRGB) {\n      r = r * alpha + 0.5 | 0;\n      g = g * alpha + 0.5 | 0;\n      b = b * alpha + 0.5 | 0;\n    }\n    return (alpha * 255 << 24) + (r << 16) + (g << 8) + b;\n  }\n  /**\n   * Convert to a hexidecimal string.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toHex(); // returns \"#ffffff\"\n   */\n  toHex() {\n    const hexString = this._int.toString(16);\n    return `#${\"000000\".substring(0, 6 - hexString.length) + hexString}`;\n  }\n  /**\n   * Convert to a hexidecimal string with alpha.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toHexa(); // returns \"#ffffffff\"\n   */\n  toHexa() {\n    const alphaValue = Math.round(this._components[3] * 255);\n    const alphaString = alphaValue.toString(16);\n    return this.toHex() + \"00\".substring(0, 2 - alphaString.length) + alphaString;\n  }\n  /**\n   * Set alpha, suitable for chaining.\n   * @param alpha\n   */\n  setAlpha(alpha) {\n    this._components[3] = this._clamp(alpha);\n    return this;\n  }\n  /**\n   * Normalize the input value into rgba\n   * @param value - Input value\n   */\n  _normalize(value) {\n    let r;\n    let g;\n    let b;\n    let a;\n    if ((typeof value === \"number\" || value instanceof Number) && value >= 0 && value <= 16777215) {\n      const int = value;\n      r = (int >> 16 & 255) / 255;\n      g = (int >> 8 & 255) / 255;\n      b = (int & 255) / 255;\n      a = 1;\n    } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {\n      value = this._clamp(value);\n      [r, g, b, a = 1] = value;\n    } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {\n      value = this._clamp(value, 0, 255);\n      [r, g, b, a = 255] = value;\n      r /= 255;\n      g /= 255;\n      b /= 255;\n      a /= 255;\n    } else if (typeof value === \"string\" || typeof value === \"object\") {\n      if (typeof value === \"string\") {\n        const match = _Color.HEX_PATTERN.exec(value);\n        if (match) {\n          value = `#${match[2]}`;\n        }\n      }\n      const color = colord(value);\n      if (color.isValid()) {\n        ({ r, g, b, a } = color.rgba);\n        r /= 255;\n        g /= 255;\n        b /= 255;\n      }\n    }\n    if (r !== void 0) {\n      this._components[0] = r;\n      this._components[1] = g;\n      this._components[2] = b;\n      this._components[3] = a;\n      this._refreshInt();\n    } else {\n      throw new Error(`Unable to convert color ${value}`);\n    }\n  }\n  /** Refresh the internal color rgb number */\n  _refreshInt() {\n    this._clamp(this._components);\n    const [r, g, b] = this._components;\n    this._int = (r * 255 << 16) + (g * 255 << 8) + (b * 255 | 0);\n  }\n  /**\n   * Clamps values to a range. Will override original values\n   * @param value - Value(s) to clamp\n   * @param min - Minimum value\n   * @param max - Maximum value\n   */\n  _clamp(value, min = 0, max = 1) {\n    if (typeof value === \"number\") {\n      return Math.min(Math.max(value, min), max);\n    }\n    value.forEach((v, i) => {\n      value[i] = Math.min(Math.max(v, min), max);\n    });\n    return value;\n  }\n  /**\n   * Check if the value is a color-like object\n   * @param value - Value to check\n   * @returns True if the value is a color-like object\n   * @static\n   * @example\n   * import { Color } from 'pixi.js';\n   * Color.isColorLike('white'); // returns true\n   * Color.isColorLike(0xffffff); // returns true\n   * Color.isColorLike([1, 1, 1]); // returns true\n   */\n  static isColorLike(value) {\n    return typeof value === \"number\" || typeof value === \"string\" || value instanceof Number || value instanceof _Color || Array.isArray(value) || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Float32Array || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 && value.a !== void 0;\n  }\n};\n/**\n * Default Color object for static uses\n * @example\n * import { Color } from 'pixi.js';\n * Color.shared.setValue(0xffffff).toHex(); // '#ffffff'\n */\n_Color.shared = new _Color();\n/**\n * Temporary Color object for static uses internally.\n * As to not conflict with Color.shared.\n * @ignore\n */\n_Color._temp = new _Color();\n/** Pattern for hex strings */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n_Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;\nlet Color = _Color;\n\nexport { Color };\n//# sourceMappingURL=Color.mjs.map\n","import { colord, extend } from '@pixi/colord';\nimport namesPlugin from '@pixi/colord/plugins/names';\n\nimport type { AnyColor, HslaColor, HslColor, HsvaColor, HsvColor, RgbaColor, RgbColor } from '@pixi/colord';\n\nextend([namesPlugin]);\n\n/**\n * Pixi supports multiple color formats, including CSS color strings, hex, numbers, and arrays.\n *\n * When providing values for any of the color properties, you can use any of the {@link color.ColorSource} formats.\n * ```typescript\n * import { Color } from 'pixi.js';\n *\n * // All of these are valid:\n * sprite.tint = 'red';\n * sprite.tint = 0xff0000;\n * sprite.tint = '#ff0000';\n * sprite.tint = new Color('red');\n *\n * // Same for graphics fill/stroke colors and other  color values:\n * graphics.fill({ color: 'red' });\n * graphics.fill({ color: 0xff0000 });\n * graphics.stroke({ color: '#ff0000' });\n * graphics.stroke({ color: new Color('red')};\n * ```\n * @namespace color\n */\n\n/**\n * RGBA color array.\n *\n * `[number, number, number, number]`\n * @memberof color\n */\nexport type RgbaArray = [number, number, number, number];\n\n/**\n * Valid formats to use when defining any color properties, also valid for the {@link color.Color} constructor.\n *\n * These types are extended from [colord](https://www.npmjs.com/package/colord) with some PixiJS-specific extensions.\n *\n * Possible value types are:\n * - [Color names](https://www.w3.org/TR/css-color-4/#named-colors):\n *   `'red'`, `'green'`, `'blue'`, `'white'`, etc.\n * - RGB hex integers (`0xRRGGBB`):\n *   `0xff0000`, `0x00ff00`, `0x0000ff`, etc.\n * - [RGB(A) hex strings](https://www.w3.org/TR/css-color-4/#hex-notation):\n *   - 6 digits (`RRGGBB`): `'ff0000'`, `'#00ff00'`, `'0x0000ff'`, etc.\n *   - 3 digits (`RGB`): `'f00'`, `'#0f0'`, `'0x00f'`, etc.\n *   - 8 digits (`RRGGBBAA`): `'ff000080'`, `'#00ff0080'`, `'0x0000ff80'`, etc.\n *   - 4 digits (`RGBA`): `'f008'`, `'#0f08'`, `'0x00f8'`, etc.\n * - RGB(A) objects:\n *   `{ r: 255, g: 0, b: 0 }`, `{ r: 255, g: 0, b: 0, a: 0.5 }`, etc.\n * - [RGB(A) strings](https://www.w3.org/TR/css-color-4/#rgb-functions):\n *   `'rgb(255, 0, 0)'`, `'rgb(100% 0% 0%)'`, `'rgba(255, 0, 0, 0.5)'`, `'rgba(100% 0% 0% / 50%)'`, etc.\n * - RGB(A) arrays:\n *   `[1, 0, 0]`, `[1, 0, 0, 0.5]`, etc.\n * - RGB(A) Float32Array:\n *   `new Float32Array([1, 0, 0])`, `new Float32Array([1, 0, 0, 0.5])`, etc.\n * - RGB(A) Uint8Array:\n *   `new Uint8Array([255, 0, 0])`, `new Uint8Array([255, 0, 0, 128])`, etc.\n * - RGB(A) Uint8ClampedArray:\n *   `new Uint8ClampedArray([255, 0, 0])`, `new Uint8ClampedArray([255, 0, 0, 128])`, etc.\n * - HSL(A) objects:\n *   `{ h: 0, s: 100, l: 50 }`, `{ h: 0, s: 100, l: 50, a: 0.5 }`, etc.\n * - [HSL(A) strings](https://www.w3.org/TR/css-color-4/#the-hsl-notation):\n *   `'hsl(0, 100%, 50%)'`, `'hsl(0deg 100% 50%)'`, `'hsla(0, 100%, 50%, 0.5)'`, `'hsla(0deg 100% 50% / 50%)'`, etc.\n * - HSV(A) objects:\n *   `{ h: 0, s: 100, v: 100 }`, `{ h: 0, s: 100, v: 100, a: 0.5 }`, etc.\n * - {@link color.Color} objects.\n * @since 7.2.0\n * @memberof color\n */\nexport type ColorSource =\n    | string\n    | number\n    | number[]\n    | Float32Array\n    | Uint8Array\n    | Uint8ClampedArray\n    | HslColor\n    | HslaColor\n    | HsvColor\n    | HsvaColor\n    | RgbColor\n    | RgbaColor\n    | Color\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    | Number;\n\ntype ColorSourceTypedArray = Float32Array | Uint8Array | Uint8ClampedArray;\n\n/**\n * Color utility class. Can accept any {@link color.ColorSource} format in its constructor.\n * ```js\n * import { Color } from 'pixi.js';\n *\n * new Color('red').toArray(); // [1, 0, 0, 1]\n * new Color(0xff0000).toArray(); // [1, 0, 0, 1]\n * new Color('ff0000').toArray(); // [1, 0, 0, 1]\n * new Color('#f00').toArray(); // [1, 0, 0, 1]\n * new Color('0xff0000ff').toArray(); // [1, 0, 0, 1]\n * new Color('#f00f').toArray(); // [1, 0, 0, 1]\n * new Color({ r: 255, g: 0, b: 0, a: 0.5 }).toArray(); // [1, 0, 0, 0.5]\n * new Color('rgb(255, 0, 0, 0.5)').toArray(); // [1, 0, 0, 0.5]\n * new Color([1, 1, 1]).toArray(); // [1, 1, 1, 1]\n * new Color([1, 0, 0, 0.5]).toArray(); // [1, 0, 0, 0.5]\n * new Color(new Float32Array([1, 0, 0, 0.5])).toArray(); // [1, 0, 0, 0.5]\n * new Color(new Uint8Array([255, 0, 0, 255])).toArray(); // [1, 0, 0, 1]\n * new Color(new Uint8ClampedArray([255, 0, 0, 255])).toArray(); // [1, 0, 0, 1]\n * new Color({ h: 0, s: 100, l: 50, a: 0.5 }).toArray(); // [1, 0, 0, 0.5]\n * new Color('hsl(0, 100%, 50%, 50%)').toArray(); // [1, 0, 0, 0.5]\n * new Color({ h: 0, s: 100, v: 100, a: 0.5 }).toArray(); // [1, 0, 0, 0.5]\n * ```\n * @since 7.2.0\n * @memberof color\n */\nexport class Color\n{\n    /**\n     * Default Color object for static uses\n     * @example\n     * import { Color } from 'pixi.js';\n     * Color.shared.setValue(0xffffff).toHex(); // '#ffffff'\n     */\n    public static readonly shared = new Color();\n\n    /**\n     * Temporary Color object for static uses internally.\n     * As to not conflict with Color.shared.\n     * @ignore\n     */\n    private static readonly _temp = new Color();\n\n    /** Pattern for hex strings */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static readonly HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;\n\n    /** Internal color source, from constructor or set value */\n    private _value: Exclude<ColorSource, Color> | null;\n\n    /** Normalized rgba component, floats from 0-1 */\n    private _components: Float32Array;\n\n    /** Cache color as number */\n    private _int: number;\n\n    /** An array of the current Color. Only populated when `toArray` functions are called */\n    private _arrayRgba: number[] | null;\n    private _arrayRgb: number[] | null;\n\n    /**\n     * @param {ColorSource} value - Optional value to use, if not provided, white is used.\n     */\n    constructor(value: ColorSource = 0xffffff)\n    {\n        this._value = null;\n        this._components = new Float32Array(4);\n        this._components.fill(1);\n        this._int = 0xffffff;\n        this.value = value;\n    }\n\n    /** Get red component (0 - 1) */\n    get red(): number\n    {\n        return this._components[0];\n    }\n\n    /** Get green component (0 - 1) */\n    get green(): number\n    {\n        return this._components[1];\n    }\n\n    /** Get blue component (0 - 1) */\n    get blue(): number\n    {\n        return this._components[2];\n    }\n\n    /** Get alpha component (0 - 1) */\n    get alpha(): number\n    {\n        return this._components[3];\n    }\n\n    /**\n     * Set the value, suitable for chaining\n     * @param value\n     * @see Color.value\n     */\n    public setValue(value: ColorSource): this\n    {\n        this.value = value;\n\n        return this;\n    }\n\n    /**\n     * The current color source.\n     *\n     * When setting:\n     * - Setting to an instance of `Color` will copy its color source and components.\n     * - Otherwise, `Color` will try to normalize the color source and set the components.\n     *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.\n     *\n     * Note: The `null` in the setter's parameter type is added to match the TypeScript rule: return type of getter\n     * must be assignable to its setter's parameter type. Setting `value` to `null` will throw an `Error`.\n     *\n     * When getting:\n     * - A return value of `null` means the previous value was overridden (e.g., {@link Color.multiply multiply},\n     *   {@link Color.premultiply premultiply} or {@link Color.round round}).\n     * - Otherwise, the color source used when setting is returned.\n     */\n    set value(value: ColorSource | null)\n    {\n        // Support copying from other Color objects\n        if (value instanceof Color)\n        {\n            this._value = this._cloneSource(value._value);\n            this._int = value._int;\n            this._components.set(value._components);\n        }\n        else if (value === null)\n        {\n            throw new Error('Cannot set Color#value to null');\n        }\n        else if (this._value === null || !this._isSourceEqual(this._value, value))\n        {\n            this._normalize(value);\n            this._value = this._cloneSource(value);\n        }\n    }\n    get value(): Exclude<ColorSource, Color> | null\n    {\n        return this._value;\n    }\n\n    /**\n     * Copy a color source internally.\n     * @param value - Color source\n     */\n    private _cloneSource(value: Exclude<ColorSource, Color> | null): Exclude<ColorSource, Color> | null\n    {\n        if (typeof value === 'string' || typeof value === 'number' || value instanceof Number || value === null)\n        {\n            return value;\n        }\n        else if (Array.isArray(value) || ArrayBuffer.isView(value))\n        {\n            return value.slice(0);\n        }\n        else if (typeof value === 'object' && value !== null)\n        {\n            return { ...value };\n        }\n\n        return value;\n    }\n\n    /**\n     * Equality check for color sources.\n     * @param value1 - First color source\n     * @param value2 - Second color source\n     * @returns `true` if the color sources are equal, `false` otherwise.\n     */\n    private _isSourceEqual(value1: Exclude<ColorSource, Color>, value2: Exclude<ColorSource, Color>): boolean\n    {\n        const type1 = typeof value1;\n        const type2 = typeof value2;\n\n        // Mismatched types\n        if (type1 !== type2)\n        {\n            return false;\n        }\n        // Handle numbers/strings and things that extend Number\n        // important to do the instanceof Number first, as this is \"object\" type\n        else if (type1 === 'number' || type1 === 'string' || value1 instanceof Number)\n        {\n            return value1 === value2;\n        }\n        // Handle Arrays and TypedArrays\n        else if (\n            (Array.isArray(value1) && Array.isArray(value2))\n            || (ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2))\n        )\n        {\n            if (value1.length !== value2.length)\n            {\n                return false;\n            }\n\n            return value1.every((v, i) => v === value2[i]);\n        }\n        // Handle Objects\n        else if (value1 !== null && value2 !== null)\n        {\n            const keys1 = Object.keys(value1) as (keyof typeof value1)[];\n            const keys2 = Object.keys(value2) as (keyof typeof value2)[];\n\n            if (keys1.length !== keys2.length)\n            {\n                return false;\n            }\n\n            return keys1.every((key) => value1[key] === value2[key]);\n        }\n\n        return value1 === value2;\n    }\n\n    /**\n     * Convert to a RGBA color object.\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }\n     */\n    public toRgba(): RgbaColor\n    {\n        const [r, g, b, a] = this._components;\n\n        return { r, g, b, a };\n    }\n\n    /**\n     * Convert to a RGB color object.\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1 }\n     */\n    public toRgb(): RgbColor\n    {\n        const [r, g, b] = this._components;\n\n        return { r, g, b };\n    }\n\n    /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */\n    public toRgbaString(): string\n    {\n        const [r, g, b] = this.toUint8RgbArray();\n\n        return `rgba(${r},${g},${b},${this.alpha})`;\n    }\n\n    /**\n     * Convert to an [R, G, B] array of clamped uint8 values (0 to 255).\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toUint8RgbArray(); // returns [255, 255, 255]\n     * @param {number[]|Uint8Array|Uint8ClampedArray} [out] - Output array\n     */\n    public toUint8RgbArray(): number[];\n    public toUint8RgbArray<T extends number[] | Uint8Array | Uint8ClampedArray>(out: T): T;\n    public toUint8RgbArray<T extends number[] | Uint8Array | Uint8ClampedArray>(out?: T): T\n    {\n        const [r, g, b] = this._components;\n\n        if (!this._arrayRgb)\n        {\n            this._arrayRgb = [];\n        }\n\n        out = out || this._arrayRgb as T;\n\n        out[0] = Math.round(r * 255);\n        out[1] = Math.round(g * 255);\n        out[2] = Math.round(b * 255);\n\n        return out;\n    }\n\n    /**\n     * Convert to an [R, G, B, A] array of normalized floats (numbers from 0.0 to 1.0).\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toArray(); // returns [1, 1, 1, 1]\n     * @param {number[]|Float32Array} [out] - Output array\n     */\n    public toArray(): number[];\n    public toArray<T extends number[] | Float32Array>(out: T): T;\n    public toArray<T extends number[] | Float32Array>(out?: T): T\n    {\n        if (!this._arrayRgba)\n        {\n            this._arrayRgba = [];\n        }\n\n        out = out || this._arrayRgba as T;\n        const [r, g, b, a] = this._components;\n\n        out[0] = r;\n        out[1] = g;\n        out[2] = b;\n        out[3] = a;\n\n        return out;\n    }\n\n    /**\n     * Convert to an [R, G, B] array of normalized floats (numbers from 0.0 to 1.0).\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toRgbArray(); // returns [1, 1, 1]\n     * @param {number[]|Float32Array} [out] - Output array\n     */\n    public toRgbArray(): number[];\n    public toRgbArray<T extends number[] | Float32Array>(out: T): T;\n    public toRgbArray<T extends number[] | Float32Array>(out?: T): T\n    {\n        if (!this._arrayRgb)\n        {\n            this._arrayRgb = [];\n        }\n\n        out = out || this._arrayRgb as T;\n        const [r, g, b] = this._components;\n\n        out[0] = r;\n        out[1] = g;\n        out[2] = b;\n\n        return out;\n    }\n\n    /**\n     * Convert to a hexadecimal number.\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toNumber(); // returns 16777215\n     */\n    public toNumber(): number\n    {\n        return this._int;\n    }\n\n    /**\n     * Convert to a BGR number\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff\n     */\n    public toBgrNumber(): number\n    {\n        const [r, g, b] = this.toUint8RgbArray();\n\n        return (b << 16) + (g << 8) + r;\n    }\n\n    /**\n     * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff\n     * @returns {number} - The color as a number in little endian format.\n     */\n    public toLittleEndianNumber(): number\n    {\n        const value = this._int;\n\n        return (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);\n    }\n\n    /**\n     * Multiply with another color. This action is destructive, and will\n     * override the previous `value` property to be `null`.\n     * @param {ColorSource} value - The color to multiply by.\n     */\n    public multiply(value: ColorSource): this\n    {\n        const [r, g, b, a] = Color._temp.setValue(value)._components;\n\n        this._components[0] *= r;\n        this._components[1] *= g;\n        this._components[2] *= b;\n        this._components[3] *= a;\n\n        this._refreshInt();\n        this._value = null;\n\n        return this;\n    }\n\n    /**\n     * Converts color to a premultiplied alpha format. This action is destructive, and will\n     * override the previous `value` property to be `null`.\n     * @param alpha - The alpha to multiply by.\n     * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n     * @returns {Color} - Itself.\n     */\n    public premultiply(alpha: number, applyToRGB = true): this\n    {\n        if (applyToRGB)\n        {\n            this._components[0] *= alpha;\n            this._components[1] *= alpha;\n            this._components[2] *= alpha;\n        }\n        this._components[3] = alpha;\n\n        this._refreshInt();\n        this._value = null;\n\n        return this;\n    }\n\n    /**\n     * Premultiplies alpha with current color.\n     * @param {number} alpha - The alpha to multiply by.\n     * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n     * @returns {number} tint multiplied by alpha\n     */\n    public toPremultiplied(alpha: number, applyToRGB = true): number\n    {\n        if (alpha === 1.0)\n        {\n            return (0xff << 24) + this._int;\n        }\n        if (alpha === 0.0)\n        {\n            return applyToRGB ? 0 : this._int;\n        }\n        let r = (this._int >> 16) & 0xff;\n        let g = (this._int >> 8) & 0xff;\n        let b = this._int & 0xff;\n\n        if (applyToRGB)\n        {\n            r = ((r * alpha) + 0.5) | 0;\n            g = ((g * alpha) + 0.5) | 0;\n            b = ((b * alpha) + 0.5) | 0;\n        }\n\n        return ((alpha * 255) << 24) + (r << 16) + (g << 8) + b;\n    }\n\n    /**\n     * Convert to a hexidecimal string.\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toHex(); // returns \"#ffffff\"\n     */\n    public toHex(): string\n    {\n        const hexString = this._int.toString(16);\n\n        return `#${'000000'.substring(0, 6 - hexString.length) + hexString}`;\n    }\n\n    /**\n     * Convert to a hexidecimal string with alpha.\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toHexa(); // returns \"#ffffffff\"\n     */\n    public toHexa(): string\n    {\n        const alphaValue = Math.round(this._components[3] * 255);\n        const alphaString = alphaValue.toString(16);\n\n        return this.toHex() + '00'.substring(0, 2 - alphaString.length) + alphaString;\n    }\n\n    /**\n     * Set alpha, suitable for chaining.\n     * @param alpha\n     */\n    public setAlpha(alpha: number): this\n    {\n        this._components[3] = this._clamp(alpha);\n\n        return this;\n    }\n\n    /**\n     * Normalize the input value into rgba\n     * @param value - Input value\n     */\n    private _normalize(value: Exclude<ColorSource, Color>): void\n    {\n        let r: number | undefined;\n        let g: number | undefined;\n        let b: number | undefined;\n        let a: number | undefined;\n\n        // Number is a primative so typeof works fine, but in the case\n        // that someone creates a class that extends Number, we also\n        // need to check for instanceof Number\n        if (\n            (typeof value === 'number' || value instanceof Number)\n            && (value as number) >= 0\n            && (value as number) <= 0xffffff\n        )\n        {\n            const int = value as number; // cast required because instanceof Number is ambiguous for TS\n\n            r = ((int >> 16) & 0xff) / 255;\n            g = ((int >> 8) & 0xff) / 255;\n            b = (int & 0xff) / 255;\n            a = 1.0;\n        }\n        else if (\n            (Array.isArray(value) || value instanceof Float32Array)\n            // Can be rgb or rgba\n            && value.length >= 3\n            && value.length <= 4\n        )\n        {\n            // make sure all values are 0 - 1\n            value = this._clamp(value);\n            [r, g, b, a = 1.0] = value;\n        }\n        else if (\n            (value instanceof Uint8Array || value instanceof Uint8ClampedArray)\n            // Can be rgb or rgba\n            && value.length >= 3\n            && value.length <= 4\n        )\n        {\n            // make sure all values are 0 - 255\n            value = this._clamp(value, 0, 255);\n            [r, g, b, a = 255] = value;\n            r /= 255;\n            g /= 255;\n            b /= 255;\n            a /= 255;\n        }\n        else if (typeof value === 'string' || typeof value === 'object')\n        {\n            if (typeof value === 'string')\n            {\n                const match = Color.HEX_PATTERN.exec(value);\n\n                if (match)\n                {\n                    // Normalize hex string, remove 0x or # prefix\n                    value = `#${match[2]}`;\n                }\n            }\n\n            const color = colord(value as AnyColor);\n\n            if (color.isValid())\n            {\n                ({ r, g, b, a } = color.rgba);\n                r /= 255;\n                g /= 255;\n                b /= 255;\n            }\n        }\n\n        // Cache normalized values for rgba and hex integer\n        if (r !== undefined)\n        {\n            this._components[0] = r as number;\n            this._components[1] = g as number;\n            this._components[2] = b as number;\n            this._components[3] = a as number;\n            this._refreshInt();\n        }\n        else\n        {\n            throw new Error(`Unable to convert color ${value}`);\n        }\n    }\n\n    /** Refresh the internal color rgb number */\n    private _refreshInt(): void\n    {\n        // Clamp values to 0 - 1\n        this._clamp(this._components);\n\n        const [r, g, b] = this._components;\n\n        this._int = ((r * 255) << 16) + ((g * 255) << 8) + ((b * 255) | 0);\n    }\n\n    /**\n     * Clamps values to a range. Will override original values\n     * @param value - Value(s) to clamp\n     * @param min - Minimum value\n     * @param max - Maximum value\n     */\n    private _clamp<T extends number | number[] | ColorSourceTypedArray>(value: T, min = 0, max = 1): T\n    {\n        if (typeof value === 'number')\n        {\n            return Math.min(Math.max(value, min), max) as T;\n        }\n\n        value.forEach((v, i) =>\n        {\n            value[i] = Math.min(Math.max(v, min), max);\n        });\n\n        return value;\n    }\n\n    /**\n     * Check if the value is a color-like object\n     * @param value - Value to check\n     * @returns True if the value is a color-like object\n     * @static\n     * @example\n     * import { Color } from 'pixi.js';\n     * Color.isColorLike('white'); // returns true\n     * Color.isColorLike(0xffffff); // returns true\n     * Color.isColorLike([1, 1, 1]); // returns true\n     */\n    public static isColorLike(value: ColorSource): value is ColorSource\n    {\n        return (\n            typeof value === 'number'\n            || typeof value === 'string'\n            || value instanceof Number\n            || value instanceof Color\n            || Array.isArray(value)\n            || value instanceof Uint8Array\n            || value instanceof Uint8ClampedArray\n            || value instanceof Float32Array\n            || ((value as RgbColor).r !== undefined\n                && (value as RgbColor).g !== undefined\n                && (value as RgbColor).b !== undefined)\n            || ((value as RgbaColor).r !== undefined\n                && (value as RgbaColor).g !== undefined\n                && (value as RgbaColor).b !== undefined\n                && (value as RgbaColor).a !== undefined)\n            || ((value as HslColor).h !== undefined\n                && (value as HslColor).s !== undefined\n                && (value as HslColor).l !== undefined)\n            || ((value as HslaColor).h !== undefined\n                && (value as HslaColor).s !== undefined\n                && (value as HslaColor).l !== undefined\n                && (value as HslaColor).a !== undefined)\n            || ((value as HsvColor).h !== undefined\n                && (value as HsvColor).s !== undefined\n                && (value as HsvColor).v !== undefined)\n            || ((value as HsvaColor).h !== undefined\n                && (value as HsvaColor).s !== undefined\n                && (value as HsvaColor).v !== undefined\n                && (value as HsvaColor).a !== undefined)\n        );\n    }\n}\n","var r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(r){return\"string\"==typeof r?r.length>0:\"number\"==typeof r},n=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u=function(r){return(r=isFinite(r)?r%360:0)>0?r:r+360},a=function(r){return{r:e(r.r,0,255),g:e(r.g,0,255),b:e(r.b,0,255),a:e(r.a)}},o=function(r){return{r:n(r.r),g:n(r.g),b:n(r.b),a:n(r.a,3)}},i=/^#([0-9a-f]{3,8})$/i,s=function(r){var t=r.toString(16);return t.length<2?\"0\"+t:t},h=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,a=Math.max(t,n,e),o=a-Math.min(t,n,e),i=o?a===t?(n-e)/o:a===n?2+(e-t)/o:4+(t-n)/o:0;return{h:60*(i<0?i+6:i),s:a?o/a*100:0,v:a/255*100,a:u}},b=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var a=Math.floor(t),o=e*(1-n),i=e*(1-(t-a)*n),s=e*(1-(1-t+a)*n),h=a%6;return{r:255*[e,i,o,o,s,e][h],g:255*[s,e,e,i,o,o][h],b:255*[o,o,s,e,e,i][h],a:u}},g=function(r){return{h:u(r.h),s:e(r.s,0,100),l:e(r.l,0,100),a:e(r.a)}},d=function(r){return{h:n(r.h),s:n(r.s),l:n(r.l),a:n(r.a,3)}},f=function(r){return b((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));var t,n,e},c=function(r){return{h:(t=h(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};var t,n,e,u},l=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,p=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s+([+-]?\\d*\\.?\\d+)%\\s+([+-]?\\d*\\.?\\d+)%\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,v=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,m=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,y={string:[[function(r){var t=i.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n(parseInt(r.substr(6,2),16)/255,2):1}:null:null},\"hex\"],[function(r){var t=v.exec(r)||m.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:a({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},\"rgb\"],[function(t){var n=l.exec(t)||p.exec(t);if(!n)return null;var e,u,a=g({h:(e=n[1],u=n[2],void 0===u&&(u=\"deg\"),Number(e)*(r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f(a)},\"hsl\"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,o=r.a,i=void 0===o?1:o;return t(n)&&t(e)&&t(u)?a({r:Number(n),g:Number(e),b:Number(u),a:Number(i)}):null},\"rgb\"],[function(r){var n=r.h,e=r.s,u=r.l,a=r.a,o=void 0===a?1:a;if(!t(n)||!t(e)||!t(u))return null;var i=g({h:Number(n),s:Number(e),l:Number(u),a:Number(o)});return f(i)},\"hsl\"],[function(r){var n=r.h,a=r.s,o=r.v,i=r.a,s=void 0===i?1:i;if(!t(n)||!t(a)||!t(o))return null;var h=function(r){return{h:u(r.h),s:e(r.s,0,100),v:e(r.v,0,100),a:e(r.a)}}({h:Number(n),s:Number(a),v:Number(o),a:Number(s)});return b(h)},\"hsv\"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return[e,t[n][1]]}return[null,void 0]},x=function(r){return\"string\"==typeof r?N(r.trim(),y.string):\"object\"==typeof r&&null!==r?N(r,y.object):[null,void 0]},I=function(r){return x(r)[1]},M=function(r,t){var n=c(r);return{h:n.h,s:e(n.s+100*t,0,100),l:n.l,a:n.a}},H=function(r){return(299*r.r+587*r.g+114*r.b)/1e3/255},$=function(r,t){var n=c(r);return{h:n.h,s:n.s,l:e(n.l+100*t,0,100),a:n.a}},j=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n(H(this.rgba),2)},r.prototype.isDark=function(){return H(this.rgba)<.5},r.prototype.isLight=function(){return H(this.rgba)>=.5},r.prototype.toHex=function(){return r=o(this.rgba),t=r.r,e=r.g,u=r.b,i=(a=r.a)<1?s(n(255*a)):\"\",\"#\"+s(t)+s(e)+s(u)+i;var r,t,e,u,a,i},r.prototype.toRgb=function(){return o(this.rgba)},r.prototype.toRgbString=function(){return r=o(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?\"rgba(\"+t+\", \"+n+\", \"+e+\", \"+u+\")\":\"rgb(\"+t+\", \"+n+\", \"+e+\")\";var r,t,n,e,u},r.prototype.toHsl=function(){return d(c(this.rgba))},r.prototype.toHslString=function(){return r=d(c(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?\"hsla(\"+t+\", \"+n+\"%, \"+e+\"%, \"+u+\")\":\"hsl(\"+t+\", \"+n+\"%, \"+e+\"%)\";var r,t,n,e,u},r.prototype.toHsv=function(){return r=h(this.rgba),{h:n(r.h),s:n(r.s),v:n(r.v),a:n(r.a,3)};var r},r.prototype.invert=function(){return w({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});var r},r.prototype.saturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,-r))},r.prototype.grayscale=function(){return w(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),w($(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),w($(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return\"number\"==typeof r?w({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n(this.rgba.a,3);var t},r.prototype.hue=function(r){var t=c(this.rgba);return\"number\"==typeof r?w({h:r,s:t.s,l:t.l,a:t.a}):n(t.h)},r.prototype.isEqual=function(r){return this.toHex()===w(r).toHex()},r}(),w=function(r){return r instanceof j?r:new j(r)},S=[],k=function(r){r.forEach(function(r){S.indexOf(r)<0&&(r(j,y),S.push(r))})},E=function(){return new j({r:255*Math.random(),g:255*Math.random(),b:255*Math.random()})};export{j as Colord,w as colord,k as extend,I as getFormat,E as random};\n","export default function(e,f){var a={white:\"#ffffff\",bisque:\"#ffe4c4\",blue:\"#0000ff\",cadetblue:\"#5f9ea0\",chartreuse:\"#7fff00\",chocolate:\"#d2691e\",coral:\"#ff7f50\",antiquewhite:\"#faebd7\",aqua:\"#00ffff\",azure:\"#f0ffff\",whitesmoke:\"#f5f5f5\",papayawhip:\"#ffefd5\",plum:\"#dda0dd\",blanchedalmond:\"#ffebcd\",black:\"#000000\",gold:\"#ffd700\",goldenrod:\"#daa520\",gainsboro:\"#dcdcdc\",cornsilk:\"#fff8dc\",cornflowerblue:\"#6495ed\",burlywood:\"#deb887\",aquamarine:\"#7fffd4\",beige:\"#f5f5dc\",crimson:\"#dc143c\",cyan:\"#00ffff\",darkblue:\"#00008b\",darkcyan:\"#008b8b\",darkgoldenrod:\"#b8860b\",darkkhaki:\"#bdb76b\",darkgray:\"#a9a9a9\",darkgreen:\"#006400\",darkgrey:\"#a9a9a9\",peachpuff:\"#ffdab9\",darkmagenta:\"#8b008b\",darkred:\"#8b0000\",darkorchid:\"#9932cc\",darkorange:\"#ff8c00\",darkslateblue:\"#483d8b\",gray:\"#808080\",darkslategray:\"#2f4f4f\",darkslategrey:\"#2f4f4f\",deeppink:\"#ff1493\",deepskyblue:\"#00bfff\",wheat:\"#f5deb3\",firebrick:\"#b22222\",floralwhite:\"#fffaf0\",ghostwhite:\"#f8f8ff\",darkviolet:\"#9400d3\",magenta:\"#ff00ff\",green:\"#008000\",dodgerblue:\"#1e90ff\",grey:\"#808080\",honeydew:\"#f0fff0\",hotpink:\"#ff69b4\",blueviolet:\"#8a2be2\",forestgreen:\"#228b22\",lawngreen:\"#7cfc00\",indianred:\"#cd5c5c\",indigo:\"#4b0082\",fuchsia:\"#ff00ff\",brown:\"#a52a2a\",maroon:\"#800000\",mediumblue:\"#0000cd\",lightcoral:\"#f08080\",darkturquoise:\"#00ced1\",lightcyan:\"#e0ffff\",ivory:\"#fffff0\",lightyellow:\"#ffffe0\",lightsalmon:\"#ffa07a\",lightseagreen:\"#20b2aa\",linen:\"#faf0e6\",mediumaquamarine:\"#66cdaa\",lemonchiffon:\"#fffacd\",lime:\"#00ff00\",khaki:\"#f0e68c\",mediumseagreen:\"#3cb371\",limegreen:\"#32cd32\",mediumspringgreen:\"#00fa9a\",lightskyblue:\"#87cefa\",lightblue:\"#add8e6\",midnightblue:\"#191970\",lightpink:\"#ffb6c1\",mistyrose:\"#ffe4e1\",moccasin:\"#ffe4b5\",mintcream:\"#f5fffa\",lightslategray:\"#778899\",lightslategrey:\"#778899\",navajowhite:\"#ffdead\",navy:\"#000080\",mediumvioletred:\"#c71585\",powderblue:\"#b0e0e6\",palegoldenrod:\"#eee8aa\",oldlace:\"#fdf5e6\",paleturquoise:\"#afeeee\",mediumturquoise:\"#48d1cc\",mediumorchid:\"#ba55d3\",rebeccapurple:\"#663399\",lightsteelblue:\"#b0c4de\",mediumslateblue:\"#7b68ee\",thistle:\"#d8bfd8\",tan:\"#d2b48c\",orchid:\"#da70d6\",mediumpurple:\"#9370db\",purple:\"#800080\",pink:\"#ffc0cb\",skyblue:\"#87ceeb\",springgreen:\"#00ff7f\",palegreen:\"#98fb98\",red:\"#ff0000\",yellow:\"#ffff00\",slateblue:\"#6a5acd\",lavenderblush:\"#fff0f5\",peru:\"#cd853f\",palevioletred:\"#db7093\",violet:\"#ee82ee\",teal:\"#008080\",slategray:\"#708090\",slategrey:\"#708090\",aliceblue:\"#f0f8ff\",darkseagreen:\"#8fbc8f\",darkolivegreen:\"#556b2f\",greenyellow:\"#adff2f\",seagreen:\"#2e8b57\",seashell:\"#fff5ee\",tomato:\"#ff6347\",silver:\"#c0c0c0\",sienna:\"#a0522d\",lavender:\"#e6e6fa\",lightgreen:\"#90ee90\",orange:\"#ffa500\",orangered:\"#ff4500\",steelblue:\"#4682b4\",royalblue:\"#4169e1\",turquoise:\"#40e0d0\",yellowgreen:\"#9acd32\",salmon:\"#fa8072\",saddlebrown:\"#8b4513\",sandybrown:\"#f4a460\",rosybrown:\"#bc8f8f\",darksalmon:\"#e9967a\",lightgoldenrodyellow:\"#fafad2\",snow:\"#fffafa\",lightgrey:\"#d3d3d3\",lightgray:\"#d3d3d3\",dimgray:\"#696969\",dimgrey:\"#696969\",olivedrab:\"#6b8e23\",olive:\"#808000\"},r={};for(var d in a)r[a[d]]=d;var l={};e.prototype.toName=function(f){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return\"transparent\";var d,i,n=r[this.toHex()];if(n)return n;if(null==f?void 0:f.closest){var o=this.toRgb(),t=1/0,b=\"black\";if(!l.length)for(var c in a)l[c]=new e(a[c]).toRgb();for(var g in a){var u=(d=o,i=l[g],Math.pow(d.r-i.r,2)+Math.pow(d.g-i.g,2)+Math.pow(d.b-i.b,2));u<t&&(t=u,b=g)}return b}};f.string.push([function(f){var r=f.toLowerCase(),d=\"transparent\"===r?\"#0000\":a[r];return d?new e(d).toRgb():null},\"name\"])}\n","\"use strict\";\nconst cullingMixin = {\n  cullArea: null,\n  cullable: false,\n  cullableChildren: true\n};\n\nexport { cullingMixin };\n//# sourceMappingURL=cullingMixin.mjs.map\n","import type { Rectangle } from '../maths/shapes/Rectangle';\n\nexport interface CullingMixinConstructor\n{\n    /**\n     * If set, this shape is used for culling instead of the bounds of this object.\n     * It can improve the culling performance of objects with many children.\n     * The culling area is defined in local space.\n     * @memberof scene.Container#\n     */\n    cullArea: Rectangle,\n    /**\n     * Should this object be rendered if the bounds of this object are out of frame?\n     *\n     * Culling has no effect on whether updateTransform is called.\n     * @default false\n     * @memberof scene.Container#\n     */\n    cullable: boolean,\n    /**\n     * Determines if the children to the container can be culled\n     * Setting this to false allows PixiJS to bypass a recursive culling function\n     * Which can help to optimize very complex scenes\n     * @default true\n     * @memberof scene.Container#\n     */\n    cullableChildren: boolean,\n}\n\nexport const cullingMixin: CullingMixinConstructor = {\n    cullArea: null,\n    cullable: false,\n    cullableChildren: true,\n};\n","import { PI_2 } from '../misc/const.mjs';\nimport { Point } from '../point/Point.mjs';\n\n\"use strict\";\nclass Matrix {\n  /**\n   * @param a - x scale\n   * @param b - y skew\n   * @param c - x skew\n   * @param d - y scale\n   * @param tx - x translation\n   * @param ty - y translation\n   */\n  constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\n    /** An array of the current matrix. Only populated when `toArray` is called */\n    this.array = null;\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.tx = tx;\n    this.ty = ty;\n  }\n  /**\n   * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:\n   *\n   * a = array[0]\n   * b = array[1]\n   * c = array[3]\n   * d = array[4]\n   * tx = array[2]\n   * ty = array[5]\n   * @param array - The array that the matrix will be populated from.\n   */\n  fromArray(array) {\n    this.a = array[0];\n    this.b = array[1];\n    this.c = array[3];\n    this.d = array[4];\n    this.tx = array[2];\n    this.ty = array[5];\n  }\n  /**\n   * Sets the matrix properties.\n   * @param a - Matrix component\n   * @param b - Matrix component\n   * @param c - Matrix component\n   * @param d - Matrix component\n   * @param tx - Matrix component\n   * @param ty - Matrix component\n   * @returns This matrix. Good for chaining method calls.\n   */\n  set(a, b, c, d, tx, ty) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.tx = tx;\n    this.ty = ty;\n    return this;\n  }\n  /**\n   * Creates an array from the current Matrix object.\n   * @param transpose - Whether we need to transpose the matrix or not\n   * @param [out=new Float32Array(9)] - If provided the array will be assigned to out\n   * @returns The newly created array which contains the matrix\n   */\n  toArray(transpose, out) {\n    if (!this.array) {\n      this.array = new Float32Array(9);\n    }\n    const array = out || this.array;\n    if (transpose) {\n      array[0] = this.a;\n      array[1] = this.b;\n      array[2] = 0;\n      array[3] = this.c;\n      array[4] = this.d;\n      array[5] = 0;\n      array[6] = this.tx;\n      array[7] = this.ty;\n      array[8] = 1;\n    } else {\n      array[0] = this.a;\n      array[1] = this.c;\n      array[2] = this.tx;\n      array[3] = this.b;\n      array[4] = this.d;\n      array[5] = this.ty;\n      array[6] = 0;\n      array[7] = 0;\n      array[8] = 1;\n    }\n    return array;\n  }\n  /**\n   * Get a new position with the current transformation applied.\n   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\n   * @param pos - The origin\n   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n   * @returns {Point} The new point, transformed through this matrix\n   */\n  apply(pos, newPos) {\n    newPos = newPos || new Point();\n    const x = pos.x;\n    const y = pos.y;\n    newPos.x = this.a * x + this.c * y + this.tx;\n    newPos.y = this.b * x + this.d * y + this.ty;\n    return newPos;\n  }\n  /**\n   * Get a new position with the inverse of the current transformation applied.\n   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\n   * @param pos - The origin\n   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n   * @returns {Point} The new point, inverse-transformed through this matrix\n   */\n  applyInverse(pos, newPos) {\n    newPos = newPos || new Point();\n    const a = this.a;\n    const b = this.b;\n    const c = this.c;\n    const d = this.d;\n    const tx = this.tx;\n    const ty = this.ty;\n    const id = 1 / (a * d + c * -b);\n    const x = pos.x;\n    const y = pos.y;\n    newPos.x = d * id * x + -c * id * y + (ty * c - tx * d) * id;\n    newPos.y = a * id * y + -b * id * x + (-ty * a + tx * b) * id;\n    return newPos;\n  }\n  /**\n   * Translates the matrix on the x and y.\n   * @param x - How much to translate x by\n   * @param y - How much to translate y by\n   * @returns This matrix. Good for chaining method calls.\n   */\n  translate(x, y) {\n    this.tx += x;\n    this.ty += y;\n    return this;\n  }\n  /**\n   * Applies a scale transformation to the matrix.\n   * @param x - The amount to scale horizontally\n   * @param y - The amount to scale vertically\n   * @returns This matrix. Good for chaining method calls.\n   */\n  scale(x, y) {\n    this.a *= x;\n    this.d *= y;\n    this.c *= x;\n    this.b *= y;\n    this.tx *= x;\n    this.ty *= y;\n    return this;\n  }\n  /**\n   * Applies a rotation transformation to the matrix.\n   * @param angle - The angle in radians.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  rotate(angle) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const a1 = this.a;\n    const c1 = this.c;\n    const tx1 = this.tx;\n    this.a = a1 * cos - this.b * sin;\n    this.b = a1 * sin + this.b * cos;\n    this.c = c1 * cos - this.d * sin;\n    this.d = c1 * sin + this.d * cos;\n    this.tx = tx1 * cos - this.ty * sin;\n    this.ty = tx1 * sin + this.ty * cos;\n    return this;\n  }\n  /**\n   * Appends the given Matrix to this Matrix.\n   * @param matrix - The matrix to append.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  append(matrix) {\n    const a1 = this.a;\n    const b1 = this.b;\n    const c1 = this.c;\n    const d1 = this.d;\n    this.a = matrix.a * a1 + matrix.b * c1;\n    this.b = matrix.a * b1 + matrix.b * d1;\n    this.c = matrix.c * a1 + matrix.d * c1;\n    this.d = matrix.c * b1 + matrix.d * d1;\n    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;\n    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;\n    return this;\n  }\n  /**\n   * Appends two matrix's and sets the result to this matrix. AB = A * B\n   * @param a - The matrix to append.\n   * @param b - The matrix to append.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  appendFrom(a, b) {\n    const a1 = a.a;\n    const b1 = a.b;\n    const c1 = a.c;\n    const d1 = a.d;\n    const tx = a.tx;\n    const ty = a.ty;\n    const a2 = b.a;\n    const b2 = b.b;\n    const c2 = b.c;\n    const d2 = b.d;\n    this.a = a1 * a2 + b1 * c2;\n    this.b = a1 * b2 + b1 * d2;\n    this.c = c1 * a2 + d1 * c2;\n    this.d = c1 * b2 + d1 * d2;\n    this.tx = tx * a2 + ty * c2 + b.tx;\n    this.ty = tx * b2 + ty * d2 + b.ty;\n    return this;\n  }\n  /**\n   * Sets the matrix based on all the available properties\n   * @param x - Position on the x axis\n   * @param y - Position on the y axis\n   * @param pivotX - Pivot on the x axis\n   * @param pivotY - Pivot on the y axis\n   * @param scaleX - Scale on the x axis\n   * @param scaleY - Scale on the y axis\n   * @param rotation - Rotation in radians\n   * @param skewX - Skew on the x axis\n   * @param skewY - Skew on the y axis\n   * @returns This matrix. Good for chaining method calls.\n   */\n  setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {\n    this.a = Math.cos(rotation + skewY) * scaleX;\n    this.b = Math.sin(rotation + skewY) * scaleX;\n    this.c = -Math.sin(rotation - skewX) * scaleY;\n    this.d = Math.cos(rotation - skewX) * scaleY;\n    this.tx = x - (pivotX * this.a + pivotY * this.c);\n    this.ty = y - (pivotX * this.b + pivotY * this.d);\n    return this;\n  }\n  /**\n   * Prepends the given Matrix to this Matrix.\n   * @param matrix - The matrix to prepend\n   * @returns This matrix. Good for chaining method calls.\n   */\n  prepend(matrix) {\n    const tx1 = this.tx;\n    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {\n      const a1 = this.a;\n      const c1 = this.c;\n      this.a = a1 * matrix.a + this.b * matrix.c;\n      this.b = a1 * matrix.b + this.b * matrix.d;\n      this.c = c1 * matrix.a + this.d * matrix.c;\n      this.d = c1 * matrix.b + this.d * matrix.d;\n    }\n    this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;\n    this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;\n    return this;\n  }\n  /**\n   * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.\n   * @param transform - The transform to apply the properties to.\n   * @returns The transform with the newly applied properties\n   */\n  decompose(transform) {\n    const a = this.a;\n    const b = this.b;\n    const c = this.c;\n    const d = this.d;\n    const pivot = transform.pivot;\n    const skewX = -Math.atan2(-c, d);\n    const skewY = Math.atan2(b, a);\n    const delta = Math.abs(skewX + skewY);\n    if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {\n      transform.rotation = skewY;\n      transform.skew.x = transform.skew.y = 0;\n    } else {\n      transform.rotation = 0;\n      transform.skew.x = skewX;\n      transform.skew.y = skewY;\n    }\n    transform.scale.x = Math.sqrt(a * a + b * b);\n    transform.scale.y = Math.sqrt(c * c + d * d);\n    transform.position.x = this.tx + (pivot.x * a + pivot.y * c);\n    transform.position.y = this.ty + (pivot.x * b + pivot.y * d);\n    return transform;\n  }\n  /**\n   * Inverts this matrix\n   * @returns This matrix. Good for chaining method calls.\n   */\n  invert() {\n    const a1 = this.a;\n    const b1 = this.b;\n    const c1 = this.c;\n    const d1 = this.d;\n    const tx1 = this.tx;\n    const n = a1 * d1 - b1 * c1;\n    this.a = d1 / n;\n    this.b = -b1 / n;\n    this.c = -c1 / n;\n    this.d = a1 / n;\n    this.tx = (c1 * this.ty - d1 * tx1) / n;\n    this.ty = -(a1 * this.ty - b1 * tx1) / n;\n    return this;\n  }\n  /** Checks if this matrix is an identity matrix */\n  isIdentity() {\n    return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;\n  }\n  /**\n   * Resets this Matrix to an identity (default) matrix.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  identity() {\n    this.a = 1;\n    this.b = 0;\n    this.c = 0;\n    this.d = 1;\n    this.tx = 0;\n    this.ty = 0;\n    return this;\n  }\n  /**\n   * Creates a new Matrix object with the same values as this one.\n   * @returns A copy of this matrix. Good for chaining method calls.\n   */\n  clone() {\n    const matrix = new Matrix();\n    matrix.a = this.a;\n    matrix.b = this.b;\n    matrix.c = this.c;\n    matrix.d = this.d;\n    matrix.tx = this.tx;\n    matrix.ty = this.ty;\n    return matrix;\n  }\n  /**\n   * Changes the values of the given matrix to be the same as the ones in this matrix\n   * @param matrix - The matrix to copy to.\n   * @returns The matrix given in parameter with its values updated.\n   */\n  copyTo(matrix) {\n    matrix.a = this.a;\n    matrix.b = this.b;\n    matrix.c = this.c;\n    matrix.d = this.d;\n    matrix.tx = this.tx;\n    matrix.ty = this.ty;\n    return matrix;\n  }\n  /**\n   * Changes the values of the matrix to be the same as the ones in given matrix\n   * @param matrix - The matrix to copy from.\n   * @returns this\n   */\n  copyFrom(matrix) {\n    this.a = matrix.a;\n    this.b = matrix.b;\n    this.c = matrix.c;\n    this.d = matrix.d;\n    this.tx = matrix.tx;\n    this.ty = matrix.ty;\n    return this;\n  }\n  /**\n   * check to see if two matrices are the same\n   * @param matrix - The matrix to compare to.\n   */\n  equals(matrix) {\n    return matrix.a === this.a && matrix.b === this.b && matrix.c === this.c && matrix.d === this.d && matrix.tx === this.tx && matrix.ty === this.ty;\n  }\n  toString() {\n    return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;\n  }\n  /**\n   * A default (identity) matrix.\n   *\n   * This is a shared object, if you want to modify it consider creating a new `Matrix`\n   * @readonly\n   */\n  static get IDENTITY() {\n    return identityMatrix.identity();\n  }\n  /**\n   * A static Matrix that can be used to avoid creating new objects.\n   * Will always ensure the matrix is reset to identity when requested.\n   * Use this object for fast but temporary calculations, as it may be mutated later on.\n   * This is a different object to the `IDENTITY` object and so can be modified without changing `IDENTITY`.\n   * @readonly\n   */\n  static get shared() {\n    return tempMatrix.identity();\n  }\n}\nconst tempMatrix = new Matrix();\nconst identityMatrix = new Matrix();\n\nexport { Matrix };\n//# sourceMappingURL=Matrix.mjs.map\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { PI_2 } from '../misc/const';\nimport { Point } from '../point/Point';\n\nimport type { PointData } from '../point/PointData';\n\ninterface TransformableObject\n{\n    position: PointData;\n    scale: PointData;\n    pivot: PointData;\n    skew: PointData;\n    rotation: number;\n}\n\n/**\n * A fast matrix for 2D transformations.\n * ```js\n * | a | c | tx|\n * | b | d | ty|\n * | 0 | 0 | 1 |\n * ```\n * @memberof maths\n */\nexport class Matrix\n{\n    /** @default 1 */\n    public a: number;\n\n    /** @default 0 */\n    public b: number;\n\n    /** @default 0 */\n    public c: number;\n\n    /** @default 1 */\n    public d: number;\n\n    /** @default 0 */\n    public tx: number;\n\n    /** @default 0 */\n    public ty: number;\n\n    /** An array of the current matrix. Only populated when `toArray` is called */\n    public array: Float32Array | null = null;\n\n    /**\n     * @param a - x scale\n     * @param b - y skew\n     * @param c - x skew\n     * @param d - y scale\n     * @param tx - x translation\n     * @param ty - y translation\n     */\n    constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0)\n    {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n    }\n\n    /**\n     * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:\n     *\n     * a = array[0]\n     * b = array[1]\n     * c = array[3]\n     * d = array[4]\n     * tx = array[2]\n     * ty = array[5]\n     * @param array - The array that the matrix will be populated from.\n     */\n    public fromArray(array: number[]): void\n    {\n        this.a = array[0];\n        this.b = array[1];\n        this.c = array[3];\n        this.d = array[4];\n        this.tx = array[2];\n        this.ty = array[5];\n    }\n\n    /**\n     * Sets the matrix properties.\n     * @param a - Matrix component\n     * @param b - Matrix component\n     * @param c - Matrix component\n     * @param d - Matrix component\n     * @param tx - Matrix component\n     * @param ty - Matrix component\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public set(a: number, b: number, c: number, d: number, tx: number, ty: number): this\n    {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n\n        return this;\n    }\n\n    /**\n     * Creates an array from the current Matrix object.\n     * @param transpose - Whether we need to transpose the matrix or not\n     * @param [out=new Float32Array(9)] - If provided the array will be assigned to out\n     * @returns The newly created array which contains the matrix\n     */\n    public toArray(transpose?: boolean, out?: Float32Array): Float32Array\n    {\n        if (!this.array)\n        {\n            this.array = new Float32Array(9);\n        }\n\n        const array = out || this.array;\n\n        if (transpose)\n        {\n            array[0] = this.a;\n            array[1] = this.b;\n            array[2] = 0;\n            array[3] = this.c;\n            array[4] = this.d;\n            array[5] = 0;\n            array[6] = this.tx;\n            array[7] = this.ty;\n            array[8] = 1;\n        }\n        else\n        {\n            array[0] = this.a;\n            array[1] = this.c;\n            array[2] = this.tx;\n            array[3] = this.b;\n            array[4] = this.d;\n            array[5] = this.ty;\n            array[6] = 0;\n            array[7] = 0;\n            array[8] = 1;\n        }\n\n        return array;\n    }\n\n    /**\n     * Get a new position with the current transformation applied.\n     * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\n     * @param pos - The origin\n     * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n     * @returns {Point} The new point, transformed through this matrix\n     */\n    public apply<P extends PointData = Point>(pos: PointData, newPos?: P): P\n    {\n        newPos = (newPos || new Point()) as P;\n\n        const x = pos.x;\n        const y = pos.y;\n\n        newPos.x = (this.a * x) + (this.c * y) + this.tx;\n        newPos.y = (this.b * x) + (this.d * y) + this.ty;\n\n        return newPos;\n    }\n\n    /**\n     * Get a new position with the inverse of the current transformation applied.\n     * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\n     * @param pos - The origin\n     * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n     * @returns {Point} The new point, inverse-transformed through this matrix\n     */\n    public applyInverse<P extends PointData = Point>(pos: PointData, newPos?: P): P\n    {\n        newPos = (newPos || new Point()) as P;\n\n        const a = this.a;\n        const b = this.b;\n        const c = this.c;\n        const d = this.d;\n        const tx = this.tx;\n        const ty = this.ty;\n\n        const id = 1 / ((a * d) + (c * -b));\n\n        const x = pos.x;\n        const y = pos.y;\n\n        newPos.x = (d * id * x) + (-c * id * y) + (((ty * c) - (tx * d)) * id);\n        newPos.y = (a * id * y) + (-b * id * x) + (((-ty * a) + (tx * b)) * id);\n\n        return newPos;\n    }\n\n    /**\n     * Translates the matrix on the x and y.\n     * @param x - How much to translate x by\n     * @param y - How much to translate y by\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public translate(x: number, y: number): this\n    {\n        this.tx += x;\n        this.ty += y;\n\n        return this;\n    }\n\n    /**\n     * Applies a scale transformation to the matrix.\n     * @param x - The amount to scale horizontally\n     * @param y - The amount to scale vertically\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public scale(x: number, y: number): this\n    {\n        this.a *= x;\n        this.d *= y;\n        this.c *= x;\n        this.b *= y;\n        this.tx *= x;\n        this.ty *= y;\n\n        return this;\n    }\n\n    /**\n     * Applies a rotation transformation to the matrix.\n     * @param angle - The angle in radians.\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public rotate(angle: number): this\n    {\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n\n        const a1 = this.a;\n        const c1 = this.c;\n        const tx1 = this.tx;\n\n        this.a = (a1 * cos) - (this.b * sin);\n        this.b = (a1 * sin) + (this.b * cos);\n        this.c = (c1 * cos) - (this.d * sin);\n        this.d = (c1 * sin) + (this.d * cos);\n        this.tx = (tx1 * cos) - (this.ty * sin);\n        this.ty = (tx1 * sin) + (this.ty * cos);\n\n        return this;\n    }\n\n    /**\n     * Appends the given Matrix to this Matrix.\n     * @param matrix - The matrix to append.\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public append(matrix: Matrix): this\n    {\n        const a1 = this.a;\n        const b1 = this.b;\n        const c1 = this.c;\n        const d1 = this.d;\n\n        this.a = (matrix.a * a1) + (matrix.b * c1);\n        this.b = (matrix.a * b1) + (matrix.b * d1);\n        this.c = (matrix.c * a1) + (matrix.d * c1);\n        this.d = (matrix.c * b1) + (matrix.d * d1);\n\n        this.tx = (matrix.tx * a1) + (matrix.ty * c1) + this.tx;\n        this.ty = (matrix.tx * b1) + (matrix.ty * d1) + this.ty;\n\n        return this;\n    }\n\n    /**\n     * Appends two matrix's and sets the result to this matrix. AB = A * B\n     * @param a - The matrix to append.\n     * @param b - The matrix to append.\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public appendFrom(a: Matrix, b: Matrix): this\n    {\n        const a1 = a.a;\n        const b1 = a.b;\n        const c1 = a.c;\n        const d1 = a.d;\n        const tx = a.tx;\n        const ty = a.ty;\n\n        const a2 = b.a;\n        const b2 = b.b;\n        const c2 = b.c;\n        const d2 = b.d;\n\n        this.a = (a1 * a2) + (b1 * c2);\n        this.b = (a1 * b2) + (b1 * d2);\n        this.c = (c1 * a2) + (d1 * c2);\n        this.d = (c1 * b2) + (d1 * d2);\n        this.tx = (tx * a2) + (ty * c2) + b.tx;\n        this.ty = (tx * b2) + (ty * d2) + b.ty;\n\n        return this;\n    }\n\n    /**\n     * Sets the matrix based on all the available properties\n     * @param x - Position on the x axis\n     * @param y - Position on the y axis\n     * @param pivotX - Pivot on the x axis\n     * @param pivotY - Pivot on the y axis\n     * @param scaleX - Scale on the x axis\n     * @param scaleY - Scale on the y axis\n     * @param rotation - Rotation in radians\n     * @param skewX - Skew on the x axis\n     * @param skewY - Skew on the y axis\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public setTransform(x: number, y: number, pivotX: number, pivotY: number, scaleX: number,\n        scaleY: number, rotation: number, skewX: number, skewY: number): this\n    {\n        this.a = Math.cos(rotation + skewY) * scaleX;\n        this.b = Math.sin(rotation + skewY) * scaleX;\n        this.c = -Math.sin(rotation - skewX) * scaleY;\n        this.d = Math.cos(rotation - skewX) * scaleY;\n\n        this.tx = x - ((pivotX * this.a) + (pivotY * this.c));\n        this.ty = y - ((pivotX * this.b) + (pivotY * this.d));\n\n        return this;\n    }\n\n    /**\n     * Prepends the given Matrix to this Matrix.\n     * @param matrix - The matrix to prepend\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public prepend(matrix: Matrix): this\n    {\n        const tx1 = this.tx;\n\n        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1)\n        {\n            const a1 = this.a;\n            const c1 = this.c;\n\n            this.a = (a1 * matrix.a) + (this.b * matrix.c);\n            this.b = (a1 * matrix.b) + (this.b * matrix.d);\n            this.c = (c1 * matrix.a) + (this.d * matrix.c);\n            this.d = (c1 * matrix.b) + (this.d * matrix.d);\n        }\n\n        this.tx = (tx1 * matrix.a) + (this.ty * matrix.c) + matrix.tx;\n        this.ty = (tx1 * matrix.b) + (this.ty * matrix.d) + matrix.ty;\n\n        return this;\n    }\n\n    /**\n     * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.\n     * @param transform - The transform to apply the properties to.\n     * @returns The transform with the newly applied properties\n     */\n    public decompose(transform: TransformableObject): TransformableObject\n    {\n        // sort out rotation / skew..\n        const a = this.a;\n        const b = this.b;\n        const c = this.c;\n        const d = this.d;\n        const pivot = transform.pivot;\n\n        const skewX = -Math.atan2(-c, d);\n        const skewY = Math.atan2(b, a);\n\n        const delta = Math.abs(skewX + skewY);\n\n        if (delta < 0.00001 || Math.abs(PI_2 - delta) < 0.00001)\n        {\n            transform.rotation = skewY;\n            transform.skew.x = transform.skew.y = 0;\n        }\n        else\n        {\n            transform.rotation = 0;\n            transform.skew.x = skewX;\n            transform.skew.y = skewY;\n        }\n\n        // next set scale\n        transform.scale.x = Math.sqrt((a * a) + (b * b));\n        transform.scale.y = Math.sqrt((c * c) + (d * d));\n\n        // next set position\n        transform.position.x = this.tx + ((pivot.x * a) + (pivot.y * c));\n        transform.position.y = this.ty + ((pivot.x * b) + (pivot.y * d));\n\n        return transform;\n    }\n\n    /**\n     * Inverts this matrix\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public invert(): this\n    {\n        const a1 = this.a;\n        const b1 = this.b;\n        const c1 = this.c;\n        const d1 = this.d;\n        const tx1 = this.tx;\n        const n = (a1 * d1) - (b1 * c1);\n\n        this.a = d1 / n;\n        this.b = -b1 / n;\n        this.c = -c1 / n;\n        this.d = a1 / n;\n        this.tx = ((c1 * this.ty) - (d1 * tx1)) / n;\n        this.ty = -((a1 * this.ty) - (b1 * tx1)) / n;\n\n        return this;\n    }\n\n    /** Checks if this matrix is an identity matrix */\n    public isIdentity(): boolean\n    {\n        return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;\n    }\n\n    /**\n     * Resets this Matrix to an identity (default) matrix.\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public identity(): this\n    {\n        this.a = 1;\n        this.b = 0;\n        this.c = 0;\n        this.d = 1;\n        this.tx = 0;\n        this.ty = 0;\n\n        return this;\n    }\n\n    /**\n     * Creates a new Matrix object with the same values as this one.\n     * @returns A copy of this matrix. Good for chaining method calls.\n     */\n    public clone(): Matrix\n    {\n        const matrix = new Matrix();\n\n        matrix.a = this.a;\n        matrix.b = this.b;\n        matrix.c = this.c;\n        matrix.d = this.d;\n        matrix.tx = this.tx;\n        matrix.ty = this.ty;\n\n        return matrix;\n    }\n\n    /**\n     * Changes the values of the given matrix to be the same as the ones in this matrix\n     * @param matrix - The matrix to copy to.\n     * @returns The matrix given in parameter with its values updated.\n     */\n    public copyTo(matrix: Matrix): Matrix\n    {\n        matrix.a = this.a;\n        matrix.b = this.b;\n        matrix.c = this.c;\n        matrix.d = this.d;\n        matrix.tx = this.tx;\n        matrix.ty = this.ty;\n\n        return matrix;\n    }\n\n    /**\n     * Changes the values of the matrix to be the same as the ones in given matrix\n     * @param matrix - The matrix to copy from.\n     * @returns this\n     */\n    public copyFrom(matrix: Matrix): this\n    {\n        this.a = matrix.a;\n        this.b = matrix.b;\n        this.c = matrix.c;\n        this.d = matrix.d;\n        this.tx = matrix.tx;\n        this.ty = matrix.ty;\n\n        return this;\n    }\n\n    /**\n     * check to see if two matrices are the same\n     * @param matrix - The matrix to compare to.\n     */\n    public equals(matrix: Matrix)\n    {\n        return matrix.a === this.a && matrix.b === this.b\n            && matrix.c === this.c && matrix.d === this.d\n            && matrix.tx === this.tx && matrix.ty === this.ty;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;\n    }\n    // #endif\n\n    /**\n     * A default (identity) matrix.\n     *\n     * This is a shared object, if you want to modify it consider creating a new `Matrix`\n     * @readonly\n     */\n    static get IDENTITY(): Readonly<Matrix>\n    {\n        return identityMatrix.identity();\n    }\n\n    /**\n     * A static Matrix that can be used to avoid creating new objects.\n     * Will always ensure the matrix is reset to identity when requested.\n     * Use this object for fast but temporary calculations, as it may be mutated later on.\n     * This is a different object to the `IDENTITY` object and so can be modified without changing `IDENTITY`.\n     * @readonly\n     */\n    static get shared(): Matrix\n    {\n        return tempMatrix.identity();\n    }\n}\n\nconst tempMatrix = new Matrix();\nconst identityMatrix = new Matrix();\n","\"use strict\";\nconst PI_2 = Math.PI * 2;\nconst RAD_TO_DEG = 180 / Math.PI;\nconst DEG_TO_RAD = Math.PI / 180;\n\nexport { DEG_TO_RAD, PI_2, RAD_TO_DEG };\n//# sourceMappingURL=const.mjs.map\n","/**\n * Two Pi.\n * @static\n * @member {number}\n * @memberof maths\n */\nexport const PI_2 = Math.PI * 2;\n\n/**\n * Conversion factor for converting radians to degrees.\n * @static\n * @member {number} RAD_TO_DEG\n * @memberof maths\n */\nexport const RAD_TO_DEG = 180 / Math.PI;\n\n/**\n * Conversion factor for converting degrees to radians.\n * @static\n * @member {number}\n * @memberof maths\n */\nexport const DEG_TO_RAD = Math.PI / 180;\n\n/**\n * Constants that identify shapes, mainly to prevent `instanceof` calls.\n * @memberof maths\n */\nexport type SHAPE_PRIMITIVE =\n    | 'polygon'\n    | 'rectangle'\n    | 'circle'\n    | 'ellipse'\n    | 'triangle'\n    | 'roundedRectangle';\n\n/**\n * The `maths` folder contains utility classes and functions for mathematical operations used throughout the project.\n * This includes constants such as conversion factors for radians and degrees, as well as shapes such as polygons,\n * rectangles, circles, ellipses, triangles, and rounded rectangles.\n * ```js\n * import { RAD_TO_DEG, Circle } from 'pixi.js';\n *\n * // Convert 180 degrees to radians\n * const radians = 180 * RAD_TO_DEG;\n *\n * // test if a point is inside a circle\n * const isPointInCircle = new Circle(0, 0, 10).contains(0, 0); // true\n * ```\n * @namespace maths\n */\n","\"use strict\";\nclass Point {\n  /**\n   * Creates a new `Point`\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=0] - position of the point on the y axis\n   */\n  constructor(x = 0, y = 0) {\n    /** Position of the point on the x axis */\n    this.x = 0;\n    /** Position of the point on the y axis */\n    this.y = 0;\n    this.x = x;\n    this.y = y;\n  }\n  /**\n   * Creates a clone of this point\n   * @returns A clone of this point\n   */\n  clone() {\n    return new Point(this.x, this.y);\n  }\n  /**\n   * Copies `x` and `y` from the given point into this point\n   * @param p - The point to copy from\n   * @returns The point instance itself\n   */\n  copyFrom(p) {\n    this.set(p.x, p.y);\n    return this;\n  }\n  /**\n   * Copies this point's x and y into the given point (`p`).\n   * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n   * @returns The point (`p`) with values updated\n   */\n  copyTo(p) {\n    p.set(this.x, this.y);\n    return p;\n  }\n  /**\n   * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n   * @param p - The point to check\n   * @returns Returns `true` if both `x` and `y` are equal\n   */\n  equals(p) {\n    return p.x === this.x && p.y === this.y;\n  }\n  /**\n   * Sets the point to a new `x` and `y` position.\n   * If `y` is omitted, both `x` and `y` will be set to `x`.\n   * @param {number} [x=0] - position of the point on the `x` axis\n   * @param {number} [y=x] - position of the point on the `y` axis\n   * @returns The point instance itself\n   */\n  set(x = 0, y = x) {\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  toString() {\n    return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;\n  }\n  /**\n   * A static Point object with `x` and `y` values of `0`. Can be used to avoid creating new objects multiple times.\n   * @readonly\n   */\n  static get shared() {\n    tempPoint.x = 0;\n    tempPoint.y = 0;\n    return tempPoint;\n  }\n}\nconst tempPoint = new Point();\n\nexport { Point };\n//# sourceMappingURL=Point.mjs.map\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport type { PointData } from './PointData';\nimport type { PointLike } from './PointLike';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface Point extends PixiMixins.Point { }\n\n/**\n * The Point object represents a location in a two-dimensional coordinate system, where `x` represents\n * the position on the horizontal axis and `y` represents the position on the vertical axis.\n * <br/>\n * Many Pixi functions accept the `PointData` type as an alternative to `Point`,\n * which only requires `x` and `y` properties.\n * @class\n * @implements {PointLike}\n * @memberof maths\n */\nexport class Point implements PointLike\n{\n    /** Position of the point on the x axis */\n    public x = 0;\n    /** Position of the point on the y axis */\n    public y = 0;\n\n    /**\n     * Creates a new `Point`\n     * @param {number} [x=0] - position of the point on the x axis\n     * @param {number} [y=0] - position of the point on the y axis\n     */\n    constructor(x = 0, y = 0)\n    {\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * Creates a clone of this point\n     * @returns A clone of this point\n     */\n    public clone(): Point\n    {\n        return new Point(this.x, this.y);\n    }\n\n    /**\n     * Copies `x` and `y` from the given point into this point\n     * @param p - The point to copy from\n     * @returns The point instance itself\n     */\n    public copyFrom(p: PointData): this\n    {\n        this.set(p.x, p.y);\n\n        return this;\n    }\n\n    /**\n     * Copies this point's x and y into the given point (`p`).\n     * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n     * @returns The point (`p`) with values updated\n     */\n    public copyTo<T extends PointLike>(p: T): T\n    {\n        p.set(this.x, this.y);\n\n        return p;\n    }\n\n    /**\n     * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n     * @param p - The point to check\n     * @returns Returns `true` if both `x` and `y` are equal\n     */\n    public equals(p: PointData): boolean\n    {\n        return (p.x === this.x) && (p.y === this.y);\n    }\n\n    /**\n     * Sets the point to a new `x` and `y` position.\n     * If `y` is omitted, both `x` and `y` will be set to `x`.\n     * @param {number} [x=0] - position of the point on the `x` axis\n     * @param {number} [y=x] - position of the point on the `y` axis\n     * @returns The point instance itself\n     */\n    public set(x = 0, y: number = x): this\n    {\n        this.x = x;\n        this.y = y;\n\n        return this;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;\n    }\n    // #endif\n\n    /**\n     * A static Point object with `x` and `y` values of `0`. Can be used to avoid creating new objects multiple times.\n     * @readonly\n     */\n    static get shared(): Point\n    {\n        tempPoint.x = 0;\n        tempPoint.y = 0;\n\n        return tempPoint;\n    }\n}\n\nconst tempPoint = new Point();\n","\"use strict\";\nclass ObservablePoint {\n  /**\n   * Creates a new `ObservablePoint`\n   * @param observer - Observer to pass to listen for change events.\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=0] - position of the point on the y axis\n   */\n  constructor(observer, x, y) {\n    this._x = x || 0;\n    this._y = y || 0;\n    this._observer = observer;\n  }\n  /**\n   * Creates a clone of this point.\n   * @param observer - Optional observer to pass to the new observable point.\n   * @returns a copy of this observable point\n   */\n  clone(observer) {\n    return new ObservablePoint(observer ?? this._observer, this._x, this._y);\n  }\n  /**\n   * Sets the point to a new `x` and `y` position.\n   * If `y` is omitted, both `x` and `y` will be set to `x`.\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=x] - position of the point on the y axis\n   * @returns The observable point instance itself\n   */\n  set(x = 0, y = x) {\n    if (this._x !== x || this._y !== y) {\n      this._x = x;\n      this._y = y;\n      this._observer._onUpdate(this);\n    }\n    return this;\n  }\n  /**\n   * Copies x and y from the given point (`p`)\n   * @param p - The point to copy from. Can be any of type that is or extends `PointData`\n   * @returns The observable point instance itself\n   */\n  copyFrom(p) {\n    if (this._x !== p.x || this._y !== p.y) {\n      this._x = p.x;\n      this._y = p.y;\n      this._observer._onUpdate(this);\n    }\n    return this;\n  }\n  /**\n   * Copies this point's x and y into that of the given point (`p`)\n   * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n   * @returns The point (`p`) with values updated\n   */\n  copyTo(p) {\n    p.set(this._x, this._y);\n    return p;\n  }\n  /**\n   * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n   * @param p - The point to check\n   * @returns Returns `true` if both `x` and `y` are equal\n   */\n  equals(p) {\n    return p.x === this._x && p.y === this._y;\n  }\n  toString() {\n    return `[pixi.js/math:ObservablePoint x=${0} y=${0} scope=${this._observer}]`;\n  }\n  /** Position of the observable point on the x axis. */\n  get x() {\n    return this._x;\n  }\n  set x(value) {\n    if (this._x !== value) {\n      this._x = value;\n      this._observer._onUpdate(this);\n    }\n  }\n  /** Position of the observable point on the y axis. */\n  get y() {\n    return this._y;\n  }\n  set y(value) {\n    if (this._y !== value) {\n      this._y = value;\n      this._observer._onUpdate(this);\n    }\n  }\n}\n\nexport { ObservablePoint };\n//# sourceMappingURL=ObservablePoint.mjs.map\n","import type { PointData } from './PointData';\nimport type { PointLike } from './PointLike';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface ObservablePoint extends PixiMixins.ObservablePoint { }\n\n/**\n * Observer used to listen for observable point changes.\n * @memberof maths\n */\nexport interface Observer<T>\n{\n    /** Callback to call when the point has updated. */\n    _onUpdate: (point?: T) => void;\n}\n\n/**\n * The ObservablePoint object represents a location in a two-dimensional coordinate system, where `x` represents\n * the position on the horizontal axis and `y` represents the position on the vertical axis.\n *\n * An `ObservablePoint` is a point that triggers the `onUpdate` method on an observer when the point's position is changed.\n * @memberof maths\n */\nexport class ObservablePoint implements PointLike\n{\n    /** @ignore */\n    public _x: number;\n    /** @ignore */\n    public _y: number;\n\n    /** This object used to call the `onUpdate` callback when the point changes. */\n    private readonly _observer: Observer<ObservablePoint>;\n\n    /**\n     * Creates a new `ObservablePoint`\n     * @param observer - Observer to pass to listen for change events.\n     * @param {number} [x=0] - position of the point on the x axis\n     * @param {number} [y=0] - position of the point on the y axis\n     */\n    constructor(observer: Observer<ObservablePoint>, x?: number, y?: number)\n    {\n        this._x = x || 0;\n        this._y = y || 0;\n\n        this._observer = observer;\n    }\n\n    /**\n     * Creates a clone of this point.\n     * @param observer - Optional observer to pass to the new observable point.\n     * @returns a copy of this observable point\n     */\n    public clone(observer?: Observer<ObservablePoint>): ObservablePoint\n    {\n        return new ObservablePoint(observer ?? this._observer, this._x, this._y);\n    }\n\n    /**\n     * Sets the point to a new `x` and `y` position.\n     * If `y` is omitted, both `x` and `y` will be set to `x`.\n     * @param {number} [x=0] - position of the point on the x axis\n     * @param {number} [y=x] - position of the point on the y axis\n     * @returns The observable point instance itself\n     */\n    public set(x = 0, y = x): this\n    {\n        if (this._x !== x || this._y !== y)\n        {\n            this._x = x;\n            this._y = y;\n            this._observer._onUpdate(this);\n        }\n\n        return this;\n    }\n\n    /**\n     * Copies x and y from the given point (`p`)\n     * @param p - The point to copy from. Can be any of type that is or extends `PointData`\n     * @returns The observable point instance itself\n     */\n    public copyFrom(p: PointData): this\n    {\n        if (this._x !== p.x || this._y !== p.y)\n        {\n            this._x = p.x;\n            this._y = p.y;\n            this._observer._onUpdate(this);\n        }\n\n        return this;\n    }\n\n    /**\n     * Copies this point's x and y into that of the given point (`p`)\n     * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n     * @returns The point (`p`) with values updated\n     */\n    public copyTo<T extends PointLike>(p: T): T\n    {\n        p.set(this._x, this._y);\n\n        return p;\n    }\n\n    /**\n     * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n     * @param p - The point to check\n     * @returns Returns `true` if both `x` and `y` are equal\n     */\n    public equals(p: PointData): boolean\n    {\n        return (p.x === this._x) && (p.y === this._y);\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:ObservablePoint x=${0} y=${0} scope=${this._observer}]`;\n    }\n    // #endif\n\n    /** Position of the observable point on the x axis. */\n    get x(): number\n    {\n        return this._x;\n    }\n\n    set x(value: number)\n    {\n        if (this._x !== value)\n        {\n            this._x = value;\n            this._observer._onUpdate(this);\n        }\n    }\n\n    /** Position of the observable point on the y axis. */\n    get y(): number\n    {\n        return this._y;\n    }\n\n    set y(value: number)\n    {\n        if (this._y !== value)\n        {\n            this._y = value;\n            this._observer._onUpdate(this);\n        }\n    }\n}\n","\"use strict\";\nconst uidCache = {\n  default: -1\n};\nfunction uid(name = \"default\") {\n  if (uidCache[name] === void 0) {\n    uidCache[name] = -1;\n  }\n  return ++uidCache[name];\n}\nfunction resetUids() {\n  for (const key in uidCache) {\n    delete uidCache[key];\n  }\n}\n\nexport { resetUids, uid };\n//# sourceMappingURL=uid.mjs.map\n","const uidCache: Record<string, number> = {\n    default: -1,\n};\n\ntype UIDNames =\n    | 'default'\n    | 'resource'\n    | 'texture'\n    | 'textureSource'\n    | 'textureResource'\n    | 'batcher' //\n    | 'graphicsContext' //\n    | 'graphicsView' //\n    | 'graphicsPath' //\n    | 'fillGradient' //\n    | 'fillPattern' //\n    | 'meshView' //\n    | 'renderable' //\n    | 'buffer' //\n    | 'bufferResource' //\n    | 'geometry'\n    | 'instructionSet' //\n    | 'renderTarget' //\n    | 'uniform' //\n    | 'spriteView' //\n    | 'textView' //\n    | 'tilingSpriteView'; // ;\n\n/**\n * Gets the next unique identifier\n * @param name - The name of the identifier.\n * @function uid\n * @returns {number} The next unique identifier to use.\n * @memberof utils\n */\nexport function uid(name: UIDNames = 'default'): number\n{\n    if (uidCache[name] === undefined)\n    {\n        uidCache[name] = -1;\n    }\n\n    return ++uidCache[name];\n}\n\n/** Resets the next unique identifier to 0. This is used for some tests, dont touch or things WILL explode :) */\nexport function resetUids(): void\n{\n    for (const key in uidCache)\n    {\n        delete uidCache[key];\n    }\n}\n","\"use strict\";\nconst warnings = {};\nconst v8_0_0 = \"8.0.0\";\nfunction deprecation(version, message, ignoreDepth = 3) {\n  if (warnings[message]) {\n    return;\n  }\n  let stack = new Error().stack;\n  if (typeof stack === \"undefined\") {\n    console.warn(\"PixiJS Deprecation Warning: \", `${message}\nDeprecated since v${version}`);\n  } else {\n    stack = stack.split(\"\\n\").splice(ignoreDepth).join(\"\\n\");\n    if (console.groupCollapsed) {\n      console.groupCollapsed(\n        \"%cPixiJS Deprecation Warning: %c%s\",\n        \"color:#614108;background:#fffbe6\",\n        \"font-weight:normal;color:#614108;background:#fffbe6\",\n        `${message}\nDeprecated since v${version}`\n      );\n      console.warn(stack);\n      console.groupEnd();\n    } else {\n      console.warn(\"PixiJS Deprecation Warning: \", `${message}\nDeprecated since v${version}`);\n      console.warn(stack);\n    }\n  }\n  warnings[message] = true;\n}\n\nexport { deprecation, v8_0_0 };\n//# sourceMappingURL=deprecation.mjs.map\n","import type { Dict } from '../types';\n\n// A map of warning messages already fired\nconst warnings: Dict<boolean> = {};\n\n/**\n * deprecation name for version 8.0.0\n * @ignore\n */\nexport const v8_0_0 = '8.0.0';\n\n/**\n * Helper for warning developers about deprecated features & settings.\n * A stack track for warnings is given; useful for tracking-down where\n * deprecated methods/properties/classes are being used within the code.\n * @memberof utils\n * @ignore\n * @function deprecation\n * @param {string} version - The version where the feature became deprecated\n * @param {string} message - Message should include what is deprecated, where, and the new solution\n * @param {number} [ignoreDepth=3] - The number of steps to ignore at the top of the error stack\n *        this is mostly to ignore internal deprecation calls.\n */\nexport function deprecation(version: string, message: string, ignoreDepth = 3): void\n{\n    // Ignore duplicat\n    if (warnings[message])\n    {\n        return;\n    }\n\n    /* eslint-disable no-console */\n    let stack = new Error().stack;\n\n    // Handle IE < 10 and Safari < 6\n    if (typeof stack === 'undefined')\n    {\n        console.warn('PixiJS Deprecation Warning: ', `${message}\\nDeprecated since v${version}`);\n    }\n    else\n    {\n        // chop off the stack trace which includes PixiJS internal calls\n        stack = stack.split('\\n').splice(ignoreDepth).join('\\n');\n\n        if (console.groupCollapsed)\n        {\n            console.groupCollapsed(\n                '%cPixiJS Deprecation Warning: %c%s',\n                'color:#614108;background:#fffbe6',\n                'font-weight:normal;color:#614108;background:#fffbe6',\n                `${message}\\nDeprecated since v${version}`\n            );\n            console.warn(stack);\n            console.groupEnd();\n        }\n        else\n        {\n            console.warn('PixiJS Deprecation Warning: ', `${message}\\nDeprecated since v${version}`);\n            console.warn(stack);\n        }\n    }\n    /* eslint-enable no-console */\n\n    warnings[message] = true;\n}\n","import { removeItems } from '../../../utils/data/removeItems.mjs';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nconst childrenHelperMixin = {\n  allowChildren: true,\n  /**\n   * Removes all children from this container that are within the begin and end indexes.\n   * @param beginIndex - The beginning position.\n   * @param endIndex - The ending position. Default value is size of the container.\n   * @returns - List of removed children\n   * @memberof scene.Container#\n   */\n  removeChildren(beginIndex = 0, endIndex) {\n    const end = endIndex ?? this.children.length;\n    const range = end - beginIndex;\n    const removed = [];\n    if (range > 0 && range <= end) {\n      for (let i = end - 1; i >= beginIndex; i--) {\n        const child = this.children[i];\n        if (!child)\n          continue;\n        if (this.renderGroup) {\n          this.renderGroup.removeChild(child);\n        }\n        removed.push(child);\n        child.parent = null;\n      }\n      removeItems(this.children, beginIndex, end);\n      for (let i = 0; i < removed.length; ++i) {\n        this.emit(\"childRemoved\", removed[i], this, i);\n        removed[i].emit(\"removed\", this);\n      }\n      return removed;\n    } else if (range === 0 && this.children.length === 0) {\n      return removed;\n    }\n    throw new RangeError(\"removeChildren: numeric values are outside the acceptable range.\");\n  },\n  /**\n   * Removes a child from the specified index position.\n   * @param index - The index to get the child from\n   * @returns The child that was removed.\n   * @memberof scene.Container#\n   */\n  removeChildAt(index) {\n    const child = this.getChildAt(index);\n    return this.removeChild(child);\n  },\n  /**\n   * Returns the child at the specified index\n   * @param index - The index to get the child at\n   * @returns - The child at the given index, if any.\n   * @memberof scene.Container#\n   */\n  getChildAt(index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(`getChildAt: Index (${index}) does not exist.`);\n    }\n    return this.children[index];\n  },\n  /**\n   * Changes the position of an existing child in the container container\n   * @param child - The child Container instance for which you want to change the index number\n   * @param index - The resulting index number for the child container\n   * @memberof scene.Container#\n   */\n  setChildIndex(child, index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n    }\n    this.getChildIndex(child);\n    this.addChildAt(child, index);\n  },\n  /**\n   * Returns the index position of a child Container instance\n   * @param child - The Container instance to identify\n   * @returns - The index position of the child container to identify\n   * @memberof scene.Container#\n   */\n  getChildIndex(child) {\n    const index = this.children.indexOf(child);\n    if (index === -1) {\n      throw new Error(\"The supplied Container must be a child of the caller\");\n    }\n    return index;\n  },\n  /**\n   * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.\n   * If the child is already in this container, it will be moved to the specified index.\n   * @param {Container} child - The child to add.\n   * @param {number} index - The absolute index where the child will be positioned at the end of the operation.\n   * @returns {Container} The child that was added.\n   * @memberof scene.Container#\n   */\n  addChildAt(child, index) {\n    if (!this.allowChildren) {\n      deprecation(v8_0_0, \"addChildAt: Only Containers will be allowed to add children in v8.0.0\");\n    }\n    const { children } = this;\n    if (index < 0 || index > children.length) {\n      throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);\n    }\n    if (child.parent) {\n      const currentIndex = child.parent.children.indexOf(child);\n      if (child.parent === this && currentIndex === index) {\n        return child;\n      }\n      if (currentIndex !== -1) {\n        child.parent.children.splice(currentIndex, 1);\n      }\n    }\n    if (index === children.length) {\n      children.push(child);\n    } else {\n      children.splice(index, 0, child);\n    }\n    child.parent = this;\n    child.didChange = true;\n    child.didViewUpdate = false;\n    child._updateFlags = 15;\n    if (this.renderGroup) {\n      this.renderGroup.addChild(child);\n    }\n    if (this.sortableChildren)\n      this.sortDirty = true;\n    this.emit(\"childAdded\", child, this, index);\n    child.emit(\"added\", this);\n    return child;\n  },\n  /**\n   * Swaps the position of 2 Containers within this container.\n   * @param child - First container to swap\n   * @param child2 - Second container to swap\n   */\n  swapChildren(child, child2) {\n    if (child === child2) {\n      return;\n    }\n    const index1 = this.getChildIndex(child);\n    const index2 = this.getChildIndex(child2);\n    this.children[index1] = child2;\n    this.children[index2] = child;\n  },\n  /**\n   * Remove the Container from its parent Container. If the Container has no parent, do nothing.\n   * @memberof scene.Container#\n   */\n  removeFromParent() {\n    this.parent?.removeChild(this);\n  }\n};\n\nexport { childrenHelperMixin };\n//# sourceMappingURL=childrenHelperMixin.mjs.map\n","import { removeItems } from '../../../utils/data/removeItems';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Container } from '../Container';\n\nexport interface ChildrenHelperMixin\n{\n    allowChildren: boolean;\n    addChild<U extends Container[]>(...children: U): U[0];\n    removeChild<U extends Container[]>(...children: U): U[0];\n    removeChildren(beginIndex?: number, endIndex?: number): Container[];\n    removeChildAt<U extends Container>(index: number): U;\n    getChildAt<U extends Container>(index: number): U;\n    setChildIndex(child: Container, index: number): void;\n    getChildIndex(child: Container): number;\n    addChildAt<U extends Container>(child: U, index: number): U;\n    swapChildren<U extends Container>(child: U, child2: U): void;\n    removeFromParent(): void;\n}\n\nexport const childrenHelperMixin: Partial<Container> = {\n\n    allowChildren: true,\n\n    /**\n     * Removes all children from this container that are within the begin and end indexes.\n     * @param beginIndex - The beginning position.\n     * @param endIndex - The ending position. Default value is size of the container.\n     * @returns - List of removed children\n     * @memberof scene.Container#\n     */\n    removeChildren(beginIndex = 0, endIndex?: number): Container[]\n    {\n        const end = endIndex ?? this.children.length;\n        const range = end - beginIndex;\n        const removed: Container[] = [];\n\n        if (range > 0 && range <= end)\n        {\n            for (let i = end - 1; i >= beginIndex; i--)\n            {\n                const child = this.children[i];\n\n                if (!child) continue;\n\n                if (this.renderGroup)\n                {\n                    this.renderGroup.removeChild(child);\n                }\n\n                removed.push(child);\n                child.parent = null;\n            }\n\n            removeItems(this.children, beginIndex, end);\n\n            for (let i = 0; i < removed.length; ++i)\n            {\n                this.emit('childRemoved', removed[i], this, i);\n                removed[i].emit('removed', this);\n            }\n\n            return removed;\n        }\n        else if (range === 0 && this.children.length === 0)\n        {\n            return removed;\n        }\n\n        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');\n    },\n\n    /**\n     * Removes a child from the specified index position.\n     * @param index - The index to get the child from\n     * @returns The child that was removed.\n     * @memberof scene.Container#\n     */\n    removeChildAt<U extends Container>(index: number): U\n    {\n        const child = this.getChildAt(index);\n\n        return this.removeChild(child) as U;\n    },\n\n    /**\n     * Returns the child at the specified index\n     * @param index - The index to get the child at\n     * @returns - The child at the given index, if any.\n     * @memberof scene.Container#\n     */\n    getChildAt<U extends Container>(index: number): U\n    {\n        if (index < 0 || index >= this.children.length)\n        {\n            throw new Error(`getChildAt: Index (${index}) does not exist.`);\n        }\n\n        return this.children[index] as U;\n    },\n\n    /**\n     * Changes the position of an existing child in the container container\n     * @param child - The child Container instance for which you want to change the index number\n     * @param index - The resulting index number for the child container\n     * @memberof scene.Container#\n     */\n    setChildIndex(child: Container, index: number): void\n    {\n        if (index < 0 || index >= this.children.length)\n        {\n            throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n        }\n\n        this.getChildIndex(child); // check if child exists\n        this.addChildAt(child, index);\n    },\n\n    /**\n     * Returns the index position of a child Container instance\n     * @param child - The Container instance to identify\n     * @returns - The index position of the child container to identify\n     * @memberof scene.Container#\n     */\n    getChildIndex(child: Container): number\n    {\n        const index = this.children.indexOf(child);\n\n        if (index === -1)\n        {\n            throw new Error('The supplied Container must be a child of the caller');\n        }\n\n        return index;\n    },\n\n    /**\n     * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.\n     * If the child is already in this container, it will be moved to the specified index.\n     * @param {Container} child - The child to add.\n     * @param {number} index - The absolute index where the child will be positioned at the end of the operation.\n     * @returns {Container} The child that was added.\n     * @memberof scene.Container#\n     */\n    addChildAt<U extends Container>(child: U, index: number): U\n    {\n        // #if _DEBUG\n        if (!this.allowChildren)\n        {\n            deprecation(v8_0_0, 'addChildAt: Only Containers will be allowed to add children in v8.0.0');\n        }\n        // #endif\n\n        const { children } = this;\n\n        if (index < 0 || index > children.length)\n        {\n            throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);\n        }\n\n        // TODO - check if child is already in the list?\n        // we should be able to optimise this!\n\n        if (child.parent)\n        {\n            const currentIndex = child.parent.children.indexOf(child);\n\n            // If this child is in the container and in the same position, do nothing\n            if (child.parent === this && currentIndex === index)\n            {\n                return child;\n            }\n\n            if (currentIndex !== -1)\n            {\n                child.parent.children.splice(currentIndex, 1);\n            }\n        }\n\n        if (index === children.length)\n        {\n            children.push(child);\n        }\n        else\n        {\n            children.splice(index, 0, child);\n        }\n\n        child.parent = this;\n        child.didChange = true;\n        child.didViewUpdate = false;\n        child._updateFlags = 0b1111;\n\n        if (this.renderGroup)\n        {\n            this.renderGroup.addChild(child);\n        }\n\n        if (this.sortableChildren) this.sortDirty = true;\n\n        this.emit('childAdded', child, this, index);\n        child.emit('added', this);\n\n        return child;\n    },\n    /**\n     * Swaps the position of 2 Containers within this container.\n     * @param child - First container to swap\n     * @param child2 - Second container to swap\n     */\n    swapChildren<U extends Container>(child: U, child2: U): void\n    {\n        if (child === child2)\n        {\n            return;\n        }\n\n        const index1 = this.getChildIndex(child);\n        const index2 = this.getChildIndex(child2);\n\n        this.children[index1] = child2;\n        this.children[index2] = child;\n    },\n    /**\n     * Remove the Container from its parent Container. If the Container has no parent, do nothing.\n     * @memberof scene.Container#\n     */\n    removeFromParent()\n    {\n        this.parent?.removeChild(this);\n    }\n} as Container;\n","\"use strict\";\nfunction removeItems(arr, startIdx, removeCount) {\n  const length = arr.length;\n  let i;\n  if (startIdx >= length || removeCount === 0) {\n    return;\n  }\n  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;\n  const len = length - removeCount;\n  for (i = startIdx; i < len; ++i) {\n    arr[i] = arr[i + removeCount];\n  }\n  arr.length = len;\n}\n\nexport { removeItems };\n//# sourceMappingURL=removeItems.mjs.map\n","/**\n * Remove items from a javascript array without generating garbage\n * @function removeItems\n * @memberof utils\n * @param {Array<any>} arr - Array to remove elements from\n * @param {number} startIdx - starting index\n * @param {number} removeCount - how many to remove\n */\nexport function removeItems(arr: any[], startIdx: number, removeCount: number): void\n{\n    const length = arr.length;\n    let i;\n\n    if (startIdx >= length || removeCount === 0)\n    {\n        return;\n    }\n\n    removeCount = (startIdx + removeCount > length ? length - startIdx : removeCount);\n\n    const len = length - removeCount;\n\n    for (i = startIdx; i < len; ++i)\n    {\n        arr[i] = arr[i + removeCount];\n    }\n\n    arr.length = len;\n}\n","import { FilterEffect } from '../../../filters/FilterEffect.mjs';\nimport { MaskEffectManager } from '../../../rendering/mask/MaskEffectManager.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\n\n\"use strict\";\nconst effectsMixin = {\n  _mask: null,\n  _filters: null,\n  /**\n   * @todo Needs docs.\n   * @memberof scene.Container#\n   * @type {Array<Effect>}\n   */\n  effects: [],\n  /**\n   * @todo Needs docs.\n   * @param effect - The effect to add.\n   * @memberof scene.Container#\n   * @ignore\n   */\n  addEffect(effect) {\n    const index = this.effects.indexOf(effect);\n    if (index !== -1)\n      return;\n    this.effects.push(effect);\n    this.effects.sort((a, b) => a.priority - b.priority);\n    if (this.renderGroup) {\n      this.renderGroup.structureDidChange = true;\n    }\n    this._updateIsSimple();\n  },\n  /**\n   * @todo Needs docs.\n   * @param effect - The effect to remove.\n   * @memberof scene.Container#\n   * @ignore\n   */\n  removeEffect(effect) {\n    const index = this.effects.indexOf(effect);\n    if (index === -1)\n      return;\n    this.effects.splice(index, 1);\n    if (!this.isRenderGroupRoot && this.renderGroup) {\n      this.renderGroup.structureDidChange = true;\n    }\n    this._updateIsSimple();\n  },\n  set mask(value) {\n    this._mask || (this._mask = { mask: null, effect: null });\n    if (this._mask.mask === value)\n      return;\n    if (this._mask.effect) {\n      this.removeEffect(this._mask.effect);\n      MaskEffectManager.returnMaskEffect(this._mask.effect);\n      this._mask.effect = null;\n    }\n    this._mask.mask = value;\n    if (value === null || value === void 0)\n      return;\n    const effect = MaskEffectManager.getMaskEffect(value);\n    this._mask.effect = effect;\n    this.addEffect(effect);\n  },\n  /**\n   * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n   * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n   * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it\n   * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\n   * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.\n   * To remove a mask, set this property to `null`.\n   *\n   * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n   * @example\n   * import { Graphics, Sprite } from 'pixi.js';\n   *\n   * const graphics = new Graphics();\n   * graphics.beginFill(0xFF3300);\n   * graphics.drawRect(50, 250, 100, 100);\n   * graphics.endFill();\n   *\n   * const sprite = new Sprite(texture);\n   * sprite.mask = graphics;\n   * @memberof scene.Container#\n   */\n  get mask() {\n    return this._mask?.mask;\n  },\n  set filters(value) {\n    if (!Array.isArray(value) && value)\n      value = [value];\n    value = value;\n    this._filters || (this._filters = { filters: null, effect: null, filterArea: null });\n    const hasFilters = value?.length > 0;\n    const didChange = this._filters.effect && !hasFilters || !this._filters.effect && hasFilters;\n    value = Array.isArray(value) ? value.slice(0) : value;\n    this._filters.filters = Object.freeze(value);\n    if (didChange) {\n      if (hasFilters) {\n        const effect = BigPool.get(FilterEffect);\n        this._filters.effect = effect;\n        this.addEffect(effect);\n      } else {\n        const effect = this._filters.effect;\n        this.removeEffect(effect);\n        effect.filterArea = null;\n        effect.filters = null;\n        this._filters.effect = null;\n        BigPool.return(effect);\n      }\n    }\n    if (hasFilters) {\n      this._filters.effect.filters = value;\n      this._filters.effect.filterArea = this.filterArea;\n    }\n  },\n  /**\n   * Sets the filters for the displayObject.\n   * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n   * To remove filters simply set this property to `'null'`.\n   * @memberof scene.Container#\n   */\n  get filters() {\n    return this._filters?.filters;\n  },\n  set filterArea(value) {\n    this._filters || (this._filters = { filters: null, effect: null, filterArea: null });\n    this._filters.filterArea = value;\n  },\n  /**\n   * The area the filter is applied to. This is used as more of an optimization\n   * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n   *\n   * Also works as an interaction mask.\n   * @memberof scene.Container#\n   */\n  get filterArea() {\n    return this._filters?.filterArea;\n  }\n};\n\nexport { effectsMixin };\n//# sourceMappingURL=effectsMixin.mjs.map\n","import { FilterEffect } from '../../../filters/FilterEffect';\nimport { MaskEffectManager } from '../../../rendering/mask/MaskEffectManager';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\n\nimport type { Filter } from '../../../filters/Filter';\nimport type { Rectangle } from '../../../maths/shapes/Rectangle';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Container } from '../Container';\nimport type { Effect } from '../Effect';\n\nexport interface EffectsMixinConstructor\n{\n    mask?: number | Container | null;\n    filters?: Filter | Filter[];\n}\nexport interface EffectsMixin extends Required<EffectsMixinConstructor>\n{\n    _mask?: {mask: unknown, effect: Effect};\n    _filters?: {\n        filters: readonly Filter[],\n        effect: FilterEffect\n        filterArea?: Rectangle,\n    },\n    filterArea?: Rectangle,\n    effects?: Effect[];\n    addEffect(effect: Effect): void;\n    removeEffect(effect: Effect): void;\n}\n\nexport const effectsMixin: Partial<Container> = {\n    _mask: null,\n    _filters: null,\n\n    /**\n     * @todo Needs docs.\n     * @memberof scene.Container#\n     * @type {Array<Effect>}\n     */\n    effects: [],\n\n    /**\n     * @todo Needs docs.\n     * @param effect - The effect to add.\n     * @memberof scene.Container#\n     * @ignore\n     */\n    addEffect(effect: Effect)\n    {\n        const index = this.effects.indexOf(effect);\n\n        if (index !== -1) return; // already exists!\n\n        this.effects.push(effect);\n\n        this.effects.sort((a, b) => a.priority - b.priority);\n\n        if (this.renderGroup)\n        {\n            this.renderGroup.structureDidChange = true;\n        }\n\n        this._updateIsSimple();\n    },\n    /**\n     * @todo Needs docs.\n     * @param effect - The effect to remove.\n     * @memberof scene.Container#\n     * @ignore\n     */\n    removeEffect(effect: Effect)\n    {\n        const index = this.effects.indexOf(effect);\n\n        if (index === -1) return; // already exists!\n\n        this.effects.splice(index, 1);\n\n        if (!this.isRenderGroupRoot && this.renderGroup)\n        {\n            this.renderGroup.structureDidChange = true;\n        }\n\n        this._updateIsSimple();\n    },\n\n    set mask(value: number | Container | null)\n    {\n        this._mask ||= { mask: null, effect: null };\n\n        if (this._mask.mask === value) return;\n\n        if (this._mask.effect)\n        {\n            this.removeEffect(this._mask.effect);\n\n            MaskEffectManager.returnMaskEffect(this._mask.effect);\n\n            this._mask.effect = null;\n        }\n\n        this._mask.mask = value;\n\n        if (value === null || value === undefined) return;\n\n        const effect = MaskEffectManager.getMaskEffect(value);\n\n        this._mask.effect = effect;\n\n        this.addEffect(effect);\n    },\n\n    /**\n     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n     * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n     * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it\n     * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\n     * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.\n     * To remove a mask, set this property to `null`.\n     *\n     * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n     * @example\n     * import { Graphics, Sprite } from 'pixi.js';\n     *\n     * const graphics = new Graphics();\n     * graphics.beginFill(0xFF3300);\n     * graphics.drawRect(50, 250, 100, 100);\n     * graphics.endFill();\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.mask = graphics;\n     * @memberof scene.Container#\n     */\n    get mask(): unknown\n    {\n        return this._mask?.mask;\n    },\n\n    set filters(value: Filter | Filter[] | null | undefined)\n    {\n        if (!Array.isArray(value) && value) value = [value];\n\n        // Ignore the Filter type\n        value = value as Filter[] | null | undefined;\n\n        // by reusing the same effect.. rather than adding and removing from the pool!\n        this._filters ||= { filters: null, effect: null, filterArea: null };\n\n        const hasFilters = value?.length > 0;\n        const didChange = (this._filters.effect && !hasFilters) || (!this._filters.effect && hasFilters);\n\n        // Clone the filters array so we don't freeze the user-input\n        value = Array.isArray(value) ? value.slice(0) : value;\n\n        // Ensure filters are immutable via filters getter\n        this._filters.filters = Object.freeze(value);\n\n        if (didChange)\n        {\n            if (hasFilters)\n            {\n                const effect = BigPool.get(FilterEffect);\n\n                this._filters.effect = effect;\n                this.addEffect(effect);\n            }\n            else\n            {\n                const effect = this._filters.effect;\n\n                this.removeEffect(effect);\n\n                effect.filterArea = null;\n                effect.filters = null;\n\n                this._filters.effect = null;\n                BigPool.return(effect as PoolItem);\n            }\n        }\n\n        if (hasFilters)\n        {\n            this._filters.effect.filters = value as Filter[];\n            this._filters.effect.filterArea = this.filterArea;\n        }\n    },\n\n    /**\n     * Sets the filters for the displayObject.\n     * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n     * To remove filters simply set this property to `'null'`.\n     * @memberof scene.Container#\n     */\n    get filters(): readonly Filter[]\n    {\n        return this._filters?.filters;\n    },\n\n    set filterArea(value: Rectangle)\n    {\n        this._filters ||= { filters: null, effect: null, filterArea: null };\n\n        this._filters.filterArea = value;\n    },\n\n    /**\n     * The area the filter is applied to. This is used as more of an optimization\n     * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n     *\n     * Also works as an interaction mask.\n     * @memberof scene.Container#\n     */\n    get filterArea(): Rectangle\n    {\n        return this._filters?.filterArea;\n    },\n\n} as Container;\n","\"use strict\";\nclass FilterEffect {\n  constructor(options) {\n    this.pipe = \"filter\";\n    this.priority = 1;\n    this.filters = options?.filters;\n    this.filterArea = options?.filterArea;\n  }\n  destroy() {\n    for (let i = 0; i < this.filters.length; i++) {\n      this.filters[i].destroy();\n    }\n    this.filters = null;\n    this.filterArea = null;\n  }\n}\n\nexport { FilterEffect };\n//# sourceMappingURL=FilterEffect.mjs.map\n","import type { Rectangle } from '../maths/shapes/Rectangle';\nimport type { Effect } from '../scene/container/Effect';\nimport type { Filter } from './Filter';\n\nexport class FilterEffect implements Effect\n{\n    public filters: Filter[];\n    public filterArea?: Rectangle;\n\n    public pipe = 'filter';\n    public priority = 1;\n\n    constructor(options?: {filters: Filter[], filterArea?: Rectangle})\n    {\n        this.filters = options?.filters;\n        this.filterArea = options?.filterArea;\n    }\n\n    public destroy(): void\n    {\n        for (let i = 0; i < this.filters.length; i++)\n        {\n            this.filters[i].destroy();\n        }\n\n        this.filters = null;\n        this.filterArea = null;\n    }\n}\n","import { extensions, ExtensionType } from '../../extensions/Extensions.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\n\n\"use strict\";\nclass MaskEffectManagerClass {\n  constructor() {\n    /**\n     * @private\n     */\n    this._effectClasses = [];\n    this._tests = [];\n    this._initialized = false;\n  }\n  init() {\n    if (this._initialized)\n      return;\n    this._initialized = true;\n    this._effectClasses.forEach((test) => {\n      this.add({\n        test: test.test,\n        maskClass: test\n      });\n    });\n  }\n  add(test) {\n    this._tests.push(test);\n  }\n  getMaskEffect(item) {\n    if (!this._initialized)\n      this.init();\n    for (let i = 0; i < this._tests.length; i++) {\n      const test = this._tests[i];\n      if (test.test(item)) {\n        return BigPool.get(test.maskClass, item);\n      }\n    }\n    return item;\n  }\n  returnMaskEffect(effect) {\n    BigPool.return(effect);\n  }\n}\nconst MaskEffectManager = new MaskEffectManagerClass();\nextensions.handleByList(ExtensionType.MaskEffect, MaskEffectManager._effectClasses);\n\nexport { MaskEffectManager, MaskEffectManagerClass };\n//# sourceMappingURL=MaskEffectManager.mjs.map\n","import { extensions, ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\n\nimport type { Effect, EffectConstructor } from '../../scene/container/Effect';\nimport type { PoolItem, PoolItemConstructor } from '../../utils/pool/Pool';\n\ninterface MaskConversionTest\n{\n    test: (item: any) => boolean;\n    maskClass: new (item: any) => Effect & PoolItem;\n}\n\n/**\n * A class that manages the conversion of masks to mask effects.\n * @memberof rendering\n * @ignore\n */\nexport class MaskEffectManagerClass\n{\n    /**\n     * @private\n     */\n    public readonly _effectClasses: EffectConstructor[] = [];\n    private readonly _tests: MaskConversionTest[] = [];\n    private _initialized = false;\n\n    public init()\n    {\n        if (this._initialized) return;\n\n        this._initialized = true;\n\n        this._effectClasses.forEach((test) =>\n        {\n            this.add({\n                test: test.test,\n                maskClass: test\n            });\n        });\n    }\n\n    public add(test: MaskConversionTest)\n    {\n        this._tests.push(test);\n    }\n\n    public getMaskEffect(item: any): Effect\n    {\n        if (!this._initialized) this.init();\n\n        for (let i = 0; i < this._tests.length; i++)\n        {\n            const test = this._tests[i];\n\n            if (test.test(item))\n            {\n                return BigPool.get(test.maskClass as PoolItemConstructor<Effect & PoolItem>, item);\n            }\n        }\n\n        return item;\n    }\n\n    public returnMaskEffect(effect: Effect & PoolItem)\n    {\n        BigPool.return(effect);\n    }\n}\n\nexport const MaskEffectManager = new MaskEffectManagerClass();\n\n// Handle registration of extensions\nextensions\n    .handleByList(ExtensionType.MaskEffect, MaskEffectManager._effectClasses);\n","import { Pool } from './Pool.mjs';\n\n\"use strict\";\nclass PoolGroupClass {\n  constructor() {\n    /**\n     * A map to store the pools by their class type.\n     * @private\n     */\n    this._poolsByClass = /* @__PURE__ */ new Map();\n  }\n  /**\n   * Prepopulates a specific pool with a given number of items.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n   * @param {number} total - The number of items to add to the pool.\n   */\n  prepopulate(Class, total) {\n    const classPool = this.getPool(Class);\n    classPool.prepopulate(total);\n  }\n  /**\n   * Gets an item from a specific pool.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n   * @param {unknown} [data] - Optional data to pass to the item's constructor.\n   * @returns {T} The item from the pool.\n   */\n  get(Class, data) {\n    const pool = this.getPool(Class);\n    return pool.get(data);\n  }\n  /**\n   * Returns an item to its respective pool.\n   * @param {PoolItem} item - The item to return to the pool.\n   */\n  return(item) {\n    const pool = this.getPool(item.constructor);\n    pool.return(item);\n  }\n  /**\n   * Gets a specific pool based on the class type.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.\n   * @returns {Pool<T>} The pool of the given class type.\n   */\n  getPool(ClassType) {\n    if (!this._poolsByClass.has(ClassType)) {\n      this._poolsByClass.set(ClassType, new Pool(ClassType));\n    }\n    return this._poolsByClass.get(ClassType);\n  }\n  /** gets the usage stats of each pool in the system */\n  stats() {\n    const stats = {};\n    this._poolsByClass.forEach((pool) => {\n      const name = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;\n      stats[name] = {\n        free: pool.totalFree,\n        used: pool.totalUsed,\n        size: pool.totalSize\n      };\n    });\n    return stats;\n  }\n}\nconst BigPool = new PoolGroupClass();\n\nexport { BigPool, PoolGroupClass };\n//# sourceMappingURL=PoolGroup.mjs.map\n","import { Pool } from './Pool';\n\nimport type { PoolItem, PoolItemConstructor } from './Pool';\n\n/**\n * A type alias for a constructor of a Pool.\n * @template T The type of items in the pool. Must extend PoolItem.\n * @memberof utils\n */\nexport type PoolConstructor<T extends PoolItem> = new () => Pool<T>;\n\n/**\n * A group of pools that can be used to store objects of different types.\n * @memberof utils\n */\nexport class PoolGroupClass\n{\n    /**\n     * A map to store the pools by their class type.\n     * @private\n     */\n    private readonly _poolsByClass: Map<PoolItemConstructor<PoolItem>, Pool<PoolItem>> = new Map();\n\n    /**\n     * Prepopulates a specific pool with a given number of items.\n     * @template T The type of items in the pool. Must extend PoolItem.\n     * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n     * @param {number} total - The number of items to add to the pool.\n     */\n    public prepopulate<T extends PoolItem>(Class: PoolItemConstructor<T>, total: number): void\n    {\n        const classPool = this.getPool(Class);\n\n        classPool.prepopulate(total);\n    }\n\n    /**\n     * Gets an item from a specific pool.\n     * @template T The type of items in the pool. Must extend PoolItem.\n     * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n     * @param {unknown} [data] - Optional data to pass to the item's constructor.\n     * @returns {T} The item from the pool.\n     */\n    public get<T extends PoolItem>(Class: PoolItemConstructor<T>, data?: unknown): T\n    {\n        const pool = this.getPool(Class);\n\n        return pool.get(data) as T;\n    }\n\n    /**\n     * Returns an item to its respective pool.\n     * @param {PoolItem} item - The item to return to the pool.\n     */\n    public return(item: PoolItem): void\n    {\n        const pool = this.getPool(item.constructor as PoolItemConstructor<PoolItem>);\n\n        pool.return(item);\n    }\n\n    /**\n     * Gets a specific pool based on the class type.\n     * @template T The type of items in the pool. Must extend PoolItem.\n     * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.\n     * @returns {Pool<T>} The pool of the given class type.\n     */\n    public getPool<T extends PoolItem>(ClassType: PoolItemConstructor<T>): Pool<T>\n    {\n        if (!this._poolsByClass.has(ClassType))\n        {\n            this._poolsByClass.set(ClassType, new Pool(ClassType));\n        }\n\n        return this._poolsByClass.get(ClassType) as Pool<T>;\n    }\n\n    /** gets the usage stats of each pool in the system */\n    public stats(): Record<string, {free: number; used: number; size: number}>\n    {\n        const stats = {} as Record<string, {free: number; used: number; size: number}>;\n\n        this._poolsByClass.forEach((pool) =>\n        {\n            // TODO: maybe we should allow the name to be set when `createEntity` is called\n            const name = stats[pool._classType.name]\n                ? pool._classType.name + (pool._classType as any).ID : pool._classType.name;\n\n            stats[name] = {\n                free: pool.totalFree,\n                used: pool.totalUsed,\n                size: pool.totalSize,\n            };\n        });\n\n        return stats;\n    }\n}\n\nexport const BigPool = new PoolGroupClass();\n","\"use strict\";\nclass Pool {\n  /**\n   * Constructs a new Pool.\n   * @param ClassType - The constructor of the items in the pool.\n   * @param {number} [initialSize] - The initial size of the pool.\n   */\n  constructor(ClassType, initialSize) {\n    this._pool = [];\n    this._count = 0;\n    this._index = 0;\n    this._classType = ClassType;\n    if (initialSize) {\n      this.prepopulate(initialSize);\n    }\n  }\n  /**\n   * Prepopulates the pool with a given number of items.\n   * @param total - The number of items to add to the pool.\n   */\n  prepopulate(total) {\n    for (let i = 0; i < total; i++) {\n      this._pool[this._index++] = new this._classType();\n    }\n    this._count += total;\n  }\n  /**\n   * Gets an item from the pool. Calls the item's `init` method if it exists.\n   * If there are no items left in the pool, a new one will be created.\n   * @param {unknown} [data] - Optional data to pass to the item's constructor.\n   * @returns {T} The item from the pool.\n   */\n  get(data) {\n    let item;\n    if (this._index > 0) {\n      item = this._pool[--this._index];\n    } else {\n      item = new this._classType();\n    }\n    item.init?.(data);\n    return item;\n  }\n  /**\n   * Returns an item to the pool. Calls the item's `reset` method if it exists.\n   * @param {T} item - The item to return to the pool.\n   */\n  return(item) {\n    item.reset?.();\n    this._pool[this._index++] = item;\n  }\n  /**\n   * Gets the number of items in the pool.\n   * @readonly\n   * @member {number}\n   */\n  get totalSize() {\n    return this._count;\n  }\n  /**\n   * Gets the number of items in the pool that are free to use without needing to create more.\n   * @readonly\n   * @member {number}\n   */\n  get totalFree() {\n    return this._index;\n  }\n  /**\n   * Gets the number of items in the pool that are currently in use.\n   * @readonly\n   * @member {number}\n   */\n  get totalUsed() {\n    return this._count - this._index;\n  }\n}\n\nexport { Pool };\n//# sourceMappingURL=Pool.mjs.map\n","/**\n * A generic class for managing a pool of items.\n * @template T The type of items in the pool. Must implement {@link utils.PoolItem}.\n * @memberof utils\n */\nexport class Pool<T extends PoolItem>\n{\n    public readonly _classType: PoolItemConstructor<T>;\n    private readonly _pool: T[] = [];\n    private _count = 0;\n    private _index = 0;\n\n    /**\n     * Constructs a new Pool.\n     * @param ClassType - The constructor of the items in the pool.\n     * @param {number} [initialSize] - The initial size of the pool.\n     */\n    constructor(ClassType: PoolItemConstructor<T>, initialSize?: number)\n    {\n        this._classType = ClassType;\n\n        if (initialSize)\n        {\n            this.prepopulate(initialSize);\n        }\n    }\n\n    /**\n     * Prepopulates the pool with a given number of items.\n     * @param total - The number of items to add to the pool.\n     */\n    public prepopulate(total: number): void\n    {\n        for (let i = 0; i < total; i++)\n        {\n            this._pool[this._index++] = new this._classType();\n        }\n\n        this._count += total;\n    }\n\n    /**\n     * Gets an item from the pool. Calls the item's `init` method if it exists.\n     * If there are no items left in the pool, a new one will be created.\n     * @param {unknown} [data] - Optional data to pass to the item's constructor.\n     * @returns {T} The item from the pool.\n     */\n    public get(data?: unknown): T\n    {\n        let item;\n\n        if (this._index > 0)\n        {\n            item = this._pool[--this._index];\n        }\n        else\n        {\n            item = new this._classType();\n        }\n\n        item.init?.(data);\n\n        return item;\n    }\n\n    /**\n     * Returns an item to the pool. Calls the item's `reset` method if it exists.\n     * @param {T} item - The item to return to the pool.\n     */\n    public return(item: T): void\n    {\n        item.reset?.();\n\n        this._pool[this._index++] = item;\n    }\n\n    /**\n     * Gets the number of items in the pool.\n     * @readonly\n     * @member {number}\n     */\n    get totalSize(): number\n    {\n        return this._count;\n    }\n\n    /**\n     * Gets the number of items in the pool that are free to use without needing to create more.\n     * @readonly\n     * @member {number}\n     */\n    get totalFree(): number\n    {\n        return this._index;\n    }\n\n    /**\n     * Gets the number of items in the pool that are currently in use.\n     * @readonly\n     * @member {number}\n     */\n    get totalUsed(): number\n    {\n        return this._count - this._index;\n    }\n}\n\n/**\n * An object that can be stored in a {@link utils.Pool}.\n * @memberof utils\n */\nexport type PoolItem = {\n    init?: (data?: any) => void;\n    reset?: () => void;\n    [key: string]: any;\n};\n\n/**\n * The constructor of an object that can be stored in a {@link utils.Pool}.\n * @typeParam K - The type of the object that can be stored in a {@link utils.Pool}.\n * @memberof utils\n */\nexport type PoolItemConstructor<K extends PoolItem> = new () => K;\n","import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nconst findMixin = {\n  /**\n   * The instance label of the object.\n   * @memberof scene.Container#\n   * @member {string} label\n   */\n  label: null,\n  /**\n   * The instance name of the object.\n   * @deprecated since 8.0.0\n   * @see scene.Container#label\n   * @member {string} name\n   * @memberof scene.Container#\n   */\n  get name() {\n    deprecation(v8_0_0, \"Container.name property has been removed, use Container.label instead\");\n    return this.label;\n  },\n  set name(value) {\n    deprecation(v8_0_0, \"Container.name property has been removed, use Container.label instead\");\n    this.label = value;\n  },\n  /**\n   * @method getChildByName\n   * @deprecated since 8.0.0\n   * @param {string} name - Instance name.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @returns {Container} The child with the specified name.\n   * @see scene.Container#getChildByLabel\n   * @memberof scene.Container#\n   */\n  getChildByName(name, deep = false) {\n    return this.getChildByLabel(name, deep);\n  },\n  /**\n   * Returns the first child in the container with the specified label.\n   *\n   * Recursive searches are done in a pre-order traversal.\n   * @memberof scene.Container#\n   * @param {string|RegExp} label - Instance label.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @returns {Container} The child with the specified label.\n   */\n  getChildByLabel(label, deep = false) {\n    const children = this.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child.label === label || label instanceof RegExp && label.test(child.label))\n        return child;\n    }\n    if (deep) {\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        const found = child.getChildByLabel(label, true);\n        if (found) {\n          return found;\n        }\n      }\n    }\n    return null;\n  },\n  /**\n   * Returns all children in the container with the specified label.\n   * @memberof scene.Container#\n   * @param {string|RegExp} label - Instance label.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @param {Container[]} [out=[]] - The array to store matching children in.\n   * @returns {Container[]} An array of children with the specified label.\n   */\n  getChildrenByLabel(label, deep = false, out = []) {\n    const children = this.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child.label === label || label instanceof RegExp && label.test(child.label)) {\n        out.push(child);\n      }\n    }\n    if (deep) {\n      for (let i = 0; i < children.length; i++) {\n        children[i].getChildrenByLabel(label, true, out);\n      }\n    }\n    return out;\n  }\n};\n\nexport { findMixin };\n//# sourceMappingURL=findMixin.mjs.map\n","import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Container } from '../Container';\n\nexport interface FindMixinConstructor\n{\n    label?: string;\n}\nexport interface FindMixin extends Required<FindMixinConstructor>\n{\n    /**\n     * @deprecated since 8.0.0\n     * @see Container#label\n     */\n    name: string;\n    getChildByName(label: RegExp | string, deep?: boolean): Container | null;\n    getChildByLabel(label: RegExp | string, deep?: boolean): Container | null;\n    getChildrenByLabel(label: RegExp | string, deep?: boolean, out?: Container[]): Container[];\n}\n\nexport const findMixin: Partial<Container> = {\n    /**\n     * The instance label of the object.\n     * @memberof scene.Container#\n     * @member {string} label\n     */\n    label: null,\n\n    /**\n     * The instance name of the object.\n     * @deprecated since 8.0.0\n     * @see scene.Container#label\n     * @member {string} name\n     * @memberof scene.Container#\n     */\n    get name(): string\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Container.name property has been removed, use Container.label instead');\n        // #endif\n\n        return this.label;\n    },\n    set name(value: string)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Container.name property has been removed, use Container.label instead');\n        // #endif\n\n        this.label = value;\n    },\n\n    /**\n     * @method getChildByName\n     * @deprecated since 8.0.0\n     * @param {string} name - Instance name.\n     * @param {boolean}[deep=false] - Whether to search recursively\n     * @returns {Container} The child with the specified name.\n     * @see scene.Container#getChildByLabel\n     * @memberof scene.Container#\n     */\n    getChildByName(name: string, deep = false): Container | null\n    {\n        return this.getChildByLabel(name, deep);\n    },\n    /**\n     * Returns the first child in the container with the specified label.\n     *\n     * Recursive searches are done in a pre-order traversal.\n     * @memberof scene.Container#\n     * @param {string|RegExp} label - Instance label.\n     * @param {boolean}[deep=false] - Whether to search recursively\n     * @returns {Container} The child with the specified label.\n     */\n    getChildByLabel(label: string | RegExp, deep = false): Container | null\n    {\n        const children = this.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            const child = children[i];\n\n            if (child.label === label || (label instanceof RegExp && label.test(child.label))) return child;\n        }\n\n        if (deep)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                const child = children[i];\n                const found = child.getChildByLabel(label, true);\n\n                if (found)\n                {\n                    return found;\n                }\n            }\n        }\n\n        return null;\n    },\n\n    /**\n     * Returns all children in the container with the specified label.\n     * @memberof scene.Container#\n     * @param {string|RegExp} label - Instance label.\n     * @param {boolean}[deep=false] - Whether to search recursively\n     * @param {Container[]} [out=[]] - The array to store matching children in.\n     * @returns {Container[]} An array of children with the specified label.\n     */\n    getChildrenByLabel(label: string | RegExp, deep = false, out = []): Container[]\n    {\n        const children = this.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            const child = children[i];\n\n            if (child.label === label || (label instanceof RegExp && label.test(child.label)))\n            {\n                out.push(child);\n            }\n        }\n\n        if (deep)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                children[i].getChildrenByLabel(label, true, out);\n            }\n        }\n\n        return out;\n    },\n} as Container;\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { Bounds } from '../bounds/Bounds.mjs';\nimport { getGlobalBounds } from '../bounds/getGlobalBounds.mjs';\nimport { getLocalBounds } from '../bounds/getLocalBounds.mjs';\nimport { checkChildrenDidChange } from '../utils/checkChildrenDidChange.mjs';\n\n\"use strict\";\nconst tempMatrix = new Matrix();\nconst measureMixin = {\n  _localBoundsCacheId: -1,\n  _localBoundsCacheData: null,\n  _setWidth(value, localWidth) {\n    const sign = Math.sign(this.scale.x) || 1;\n    if (localWidth !== 0) {\n      this.scale.x = value / localWidth * sign;\n    } else {\n      this.scale.x = sign;\n    }\n  },\n  _setHeight(value, localHeight) {\n    const sign = Math.sign(this.scale.y) || 1;\n    if (localHeight !== 0) {\n      this.scale.y = value / localHeight * sign;\n    } else {\n      this.scale.y = sign;\n    }\n  },\n  /**\n   * Retrieves the local bounds of the container as a Bounds object.\n   * @returns - The bounding area.\n   * @memberof scene.Container#\n   */\n  getLocalBounds() {\n    if (!this._localBoundsCacheData) {\n      this._localBoundsCacheData = {\n        data: [],\n        index: 1,\n        didChange: false,\n        localBounds: new Bounds()\n      };\n    }\n    const localBoundsCacheData = this._localBoundsCacheData;\n    localBoundsCacheData.index = 1;\n    localBoundsCacheData.didChange = false;\n    if (localBoundsCacheData.data[0] !== this._didChangeId >> 12) {\n      localBoundsCacheData.didChange = true;\n      localBoundsCacheData.data[0] = this._didChangeId >> 12;\n    }\n    checkChildrenDidChange(this, localBoundsCacheData);\n    if (localBoundsCacheData.didChange) {\n      getLocalBounds(this, localBoundsCacheData.localBounds, tempMatrix);\n    }\n    return localBoundsCacheData.localBounds;\n  },\n  /**\n   * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.\n   * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from\n   *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n   *  nice performance boost.\n   * @param bounds - Optional bounds to store the result of the bounds calculation.\n   * @returns - The minimum axis-aligned rectangle in world space that fits around this object.\n   * @memberof scene.Container#\n   */\n  getBounds(skipUpdate, bounds) {\n    return getGlobalBounds(this, skipUpdate, bounds || new Bounds());\n  }\n};\n\nexport { measureMixin };\n//# sourceMappingURL=measureMixin.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { Bounds } from '../bounds/Bounds';\nimport { getGlobalBounds } from '../bounds/getGlobalBounds';\nimport { getLocalBounds } from '../bounds/getLocalBounds';\nimport { checkChildrenDidChange } from '../utils/checkChildrenDidChange';\n\nimport type { Size } from '../../../maths/misc/Size';\nimport type { Container } from '../Container';\n\nexport type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\nexport interface MeasureMixinConstructor\n{\n    width?: number;\n    height?: number;\n}\nexport interface MeasureMixin extends Required<MeasureMixinConstructor>\n{\n    getSize(out?: Size): Size;\n    setSize(width: number, height?: number): void;\n    setSize(value: Optional<Size, 'height'>): void;\n    getLocalBounds(bounds?: Bounds): Bounds;\n    getBounds(skipUpdate?: boolean, bounds?: Bounds): Bounds;\n    _localBoundsCacheData: LocalBoundsCacheData;\n    _localBoundsCacheId: number;\n    _setWidth(width: number, localWidth: number): void;\n    _setHeight(height: number, localHeight: number): void;\n}\n\ninterface LocalBoundsCacheData\n{\n    data: number[];\n    index: number;\n    didChange: boolean;\n    localBounds: Bounds;\n}\n\nconst tempMatrix = new Matrix();\n\nexport const measureMixin: Partial<Container> = {\n\n    _localBoundsCacheId: -1,\n    _localBoundsCacheData: null,\n\n    _setWidth(value: number, localWidth: number)\n    {\n        const sign = Math.sign(this.scale.x) || 1;\n\n        if (localWidth !== 0)\n        {\n            this.scale.x = (value / localWidth) * sign;\n        }\n        else\n        {\n            this.scale.x = sign;\n        }\n    },\n\n    _setHeight(value: number, localHeight: number)\n    {\n        const sign = Math.sign(this.scale.y) || 1;\n\n        if (localHeight !== 0)\n        {\n            this.scale.y = (value / localHeight) * sign;\n        }\n        else\n        {\n            this.scale.y = sign;\n        }\n    },\n\n    /**\n     * Retrieves the local bounds of the container as a Bounds object.\n     * @returns - The bounding area.\n     * @memberof scene.Container#\n     */\n    getLocalBounds(): Bounds\n    {\n        if (!this._localBoundsCacheData)\n        {\n            this._localBoundsCacheData = {\n                data: [],\n                index: 1,\n                didChange: false,\n                localBounds: new Bounds()\n            };\n        }\n\n        const localBoundsCacheData = this._localBoundsCacheData;\n\n        localBoundsCacheData.index = 1;\n        localBoundsCacheData.didChange = false;\n\n        if (localBoundsCacheData.data[0] !== this._didChangeId >> 12)\n        {\n            localBoundsCacheData.didChange = true;\n            localBoundsCacheData.data[0] = this._didChangeId >> 12;\n        }\n\n        checkChildrenDidChange(this, localBoundsCacheData);\n\n        if (localBoundsCacheData.didChange)\n        {\n            getLocalBounds(this, localBoundsCacheData.localBounds, tempMatrix);\n        }\n\n        return localBoundsCacheData.localBounds;\n    },\n\n    /**\n     * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.\n     * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from\n     *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n     *  nice performance boost.\n     * @param bounds - Optional bounds to store the result of the bounds calculation.\n     * @returns - The minimum axis-aligned rectangle in world space that fits around this object.\n     * @memberof scene.Container#\n     */\n    getBounds(skipUpdate?: boolean, bounds?: Bounds): Bounds\n    {\n        return getGlobalBounds(this, skipUpdate, bounds || new Bounds());\n    },\n} as Container;\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { Rectangle } from '../../../maths/shapes/Rectangle.mjs';\n\n\"use strict\";\nconst defaultMatrix = new Matrix();\nclass Bounds {\n  constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {\n    /** @default Infinity */\n    this.minX = Infinity;\n    /** @default Infinity */\n    this.minY = Infinity;\n    /** @default -Infinity */\n    this.maxX = -Infinity;\n    /** @default -Infinity */\n    this.maxY = -Infinity;\n    this.matrix = defaultMatrix;\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /**\n   * Checks if bounds are empty.\n   * @returns - True if empty.\n   */\n  isEmpty() {\n    return this.minX > this.maxX || this.minY > this.maxY;\n  }\n  /** The bounding rectangle of the bounds. */\n  get rectangle() {\n    if (!this._rectangle) {\n      this._rectangle = new Rectangle();\n    }\n    const rectangle = this._rectangle;\n    if (this.minX > this.maxX || this.minY > this.maxY) {\n      rectangle.x = 0;\n      rectangle.y = 0;\n      rectangle.width = 0;\n      rectangle.height = 0;\n    } else {\n      rectangle.copyFromBounds(this);\n    }\n    return rectangle;\n  }\n  /** Clears the bounds and resets. */\n  clear() {\n    this.minX = Infinity;\n    this.minY = Infinity;\n    this.maxX = -Infinity;\n    this.maxY = -Infinity;\n    this.matrix = defaultMatrix;\n    return this;\n  }\n  /**\n   * Sets the bounds.\n   * @param x0 - left X of frame\n   * @param y0 - top Y of frame\n   * @param x1 - right X of frame\n   * @param y1 - bottom Y of frame\n   */\n  set(x0, y0, x1, y1) {\n    this.minX = x0;\n    this.minY = y0;\n    this.maxX = x1;\n    this.maxY = y1;\n  }\n  /**\n   * Adds sprite frame\n   * @param x0 - left X of frame\n   * @param y0 - top Y of frame\n   * @param x1 - right X of frame\n   * @param y1 - bottom Y of frame\n   * @param matrix\n   */\n  addFrame(x0, y0, x1, y1, matrix) {\n    matrix || (matrix = this.matrix);\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    let x = a * x0 + c * y0 + tx;\n    let y = b * x0 + d * y0 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    x = a * x1 + c * y0 + tx;\n    y = b * x1 + d * y0 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    x = a * x0 + c * y1 + tx;\n    y = b * x0 + d * y1 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    x = a * x1 + c * y1 + tx;\n    y = b * x1 + d * y1 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /**\n   * Adds a rectangle to the bounds.\n   * @param rect - The rectangle to be added.\n   * @param matrix - The matrix to apply to the bounds.\n   */\n  addRect(rect, matrix) {\n    this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);\n  }\n  /**\n   * Adds other {@link Bounds}.\n   * @param bounds - The Bounds to be added\n   * @param matrix\n   */\n  addBounds(bounds, matrix) {\n    this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);\n  }\n  /**\n   * Adds other Bounds, masked with Bounds.\n   * @param mask - The Bounds to be added.\n   */\n  addBoundsMask(mask) {\n    this.minX = this.minX > mask.minX ? this.minX : mask.minX;\n    this.minY = this.minY > mask.minY ? this.minY : mask.minY;\n    this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;\n    this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;\n  }\n  /**\n   * Adds other Bounds, multiplied with matrix.\n   * @param matrix - The matrix to apply to the bounds.\n   */\n  applyMatrix(matrix) {\n    const minX = this.minX;\n    const minY = this.minY;\n    const maxX = this.maxX;\n    const maxY = this.maxY;\n    const { a, b, c, d, tx, ty } = matrix;\n    let x = a * minX + c * minY + tx;\n    let y = b * minX + d * minY + ty;\n    this.minX = x;\n    this.minY = y;\n    this.maxX = x;\n    this.maxY = y;\n    x = a * maxX + c * minY + tx;\n    y = b * maxX + d * minY + ty;\n    this.minX = x < this.minX ? x : this.minX;\n    this.minY = y < this.minY ? y : this.minY;\n    this.maxX = x > this.maxX ? x : this.maxX;\n    this.maxY = y > this.maxY ? y : this.maxY;\n    x = a * minX + c * maxY + tx;\n    y = b * minX + d * maxY + ty;\n    this.minX = x < this.minX ? x : this.minX;\n    this.minY = y < this.minY ? y : this.minY;\n    this.maxX = x > this.maxX ? x : this.maxX;\n    this.maxY = y > this.maxY ? y : this.maxY;\n    x = a * maxX + c * maxY + tx;\n    y = b * maxX + d * maxY + ty;\n    this.minX = x < this.minX ? x : this.minX;\n    this.minY = y < this.minY ? y : this.minY;\n    this.maxX = x > this.maxX ? x : this.maxX;\n    this.maxY = y > this.maxY ? y : this.maxY;\n  }\n  /**\n   * Resizes the bounds object to include the given rectangle.\n   * @param rect - The rectangle to be included.\n   */\n  fit(rect) {\n    if (this.minX < rect.left)\n      this.minX = rect.left;\n    if (this.maxX > rect.right)\n      this.maxX = rect.right;\n    if (this.minY < rect.top)\n      this.minY = rect.top;\n    if (this.maxY > rect.bottom)\n      this.maxY = rect.bottom;\n    return this;\n  }\n  /**\n   * Resizes the bounds object to include the given bounds.\n   * @param left - The left value of the bounds.\n   * @param right - The right value of the bounds.\n   * @param top - The top value of the bounds.\n   * @param bottom - The bottom value of the bounds.\n   */\n  fitBounds(left, right, top, bottom) {\n    if (this.minX < left)\n      this.minX = left;\n    if (this.maxX > right)\n      this.maxX = right;\n    if (this.minY < top)\n      this.minY = top;\n    if (this.maxY > bottom)\n      this.maxY = bottom;\n    return this;\n  }\n  /**\n   * Pads bounds object, making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   */\n  pad(paddingX, paddingY = paddingX) {\n    this.minX -= paddingX;\n    this.maxX += paddingX;\n    this.minY -= paddingY;\n    this.maxY += paddingY;\n    return this;\n  }\n  /** Ceils the bounds. */\n  ceil() {\n    this.minX = Math.floor(this.minX);\n    this.minY = Math.floor(this.minY);\n    this.maxX = Math.ceil(this.maxX);\n    this.maxY = Math.ceil(this.maxY);\n    return this;\n  }\n  /** Clones the bounds. */\n  clone() {\n    return new Bounds(this.minX, this.minY, this.maxX, this.maxY);\n  }\n  /**\n   * Scales the bounds by the given values\n   * @param x - The X value to scale by.\n   * @param y - The Y value to scale by.\n   */\n  scale(x, y = x) {\n    this.minX *= x;\n    this.minY *= y;\n    this.maxX *= x;\n    this.maxY *= y;\n    return this;\n  }\n  /** the x value of the bounds. */\n  get x() {\n    return this.minX;\n  }\n  set x(value) {\n    const width = this.maxX - this.minX;\n    this.minX = value;\n    this.maxX = value + width;\n  }\n  /** the y value of the bounds. */\n  get y() {\n    return this.minY;\n  }\n  set y(value) {\n    const height = this.maxY - this.minY;\n    this.minY = value;\n    this.maxY = value + height;\n  }\n  /** the width value of the bounds. */\n  get width() {\n    return this.maxX - this.minX;\n  }\n  set width(value) {\n    this.maxX = this.minX + value;\n  }\n  /** the height value of the bounds. */\n  get height() {\n    return this.maxY - this.minY;\n  }\n  set height(value) {\n    this.maxY = this.minY + value;\n  }\n  /** the left value of the bounds. */\n  get left() {\n    return this.minX;\n  }\n  /** the right value of the bounds. */\n  get right() {\n    return this.maxX;\n  }\n  /** the top value of the bounds. */\n  get top() {\n    return this.minY;\n  }\n  /** the bottom value of the bounds. */\n  get bottom() {\n    return this.maxY;\n  }\n  /** Is the bounds positive. */\n  get isPositive() {\n    return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;\n  }\n  get isValid() {\n    return this.minX + this.minY !== Infinity;\n  }\n  /**\n   * Adds screen vertices from array\n   * @param vertexData - calculated vertices\n   * @param beginOffset - begin offset\n   * @param endOffset - end offset, excluded\n   * @param matrix\n   */\n  addVertexData(vertexData, beginOffset, endOffset, matrix) {\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    matrix || (matrix = this.matrix);\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    for (let i = beginOffset; i < endOffset; i += 2) {\n      const localX = vertexData[i];\n      const localY = vertexData[i + 1];\n      const x = a * localX + c * localY + tx;\n      const y = b * localX + d * localY + ty;\n      minX = x < minX ? x : minX;\n      minY = y < minY ? y : minY;\n      maxX = x > maxX ? x : maxX;\n      maxY = y > maxY ? y : maxY;\n    }\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /**\n   * Checks if the point is contained within the bounds.\n   * @param x - x coordinate\n   * @param y - y coordinate\n   */\n  containsPoint(x, y) {\n    if (this.minX <= x && this.minY <= y && this.maxX >= x && this.maxY >= y) {\n      return true;\n    }\n    return false;\n  }\n  toString() {\n    return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;\n  }\n}\n\nexport { Bounds };\n//# sourceMappingURL=Bounds.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../maths/shapes/Rectangle';\n\n/**\n * Simple bounds implementation instead of more ambiguous [number, number, number, number]\n * @memberof rendering\n */\nexport interface BoundsData\n{\n    minX: number;\n    minY: number;\n    maxX: number;\n    maxY: number;\n}\n\nconst defaultMatrix = new Matrix();\n\n// TODO optimisations\n// 1 - get rectangle could use a dirty flag, rather than setting the data each time is called\n// 2- getFrame ALWAYS assumes a matrix, could be optimised to avoid the matrix calculation if not needed\n\n/**\n * A representation of an AABB bounding box.\n * @memberof rendering\n */\nexport class Bounds\n{\n    /** @default Infinity */\n    public minX = Infinity;\n\n    /** @default Infinity */\n    public minY = Infinity;\n\n    /** @default -Infinity */\n    public maxX = -Infinity;\n\n    /** @default -Infinity */\n    public maxY = -Infinity;\n\n    public matrix = defaultMatrix;\n\n    private _rectangle: Rectangle;\n\n    constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity)\n    {\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Checks if bounds are empty.\n     * @returns - True if empty.\n     */\n    public isEmpty(): boolean\n    {\n        return this.minX > this.maxX || this.minY > this.maxY;\n    }\n\n    /** The bounding rectangle of the bounds. */\n    get rectangle(): Rectangle\n    {\n        if (!this._rectangle)\n        {\n            this._rectangle = new Rectangle();\n        }\n\n        const rectangle = this._rectangle;\n\n        if (this.minX > this.maxX || this.minY > this.maxY)\n        {\n            rectangle.x = 0;\n            rectangle.y = 0;\n            rectangle.width = 0;\n            rectangle.height = 0;\n        }\n        else\n        {\n            rectangle.copyFromBounds(this);\n        }\n\n        return rectangle;\n    }\n\n    /** Clears the bounds and resets. */\n    public clear(): this\n    {\n        this.minX = Infinity;\n        this.minY = Infinity;\n        this.maxX = -Infinity;\n        this.maxY = -Infinity;\n\n        this.matrix = defaultMatrix;\n\n        return this;\n    }\n\n    /**\n     * Sets the bounds.\n     * @param x0 - left X of frame\n     * @param y0 - top Y of frame\n     * @param x1 - right X of frame\n     * @param y1 - bottom Y of frame\n     */\n    public set(x0: number, y0: number, x1: number, y1: number)\n    {\n        this.minX = x0;\n        this.minY = y0;\n        this.maxX = x1;\n        this.maxY = y1;\n    }\n\n    /**\n     * Adds sprite frame\n     * @param x0 - left X of frame\n     * @param y0 - top Y of frame\n     * @param x1 - right X of frame\n     * @param y1 - bottom Y of frame\n     * @param matrix\n     */\n    public addFrame(x0: number, y0: number, x1: number, y1: number, matrix?: Matrix): void\n    {\n        matrix ||= this.matrix;\n\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        let x = (a * x0) + (c * y0) + tx;\n        let y = (b * x0) + (d * y0) + ty;\n\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n\n        x = (a * x1) + (c * y0) + tx;\n        y = (b * x1) + (d * y0) + ty;\n\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n\n        x = (a * x0) + (c * y1) + tx;\n        y = (b * x0) + (d * y1) + ty;\n\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n\n        x = (a * x1) + (c * y1) + tx;\n        y = (b * x1) + (d * y1) + ty;\n\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Adds a rectangle to the bounds.\n     * @param rect - The rectangle to be added.\n     * @param matrix - The matrix to apply to the bounds.\n     */\n    public addRect(rect: Rectangle, matrix?: Matrix)\n    {\n        this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);\n    }\n\n    /**\n     * Adds other {@link Bounds}.\n     * @param bounds - The Bounds to be added\n     * @param matrix\n     */\n    public addBounds(bounds: BoundsData, matrix?: Matrix)\n    {\n        this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);\n    }\n\n    /**\n     * Adds other Bounds, masked with Bounds.\n     * @param mask - The Bounds to be added.\n     */\n    public addBoundsMask(mask: Bounds): void\n    {\n        this.minX = this.minX > mask.minX ? this.minX : mask.minX;\n        this.minY = this.minY > mask.minY ? this.minY : mask.minY;\n        this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;\n        this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;\n    }\n\n    /**\n     * Adds other Bounds, multiplied with matrix.\n     * @param matrix - The matrix to apply to the bounds.\n     */\n    public applyMatrix(matrix: Matrix): void\n    {\n        const minX = this.minX;\n        const minY = this.minY;\n        const maxX = this.maxX;\n        const maxY = this.maxY;\n\n        // multiple bounds by matrix\n        const { a, b, c, d, tx, ty } = matrix;\n\n        let x = (a * minX) + (c * minY) + tx;\n        let y = (b * minX) + (d * minY) + ty;\n\n        this.minX = x;\n        this.minY = y;\n        this.maxX = x;\n        this.maxY = y;\n\n        x = (a * maxX) + (c * minY) + tx;\n        y = (b * maxX) + (d * minY) + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n\n        x = (a * minX) + (c * maxY) + tx;\n        y = (b * minX) + (d * maxY) + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n\n        x = (a * maxX) + (c * maxY) + tx;\n        y = (b * maxX) + (d * maxY) + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n    }\n\n    /**\n     * Resizes the bounds object to include the given rectangle.\n     * @param rect - The rectangle to be included.\n     */\n    public fit(rect: Rectangle): this\n    {\n        if (this.minX < rect.left) this.minX = rect.left;\n        if (this.maxX > rect.right) this.maxX = rect.right;\n\n        if (this.minY < rect.top) this.minY = rect.top;\n        if (this.maxY > rect.bottom) this.maxY = rect.bottom;\n\n        return this;\n    }\n\n    /**\n     * Resizes the bounds object to include the given bounds.\n     * @param left - The left value of the bounds.\n     * @param right - The right value of the bounds.\n     * @param top - The top value of the bounds.\n     * @param bottom - The bottom value of the bounds.\n     */\n    public fitBounds(left: number, right: number, top: number, bottom: number): this\n    {\n        if (this.minX < left) this.minX = left;\n        if (this.maxX > right) this.maxX = right;\n\n        if (this.minY < top) this.minY = top;\n        if (this.maxY > bottom) this.maxY = bottom;\n\n        return this;\n    }\n\n    /**\n     * Pads bounds object, making it grow in all directions.\n     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n     * @param paddingX - The horizontal padding amount.\n     * @param paddingY - The vertical padding amount.\n     */\n    public pad(paddingX: number, paddingY: number = paddingX): this\n    {\n        this.minX -= paddingX;\n        this.maxX += paddingX;\n\n        this.minY -= paddingY;\n        this.maxY += paddingY;\n\n        return this;\n    }\n\n    /** Ceils the bounds. */\n    public ceil(): this\n    {\n        this.minX = Math.floor(this.minX);\n        this.minY = Math.floor(this.minY);\n        this.maxX = Math.ceil(this.maxX);\n        this.maxY = Math.ceil(this.maxY);\n\n        return this;\n    }\n\n    /** Clones the bounds. */\n    public clone(): Bounds\n    {\n        return new Bounds(this.minX, this.minY, this.maxX, this.maxY);\n    }\n\n    /**\n     * Scales the bounds by the given values\n     * @param x - The X value to scale by.\n     * @param y - The Y value to scale by.\n     */\n    public scale(x: number, y: number = x): this\n    {\n        this.minX *= x;\n        this.minY *= y;\n        this.maxX *= x;\n        this.maxY *= y;\n\n        return this;\n    }\n\n    /** the x value of the bounds. */\n    get x(): number\n    {\n        return this.minX;\n    }\n    set x(value: number)\n    {\n        const width = this.maxX - this.minX;\n\n        this.minX = value;\n        this.maxX = value + width;\n    }\n\n    /** the y value of the bounds. */\n    get y(): number\n    {\n        return this.minY;\n    }\n\n    set y(value: number)\n    {\n        const height = this.maxY - this.minY;\n\n        this.minY = value;\n        this.maxY = value + height;\n    }\n\n    /** the width value of the bounds. */\n    get width(): number\n    {\n        return this.maxX - this.minX;\n    }\n\n    set width(value: number)\n    {\n        this.maxX = this.minX + value;\n    }\n\n    /** the height value of the bounds. */\n    get height(): number\n    {\n        return this.maxY - this.minY;\n    }\n\n    set height(value: number)\n    {\n        this.maxY = this.minY + value;\n    }\n\n    /** the left value of the bounds. */\n    get left(): number\n    {\n        return this.minX;\n    }\n\n    /** the right value of the bounds. */\n    get right(): number\n    {\n        return this.maxX;\n    }\n\n    /** the top value of the bounds. */\n    get top(): number\n    {\n        return this.minY;\n    }\n\n    /** the bottom value of the bounds. */\n    get bottom(): number\n    {\n        return this.maxY;\n    }\n\n    /** Is the bounds positive. */\n    get isPositive(): boolean\n    {\n        return (this.maxX - this.minX > 0) && (this.maxY - this.minY > 0);\n    }\n\n    get isValid(): boolean\n    {\n        return (this.minX + this.minY !== Infinity);\n    }\n\n    /**\n     * Adds screen vertices from array\n     * @param vertexData - calculated vertices\n     * @param beginOffset - begin offset\n     * @param endOffset - end offset, excluded\n     * @param matrix\n     */\n    public addVertexData(vertexData: Float32Array, beginOffset: number, endOffset: number, matrix?: Matrix): void\n    {\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        matrix ||= this.matrix;\n\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        for (let i = beginOffset; i < endOffset; i += 2)\n        {\n            const localX = vertexData[i];\n            const localY = vertexData[i + 1];\n\n            const x = (a * localX) + (c * localY) + tx;\n            const y = (b * localX) + (d * localY) + ty;\n\n            minX = x < minX ? x : minX;\n            minY = y < minY ? y : minY;\n            maxX = x > maxX ? x : maxX;\n            maxY = y > maxY ? y : maxY;\n        }\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Checks if the point is contained within the bounds.\n     * @param x - x coordinate\n     * @param y - y coordinate\n     */\n    public containsPoint(x: number, y: number): boolean\n    {\n        if (this.minX <= x && this.minY <= y && this.maxX >= x && this.maxY >= y)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    public toString(): string\n    {\n        // eslint-disable-next-line max-len\n        return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;\n    }\n}\n\n","import { Point } from '../point/Point.mjs';\n\n\"use strict\";\nconst tempPoints = [new Point(), new Point(), new Point(), new Point()];\nclass Rectangle {\n  /**\n   * @param x - The X coordinate of the upper-left corner of the rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rectangle\n   * @param width - The overall width of the rectangle\n   * @param height - The overall height of the rectangle\n   */\n  constructor(x = 0, y = 0, width = 0, height = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'rectangle'\n     */\n    this.type = \"rectangle\";\n    this.x = Number(x);\n    this.y = Number(y);\n    this.width = Number(width);\n    this.height = Number(height);\n  }\n  /** Returns the left edge of the rectangle. */\n  get left() {\n    return this.x;\n  }\n  /** Returns the right edge of the rectangle. */\n  get right() {\n    return this.x + this.width;\n  }\n  /** Returns the top edge of the rectangle. */\n  get top() {\n    return this.y;\n  }\n  /** Returns the bottom edge of the rectangle. */\n  get bottom() {\n    return this.y + this.height;\n  }\n  /** Determines whether the Rectangle is empty. */\n  isEmpty() {\n    return this.left === this.right || this.top === this.bottom;\n  }\n  /** A constant empty rectangle. This is a new object every time the property is accessed */\n  static get EMPTY() {\n    return new Rectangle(0, 0, 0, 0);\n  }\n  /**\n   * Creates a clone of this Rectangle\n   * @returns a copy of the rectangle\n   */\n  clone() {\n    return new Rectangle(this.x, this.y, this.width, this.height);\n  }\n  /**\n   * Converts a Bounds object to a Rectangle object.\n   * @param bounds - The bounds to copy and convert to a rectangle.\n   * @returns Returns itself.\n   */\n  copyFromBounds(bounds) {\n    this.x = bounds.minX;\n    this.y = bounds.minY;\n    this.width = bounds.maxX - bounds.minX;\n    this.height = bounds.maxY - bounds.minY;\n    return this;\n  }\n  /**\n   * Copies another rectangle to this one.\n   * @param rectangle - The rectangle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(rectangle) {\n    this.x = rectangle.x;\n    this.y = rectangle.y;\n    this.width = rectangle.width;\n    this.height = rectangle.height;\n    return this;\n  }\n  /**\n   * Copies this rectangle to another one.\n   * @param rectangle - The rectangle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(rectangle) {\n    rectangle.copyFrom(this);\n    return rectangle;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this Rectangle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Rectangle\n   */\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    if (x >= this.x && x < this.x + this.width) {\n      if (y >= this.y && y < this.y + this.height) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this rectangle\n   */\n  strokeContains(x, y, strokeWidth) {\n    const { width, height } = this;\n    if (width <= 0 || height <= 0)\n      return false;\n    const _x = this.x;\n    const _y = this.y;\n    const outerLeft = _x - strokeWidth / 2;\n    const outerRight = _x + width + strokeWidth / 2;\n    const outerTop = _y - strokeWidth / 2;\n    const outerBottom = _y + height + strokeWidth / 2;\n    const innerLeft = _x + strokeWidth / 2;\n    const innerRight = _x + width - strokeWidth / 2;\n    const innerTop = _y + strokeWidth / 2;\n    const innerBottom = _y + height - strokeWidth / 2;\n    return x >= outerLeft && x <= outerRight && y >= outerTop && y <= outerBottom && !(x > innerLeft && x < innerRight && y > innerTop && y < innerBottom);\n  }\n  /**\n   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n   * Returns true only if the area of the intersection is >0, this means that Rectangles\n   * sharing a side are not overlapping. Another side effect is that an arealess rectangle\n   * (width or height equal to zero) can't intersect any other rectangle.\n   * @param {Rectangle} other - The Rectangle to intersect with `this`.\n   * @param {Matrix} transform - The transformation matrix of `other`.\n   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\n   */\n  intersects(other, transform) {\n    if (!transform) {\n      const x02 = this.x < other.x ? other.x : this.x;\n      const x12 = this.right > other.right ? other.right : this.right;\n      if (x12 <= x02) {\n        return false;\n      }\n      const y02 = this.y < other.y ? other.y : this.y;\n      const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;\n      return y12 > y02;\n    }\n    const x0 = this.left;\n    const x1 = this.right;\n    const y0 = this.top;\n    const y1 = this.bottom;\n    if (x1 <= x0 || y1 <= y0) {\n      return false;\n    }\n    const lt = tempPoints[0].set(other.left, other.top);\n    const lb = tempPoints[1].set(other.left, other.bottom);\n    const rt = tempPoints[2].set(other.right, other.top);\n    const rb = tempPoints[3].set(other.right, other.bottom);\n    if (rt.x <= lt.x || lb.y <= lt.y) {\n      return false;\n    }\n    const s = Math.sign(transform.a * transform.d - transform.b * transform.c);\n    if (s === 0) {\n      return false;\n    }\n    transform.apply(lt, lt);\n    transform.apply(lb, lb);\n    transform.apply(rt, rt);\n    transform.apply(rb, rb);\n    if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {\n      return false;\n    }\n    const nx = s * (lb.y - lt.y);\n    const ny = s * (lt.x - lb.x);\n    const n00 = nx * x0 + ny * y0;\n    const n10 = nx * x1 + ny * y0;\n    const n01 = nx * x0 + ny * y1;\n    const n11 = nx * x1 + ny * y1;\n    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {\n      return false;\n    }\n    const mx = s * (lt.y - rt.y);\n    const my = s * (rt.x - lt.x);\n    const m00 = mx * x0 + my * y0;\n    const m10 = mx * x1 + my * y0;\n    const m01 = mx * x0 + my * y1;\n    const m11 = mx * x1 + my * y1;\n    if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Pads the rectangle making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   * @returns Returns itself.\n   */\n  pad(paddingX = 0, paddingY = paddingX) {\n    this.x -= paddingX;\n    this.y -= paddingY;\n    this.width += paddingX * 2;\n    this.height += paddingY * 2;\n    return this;\n  }\n  /**\n   * Fits this rectangle around the passed one.\n   * @param rectangle - The rectangle to fit.\n   * @returns Returns itself.\n   */\n  fit(rectangle) {\n    const x1 = Math.max(this.x, rectangle.x);\n    const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n    const y1 = Math.max(this.y, rectangle.y);\n    const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n    this.x = x1;\n    this.width = Math.max(x2 - x1, 0);\n    this.y = y1;\n    this.height = Math.max(y2 - y1, 0);\n    return this;\n  }\n  /**\n   * Enlarges rectangle that way its corners lie on grid\n   * @param resolution - resolution\n   * @param eps - precision\n   * @returns Returns itself.\n   */\n  ceil(resolution = 1, eps = 1e-3) {\n    const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n    const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n    this.x = Math.floor((this.x + eps) * resolution) / resolution;\n    this.y = Math.floor((this.y + eps) * resolution) / resolution;\n    this.width = x2 - this.x;\n    this.height = y2 - this.y;\n    return this;\n  }\n  /**\n   * Enlarges this rectangle to include the passed rectangle.\n   * @param rectangle - The rectangle to include.\n   * @returns Returns itself.\n   */\n  enlarge(rectangle) {\n    const x1 = Math.min(this.x, rectangle.x);\n    const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n    const y1 = Math.min(this.y, rectangle.y);\n    const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n    this.x = x1;\n    this.width = x2 - x1;\n    this.y = y1;\n    this.height = y2 - y1;\n    return this;\n  }\n  /**\n   * Returns the framing rectangle of the rectangle as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle();\n    out.copyFrom(this);\n    return out;\n  }\n  toString() {\n    return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n  }\n}\n\nexport { Rectangle };\n//# sourceMappingURL=Rectangle.mjs.map\n","// import { SHAPES } from '../const';\nimport { Point } from '../point/Point';\n\nimport type { Bounds } from '../../scene/container/bounds/Bounds';\nimport type { Matrix } from '../matrix/Matrix';\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\nconst tempPoints = [new Point(), new Point(), new Point(), new Point()];\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface Rectangle extends PixiMixins.Rectangle { }\n\n/**\n * The `Rectangle` object is an area defined by its position, as indicated by its top-left corner\n * point (`x`, `y`) and by its `width` and its `height`.\n *\n * It also provides convenience methods to get and set the position and size of the rectangle such as\n * {@link maths.Rectangle#bottom|bottom}, {@link maths.Rectangle#right|right} and {@link maths.Rectangle#isEmpty|isEmpty}.\n * @memberof maths\n */\nexport class Rectangle implements ShapePrimitive\n{\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'rectangle'\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'rectangle';\n\n    /**\n     * The X coordinate of the upper-left corner of the rectangle\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the upper-left corner of the rectangle\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The overall width of this rectangle\n     *  @default 0\n     */\n    public width: number;\n\n    /**\n     * The overall height of this rectangle\n     * @default 0\n     */\n    public height: number;\n\n    /**\n     * @param x - The X coordinate of the upper-left corner of the rectangle\n     * @param y - The Y coordinate of the upper-left corner of the rectangle\n     * @param width - The overall width of the rectangle\n     * @param height - The overall height of the rectangle\n     */\n    constructor(x: string | number = 0, y: string | number = 0, width: string | number = 0, height: string | number = 0)\n    {\n        this.x = Number(x);\n        this.y = Number(y);\n        this.width = Number(width);\n        this.height = Number(height);\n    }\n\n    /** Returns the left edge of the rectangle. */\n    get left(): number\n    {\n        return this.x;\n    }\n\n    /** Returns the right edge of the rectangle. */\n    get right(): number\n    {\n        return this.x + this.width;\n    }\n\n    /** Returns the top edge of the rectangle. */\n    get top(): number\n    {\n        return this.y;\n    }\n\n    /** Returns the bottom edge of the rectangle. */\n    get bottom(): number\n    {\n        return this.y + this.height;\n    }\n\n    /** Determines whether the Rectangle is empty. */\n    public isEmpty(): boolean\n    {\n        return this.left === this.right || this.top === this.bottom;\n    }\n\n    /** A constant empty rectangle. This is a new object every time the property is accessed */\n    static get EMPTY(): Rectangle\n    {\n        return new Rectangle(0, 0, 0, 0);\n    }\n\n    /**\n     * Creates a clone of this Rectangle\n     * @returns a copy of the rectangle\n     */\n    public clone(): Rectangle\n    {\n        return new Rectangle(this.x, this.y, this.width, this.height);\n    }\n\n    /**\n     * Converts a Bounds object to a Rectangle object.\n     * @param bounds - The bounds to copy and convert to a rectangle.\n     * @returns Returns itself.\n     */\n    public copyFromBounds(bounds: Bounds): this\n    {\n        this.x = bounds.minX;\n        this.y = bounds.minY;\n        this.width = bounds.maxX - bounds.minX;\n        this.height = bounds.maxY - bounds.minY;\n\n        return this;\n    }\n\n    /**\n     * Copies another rectangle to this one.\n     * @param rectangle - The rectangle to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(rectangle: Rectangle): Rectangle\n    {\n        this.x = rectangle.x;\n        this.y = rectangle.y;\n        this.width = rectangle.width;\n        this.height = rectangle.height;\n\n        return this;\n    }\n\n    /**\n     * Copies this rectangle to another one.\n     * @param rectangle - The rectangle to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(rectangle: Rectangle): Rectangle\n    {\n        rectangle.copyFrom(this);\n\n        return rectangle;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this Rectangle\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coordinates are within this Rectangle\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.width <= 0 || this.height <= 0)\n        {\n            return false;\n        }\n\n        if (x >= this.x && x < this.x + this.width)\n        {\n            if (y >= this.y && y < this.y + this.height)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @returns Whether the x/y coordinates are within this rectangle\n     */\n    public strokeContains(x: number, y: number, strokeWidth: number): boolean\n    {\n        const { width, height } = this;\n\n        if (width <= 0 || height <= 0) return false;\n\n        const _x = this.x;\n        const _y = this.y;\n\n        const outerLeft = _x - (strokeWidth / 2);\n        const outerRight = _x + width + (strokeWidth / 2);\n        const outerTop = _y - (strokeWidth / 2);\n        const outerBottom = _y + height + (strokeWidth / 2);\n        const innerLeft = _x + (strokeWidth / 2);\n        const innerRight = _x + width - (strokeWidth / 2);\n        const innerTop = _y + (strokeWidth / 2);\n        const innerBottom = _y + height - (strokeWidth / 2);\n\n        return (x >= outerLeft && x <= outerRight && y >= outerTop && y <= outerBottom)\n        && !(x > innerLeft && x < innerRight && y > innerTop && y < innerBottom);\n    }\n    /**\n     * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n     * Returns true only if the area of the intersection is >0, this means that Rectangles\n     * sharing a side are not overlapping. Another side effect is that an arealess rectangle\n     * (width or height equal to zero) can't intersect any other rectangle.\n     * @param {Rectangle} other - The Rectangle to intersect with `this`.\n     * @param {Matrix} transform - The transformation matrix of `other`.\n     * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\n     */\n    public intersects(other: Rectangle, transform?: Matrix): boolean\n    {\n        if (!transform)\n        {\n            const x0 = this.x < other.x ? other.x : this.x;\n            const x1 = this.right > other.right ? other.right : this.right;\n\n            if (x1 <= x0)\n            {\n                return false;\n            }\n\n            const y0 = this.y < other.y ? other.y : this.y;\n            const y1 = this.bottom > other.bottom ? other.bottom : this.bottom;\n\n            return y1 > y0;\n        }\n\n        const x0 = this.left;\n        const x1 = this.right;\n        const y0 = this.top;\n        const y1 = this.bottom;\n\n        if (x1 <= x0 || y1 <= y0)\n        {\n            return false;\n        }\n\n        const lt = tempPoints[0].set(other.left, other.top);\n        const lb = tempPoints[1].set(other.left, other.bottom);\n        const rt = tempPoints[2].set(other.right, other.top);\n        const rb = tempPoints[3].set(other.right, other.bottom);\n\n        if (rt.x <= lt.x || lb.y <= lt.y)\n        {\n            return false;\n        }\n\n        const s = Math.sign((transform.a * transform.d) - (transform.b * transform.c));\n\n        if (s === 0)\n        {\n            return false;\n        }\n\n        transform.apply(lt, lt);\n        transform.apply(lb, lb);\n        transform.apply(rt, rt);\n        transform.apply(rb, rb);\n\n        if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0\n            || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1\n            || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0\n            || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1)\n        {\n            return false;\n        }\n\n        const nx = s * (lb.y - lt.y);\n        const ny = s * (lt.x - lb.x);\n        const n00 = (nx * x0) + (ny * y0);\n        const n10 = (nx * x1) + (ny * y0);\n        const n01 = (nx * x0) + (ny * y1);\n        const n11 = (nx * x1) + (ny * y1);\n\n        if (Math.max(n00, n10, n01, n11) <= (nx * lt.x) + (ny * lt.y)\n            || Math.min(n00, n10, n01, n11) >= (nx * rb.x) + (ny * rb.y))\n        {\n            return false;\n        }\n\n        const mx = s * (lt.y - rt.y);\n        const my = s * (rt.x - lt.x);\n        const m00 = (mx * x0) + (my * y0);\n        const m10 = (mx * x1) + (my * y0);\n        const m01 = (mx * x0) + (my * y1);\n        const m11 = (mx * x1) + (my * y1);\n\n        if (Math.max(m00, m10, m01, m11) <= (mx * lt.x) + (my * lt.y)\n            || Math.min(m00, m10, m01, m11) >= (mx * rb.x) + (my * rb.y))\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Pads the rectangle making it grow in all directions.\n     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n     * @param paddingX - The horizontal padding amount.\n     * @param paddingY - The vertical padding amount.\n     * @returns Returns itself.\n     */\n    public pad(paddingX = 0, paddingY = paddingX): this\n    {\n        this.x -= paddingX;\n        this.y -= paddingY;\n\n        this.width += paddingX * 2;\n        this.height += paddingY * 2;\n\n        return this;\n    }\n\n    /**\n     * Fits this rectangle around the passed one.\n     * @param rectangle - The rectangle to fit.\n     * @returns Returns itself.\n     */\n    public fit(rectangle: Rectangle): this\n    {\n        const x1 = Math.max(this.x, rectangle.x);\n        const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n        const y1 = Math.max(this.y, rectangle.y);\n        const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n\n        this.x = x1;\n        this.width = Math.max(x2 - x1, 0);\n        this.y = y1;\n        this.height = Math.max(y2 - y1, 0);\n\n        return this;\n    }\n\n    /**\n     * Enlarges rectangle that way its corners lie on grid\n     * @param resolution - resolution\n     * @param eps - precision\n     * @returns Returns itself.\n     */\n    public ceil(resolution = 1, eps = 0.001): this\n    {\n        const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n        const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n\n        this.x = Math.floor((this.x + eps) * resolution) / resolution;\n        this.y = Math.floor((this.y + eps) * resolution) / resolution;\n\n        this.width = x2 - this.x;\n        this.height = y2 - this.y;\n\n        return this;\n    }\n\n    /**\n     * Enlarges this rectangle to include the passed rectangle.\n     * @param rectangle - The rectangle to include.\n     * @returns Returns itself.\n     */\n    public enlarge(rectangle: Rectangle): this\n    {\n        const x1 = Math.min(this.x, rectangle.x);\n        const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n        const y1 = Math.min(this.y, rectangle.y);\n        const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n\n        this.x = x1;\n        this.width = x2 - x1;\n        this.y = y1;\n        this.height = y2 - y1;\n\n        return this;\n    }\n\n    /**\n     * Returns the framing rectangle of the rectangle as a Rectangle object\n     * @param out - optional rectangle to store the result\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out = out || new Rectangle();\n        out.copyFrom(this);\n\n        return out;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n    }\n    // #endif\n}\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { matrixPool, boundsPool } from './utils/matrixAndBoundsPool.mjs';\n\n\"use strict\";\nfunction getGlobalBounds(target, skipUpdateTransform, bounds) {\n  bounds.clear();\n  let parentTransform;\n  let pooledMatrix;\n  if (target.parent) {\n    if (!skipUpdateTransform) {\n      pooledMatrix = matrixPool.get().identity();\n      parentTransform = updateTransformBackwards(target, pooledMatrix);\n    } else {\n      parentTransform = target.parent.worldTransform;\n    }\n  } else {\n    parentTransform = Matrix.IDENTITY;\n  }\n  _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);\n  if (pooledMatrix) {\n    matrixPool.return(pooledMatrix);\n  }\n  if (!bounds.isValid) {\n    bounds.set(0, 0, 0, 0);\n  }\n  return bounds;\n}\nfunction _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform) {\n  if (!target.visible || !target.measurable)\n    return;\n  let worldTransform;\n  if (!skipUpdateTransform) {\n    target.updateLocalTransform();\n    worldTransform = matrixPool.get();\n    worldTransform.appendFrom(target.localTransform, parentTransform);\n  } else {\n    worldTransform = target.worldTransform;\n  }\n  const parentBounds = bounds;\n  const preserveBounds = !!target.effects.length;\n  if (preserveBounds) {\n    bounds = boundsPool.get().clear();\n  }\n  if (target.boundsArea) {\n    bounds.addRect(target.boundsArea, worldTransform);\n  } else {\n    if (target.addBounds) {\n      bounds.matrix = worldTransform;\n      target.addBounds(bounds);\n    }\n    for (let i = 0; i < target.children.length; i++) {\n      _getGlobalBounds(target.children[i], bounds, worldTransform, skipUpdateTransform);\n    }\n  }\n  if (preserveBounds) {\n    for (let i = 0; i < target.effects.length; i++) {\n      target.effects[i].addBounds?.(bounds);\n    }\n    parentBounds.addBounds(bounds, Matrix.IDENTITY);\n    boundsPool.return(bounds);\n  }\n  if (!skipUpdateTransform) {\n    matrixPool.return(worldTransform);\n  }\n}\nfunction updateTransformBackwards(target, parentTransform) {\n  const parent = target.parent;\n  if (parent) {\n    updateTransformBackwards(parent, parentTransform);\n    parent.updateLocalTransform();\n    parentTransform.append(parent.localTransform);\n  }\n  return parentTransform;\n}\n\nexport { _getGlobalBounds, getGlobalBounds, updateTransformBackwards };\n//# sourceMappingURL=getGlobalBounds.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { boundsPool, matrixPool } from './utils/matrixAndBoundsPool';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Container } from '../Container';\nimport type { Bounds } from './Bounds';\n\nexport function getGlobalBounds(target: Container, skipUpdateTransform: boolean, bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    let parentTransform;\n    let pooledMatrix;\n\n    if (target.parent)\n    {\n        if (!skipUpdateTransform)\n        {\n            pooledMatrix = matrixPool.get().identity();\n            parentTransform = updateTransformBackwards(target, pooledMatrix);\n        }\n        else\n        {\n            parentTransform = target.parent.worldTransform;\n        }\n    }\n    else\n    {\n        parentTransform = Matrix.IDENTITY;\n    }\n\n    // then collect them...\n\n    _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);\n\n    if (pooledMatrix)\n    {\n        matrixPool.return(pooledMatrix);\n    }\n\n    if (!bounds.isValid)\n    {\n        bounds.set(0, 0, 0, 0);\n    }\n\n    return bounds;\n}\n\nexport function _getGlobalBounds(\n    target: Container,\n    bounds: Bounds,\n    parentTransform: Matrix,\n    skipUpdateTransform: boolean,\n): void\n{\n    if (!target.visible || !target.measurable) return;\n\n    let worldTransform: Matrix;\n\n    if (!skipUpdateTransform)\n    {\n        target.updateLocalTransform();\n\n        worldTransform = matrixPool.get();\n\n        worldTransform.appendFrom(target.localTransform, parentTransform);\n    }\n    else\n    {\n        worldTransform = target.worldTransform;\n    }\n\n    const parentBounds = bounds;\n    const preserveBounds = !!target.effects.length;\n\n    if (preserveBounds)\n    {\n        bounds = boundsPool.get().clear();\n    }\n\n    if (target.boundsArea)\n    {\n        bounds.addRect(target.boundsArea, worldTransform);\n    }\n    else\n    {\n        if ((target as Renderable).addBounds)\n        {\n            // save a copy\n            bounds.matrix = worldTransform;\n\n            (target as Renderable).addBounds(bounds);\n        }\n\n        for (let i = 0; i < target.children.length; i++)\n        {\n            _getGlobalBounds(target.children[i], bounds, worldTransform, skipUpdateTransform);\n        }\n    }\n\n    if (preserveBounds)\n    {\n        for (let i = 0; i < target.effects.length; i++)\n        {\n            target.effects[i].addBounds?.(bounds);\n        }\n\n        parentBounds.addBounds(bounds, Matrix.IDENTITY);\n\n        boundsPool.return(bounds);\n    }\n\n    if (!skipUpdateTransform)\n    {\n        matrixPool.return(worldTransform);\n    }\n}\n\nexport function updateTransformBackwards(target: Container, parentTransform: Matrix)\n{\n    const parent = target.parent;\n\n    if (parent)\n    {\n        updateTransformBackwards(parent, parentTransform);\n\n        parent.updateLocalTransform();\n\n        parentTransform.append(parent.localTransform);\n    }\n\n    return parentTransform;\n}\n","import { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Pool } from '../../../../utils/pool/Pool.mjs';\nimport { Bounds } from '../Bounds.mjs';\n\n\"use strict\";\nconst matrixPool = new Pool(Matrix);\nconst boundsPool = new Pool(Bounds);\n\nexport { boundsPool, matrixPool };\n//# sourceMappingURL=matrixAndBoundsPool.mjs.map\n","import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Pool } from '../../../../utils/pool/Pool';\nimport { Bounds } from '../Bounds';\n\nimport type { PoolItem } from '../../../../utils/pool/Pool';\n\ntype MatrixPoolItem = Matrix & PoolItem;\ntype BoundsPoolItem = Bounds & PoolItem;\nexport const matrixPool = new Pool<MatrixPoolItem>(Matrix);\nexport const boundsPool = new Pool<BoundsPoolItem>(Bounds);\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { warn } from '../../../utils/logging/warn.mjs';\nimport { matrixPool, boundsPool } from './utils/matrixAndBoundsPool.mjs';\n\n\"use strict\";\nfunction getLocalBounds(target, bounds, relativeMatrix) {\n  bounds.clear();\n  relativeMatrix || (relativeMatrix = Matrix.IDENTITY);\n  _getLocalBounds(target, bounds, relativeMatrix, target, true);\n  if (!bounds.isValid) {\n    bounds.set(0, 0, 0, 0);\n  }\n  return bounds;\n}\nfunction _getLocalBounds(target, bounds, parentTransform, rootContainer, isRoot) {\n  let relativeTransform;\n  if (!isRoot) {\n    if (!target.visible || !target.measurable)\n      return;\n    target.updateLocalTransform();\n    const localTransform = target.localTransform;\n    relativeTransform = matrixPool.get();\n    relativeTransform.appendFrom(localTransform, parentTransform);\n  } else {\n    relativeTransform = matrixPool.get();\n    relativeTransform = parentTransform.copyTo(relativeTransform);\n  }\n  const parentBounds = bounds;\n  const preserveBounds = !!target.effects.length;\n  if (preserveBounds) {\n    bounds = boundsPool.get().clear();\n  }\n  if (target.boundsArea) {\n    bounds.addRect(target.boundsArea, relativeTransform);\n  } else {\n    if (target.renderPipeId) {\n      bounds.matrix = relativeTransform;\n      target.addBounds(bounds);\n    }\n    const children = target.children;\n    for (let i = 0; i < children.length; i++) {\n      _getLocalBounds(children[i], bounds, relativeTransform, rootContainer, false);\n    }\n  }\n  if (preserveBounds) {\n    for (let i = 0; i < target.effects.length; i++) {\n      target.effects[i].addLocalBounds?.(bounds, rootContainer);\n    }\n    parentBounds.addBounds(bounds, Matrix.IDENTITY);\n    boundsPool.return(bounds);\n  }\n  matrixPool.return(relativeTransform);\n}\nfunction getParent(target, root, matrix) {\n  const parent = target.parent;\n  if (!parent) {\n    warn(\"Item is not inside the root container\");\n    return;\n  }\n  if (parent !== root) {\n    getParent(parent, root, matrix);\n    parent.updateLocalTransform();\n    matrix.append(parent.localTransform);\n  }\n}\n\nexport { getLocalBounds, getParent };\n//# sourceMappingURL=getLocalBounds.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { warn } from '../../../utils/logging/warn';\nimport { boundsPool, matrixPool } from './utils/matrixAndBoundsPool';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Container } from '../Container';\nimport type { Bounds } from './Bounds';\n\nexport function getLocalBounds(target: Container, bounds: Bounds, relativeMatrix?: Matrix): Bounds\n{\n    bounds.clear();\n\n    relativeMatrix ||= Matrix.IDENTITY;\n\n    _getLocalBounds(target, bounds, relativeMatrix, target, true);\n\n    if (!bounds.isValid)\n    {\n        bounds.set(0, 0, 0, 0);\n    }\n\n    return bounds;\n}\n\nfunction _getLocalBounds(\n    target: Container,\n    bounds: Bounds,\n    parentTransform: Matrix,\n    rootContainer: Container,\n    isRoot: boolean\n): void\n{\n    let relativeTransform: Matrix;\n\n    if (!isRoot)\n    {\n        if (!target.visible || !target.measurable) return;\n\n        target.updateLocalTransform();\n\n        const localTransform = target.localTransform;\n\n        relativeTransform = matrixPool.get();\n        relativeTransform.appendFrom(localTransform, parentTransform);\n    }\n    else\n    {\n        relativeTransform = matrixPool.get();\n        relativeTransform = parentTransform.copyTo(relativeTransform);\n    }\n\n    const parentBounds = bounds;\n    const preserveBounds = !!target.effects.length;\n\n    if (preserveBounds)\n    {\n        bounds = boundsPool.get().clear();\n    }\n\n    if (target.boundsArea)\n    {\n        bounds.addRect(target.boundsArea, relativeTransform);\n    }\n    else\n    {\n        if (target.renderPipeId)\n        {\n            bounds.matrix = relativeTransform;\n            (target as Renderable).addBounds(bounds);\n        }\n\n        const children = target.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            _getLocalBounds(children[i], bounds, relativeTransform, rootContainer, false);\n        }\n    }\n\n    if (preserveBounds)\n    {\n        for (let i = 0; i < target.effects.length; i++)\n        {\n            target.effects[i].addLocalBounds?.(bounds, rootContainer);\n        }\n\n        // TODO - make a add transformed bounds?\n        parentBounds.addBounds(bounds, Matrix.IDENTITY);\n\n        boundsPool.return(bounds);\n    }\n\n    matrixPool.return(relativeTransform);\n}\n\nexport function getParent(target: Container, root: Container, matrix: Matrix)\n{\n    const parent = target.parent;\n\n    if (!parent)\n    {\n        // we have reach the top of the tree!\n        // #if _DEBUG\n        warn('Item is not inside the root container');\n        // #endif\n\n        return;\n    }\n\n    if (parent !== root)\n    {\n        getParent(parent, root, matrix);\n\n        parent.updateLocalTransform();\n        matrix.append(parent.localTransform);\n    }\n}\n\n","\"use strict\";\nlet warnCount = 0;\nconst maxWarnings = 500;\nfunction warn(...args) {\n  if (warnCount === maxWarnings)\n    return;\n  warnCount++;\n  if (warnCount === maxWarnings) {\n    console.warn(\"PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.\");\n  } else {\n    console.warn(\"PixiJS Warning: \", ...args);\n  }\n}\n\nexport { warn };\n//# sourceMappingURL=warn.mjs.map\n","let warnCount = 0;\nconst maxWarnings = 500;\n\n/**\n * Logs a PixiJS warning message to the console. Stops logging after 500 warnings have been logged.\n * @param args - The warning message(s) to log\n * @returns {void}\n * @memberof utils\n * @ignore\n */\nexport function warn(...args: any[])\n{\n    if (warnCount === maxWarnings) return;\n\n    warnCount++;\n\n    if (warnCount === maxWarnings)\n    {\n        console.warn('PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.');\n    }\n    else\n    {\n        console.warn('PixiJS Warning: ', ...args);\n    }\n}\n","\"use strict\";\nfunction checkChildrenDidChange(container, previousData) {\n  const children = container.children;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    const changeId = (child.uid & 255) << 24 | child._didChangeId & 16777215;\n    if (previousData.data[previousData.index] !== changeId) {\n      previousData.data[previousData.index] = changeId;\n      previousData.didChange = true;\n    }\n    previousData.index++;\n    if (child.children.length) {\n      checkChildrenDidChange(child, previousData);\n    }\n  }\n  return previousData.didChange;\n}\n\nexport { checkChildrenDidChange };\n//# sourceMappingURL=checkChildrenDidChange.mjs.map\n","import type { Container } from '../Container';\n\n/**\n * This function will crawl through the container essentially check if the children have changed.\n *\n * This function checkChildrenDidChange recursively checks if any child in a Container\n * or its children has changed. It does this by comparing a generated changeId for each\n * child against a stored value in previousData.\n * The changeId is a combination of the child's uid and _didChangeId, bitwise manipulated for uniqueness.\n * If a change is detected, it updates previousData and sets didChange to true.\n * The function returns a boolean indicating if any change was detected in the entire hierarchy of children.\n * @param container - the container to check for changes\n * @param previousData - the previous data from the last check made\n * @param previousData.data - the data array\n * @param previousData.index - the index of the data array\n * @param previousData.didChange - did the data change\n */\nexport function checkChildrenDidChange(\n    container: Container,\n    previousData: {\n        data: number[];\n        index: number;\n        didChange: boolean;\n    })\n{\n    const children = container.children;\n\n    for (let i = 0; i < children.length; i++)\n    {\n        const child = children[i];\n\n        const changeId = ((child.uid & 255) << 24)\n            | (child._didChangeId & 16777215);\n\n        if (previousData.data[previousData.index] !== changeId)\n        {\n            previousData.data[previousData.index] = changeId;\n\n            previousData.didChange = true;\n        }\n\n        previousData.index++;\n\n        if (child.children.length)\n        {\n            checkChildrenDidChange(child, previousData);\n        }\n    }\n\n    return previousData.didChange;\n}\n","\"use strict\";\nconst onRenderMixin = {\n  _onRender: null,\n  set onRender(func) {\n    const renderGroup = this.renderGroup;\n    if (!func) {\n      if (this._onRender) {\n        renderGroup?.removeOnRender(this);\n      }\n      this._onRender = null;\n      return;\n    }\n    if (!this._onRender) {\n      renderGroup?.addOnRender(this);\n    }\n    this._onRender = func;\n  },\n  /**\n   * This callback is used when the container is rendered. This is where you should add your custom\n   * logic that is needed to be run every frame.\n   *\n   * In v7 many users used `updateTransform` for this, however the way v8 renders objects is different\n   * and \"updateTransform\" is no longer called every frame\n   * @example\n   * const container = new Container();\n   * container.onRender = () => {\n   *    container.rotation += 0.01;\n   * };\n   * @memberof scene.Container#\n   */\n  get onRender() {\n    return this._onRender;\n  }\n};\n\nexport { onRenderMixin };\n//# sourceMappingURL=onRenderMixin.mjs.map\n","import type { Container } from '../Container';\n\nexport interface OnRenderMixinConstructor\n{\n    onRender?: (() => void | null);\n}\nexport interface OnRenderMixin extends Required<OnRenderMixinConstructor>\n{\n    _onRender: (() => void) | null;\n}\n\nexport const onRenderMixin: Partial<Container> = {\n    _onRender: null,\n\n    set onRender(func: () => void)\n    {\n        const renderGroup = this.renderGroup;\n\n        if (!func)\n        {\n            if (this._onRender)\n            {\n                renderGroup?.removeOnRender(this);\n            }\n\n            this._onRender = null;\n\n            return;\n        }\n\n        if (!this._onRender)\n        {\n            renderGroup?.addOnRender(this);\n        }\n\n        this._onRender = func;\n    },\n\n    /**\n     * This callback is used when the container is rendered. This is where you should add your custom\n     * logic that is needed to be run every frame.\n     *\n     * In v7 many users used `updateTransform` for this, however the way v8 renders objects is different\n     * and \"updateTransform\" is no longer called every frame\n     * @example\n     * const container = new Container();\n     * container.onRender = () => {\n     *    container.rotation += 0.01;\n     * };\n     * @memberof scene.Container#\n     */\n    get onRender(): () => void\n    {\n        return this._onRender;\n    }\n} as Container;\n","\"use strict\";\nconst sortMixin = {\n  _zIndex: 0,\n  /**\n   * Should children be sorted by zIndex at the next render call.\n   *\n   * Will get automatically set to true if a new child is added, or if a child's zIndex changes.\n   * @type {boolean}\n   * @memberof scene.Container#\n   */\n  sortDirty: false,\n  /**\n   * If set to true, the container will sort its children by `zIndex` value\n   * when the next render is called, or manually if `sortChildren()` is called.\n   *\n   * This actually changes the order of elements in the array, so should be treated\n   * as a basic solution that is not performant compared to other solutions,\n   * such as {@link https://github.com/pixijs/layers PixiJS Layers}\n   *\n   * Also be aware of that this may not work nicely with the `addChildAt()` function,\n   * as the `zIndex` sorting may cause the child to automatically sorted to another position.\n   * @type {boolean}\n   * @memberof scene.Container#\n   */\n  sortableChildren: false,\n  /**\n   * The zIndex of the container.\n   *\n   * Setting this value, will automatically set the parent to be sortable. Children will be automatically\n   * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\n   * and thus rendered on top of other display objects within the same container.\n   * @see scene.Container#sortableChildren\n   * @memberof scene.Container#\n   */\n  get zIndex() {\n    return this._zIndex;\n  },\n  set zIndex(value) {\n    if (this._zIndex === value)\n      return;\n    this._zIndex = value;\n    this.depthOfChildModified();\n  },\n  depthOfChildModified() {\n    if (this.parent) {\n      this.parent.sortableChildren = true;\n      this.parent.sortDirty = true;\n    }\n    if (this.renderGroup && !this.isRenderGroupRoot) {\n      this.renderGroup.structureDidChange = true;\n    }\n  },\n  /**\n   * Sorts children by zIndex.\n   * @memberof scene.Container#\n   */\n  sortChildren() {\n    if (!this.sortDirty)\n      return;\n    this.sortDirty = false;\n    this.children.sort(sortChildren);\n  }\n};\nfunction sortChildren(a, b) {\n  return a._zIndex - b._zIndex;\n}\n\nexport { sortMixin };\n//# sourceMappingURL=sortMixin.mjs.map\n","import type { Container } from '../Container';\n\nexport interface SortMixinConstructor\n{\n    zIndex?: number;\n    sortDirty?: boolean;\n    sortableChildren?: boolean;\n}\nexport interface SortMixin extends Required<SortMixinConstructor>\n{\n    _zIndex: number;\n\n    sortChildren: () => void;\n    depthOfChildModified: () => void;\n}\n\nexport const sortMixin: Partial<Container> = {\n    _zIndex: 0,\n    /**\n     * Should children be sorted by zIndex at the next render call.\n     *\n     * Will get automatically set to true if a new child is added, or if a child's zIndex changes.\n     * @type {boolean}\n     * @memberof scene.Container#\n     */\n    sortDirty: false,\n    /**\n     * If set to true, the container will sort its children by `zIndex` value\n     * when the next render is called, or manually if `sortChildren()` is called.\n     *\n     * This actually changes the order of elements in the array, so should be treated\n     * as a basic solution that is not performant compared to other solutions,\n     * such as {@link https://github.com/pixijs/layers PixiJS Layers}\n     *\n     * Also be aware of that this may not work nicely with the `addChildAt()` function,\n     * as the `zIndex` sorting may cause the child to automatically sorted to another position.\n     * @type {boolean}\n     * @memberof scene.Container#\n     */\n    sortableChildren: false,\n\n    /**\n     * The zIndex of the container.\n     *\n     * Setting this value, will automatically set the parent to be sortable. Children will be automatically\n     * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\n     * and thus rendered on top of other display objects within the same container.\n     * @see scene.Container#sortableChildren\n     * @memberof scene.Container#\n     */\n    get zIndex()\n    {\n        return this._zIndex;\n    },\n\n    set zIndex(value: number)\n    {\n        if (this._zIndex === value) return;\n\n        this._zIndex = value;\n\n        this.depthOfChildModified();\n    },\n\n    depthOfChildModified()\n    {\n        if (this.parent)\n        {\n            this.parent.sortableChildren = true;\n            this.parent.sortDirty = true;\n        }\n\n        if (this.renderGroup && !this.isRenderGroupRoot)\n        {\n            this.renderGroup.structureDidChange = true;\n        }\n    },\n\n    /**\n     * Sorts children by zIndex.\n     * @memberof scene.Container#\n     */\n    sortChildren()\n    {\n        if (!this.sortDirty) return;\n\n        this.sortDirty = false;\n\n        this.children.sort(sortChildren);\n    },\n} as Container;\n\nfunction sortChildren(a: Container, b: Container): number\n{\n    return a._zIndex - b._zIndex;\n}\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { Point } from '../../../maths/point/Point.mjs';\nimport { updateTransformBackwards } from '../bounds/getGlobalBounds.mjs';\n\n\"use strict\";\nconst toLocalGlobalMixin = {\n  /**\n   * Returns the global position of the container.\n   * @param point - The optional point to write the global value to.\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - The updated point.\n   * @memberof scene.Container#\n   */\n  getGlobalPosition(point = new Point(), skipUpdate = false) {\n    if (this.parent) {\n      this.parent.toGlobal(this._position, point, skipUpdate);\n    } else {\n      point.x = this._position.x;\n      point.y = this._position.y;\n    }\n    return point;\n  },\n  /**\n   * Calculates the global position of the container.\n   * @param position - The world origin to calculate from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - A point object representing the position of this object.\n   * @memberof scene.Container#\n   */\n  toGlobal(position, point, skipUpdate = false) {\n    if (!skipUpdate) {\n      this.updateLocalTransform();\n      const globalMatrix = updateTransformBackwards(this, new Matrix());\n      globalMatrix.append(this.localTransform);\n      return globalMatrix.apply(position, point);\n    }\n    return this.worldTransform.apply(position, point);\n  },\n  /**\n   * Calculates the local position of the container relative to another point.\n   * @param position - The world origin to calculate from.\n   * @param from - The Container to calculate the global position from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform\n   * @returns - A point object representing the position of this object\n   * @memberof scene.Container#\n   */\n  toLocal(position, from, point, skipUpdate) {\n    if (from) {\n      position = from.toGlobal(position, point, skipUpdate);\n    }\n    if (!skipUpdate) {\n      this.updateLocalTransform();\n      const globalMatrix = updateTransformBackwards(this, new Matrix());\n      globalMatrix.append(this.localTransform);\n      return globalMatrix.applyInverse(position, point);\n    }\n    return this.worldTransform.applyInverse(position, point);\n  }\n};\n\nexport { toLocalGlobalMixin };\n//# sourceMappingURL=toLocalGlobalMixin.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { Point } from '../../../maths/point/Point';\nimport { updateTransformBackwards } from '../bounds/getGlobalBounds';\n\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Container } from '../Container';\n\nexport interface ToLocalGlobalMixin\n{\n    getGlobalPosition(point?: Point, skipUpdate?: boolean): Point;\n    toGlobal<P extends PointData = Point>(position: PointData, point?: P, skipUpdate?: boolean): P;\n    toLocal<P extends PointData = Point>(position: PointData, from?: Container, point?: P, skipUpdate?: boolean): P;\n}\n\nexport const toLocalGlobalMixin: Partial<Container> = {\n    /**\n     * Returns the global position of the container.\n     * @param point - The optional point to write the global value to.\n     * @param skipUpdate - Should we skip the update transform.\n     * @returns - The updated point.\n     * @memberof scene.Container#\n     */\n    getGlobalPosition(point: Point = new Point(), skipUpdate = false): Point\n    {\n        if (this.parent)\n        {\n            this.parent.toGlobal(this._position, point, skipUpdate);\n        }\n        else\n        {\n            point.x = this._position.x;\n            point.y = this._position.y;\n        }\n\n        return point;\n    },\n\n    /**\n     * Calculates the global position of the container.\n     * @param position - The world origin to calculate from.\n     * @param point - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point).\n     * @param skipUpdate - Should we skip the update transform.\n     * @returns - A point object representing the position of this object.\n     * @memberof scene.Container#\n     */\n    toGlobal<P extends PointData = Point>(position: PointData, point?: P, skipUpdate = false): P\n    {\n        if (!skipUpdate)\n        {\n            this.updateLocalTransform();\n\n            const globalMatrix = updateTransformBackwards(this, new Matrix());\n\n            globalMatrix.append(this.localTransform);\n\n            return globalMatrix.apply<P>(position, point);\n        }\n\n        // simply apply the matrix..\n        return this.worldTransform.apply<P>(position, point);\n    },\n\n    /**\n     * Calculates the local position of the container relative to another point.\n     * @param position - The world origin to calculate from.\n     * @param from - The Container to calculate the global position from.\n     * @param point - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point).\n     * @param skipUpdate - Should we skip the update transform\n     * @returns - A point object representing the position of this object\n     * @memberof scene.Container#\n     */\n    toLocal<P extends PointData = Point>(position: PointData, from?: Container, point?: P, skipUpdate?: boolean): P\n    {\n        if (from)\n        {\n            position = from.toGlobal(position, point, skipUpdate);\n        }\n\n        if (!skipUpdate)\n        {\n            this.updateLocalTransform();\n\n            const globalMatrix = updateTransformBackwards(this, new Matrix());\n\n            globalMatrix.append(this.localTransform);\n\n            return globalMatrix.applyInverse<P>(position, point);\n        }\n\n        // simply apply the matrix..\n        return this.worldTransform.applyInverse<P>(position, point);\n    }\n} as Container;\n","import { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet.mjs';\n\n\"use strict\";\nclass RenderGroup {\n  constructor(root) {\n    this.renderPipeId = \"renderGroup\";\n    this.root = null;\n    this.canBundle = false;\n    this.renderGroupParent = null;\n    this.renderGroupChildren = [];\n    this._children = [];\n    this.worldTransform = new Matrix();\n    this.worldColorAlpha = 4294967295;\n    this.worldColor = 16777215;\n    this.worldAlpha = 1;\n    // these updates are transform changes..\n    this.childrenToUpdate = /* @__PURE__ */ Object.create(null);\n    this.updateTick = 0;\n    // these update are renderable changes..\n    this.childrenRenderablesToUpdate = { list: [], index: 0 };\n    // other\n    this.structureDidChange = true;\n    this.instructionSet = new InstructionSet();\n    this._onRenderContainers = [];\n    this.root = root;\n    this.addChild(root);\n  }\n  get localTransform() {\n    return this.root.localTransform;\n  }\n  addRenderGroupChild(renderGroupChild) {\n    if (renderGroupChild.renderGroupParent) {\n      renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);\n    }\n    renderGroupChild.renderGroupParent = this;\n    this.onChildUpdate(renderGroupChild.root);\n    this.renderGroupChildren.push(renderGroupChild);\n  }\n  _removeRenderGroupChild(renderGroupChild) {\n    if (renderGroupChild.root.didChange) {\n      this._removeChildFromUpdate(renderGroupChild.root);\n    }\n    const index = this.renderGroupChildren.indexOf(renderGroupChild);\n    if (index > -1) {\n      this.renderGroupChildren.splice(index, 1);\n    }\n    renderGroupChild.renderGroupParent = null;\n  }\n  addChild(child) {\n    this.structureDidChange = true;\n    if (child !== this.root) {\n      this._children.push(child);\n      child.updateTick = -1;\n      if (child.parent === this.root) {\n        child.relativeRenderGroupDepth = 1;\n      } else {\n        child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;\n      }\n      if (child._onRender) {\n        this.addOnRender(child);\n      }\n    }\n    if (child.renderGroup) {\n      if (child.renderGroup.root === child) {\n        this.addRenderGroupChild(child.renderGroup);\n        return;\n      }\n    } else {\n      child.renderGroup = this;\n      child.didChange = true;\n    }\n    const children = child.children;\n    if (!child.isRenderGroupRoot) {\n      this.onChildUpdate(child);\n    }\n    for (let i = 0; i < children.length; i++) {\n      this.addChild(children[i]);\n    }\n  }\n  removeChild(child) {\n    this.structureDidChange = true;\n    if (child._onRender) {\n      this.removeOnRender(child);\n    }\n    if (child.renderGroup.root !== child) {\n      const children = child.children;\n      for (let i = 0; i < children.length; i++) {\n        this.removeChild(children[i]);\n      }\n      if (child.didChange) {\n        child.renderGroup._removeChildFromUpdate(child);\n      }\n      child.renderGroup = null;\n    } else {\n      this._removeRenderGroupChild(child.renderGroup);\n    }\n    const index = this._children.indexOf(child);\n    if (index > -1) {\n      this._children.splice(index, 1);\n    }\n  }\n  onChildUpdate(child) {\n    let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n    if (!childrenToUpdate) {\n      childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {\n        index: 0,\n        list: []\n      };\n    }\n    childrenToUpdate.list[childrenToUpdate.index++] = child;\n  }\n  // SHOULD THIS BE HERE?\n  updateRenderable(container) {\n    if (container.globalDisplayStatus < 7)\n      return;\n    container.didViewUpdate = false;\n    this.instructionSet.renderPipes[container.renderPipeId].updateRenderable(container);\n  }\n  onChildViewUpdate(child) {\n    this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;\n  }\n  _removeChildFromUpdate(child) {\n    const childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n    if (!childrenToUpdate) {\n      return;\n    }\n    const index = childrenToUpdate.list.indexOf(child);\n    if (index > -1) {\n      childrenToUpdate.list.splice(index, 1);\n    }\n    childrenToUpdate.index--;\n  }\n  get isRenderable() {\n    return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;\n  }\n  /**\n   * adding a container to the onRender list will make sure the user function\n   * passed in to the user defined 'onRender` callBack\n   * @param container - the container to add to the onRender list\n   */\n  addOnRender(container) {\n    this._onRenderContainers.push(container);\n  }\n  removeOnRender(container) {\n    this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);\n  }\n  runOnRender() {\n    for (let i = 0; i < this._onRenderContainers.length; i++) {\n      this._onRenderContainers[i]._onRender();\n    }\n  }\n}\n\nexport { RenderGroup };\n//# sourceMappingURL=RenderGroup.mjs.map\n","import { Matrix } from '../../maths/matrix/Matrix';\nimport { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\n\nimport type { Instruction } from '../../rendering/renderers/shared/instructions/Instruction';\nimport type { Container } from './Container';\n\n/**\n * The render group is the base class for all render groups\n * It is used to render a group of containers together\n * @memberof rendering\n */\nexport class RenderGroup implements Instruction\n{\n    public renderPipeId = 'renderGroup';\n    public root: Container = null;\n\n    public canBundle = false;\n\n    public renderGroupParent: RenderGroup = null;\n    public renderGroupChildren: RenderGroup[] = [];\n\n    private readonly _children: Container[] = [];\n\n    public worldTransform: Matrix = new Matrix();\n    public worldColorAlpha = 0xffffffff;\n    public worldColor = 0xffffff;\n    public worldAlpha = 1;\n\n    // these updates are transform changes..\n    public readonly childrenToUpdate: Record<number, { list: Container[]; index: number; }> = Object.create(null);\n    public updateTick = 0;\n\n    // these update are renderable changes..\n    public readonly childrenRenderablesToUpdate: { list: Container[]; index: number; } = { list: [], index: 0 };\n\n    // other\n    public structureDidChange = true;\n\n    public instructionSet: InstructionSet = new InstructionSet();\n\n    private readonly _onRenderContainers: Container[] = [];\n\n    constructor(root: Container)\n    {\n        this.root = root;\n\n        this.addChild(root);\n    }\n\n    get localTransform()\n    {\n        return this.root.localTransform;\n    }\n\n    public addRenderGroupChild(renderGroupChild: RenderGroup)\n    {\n        if (renderGroupChild.renderGroupParent)\n        {\n            renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);\n        }\n\n        renderGroupChild.renderGroupParent = this;\n\n        this.onChildUpdate(renderGroupChild.root);\n\n        this.renderGroupChildren.push(renderGroupChild);\n    }\n\n    private _removeRenderGroupChild(renderGroupChild: RenderGroup)\n    {\n        if (renderGroupChild.root.didChange)\n        {\n            this._removeChildFromUpdate(renderGroupChild.root);\n        }\n\n        const index = this.renderGroupChildren.indexOf(renderGroupChild);\n\n        if (index > -1)\n        {\n            this.renderGroupChildren.splice(index, 1);\n        }\n\n        renderGroupChild.renderGroupParent = null;\n    }\n\n    public addChild(child: Container)\n    {\n        this.structureDidChange = true;\n\n        // TODO this can be optimized..\n        if (child !== this.root)\n        {\n            this._children.push(child);\n\n            child.updateTick = -1;\n\n            if (child.parent === this.root)\n            {\n                child.relativeRenderGroupDepth = 1;\n            }\n\n            else\n            {\n                child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;\n            }\n\n            if (child._onRender)\n            {\n                this.addOnRender(child);\n            }\n        }\n\n        if (child.renderGroup)\n        {\n            if (child.renderGroup.root === child)\n            {\n                // its already its own render group..\n                this.addRenderGroupChild(child.renderGroup);\n\n                return;\n            }\n        }\n        else\n        {\n            child.renderGroup = this;\n            child.didChange = true;\n        }\n\n        const children = child.children;\n\n        if (!child.isRenderGroupRoot)\n        {\n            this.onChildUpdate(child);\n        }\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this.addChild(children[i]);\n        }\n    }\n\n    public removeChild(child: Container)\n    {\n        // remove all the children...\n        this.structureDidChange = true;\n\n        if (child._onRender)\n        {\n            this.removeOnRender(child);\n        }\n\n        if (child.renderGroup.root !== child)\n        {\n            const children = child.children;\n\n            for (let i = 0; i < children.length; i++)\n            {\n                this.removeChild(children[i]);\n            }\n\n            if (child.didChange)\n            {\n                child.renderGroup._removeChildFromUpdate(child);\n            }\n\n            child.renderGroup = null;\n        }\n\n        else\n        {\n            this._removeRenderGroupChild(child.renderGroup);\n        }\n\n        const index = this._children.indexOf(child);\n\n        if (index > -1)\n        {\n            this._children.splice(index, 1);\n        }\n    }\n\n    public onChildUpdate(child: Container)\n    {\n        let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n\n        if (!childrenToUpdate)\n        {\n            childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {\n                index: 0,\n                list: [],\n            };\n        }\n\n        childrenToUpdate.list[childrenToUpdate.index++] = child;\n    }\n\n    // SHOULD THIS BE HERE?\n    public updateRenderable(container: Container)\n    {\n        // only update if its visible!\n        if (container.globalDisplayStatus < 0b111) return;\n\n        container.didViewUpdate = false;\n        // actually updates the renderable..\n        this.instructionSet.renderPipes[container.renderPipeId].updateRenderable(container);\n    }\n\n    public onChildViewUpdate(child: Container)\n    {\n        this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;\n    }\n\n    private _removeChildFromUpdate(child: Container)\n    {\n        const childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n\n        if (!childrenToUpdate)\n        { return; }\n\n        const index = childrenToUpdate.list.indexOf(child);\n\n        // TODO this should be optimized - don't really want to change array size on the fly if we can avoid!\n        if (index > -1)\n        {\n            childrenToUpdate.list.splice(index, 1);\n        }\n\n        childrenToUpdate.index--;\n    }\n\n    get isRenderable(): boolean\n    {\n        return (this.root.localDisplayStatus === 0b111 && this.worldAlpha > 0);\n    }\n\n    /**\n     * adding a container to the onRender list will make sure the user function\n     * passed in to the user defined 'onRender` callBack\n     * @param container - the container to add to the onRender list\n     */\n    public addOnRender(container: Container)\n    {\n        this._onRenderContainers.push(container);\n    }\n\n    public removeOnRender(container: Container)\n    {\n        this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);\n    }\n\n    public runOnRender()\n    {\n        for (let i = 0; i < this._onRenderContainers.length; i++)\n        {\n            this._onRenderContainers[i]._onRender();\n        }\n    }\n}\n","import { uid } from '../../../../utils/data/uid.mjs';\n\n\"use strict\";\nclass InstructionSet {\n  constructor() {\n    /** a unique id for this instruction set used through the renderer */\n    this.uid = uid(\"instructionSet\");\n    /** the array of instructions */\n    this.instructions = [];\n    /** the actual size of the array (any instructions passed this should be ignored) */\n    this.instructionSize = 0;\n  }\n  /** reset the instruction set so it can be reused set size back to 0 */\n  reset() {\n    this.instructionSize = 0;\n  }\n  /**\n   * Add an instruction to the set\n   * @param instruction - add an instruction to the set\n   */\n  add(instruction) {\n    this.instructions[this.instructionSize++] = instruction;\n  }\n  /**\n   * Log the instructions to the console (for debugging)\n   * @internal\n   * @ignore\n   */\n  log() {\n    this.instructions.length = this.instructionSize;\n    console.table(this.instructions, [\"type\", \"action\"]);\n  }\n}\n\nexport { InstructionSet };\n//# sourceMappingURL=InstructionSet.mjs.map\n","import { uid } from '../../../../utils/data/uid';\n\nimport type { Instruction } from './Instruction';\n\n/**\n * A set of instructions that can be executed by the renderer.\n * Basically wraps an array, but with some extra properties that help the renderer\n * to keep things nice and optimised.\n *\n * Note:\n * InstructionSet.instructions contains all the instructions, but does not resize (for performance).\n * So for the true length of the instructions you need to use InstructionSet.instructionSize\n * @memberof rendering\n */\nexport class InstructionSet\n{\n    /** a unique id for this instruction set used through the renderer */\n    public readonly uid = uid('instructionSet');\n    /** the array of instructions */\n    public readonly instructions: Instruction[] = [];\n    /** the actual size of the array (any instructions passed this should be ignored) */\n    public instructionSize = 0;\n    /** allows for access to the render pipes of the renderer */\n    public renderPipes: any;\n\n    /** reset the instruction set so it can be reused set size back to 0 */\n    public reset()\n    {\n        this.instructionSize = 0;\n    }\n\n    /**\n     * Add an instruction to the set\n     * @param instruction - add an instruction to the set\n     */\n    public add(instruction: Instruction)\n    {\n        this.instructions[this.instructionSize++] = instruction;\n    }\n\n    /**\n     * Log the instructions to the console (for debugging)\n     * @internal\n     * @ignore\n     */\n    public log()\n    {\n        this.instructions.length = this.instructionSize;\n        // eslint-disable-next-line no-console\n        console.table(this.instructions, ['type', 'action']);\n    }\n}\n","\"use strict\";\nfunction assignWithIgnore(target, options, ignore = {}) {\n  for (const key in options) {\n    if (!ignore[key] && options[key] !== void 0) {\n      target[key] = options[key];\n    }\n  }\n}\n\nexport { assignWithIgnore };\n//# sourceMappingURL=assignWithIgnore.mjs.map\n","/**\n * Assigns properties from one object to another, using an optional array of property names to ignore.\n * @param target - The target object to assign properties to.\n * @param options - The object to assign properties from.\n * @param ignore - An object of property names to ignore ({ propToIgnore: true }).\n */\nexport function assignWithIgnore<T extends Record<string, any>>(\n    target: T,\n    options: T,\n    ignore: Record<string, boolean> = {}\n)\n{\n    for (const key in options)\n    {\n        if (!ignore[key] && options[key] !== undefined)\n        {\n            target[key] = options[key];\n        }\n    }\n}\n","import { BrowserAdapter } from '../environment-browser/BrowserAdapter.mjs';\n\n\"use strict\";\nlet currentAdapter = BrowserAdapter;\nconst DOMAdapter = {\n  /**\n   * Returns the current adapter.\n   * @returns {environment.Adapter} The current adapter.\n   */\n  get() {\n    return currentAdapter;\n  },\n  /**\n   * Sets the current adapter.\n   * @param adapter - The new adapter.\n   */\n  set(adapter) {\n    currentAdapter = adapter;\n  }\n};\n\nexport { DOMAdapter };\n//# sourceMappingURL=adapter.mjs.map\n","import { BrowserAdapter } from '../environment-browser/BrowserAdapter';\n\nimport type { ICanvas } from './canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from './canvas/ICanvasRenderingContext2D';\n\n/**\n * PixiJS supports multiple environments including browsers, Web Workers, and Node.js.\n * The environment is auto-detected by default using the {@link environment.autoDetectEnvironment} function.\n *\n * The {@link environment.Adapter} interface provides a way to abstract away the differences between\n * these environments. PixiJS uses the {@link environment.BrowserAdapter} by default.\n *\n * However you can manually set the environment using the {@link environment.DOMAdapter} singleton, for example to\n * use Pixi within a WebWorker.\n * ```js\n * import { DOMAdapter, WebWorkerAdapter } from 'pixi.js';\n *\n * // WebWorkerAdapter is an implementation of the Adapter interface\n * DOMAdapter.set(WebWorkerAdapter);\n *\n * // use the adapter to create a canvas (in this case an OffscreenCanvas)\n * DOMAdapter.get().createCanvas(800, 600);\n * ```\n * @namespace environment\n */\n\n/**\n * This interface describes all the DOM dependent calls that Pixi makes throughout its codebase.\n * Implementations of this interface can be used to make sure Pixi will work in any environment,\n * such as browser, Web Workers, and Node.js.\n * @memberof environment\n */\nexport interface Adapter\n{\n    /** Returns a canvas object that can be used to create a webgl context. */\n    createCanvas: (width?: number, height?: number) => ICanvas;\n    /** Returns a 2D rendering context. */\n    getCanvasRenderingContext2D: () => { prototype: ICanvasRenderingContext2D; };\n    /** Returns a WebGL rendering context. */\n    getWebGLRenderingContext: () => typeof WebGLRenderingContext;\n    /** Returns a WebGL2 rendering context. */\n    getWebGL2RenderingContext: () => typeof WebGL2RenderingContext;\n    /** Returns a partial implementation of the browsers window.navigator */\n    getNavigator: () => { userAgent: string, gpu: GPU | null };\n    /** Returns the current base URL For browser environments this is either the document.baseURI or window.location.href */\n    getBaseUrl: () => string;\n    /** Return the font face set if available */\n    getFontFaceSet: () => FontFaceSet | null;\n    /** Returns a Response object that has been fetched from the given URL. */\n    fetch: (url: RequestInfo, options?: RequestInit) => Promise<Response>;\n    /** Returns Document object that has been parsed from the given XML string. */\n    parseXML: (xml: string) => Document;\n}\n\nlet currentAdapter: Adapter = BrowserAdapter;\n\n/**\n * The DOMAdapter is a singleton that allows PixiJS to perform DOM operations, such as creating a canvas.\n * This allows PixiJS to be used in any environment, such as a web browser, Web Worker, or Node.js.\n * It uses the {@link environment.Adapter} interface to abstract away the differences between these environments\n * and uses the {@link environment.BrowserAdapter} by default.\n *\n * It has two methods: `get():Adapter` and `set(adapter: Adapter)`.\n *\n * Defaults to the {@link environment.BrowserAdapter}.\n * @example\n * import { DOMAdapter, WebWorkerAdapter } from 'pixi.js';\n *\n * // WebWorkerAdapter is an implementation of the Adapter interface\n * DOMAdapter.set(WebWorkerAdapter);\n *\n * // use the adapter to create a canvas (in this case an OffscreenCanvas)\n * DOMAdapter.get().createCanvas(800, 600);\n * @memberof environment\n */\nexport const DOMAdapter = {\n    /**\n     * Returns the current adapter.\n     * @returns {environment.Adapter} The current adapter.\n     */\n    get(): Adapter\n    {\n        return currentAdapter;\n    },\n    /**\n     * Sets the current adapter.\n     * @param adapter - The new adapter.\n     */\n    set(adapter: Adapter): void\n    {\n        currentAdapter = adapter;\n    },\n};\n","\"use strict\";\nconst BrowserAdapter = {\n  createCanvas: (width, height) => {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n  },\n  getCanvasRenderingContext2D: () => CanvasRenderingContext2D,\n  getWebGLRenderingContext: () => WebGLRenderingContext,\n  getWebGL2RenderingContext: () => WebGL2RenderingContext,\n  getNavigator: () => navigator,\n  getBaseUrl: () => document.baseURI ?? window.location.href,\n  getFontFaceSet: () => document.fonts,\n  fetch: (url, options) => fetch(url, options),\n  parseXML: (xml) => {\n    const parser = new DOMParser();\n    return parser.parseFromString(xml, \"text/xml\");\n  }\n};\n\nexport { BrowserAdapter };\n//# sourceMappingURL=BrowserAdapter.mjs.map\n","import { type Adapter } from '../environment/adapter';\n\n/**\n * This is an implementation of the {@link environment.Adapter} interface.\n * It can be used to make Pixi work in the browser.\n * @memberof environment\n * @property {Function} createCanvas - Creates a canvas element of the given size.\n * This canvas is created using the browser's native canvas element.\n * @property {Function} getCanvasRenderingContext2D - Returns a 2D rendering context.\n * @property {Function} getWebGLRenderingContext - Returns a WebGL rendering context.\n * @property {Function} getNavigator - Returns browsers window.navigator\n * @property {Function} getBaseUrl - Returns the current base URL for browser environments this is either\n * the document.baseURI or window.location.href\n * @property {Function} getFontFaceSet - Return the font face set if available\n * @property {Function} fetch - Returns a Response object that has been fetched from the given URL.\n * @property {Function} parseXML - Returns Document object that has been parsed from the given XML string.\n */\nexport const BrowserAdapter = {\n    createCanvas: (width: number, height: number): HTMLCanvasElement =>\n    {\n        const canvas = document.createElement('canvas');\n\n        canvas.width = width;\n        canvas.height = height;\n\n        return canvas;\n    },\n    getCanvasRenderingContext2D: () => CanvasRenderingContext2D,\n    getWebGLRenderingContext: () => WebGLRenderingContext,\n    getWebGL2RenderingContext: () => WebGL2RenderingContext,\n    getNavigator: () => navigator,\n    getBaseUrl: () => (document.baseURI ?? window.location.href),\n    getFontFaceSet: () => document.fonts,\n    fetch: (url: RequestInfo, options?: RequestInit) => fetch(url, options),\n    parseXML: (xml: string) =>\n    {\n        const parser = new DOMParser();\n\n        return parser.parseFromString(xml, 'text/xml');\n    },\n} as Adapter;\n","import EventEmitter from 'eventemitter3';\nimport { groupD8 } from '../../../../maths/matrix/groupD8.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation.mjs';\nimport { NOOP } from '../../../../utils/misc/NOOP.mjs';\nimport { BufferImageSource } from './sources/BufferSource.mjs';\nimport { TextureSource } from './sources/TextureSource.mjs';\nimport { TextureMatrix } from './TextureMatrix.mjs';\n\n\"use strict\";\nclass Texture extends EventEmitter {\n  /**\n   * @param {TextureOptions} param0 - Options for the texture\n   */\n  constructor({\n    source,\n    label,\n    frame,\n    orig,\n    trim,\n    defaultAnchor,\n    defaultBorders,\n    rotate,\n    dynamic\n  } = {}) {\n    super();\n    /** unique id for this texture */\n    this.uid = uid(\"texture\");\n    /** A uvs object based on the given frame and the texture source */\n    this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };\n    /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     */\n    this.frame = new Rectangle();\n    /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * This mode is enabled automatically if no frame was passed inside constructor.\n     *\n     * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.\n     *\n     * Beware, after loading or resize of baseTexture event can fired two times!\n     * If you want more control, subscribe on baseTexture itself.\n     * @example\n     * texture.on('update', () => {});\n     */\n    this.noFrame = false;\n    /**\n     * Set to true if you plan on modifying the uvs of this texture.\n     * When this is the case, sprites and other objects using the texture will\n     * make sure to listen for changes to the uvs and update their vertices accordingly.\n     */\n    this.dynamic = false;\n    /** is it a texture? yes! used for type checking */\n    this.isTexture = true;\n    this.label = label;\n    this.source = source?.source ?? new TextureSource();\n    this.noFrame = !frame;\n    if (frame) {\n      this.frame.copyFrom(frame);\n    } else {\n      const { width, height } = this._source;\n      this.frame.width = width;\n      this.frame.height = height;\n    }\n    this.orig = orig || this.frame;\n    this.trim = trim;\n    this.rotate = rotate ?? 0;\n    this.defaultAnchor = defaultAnchor;\n    this.defaultBorders = defaultBorders;\n    this.destroyed = false;\n    this.dynamic = dynamic || false;\n    this.updateUvs();\n  }\n  set source(value) {\n    if (this._source) {\n      this._source.off(\"resize\", this.update, this);\n    }\n    this._source = value;\n    value.on(\"resize\", this.update, this);\n    this.emit(\"update\", this);\n  }\n  /** the underlying source of the texture (equivalent of baseTexture in v7) */\n  get source() {\n    return this._source;\n  }\n  /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */\n  get textureMatrix() {\n    if (!this._textureMatrix) {\n      this._textureMatrix = new TextureMatrix(this);\n    }\n    return this._textureMatrix;\n  }\n  /** The width of the Texture in pixels. */\n  get width() {\n    return this.orig.width;\n  }\n  /** The height of the Texture in pixels. */\n  get height() {\n    return this.orig.height;\n  }\n  /** Call this function when you have modified the frame of this texture. */\n  updateUvs() {\n    const { uvs, frame } = this;\n    const { width, height } = this._source;\n    const nX = frame.x / width;\n    const nY = frame.y / height;\n    const nW = frame.width / width;\n    const nH = frame.height / height;\n    let rotate = this.rotate;\n    if (rotate) {\n      const w2 = nW / 2;\n      const h2 = nH / 2;\n      const cX = nX + w2;\n      const cY = nY + h2;\n      rotate = groupD8.add(rotate, groupD8.NW);\n      uvs.x0 = cX + w2 * groupD8.uX(rotate);\n      uvs.y0 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x1 = cX + w2 * groupD8.uX(rotate);\n      uvs.y1 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x2 = cX + w2 * groupD8.uX(rotate);\n      uvs.y2 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x3 = cX + w2 * groupD8.uX(rotate);\n      uvs.y3 = cY + h2 * groupD8.uY(rotate);\n    } else {\n      uvs.x0 = nX;\n      uvs.y0 = nY;\n      uvs.x1 = nX + nW;\n      uvs.y1 = nY;\n      uvs.x2 = nX + nW;\n      uvs.y2 = nY + nH;\n      uvs.x3 = nX;\n      uvs.y3 = nY + nH;\n    }\n  }\n  /**\n   * Destroys this texture\n   * @param destroySource - Destroy the source when the texture is destroyed.\n   */\n  destroy(destroySource = false) {\n    if (this._source) {\n      if (destroySource) {\n        this._source.destroy();\n        this._source = null;\n      }\n    }\n    this._textureMatrix = null;\n    this.destroyed = true;\n    this.emit(\"destroy\", this);\n    this.removeAllListeners();\n  }\n  /** call this if you have modified the `texture outside` of the constructor */\n  update() {\n    if (this.noFrame) {\n      this.frame.width = this._source.width;\n      this.frame.height = this._source.height;\n    }\n    this.updateUvs();\n    this.emit(\"update\", this);\n  }\n  /** @deprecated since 8.0.0 */\n  get baseTexture() {\n    deprecation(v8_0_0, \"Texture.baseTexture is now Texture.source\");\n    return this._source;\n  }\n}\nTexture.EMPTY = new Texture({\n  label: \"EMPTY\",\n  source: new TextureSource({\n    label: \"EMPTY\"\n  })\n});\nTexture.EMPTY.destroy = NOOP;\nTexture.WHITE = new Texture({\n  source: new BufferImageSource({\n    resource: new Uint8Array([255, 255, 255, 255]),\n    width: 1,\n    height: 1,\n    alphaMode: \"premultiply-alpha-on-upload\",\n    label: \"WHITE\"\n  }),\n  label: \"WHITE\"\n});\nTexture.WHITE.destroy = NOOP;\n\nexport { Texture };\n//# sourceMappingURL=Texture.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { groupD8 } from '../../../../maths/matrix/groupD8';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { uid } from '../../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\nimport { NOOP } from '../../../../utils/misc/NOOP';\nimport { BufferImageSource } from './sources/BufferSource';\nimport { TextureSource } from './sources/TextureSource';\nimport { TextureMatrix } from './TextureMatrix';\n\nimport type { TextureResourceOrOptions } from './utils/textureFrom';\n\n/**\n * Stores the width of the non-scalable borders, for example when used with {@link scene.NineSlicePlane} texture.\n * @memberof rendering\n */\nexport interface TextureBorders\n{\n    /** left border in pixels */\n    left: number;\n    /** top border in pixels */\n    top: number;\n    /** right border in pixels */\n    right: number;\n    /** bottom border in pixels */\n    bottom: number;\n}\n\n/**\n * The UVs data structure for a texture.\n * @memberof rendering\n */\nexport type UVs = {\n    x0: number;\n    y0: number;\n    x1: number;\n    y1: number;\n    x2: number;\n    y2: number;\n    x3: number;\n    y3: number;\n};\n\n/**\n * The options that can be passed to a new Texture\n * @memberof rendering\n */\nexport interface TextureOptions\n{\n    /** the underlying texture data that this texture will use  */\n    source?: TextureSource;\n    /** optional label, for debugging */\n    label?: string;\n    /** The rectangle frame of the texture to show */\n    frame?: Rectangle;\n    /** The area of original texture */\n    orig?: Rectangle;\n    /** Trimmed rectangle of original texture */\n    trim?: Rectangle;\n    /** Default anchor point used for sprite placement / rotation */\n    defaultAnchor?: { x: number; y: number };\n    /** Default borders used for 9-slice scaling {@link NineSlicePlane}*/\n    defaultBorders?: TextureBorders;\n    /** indicates how the texture was rotated by texture packer. See {@link groupD8} */\n    rotate?: number;\n    /** set to true if you plan on modifying the uvs of this texture - can affect performance with high numbers of sprites*/\n    dynamic?: boolean;\n}\n\nexport interface BindableTexture\n{\n    source: TextureSource;\n}\n\nexport type TextureSourceLike = TextureSource | TextureResourceOrOptions | string;\n\n/**\n * A texture stores the information that represents an image or part of an image.\n *\n * A texture must have a loaded resource passed to it to work. It does not contain any\n * loading mechanisms.\n *\n * The Assets class can be used to load an texture from a file. This is the recommended\n * way as it will handle the loading and caching for you.\n *\n * ```js\n *\n * const texture = await Asset.load('assets/image.png');\n *\n * // once Assets has loaded the image it will be available via the from method\n * const sameTexture = Texture.from('assets/image.png');\n * // another way to acces the texture once loaded\n * const sameAgainTexture = Asset.get('assets/image.png');\n *\n * const sprite1 = new Sprite(texture);\n *\n * ```\n *\n * It cannot be added to the display list directly; instead use it as the texture for a Sprite.\n * If no frame is provided for a texture, then the whole image is used.\n *\n * You can directly create a texture from an image and then reuse it multiple times like this :\n *\n * ```js\n * import { Sprite, Texture } from 'pixi.js';\n *\n * const texture = await Asset.load('assets/image.png');\n * const sprite1 = new Sprite(texture);\n * const sprite2 = new Sprite(texture);\n * ```\n *\n * If you didn't pass the texture frame to constructor, it enables `noFrame` mode:\n * it subscribes on baseTexture events, it automatically resizes at the same time as baseTexture.\n * @memberof rendering\n * @class\n */\nexport class Texture extends EventEmitter<{\n    update: Texture\n    destroy: Texture\n}> implements BindableTexture\n{\n    /**\n     * Helper function that creates a returns Texture based on the source you provide.\n     * The source should be loaded and ready to go. If not its best to grab the asset using Assets.\n     * @param id - String or Source to create texture from\n     * @param skipCache - Skip adding the texture to the cache\n     * @returns The texture based on the Id provided\n     */\n    public static from: (id: TextureSourceLike, skipCache?: boolean) => Texture;\n\n    /** label used for debugging */\n    public label?: string;\n    /** unique id for this texture */\n    public uid = uid('texture');\n    /**\n     * Has the texture been destroyed?\n     * @readonly\n     */\n    public destroyed: boolean;\n\n    public _source: TextureSource;\n\n    /**\n     * Indicates whether the texture is rotated inside the atlas\n     * set to 2 to compensate for texture packer rotation\n     * set to 6 to compensate for spine packer rotation\n     * can be used to rotate or mirror sprites\n     * See {@link PIXI.groupD8} for explanation\n     */\n    public readonly rotate: number;\n    /** A uvs object based on the given frame and the texture source */\n    public readonly uvs: UVs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };\n    /**\n     * Anchor point that is used as default if sprite is created with this texture.\n     * Changing the `defaultAnchor` at a later point of time will not update Sprite's anchor point.\n     * @default {0,0}\n     */\n    public readonly defaultAnchor?: { x: number; y: number };\n    /**\n     * Default width of the non-scalable border that is used if 9-slice plane is created with this texture.\n     * @since 7.2.0\n     * @see PIXI.NineSlicePlane\n     */\n    public readonly defaultBorders?: TextureBorders;\n    /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     */\n    public readonly frame = new Rectangle();\n    /** This is the area of original texture, before it was put in atlas. */\n    public readonly orig: Rectangle;\n    /**\n     * This is the trimmed area of original texture, before it was put in atlas\n     * Please call `updateUvs()` after you change coordinates of `trim` manually.\n     */\n    public readonly trim: Rectangle;\n\n    /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * This mode is enabled automatically if no frame was passed inside constructor.\n     *\n     * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.\n     *\n     * Beware, after loading or resize of baseTexture event can fired two times!\n     * If you want more control, subscribe on baseTexture itself.\n     * @example\n     * texture.on('update', () => {});\n     */\n    public noFrame = false;\n\n    /**\n     * Set to true if you plan on modifying the uvs of this texture.\n     * When this is the case, sprites and other objects using the texture will\n     * make sure to listen for changes to the uvs and update their vertices accordingly.\n     */\n    public dynamic = false;\n\n    private _textureMatrix: TextureMatrix;\n\n    /** is it a texture? yes! used for type checking */\n    public readonly isTexture = true;\n\n    /**\n     * @param {TextureOptions} param0 - Options for the texture\n     */\n    constructor({\n        source,\n        label,\n        frame,\n        orig,\n        trim,\n        defaultAnchor,\n        defaultBorders,\n        rotate,\n        dynamic\n    }: TextureOptions = {})\n    {\n        super();\n\n        this.label = label;\n        this.source = source?.source ?? new TextureSource();\n\n        this.noFrame = !frame;\n\n        if (frame)\n        {\n            this.frame.copyFrom(frame);\n        }\n        else\n        {\n            const { width, height } = this._source;\n\n            this.frame.width = width;\n            this.frame.height = height;\n        }\n\n        this.orig = orig || this.frame;\n        this.trim = trim;\n\n        this.rotate = rotate ?? 0;\n        this.defaultAnchor = defaultAnchor;\n        this.defaultBorders = defaultBorders;\n\n        this.destroyed = false;\n        this.dynamic = dynamic || false;\n\n        this.updateUvs();\n    }\n\n    set source(value: TextureSource)\n    {\n        if (this._source)\n        {\n            this._source.off('resize', this.update, this);\n        }\n\n        this._source = value;\n\n        value.on('resize', this.update, this);\n\n        this.emit('update', this);\n    }\n\n    /** the underlying source of the texture (equivalent of baseTexture in v7) */\n    get source(): TextureSource\n    {\n        return this._source;\n    }\n\n    /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */\n    get textureMatrix()\n    {\n        if (!this._textureMatrix)\n        {\n            this._textureMatrix = new TextureMatrix(this);\n        }\n\n        return this._textureMatrix;\n    }\n\n    /** The width of the Texture in pixels. */\n    get width(): number\n    {\n        return this.orig.width;\n    }\n\n    /** The height of the Texture in pixels. */\n    get height(): number\n    {\n        return this.orig.height;\n    }\n\n    /** Call this function when you have modified the frame of this texture. */\n    public updateUvs()\n    {\n        const { uvs, frame } = this;\n        const { width, height } = this._source;\n\n        const nX = frame.x / width;\n        const nY = frame.y / height;\n\n        const nW = frame.width / width;\n        const nH = frame.height / height;\n\n        let rotate = this.rotate;\n\n        if (rotate)\n        {\n            // width and height div 2 div baseFrame size\n            const w2 = nW / 2;\n            const h2 = nH / 2;\n\n            // coordinates of center\n            const cX = nX + w2;\n            const cY = nY + h2;\n\n            rotate = groupD8.add(rotate, groupD8.NW); // NW is top-left corner\n            uvs.x0 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y0 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2); // rotate 90 degrees clockwise\n            uvs.x1 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y1 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2);\n            uvs.x2 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y2 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2);\n            uvs.x3 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y3 = cY + (h2 * groupD8.uY(rotate));\n        }\n\n        else\n        {\n            uvs.x0 = nX;\n            uvs.y0 = nY;\n            uvs.x1 = nX + nW;\n            uvs.y1 = nY;\n            uvs.x2 = nX + nW;\n            uvs.y2 = nY + nH;\n            uvs.x3 = nX;\n            uvs.y3 = nY + nH;\n        }\n    }\n\n    /**\n     * Destroys this texture\n     * @param destroySource - Destroy the source when the texture is destroyed.\n     */\n    public destroy(destroySource = false)\n    {\n        if (this._source)\n        {\n            if (destroySource)\n            {\n                this._source.destroy();\n                this._source = null;\n            }\n        }\n\n        this._textureMatrix = null;\n        this.destroyed = true;\n        this.emit('destroy', this);\n        this.removeAllListeners();\n    }\n\n    /** call this if you have modified the `texture outside` of the constructor */\n    public update(): void\n    {\n        if (this.noFrame)\n        {\n            this.frame.width = this._source.width;\n            this.frame.height = this._source.height;\n        }\n\n        this.updateUvs();\n        this.emit('update', this);\n    }\n\n    /** @deprecated since 8.0.0 */\n    get baseTexture(): TextureSource\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Texture.baseTexture is now Texture.source');\n        // #endif\n\n        return this._source;\n    }\n\n    /** an Empty Texture used internally by the engine */\n    public static EMPTY: Texture;\n    /** a White texture used internally by the engine */\n    public static WHITE: Texture;\n}\n\nTexture.EMPTY = new Texture({\n    label: 'EMPTY',\n    source: new TextureSource({\n        label: 'EMPTY',\n    })\n});\n\nTexture.EMPTY.destroy = NOOP;\n\nTexture.WHITE = new Texture({\n    source: new BufferImageSource({\n        resource: new Uint8Array([255, 255, 255, 255]),\n        width: 1,\n        height: 1,\n        alphaMode: 'premultiply-alpha-on-upload',\n        label: 'WHITE',\n    }),\n    label: 'WHITE',\n});\n\nTexture.WHITE.destroy = NOOP;\n","import { Matrix } from './Matrix.mjs';\n\n\"use strict\";\nconst ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];\nconst uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];\nconst rotationCayley = [];\nconst rotationMatrices = [];\nconst signum = Math.sign;\nfunction init() {\n  for (let i = 0; i < 16; i++) {\n    const row = [];\n    rotationCayley.push(row);\n    for (let j = 0; j < 16; j++) {\n      const _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);\n      const _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);\n      const _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);\n      const _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);\n      for (let k = 0; k < 16; k++) {\n        if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {\n          row.push(k);\n          break;\n        }\n      }\n    }\n  }\n  for (let i = 0; i < 16; i++) {\n    const mat = new Matrix();\n    mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);\n    rotationMatrices.push(mat);\n  }\n}\ninit();\nconst groupD8 = {\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 0°       | East      |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  E: 0,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 45°↻     | Southeast |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  SE: 1,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 90°↻     | South     |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  S: 2,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 135°↻    | Southwest |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  SW: 3,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 180°     | West      |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  W: 4,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -135°/225°↻ | Northwest    |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  NW: 5,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -90°/270°↻  | North        |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  N: 6,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -45°/315°↻  | Northeast    |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  NE: 7,\n  /**\n   * Reflection about Y-axis.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  MIRROR_VERTICAL: 8,\n  /**\n   * Reflection about the main diagonal.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  MAIN_DIAGONAL: 10,\n  /**\n   * Reflection about X-axis.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  MIRROR_HORIZONTAL: 12,\n  /**\n   * Reflection about reverse diagonal.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  REVERSE_DIAGONAL: 14,\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The X-component of the U-axis\n   *    after rotating the axes.\n   */\n  uX: (ind) => ux[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The Y-component of the U-axis\n   *    after rotating the axes.\n   */\n  uY: (ind) => uy[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The X-component of the V-axis\n   *    after rotating the axes.\n   */\n  vX: (ind) => vx[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The Y-component of the V-axis\n   *    after rotating the axes.\n   */\n  vY: (ind) => vy[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotation - symmetry whose opposite\n   *   is needed. Only rotations have opposite symmetries while\n   *   reflections don't.\n   * @returns {GD8Symmetry} The opposite symmetry of `rotation`\n   */\n  inv: (rotation) => {\n    if (rotation & 8) {\n      return rotation & 15;\n    }\n    return -rotation & 7;\n  },\n  /**\n   * Composes the two D8 operations.\n   *\n   * Taking `^` as reflection:\n   *\n   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |\n   * |-------|-----|-----|-----|-----|------|-------|-------|-------|\n   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |\n   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |\n   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |\n   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |\n   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |\n   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |\n   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |\n   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |\n   *\n   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotationSecond - Second operation, which\n   *   is the row in the above cayley table.\n   * @param {GD8Symmetry} rotationFirst - First operation, which\n   *   is the column in the above cayley table.\n   * @returns {GD8Symmetry} Composed operation\n   */\n  add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],\n  /**\n   * Reverse of `add`.\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotationSecond - Second operation\n   * @param {GD8Symmetry} rotationFirst - First operation\n   * @returns {GD8Symmetry} Result\n   */\n  sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],\n  /**\n   * Adds 180 degrees to rotation, which is a commutative\n   * operation.\n   * @memberof maths.groupD8\n   * @param {number} rotation - The number to rotate.\n   * @returns {number} Rotated number\n   */\n  rotate180: (rotation) => rotation ^ 4,\n  /**\n   * Checks if the rotation angle is vertical, i.e. south\n   * or north. It doesn't work for reflections.\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotation - The number to check.\n   * @returns {boolean} Whether or not the direction is vertical\n   */\n  isVertical: (rotation) => (rotation & 3) === 2,\n  // rotation % 4 === 2\n  /**\n   * Approximates the vector `V(dx,dy)` into one of the\n   * eight directions provided by `groupD8`.\n   * @memberof maths.groupD8\n   * @param {number} dx - X-component of the vector\n   * @param {number} dy - Y-component of the vector\n   * @returns {GD8Symmetry} Approximation of the vector into\n   *  one of the eight symmetries.\n   */\n  byDirection: (dx, dy) => {\n    if (Math.abs(dx) * 2 <= Math.abs(dy)) {\n      if (dy >= 0) {\n        return groupD8.S;\n      }\n      return groupD8.N;\n    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {\n      if (dx > 0) {\n        return groupD8.E;\n      }\n      return groupD8.W;\n    } else if (dy > 0) {\n      if (dx > 0) {\n        return groupD8.SE;\n      }\n      return groupD8.SW;\n    } else if (dx > 0) {\n      return groupD8.NE;\n    }\n    return groupD8.NW;\n  },\n  /**\n   * Helps sprite to compensate texture packer rotation.\n   * @memberof maths.groupD8\n   * @param {Matrix} matrix - sprite world matrix\n   * @param {GD8Symmetry} rotation - The rotation factor to use.\n   * @param {number} tx - sprite anchoring\n   * @param {number} ty - sprite anchoring\n   */\n  matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {\n    const mat = rotationMatrices[groupD8.inv(rotation)];\n    mat.tx = tx;\n    mat.ty = ty;\n    matrix.append(mat);\n  }\n};\n\nexport { groupD8 };\n//# sourceMappingURL=groupD8.mjs.map\n","// Your friendly neighbour https://en.wikipedia.org/wiki/Dihedral_group\n//\n// This file implements the dihedral group of order 16, also called\n// of degree 8. That's why its called groupD8.\n\nimport { Matrix } from './Matrix';\n\n/*\n * Transform matrix for operation n is:\n * | ux | vx |\n * | uy | vy |\n */\n\nconst ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];\nconst uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];\n\n/**\n * [Cayley Table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n * for the composition of each rotation in the dihederal group D8.\n * @type {number[][]}\n * @private\n */\nconst rotationCayley: number[][] = [];\n\n/**\n * Matrices for each `GD8Symmetry` rotation.\n * @type {Matrix[]}\n * @private\n */\nconst rotationMatrices: Matrix[] = [];\n\n/*\n * Alias for {@code Math.sign}.\n */\nconst signum = Math.sign;\n\n/*\n * Initializes `rotationCayley` and `rotationMatrices`. It is called\n * only once below.\n */\nfunction init(): void\n{\n    for (let i = 0; i < 16; i++)\n    {\n        const row: number[] = [];\n\n        rotationCayley.push(row);\n\n        for (let j = 0; j < 16; j++)\n        {\n            /* Multiplies rotation matrices i and j. */\n            const _ux = signum((ux[i] * ux[j]) + (vx[i] * uy[j]));\n            const _uy = signum((uy[i] * ux[j]) + (vy[i] * uy[j]));\n            const _vx = signum((ux[i] * vx[j]) + (vx[i] * vy[j]));\n            const _vy = signum((uy[i] * vx[j]) + (vy[i] * vy[j]));\n\n            /* Finds rotation matrix matching the product and pushes it. */\n            for (let k = 0; k < 16; k++)\n            {\n                if (ux[k] === _ux && uy[k] === _uy\n                      && vx[k] === _vx && vy[k] === _vy)\n                {\n                    row.push(k);\n                    break;\n                }\n            }\n        }\n    }\n\n    for (let i = 0; i < 16; i++)\n    {\n        const mat = new Matrix();\n\n        mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);\n        rotationMatrices.push(mat);\n    }\n}\n\ninit();\n\ntype GD8Symmetry = number;\n/**\n * @typedef {number} GD8Symmetry\n * @see groupD8\n */\n\n/**\n * Implements the dihedral group D8, which is similar to\n * [group D4]{@link http://mathworld.wolfram.com/DihedralGroupD4.html};\n * D8 is the same but with diagonals, and it is used for texture\n * rotations.\n *\n * The directions the U- and V- axes after rotation\n * of an angle of `a: GD8Constant` are the vectors `(uX(a), uY(a))`\n * and `(vX(a), vY(a))`. These aren't necessarily unit vectors.\n *\n * **Origin:**<br>\n *  This is the small part of gameofbombs.com portal system. It works.\n * @see maths.groupD8.E\n * @see maths.groupD8.SE\n * @see maths.groupD8.S\n * @see maths.groupD8.SW\n * @see maths.groupD8.W\n * @see maths.groupD8.NW\n * @see maths.groupD8.N\n * @see maths.groupD8.NE\n * @author Ivan @ivanpopelyshev\n * @namespace maths.groupD8\n */\nexport const groupD8 = {\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 0°       | East      |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    E: 0,\n\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 45°↻     | Southeast |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    SE: 1,\n\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 90°↻     | South     |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    S: 2,\n\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 135°↻    | Southwest |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    SW: 3,\n\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 180°     | West      |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    W: 4,\n\n    /**\n     * | Rotation    | Direction    |\n     * |-------------|--------------|\n     * | -135°/225°↻ | Northwest    |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    NW: 5,\n\n    /**\n     * | Rotation    | Direction    |\n     * |-------------|--------------|\n     * | -90°/270°↻  | North        |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    N: 6,\n\n    /**\n     * | Rotation    | Direction    |\n     * |-------------|--------------|\n     * | -45°/315°↻  | Northeast    |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    NE: 7,\n\n    /**\n     * Reflection about Y-axis.\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    MIRROR_VERTICAL: 8,\n\n    /**\n     * Reflection about the main diagonal.\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    MAIN_DIAGONAL: 10,\n\n    /**\n     * Reflection about X-axis.\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    MIRROR_HORIZONTAL: 12,\n\n    /**\n     * Reflection about reverse diagonal.\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    REVERSE_DIAGONAL: 14,\n\n    /**\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} ind - sprite rotation angle.\n     * @returns {GD8Symmetry} The X-component of the U-axis\n     *    after rotating the axes.\n     */\n    uX: (ind: GD8Symmetry): GD8Symmetry => ux[ind],\n\n    /**\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} ind - sprite rotation angle.\n     * @returns {GD8Symmetry} The Y-component of the U-axis\n     *    after rotating the axes.\n     */\n    uY: (ind: GD8Symmetry): GD8Symmetry => uy[ind],\n\n    /**\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} ind - sprite rotation angle.\n     * @returns {GD8Symmetry} The X-component of the V-axis\n     *    after rotating the axes.\n     */\n    vX: (ind: GD8Symmetry): GD8Symmetry => vx[ind],\n\n    /**\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} ind - sprite rotation angle.\n     * @returns {GD8Symmetry} The Y-component of the V-axis\n     *    after rotating the axes.\n     */\n    vY: (ind: GD8Symmetry): GD8Symmetry => vy[ind],\n\n    /**\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} rotation - symmetry whose opposite\n     *   is needed. Only rotations have opposite symmetries while\n     *   reflections don't.\n     * @returns {GD8Symmetry} The opposite symmetry of `rotation`\n     */\n    inv: (rotation: GD8Symmetry): GD8Symmetry =>\n    {\n        if (rotation & 8)// true only if between 8 & 15 (reflections)\n        {\n            return rotation & 15;// or rotation % 16\n        }\n\n        return (-rotation) & 7;// or (8 - rotation) % 8\n    },\n\n    /**\n     * Composes the two D8 operations.\n     *\n     * Taking `^` as reflection:\n     *\n     * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |\n     * |-------|-----|-----|-----|-----|------|-------|-------|-------|\n     * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |\n     * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |\n     * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |\n     * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |\n     * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |\n     * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |\n     * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |\n     * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |\n     *\n     * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} rotationSecond - Second operation, which\n     *   is the row in the above cayley table.\n     * @param {GD8Symmetry} rotationFirst - First operation, which\n     *   is the column in the above cayley table.\n     * @returns {GD8Symmetry} Composed operation\n     */\n    add: (rotationSecond: GD8Symmetry, rotationFirst: GD8Symmetry): GD8Symmetry => (\n        rotationCayley[rotationSecond][rotationFirst]\n    ),\n\n    /**\n     * Reverse of `add`.\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} rotationSecond - Second operation\n     * @param {GD8Symmetry} rotationFirst - First operation\n     * @returns {GD8Symmetry} Result\n     */\n    sub: (rotationSecond: GD8Symmetry, rotationFirst: GD8Symmetry): GD8Symmetry => (\n        rotationCayley[rotationSecond][groupD8.inv(rotationFirst)]\n    ),\n\n    /**\n     * Adds 180 degrees to rotation, which is a commutative\n     * operation.\n     * @memberof maths.groupD8\n     * @param {number} rotation - The number to rotate.\n     * @returns {number} Rotated number\n     */\n    rotate180: (rotation: number): number => rotation ^ 4,\n\n    /**\n     * Checks if the rotation angle is vertical, i.e. south\n     * or north. It doesn't work for reflections.\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} rotation - The number to check.\n     * @returns {boolean} Whether or not the direction is vertical\n     */\n    isVertical: (rotation: GD8Symmetry): boolean => (rotation & 3) === 2, // rotation % 4 === 2\n\n    /**\n     * Approximates the vector `V(dx,dy)` into one of the\n     * eight directions provided by `groupD8`.\n     * @memberof maths.groupD8\n     * @param {number} dx - X-component of the vector\n     * @param {number} dy - Y-component of the vector\n     * @returns {GD8Symmetry} Approximation of the vector into\n     *  one of the eight symmetries.\n     */\n    byDirection: (dx: number, dy: number): GD8Symmetry =>\n    {\n        if (Math.abs(dx) * 2 <= Math.abs(dy))\n        {\n            if (dy >= 0)\n            {\n                return groupD8.S;\n            }\n\n            return groupD8.N;\n        }\n        else if (Math.abs(dy) * 2 <= Math.abs(dx))\n        {\n            if (dx > 0)\n            {\n                return groupD8.E;\n            }\n\n            return groupD8.W;\n        }\n        else if (dy > 0)\n        {\n            if (dx > 0)\n            {\n                return groupD8.SE;\n            }\n\n            return groupD8.SW;\n        }\n        else if (dx > 0)\n        {\n            return groupD8.NE;\n        }\n\n        return groupD8.NW;\n    },\n\n    /**\n     * Helps sprite to compensate texture packer rotation.\n     * @memberof maths.groupD8\n     * @param {Matrix} matrix - sprite world matrix\n     * @param {GD8Symmetry} rotation - The rotation factor to use.\n     * @param {number} tx - sprite anchoring\n     * @param {number} ty - sprite anchoring\n     */\n    matrixAppendRotationInv: (matrix: Matrix, rotation: GD8Symmetry, tx = 0, ty = 0): void =>\n    {\n        // Packer used \"rotation\", we use \"inv(rotation)\"\n        const mat: Matrix = rotationMatrices[groupD8.inv(rotation)];\n\n        mat.tx = tx;\n        mat.ty = ty;\n        matrix.append(mat);\n    },\n};\n","\"use strict\";\nconst NOOP = () => {\n};\n\nexport { NOOP };\n//# sourceMappingURL=NOOP.mjs.map\n","export const NOOP = () =>\n{\n    // empty!\n};\n","import { ExtensionType } from '../../../../../extensions/Extensions.mjs';\nimport { TextureSource } from './TextureSource.mjs';\n\n\"use strict\";\nclass BufferImageSource extends TextureSource {\n  constructor(options) {\n    const buffer = options.resource || new Float32Array(options.width * options.height * 4);\n    let format = options.format;\n    if (!format) {\n      if (buffer instanceof Float32Array) {\n        format = \"rgba32float\";\n      } else if (buffer instanceof Int32Array) {\n        format = \"rgba32uint\";\n      } else if (buffer instanceof Uint32Array) {\n        format = \"rgba32uint\";\n      } else if (buffer instanceof Int16Array) {\n        format = \"rgba16uint\";\n      } else if (buffer instanceof Uint16Array) {\n        format = \"rgba16uint\";\n      } else if (buffer instanceof Int8Array) {\n        format = \"bgra8unorm\";\n      } else {\n        format = \"bgra8unorm\";\n      }\n    }\n    super({\n      ...options,\n      resource: buffer,\n      format\n    });\n    this.uploadMethodId = \"buffer\";\n  }\n  static test(resource) {\n    return resource instanceof Int8Array || resource instanceof Uint8Array || resource instanceof Uint8ClampedArray || resource instanceof Int16Array || resource instanceof Uint16Array || resource instanceof Int32Array || resource instanceof Uint32Array || resource instanceof Float32Array;\n  }\n}\nBufferImageSource.extension = ExtensionType.TextureSource;\n\nexport { BufferImageSource };\n//# sourceMappingURL=BufferSource.mjs.map\n","import { ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from './TextureSource';\n\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { TypedArray } from '../../buffer/Buffer';\nimport type { TextureSourceOptions } from './TextureSource';\n\nexport interface BufferSourceOptions extends TextureSourceOptions<TypedArray | ArrayBuffer>\n{\n    width: number;\n    height: number;\n}\n\nexport class BufferImageSource extends TextureSource<TypedArray | ArrayBuffer>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n\n    public uploadMethodId = 'buffer';\n\n    constructor(options: BufferSourceOptions)\n    {\n        const buffer = options.resource || new Float32Array(options.width * options.height * 4);\n        let format = options.format;\n\n        if (!format)\n        {\n            if (buffer instanceof Float32Array)\n            {\n                format = 'rgba32float';\n            }\n            else if (buffer instanceof Int32Array)\n            {\n                format = 'rgba32uint';\n            }\n            else if (buffer instanceof Uint32Array)\n            {\n                format = 'rgba32uint';\n            }\n            else if (buffer instanceof Int16Array)\n            {\n                format = 'rgba16uint';\n            }\n            else if (buffer instanceof Uint16Array)\n            {\n                format = 'rgba16uint';\n            }\n            else if (buffer instanceof Int8Array)\n            {\n                format = 'bgra8unorm';\n            }\n            else\n            {\n                format = 'bgra8unorm';\n            }\n        }\n\n        super({\n            ...options,\n            resource: buffer,\n            format,\n        });\n    }\n\n    public static test(resource: any): resource is TypedArray | ArrayBuffer\n    {\n        return resource instanceof Int8Array\n        || resource instanceof Uint8Array\n        || resource instanceof Uint8ClampedArray\n        || resource instanceof Int16Array\n        || resource instanceof Uint16Array\n        || resource instanceof Int32Array\n        || resource instanceof Uint32Array\n        || resource instanceof Float32Array;\n    }\n}\n","import EventEmitter from 'eventemitter3';\nimport { isPow2 } from '../../../../../maths/misc/pow2.mjs';\nimport { definedProps } from '../../../../../scene/container/utils/definedProps.mjs';\nimport { uid } from '../../../../../utils/data/uid.mjs';\nimport { TextureStyle } from '../TextureStyle.mjs';\n\n\"use strict\";\nconst _TextureSource = class _TextureSource extends EventEmitter {\n  /**\n   * @param options - options for creating a new TextureSource\n   */\n  constructor(options = {}) {\n    super();\n    this.options = options;\n    /** unique id for this Texture source */\n    this.uid = uid(\"textureSource\");\n    /**\n     * The resource type used by this TextureSource. This is used by the bind groups to determine\n     * how to handle this resource.\n     * @ignore\n     * @internal\n     */\n    this._resourceType = \"textureSource\";\n    /**\n     * i unique resource id, used by the bind group systems.\n     * This can change if the texture is resized or its resource changes\n     */\n    this._resourceId = uid(\"resource\");\n    /**\n     * this is how the backends know how to upload this texture to the GPU\n     * It changes depending on the resource type. Classes that extend TextureSource\n     * should override this property.\n     * @ignore\n     * @internal\n     */\n    this.uploadMethodId = \"unknown\";\n    // dimensions\n    this._resolution = 1;\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    this.pixelWidth = 1;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    this.pixelHeight = 1;\n    /**\n     * the width of this texture source, accounting for resolution\n     * eg pixelWidth 200, resolution 2, then width will be 100\n     */\n    this.width = 1;\n    /**\n     * the height of this texture source, accounting for resolution\n     * eg pixelHeight 200, resolution 2, then height will be 100\n     */\n    this.height = 1;\n    /**\n     * The number of samples of a multisample texture. This is always 1 for non-multisample textures.\n     * To enable multisample for a texture, set antialias to true\n     * @internal\n     * @ignore\n     */\n    this.sampleCount = 1;\n    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n    this.mipLevelCount = 1;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    this.autoGenerateMipmaps = false;\n    /** the format that the texture data has */\n    this.format = \"rgba8unorm\";\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    this.dimension = \"2d\";\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    this.antialias = false;\n    /**\n     * Used by automatic texture Garbage Collection, stores last GC tick when it was bound\n     * @protected\n     */\n    this._touched = 0;\n    /**\n     * Used by the batcher to build texture batches. faster to have the variable here!\n     * @protected\n     */\n    this._batchTick = -1;\n    /**\n     * A temporary batch location for the texture batching. Here for performance reasons only!\n     * @protected\n     */\n    this._textureBindLocation = -1;\n    options = { ..._TextureSource.defaultOptions, ...options };\n    this.label = options.label ?? \"\";\n    this.resource = options.resource;\n    this.autoGarbageCollect = options.autoGarbageCollect;\n    this._resolution = options.resolution;\n    if (options.width) {\n      this.pixelWidth = options.width * this._resolution;\n    } else {\n      this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1;\n    }\n    if (options.height) {\n      this.pixelHeight = options.height * this._resolution;\n    } else {\n      this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1;\n    }\n    this.width = this.pixelWidth / this._resolution;\n    this.height = this.pixelHeight / this._resolution;\n    this.format = options.format;\n    this.dimension = options.dimensions;\n    this.mipLevelCount = options.mipLevelCount;\n    this.autoGenerateMipmaps = options.autoGenerateMipmaps;\n    this.sampleCount = options.sampleCount;\n    this.antialias = options.antialias;\n    this.alphaMode = options.alphaMode;\n    this.style = new TextureStyle(definedProps(options));\n    this.destroyed = false;\n    this._refreshPOT();\n  }\n  /** returns itself */\n  get source() {\n    return this;\n  }\n  /** the style of the texture */\n  get style() {\n    return this._style;\n  }\n  set style(value) {\n    if (this.style === value)\n      return;\n    this._style?.off(\"change\", this._onStyleChange, this);\n    this._style = value;\n    this._style?.on(\"change\", this._onStyleChange, this);\n    this._onStyleChange();\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get addressMode() {\n    return this._style.addressMode;\n  }\n  set addressMode(value) {\n    this._style.addressMode = value;\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get repeatMode() {\n    return this._style.addressMode;\n  }\n  set repeatMode(value) {\n    this._style.addressMode = value;\n  }\n  /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n  get magFilter() {\n    return this._style.magFilter;\n  }\n  set magFilter(value) {\n    this._style.magFilter = value;\n  }\n  /** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n  get minFilter() {\n    return this._style.minFilter;\n  }\n  set minFilter(value) {\n    this._style.minFilter = value;\n  }\n  /** Specifies behavior for sampling between mipmap levels. */\n  get mipmapFilter() {\n    return this._style.mipmapFilter;\n  }\n  set mipmapFilter(value) {\n    this._style.mipmapFilter = value;\n  }\n  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n  get lodMinClamp() {\n    return this._style.lodMinClamp;\n  }\n  set lodMinClamp(value) {\n    this._style.lodMinClamp = value;\n  }\n  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n  get lodMaxClamp() {\n    return this._style.lodMaxClamp;\n  }\n  set lodMaxClamp(value) {\n    this._style.lodMaxClamp = value;\n  }\n  _onStyleChange() {\n    this.emit(\"styleChange\", this);\n  }\n  /** call this if you have modified the texture outside of the constructor */\n  update() {\n    if (this.resource) {\n      const resolution = this._resolution;\n      const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);\n      if (didResize)\n        return;\n    }\n    this.emit(\"update\", this);\n  }\n  /** Destroys this texture source */\n  destroy() {\n    this.destroyed = true;\n    this.emit(\"destroy\", this);\n    if (this._style) {\n      this._style.destroy();\n      this._style = null;\n    }\n    this.uploadMethodId = null;\n    this.resource = null;\n    this.removeAllListeners();\n  }\n  /**\n   * This will unload the Texture source from the GPU. This will free up the GPU memory\n   * As soon as it is required fore rendering, it will be re-uploaded.\n   */\n  unload() {\n    this._resourceId = uid(\"resource\");\n    this.emit(\"change\", this);\n    this.emit(\"unload\", this);\n  }\n  /** the width of the resource. This is the REAL pure number, not accounting resolution   */\n  get resourceWidth() {\n    const { resource } = this;\n    return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;\n  }\n  /** the height of the resource. This is the REAL pure number, not accounting resolution */\n  get resourceHeight() {\n    const { resource } = this;\n    return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;\n  }\n  /**\n   * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture\n   * but will the size of the texture when rendered.\n   *\n   * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel\n   * density will have increased)\n   */\n  get resolution() {\n    return this._resolution;\n  }\n  set resolution(resolution) {\n    if (this._resolution === resolution)\n      return;\n    this._resolution = resolution;\n    this.width = this.pixelWidth / resolution;\n    this.height = this.pixelHeight / resolution;\n  }\n  /**\n   * Resize the texture, this is handy if you want to use the texture as a render texture\n   * @param width - the new width of the texture\n   * @param height - the new height of the texture\n   * @param resolution - the new resolution of the texture\n   * @returns - if the texture was resized\n   */\n  resize(width, height, resolution) {\n    resolution = resolution || this._resolution;\n    width = width || this.width;\n    height = height || this.height;\n    const newPixelWidth = Math.round(width * resolution);\n    const newPixelHeight = Math.round(height * resolution);\n    this.width = newPixelWidth / resolution;\n    this.height = newPixelHeight / resolution;\n    this._resolution = resolution;\n    if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) {\n      return false;\n    }\n    this._refreshPOT();\n    this.pixelWidth = newPixelWidth;\n    this.pixelHeight = newPixelHeight;\n    this.emit(\"resize\", this);\n    this._resourceId = uid(\"resource\");\n    this.emit(\"change\", this);\n    return true;\n  }\n  /**\n   * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.\n   * This is only important for RenderTexture instances, as standard Texture instances will have their\n   * mipmaps generated on upload. You should call this method after you make any change to the texture\n   *\n   * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,\n   * We want you, the developer to specify when this action should happen.\n   *\n   * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,\n   */\n  updateMipmaps() {\n    if (this.autoGenerateMipmaps && this.mipLevelCount > 1) {\n      this.emit(\"updateMipmaps\", this);\n    }\n  }\n  set wrapMode(value) {\n    this._style.wrapMode = value;\n  }\n  get wrapMode() {\n    return this._style.wrapMode;\n  }\n  set scaleMode(value) {\n    this._style.scaleMode = value;\n  }\n  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n  get scaleMode() {\n    return this._style.scaleMode;\n  }\n  /**\n   * Refresh check for isPowerOfTwo texture based on size\n   * @private\n   */\n  _refreshPOT() {\n    this.isPowerOfTwo = isPow2(this.pixelWidth) && isPow2(this.pixelHeight);\n  }\n  static test(_resource) {\n    throw new Error(\"Unimplemented\");\n  }\n};\n/** The default options used when creating a new TextureSource. override these to add your own defaults */\n_TextureSource.defaultOptions = {\n  resolution: 1,\n  format: \"bgra8unorm\",\n  alphaMode: \"premultiply-alpha-on-upload\",\n  dimensions: \"2d\",\n  mipLevelCount: 1,\n  autoGenerateMipmaps: false,\n  sampleCount: 1,\n  antialias: false,\n  autoGarbageCollect: false\n};\nlet TextureSource = _TextureSource;\n\nexport { TextureSource };\n//# sourceMappingURL=TextureSource.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { isPow2 } from '../../../../../maths/misc/pow2';\nimport { definedProps } from '../../../../../scene/container/utils/definedProps';\nimport { uid } from '../../../../../utils/data/uid';\nimport { TextureStyle } from '../TextureStyle';\n\nimport type { BindResource } from '../../../gpu/shader/BindResource';\nimport type { ALPHA_MODES, SCALE_MODE, TEXTURE_DIMENSIONS, TEXTURE_FORMATS, WRAP_MODE } from '../const';\nimport type { TextureStyleOptions } from '../TextureStyle';\n\n/**\n * options for creating a new TextureSource\n * @memberof rendering\n */\nexport interface TextureSourceOptions<T extends Record<string, any> = any> extends TextureStyleOptions\n{\n    /**\n     * the resource that will be upladed to the GPU. This is where we get our pixels from\n     * eg an ImageBimt / Canvas / Video etc\n     */\n    resource?: T;\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    width?: number;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    height?: number;\n    /** the resolution of the texture. */\n    resolution?: number;\n    /** the format that the texture data has */\n    format?: TEXTURE_FORMATS;\n    /**\n     * Used by internal textures\n     * @ignore\n     */\n    sampleCount?: number;\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    antialias?: boolean;\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    dimensions?: TEXTURE_DIMENSIONS;\n    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n    mipLevelCount?: number;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    autoGenerateMipmaps?: boolean;\n    /** the alpha mode of the texture */\n    alphaMode?: ALPHA_MODES;\n    /** optional label, can be used for debugging */\n    label?: string;\n    /** If true, the Garbage Collector will unload this texture if it is not used after a period of time */\n    autoGarbageCollect?: boolean;\n}\n\n/**\n * A TextureSource stores the information that represents an image.\n * All textures have require TextureSource, which contains information about the source.\n * Therefore you can have many textures all using a single TextureSource (eg a sprite sheet)\n *\n * This is an class is extended depending on the source of the texture.\n * Eg if you are using an an image as your resource, then an ImageSource is used.\n * @memberof rendering\n * @typeParam T - The TextureSource's Resource type.\n */\nexport class TextureSource<T extends Record<string, any> = any> extends EventEmitter<{\n    change: BindResource;\n    update: TextureSource;\n    unload: TextureSource;\n    destroy: TextureSource;\n    resize: TextureSource;\n    styleChange: TextureSource;\n    updateMipmaps: TextureSource;\n    error: Error;\n}> implements BindResource\n{\n    /** The default options used when creating a new TextureSource. override these to add your own defaults */\n    public static defaultOptions: TextureSourceOptions = {\n        resolution: 1,\n        format: 'bgra8unorm',\n        alphaMode: 'premultiply-alpha-on-upload',\n        dimensions: '2d',\n        mipLevelCount: 1,\n        autoGenerateMipmaps: false,\n        sampleCount: 1,\n        antialias: false,\n        autoGarbageCollect: false,\n    };\n\n    /** unique id for this Texture source */\n    public readonly uid = uid('textureSource');\n    /** optional label, can be used for debugging */\n    public label: string;\n\n    /**\n     * The resource type used by this TextureSource. This is used by the bind groups to determine\n     * how to handle this resource.\n     * @ignore\n     * @internal\n     */\n    public readonly _resourceType = 'textureSource';\n    /**\n     * i unique resource id, used by the bind group systems.\n     * This can change if the texture is resized or its resource changes\n     */\n    public _resourceId = uid('resource');\n    /**\n     * this is how the backends know how to upload this texture to the GPU\n     * It changes depending on the resource type. Classes that extend TextureSource\n     * should override this property.\n     * @ignore\n     * @internal\n     */\n    public uploadMethodId = 'unknown';\n\n    // dimensions\n    public _resolution = 1;\n\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    public pixelWidth = 1;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    public pixelHeight = 1;\n\n    /**\n     * the width of this texture source, accounting for resolution\n     * eg pixelWidth 200, resolution 2, then width will be 100\n     */\n    public width = 1;\n    /**\n     * the height of this texture source, accounting for resolution\n     * eg pixelHeight 200, resolution 2, then height will be 100\n     */\n    public height = 1;\n\n    /**\n     * the resource that will be upladed to the GPU. This is where we get our pixels from\n     * eg an ImageBimt / Canvas / Video etc\n     */\n    public resource: T;\n\n    /**\n     * The number of samples of a multisample texture. This is always 1 for non-multisample textures.\n     * To enable multisample for a texture, set antialias to true\n     * @internal\n     * @ignore\n     */\n    public sampleCount = 1;\n\n    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n    public mipLevelCount = 1;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    public autoGenerateMipmaps = false;\n    /** the format that the texture data has */\n    public format: TEXTURE_FORMATS = 'rgba8unorm';\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    public dimension: TEXTURE_DIMENSIONS = '2d';\n    /** the alpha mode of the texture */\n    public alphaMode: ALPHA_MODES;\n    private _style: TextureStyle;\n\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    public antialias = false;\n\n    /**\n     * Has the source been destroyed?\n     * @readonly\n     */\n    public destroyed: boolean;\n\n    /**\n     * Used by automatic texture Garbage Collection, stores last GC tick when it was bound\n     * @protected\n     */\n    public _touched = 0;\n\n    /**\n     * Used by the batcher to build texture batches. faster to have the variable here!\n     * @protected\n     */\n    public _batchTick = -1;\n    /**\n     * A temporary batch location for the texture batching. Here for performance reasons only!\n     * @protected\n     */\n    public _textureBindLocation = -1;\n\n    public isPowerOfTwo: boolean;\n\n    /** If true, the Garbage Collector will unload this texture if it is not used after a period of time */\n    public autoGarbageCollect: boolean;\n\n    /**\n     * used internally to know where a texture came from. Usually assigned by the asset loader!\n     * @ignore\n     */\n    public _sourceOrigin: string;\n\n    /**\n     * @param options - options for creating a new TextureSource\n     */\n    constructor(protected readonly options: TextureSourceOptions<T> = {})\n    {\n        super();\n\n        options = { ...TextureSource.defaultOptions, ...options };\n\n        this.label = options.label ?? '';\n        this.resource = options.resource;\n        this.autoGarbageCollect = options.autoGarbageCollect;\n        this._resolution = options.resolution;\n\n        if (options.width)\n        {\n            this.pixelWidth = options.width * this._resolution;\n        }\n        else\n        {\n            this.pixelWidth = this.resource ? (this.resourceWidth ?? 1) : 1;\n        }\n\n        if (options.height)\n        {\n            this.pixelHeight = options.height * this._resolution;\n        }\n        else\n        {\n            this.pixelHeight = this.resource ? (this.resourceHeight ?? 1) : 1;\n        }\n\n        this.width = this.pixelWidth / this._resolution;\n        this.height = this.pixelHeight / this._resolution;\n\n        this.format = options.format;\n        this.dimension = options.dimensions;\n        this.mipLevelCount = options.mipLevelCount;\n        this.autoGenerateMipmaps = options.autoGenerateMipmaps;\n        this.sampleCount = options.sampleCount;\n        this.antialias = options.antialias;\n        this.alphaMode = options.alphaMode;\n\n        this.style = new TextureStyle(definedProps(options));\n\n        this.destroyed = false;\n\n        this._refreshPOT();\n    }\n\n    /** returns itself */\n    get source(): TextureSource\n    {\n        return this;\n    }\n\n    /** the style of the texture */\n    get style(): TextureStyle\n    {\n        return this._style;\n    }\n\n    set style(value: TextureStyle)\n    {\n        if (this.style === value) return;\n\n        this._style?.off('change', this._onStyleChange, this);\n        this._style = value;\n        this._style?.on('change', this._onStyleChange, this);\n\n        this._onStyleChange();\n    }\n\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n    get addressMode(): WRAP_MODE\n    {\n        return this._style.addressMode;\n    }\n\n    set addressMode(value: WRAP_MODE)\n    {\n        this._style.addressMode = value;\n    }\n\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n    get repeatMode(): WRAP_MODE\n    {\n        return this._style.addressMode;\n    }\n\n    set repeatMode(value: WRAP_MODE)\n    {\n        this._style.addressMode = value;\n    }\n\n    /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n    get magFilter(): SCALE_MODE\n    {\n        return this._style.magFilter;\n    }\n\n    set magFilter(value: SCALE_MODE)\n    {\n        this._style.magFilter = value;\n    }\n\n    /** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n    get minFilter(): SCALE_MODE\n    {\n        return this._style.minFilter;\n    }\n\n    set minFilter(value: SCALE_MODE)\n    {\n        this._style.minFilter = value;\n    }\n\n    /** Specifies behavior for sampling between mipmap levels. */\n    get mipmapFilter(): SCALE_MODE\n    {\n        return this._style.mipmapFilter;\n    }\n\n    set mipmapFilter(value: SCALE_MODE)\n    {\n        this._style.mipmapFilter = value;\n    }\n\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    get lodMinClamp(): number\n    {\n        return this._style.lodMinClamp;\n    }\n\n    set lodMinClamp(value: number)\n    {\n        this._style.lodMinClamp = value;\n    }\n\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    get lodMaxClamp(): number\n    {\n        return this._style.lodMaxClamp;\n    }\n\n    set lodMaxClamp(value: number)\n    {\n        this._style.lodMaxClamp = value;\n    }\n\n    private _onStyleChange()\n    {\n        this.emit('styleChange', this);\n    }\n\n    /** call this if you have modified the texture outside of the constructor */\n    public update()\n    {\n        // update resource...\n        if (this.resource)\n        {\n            const resolution = this._resolution;\n\n            const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);\n\n            // no ned to dispatch the update we resized as that will\n            // notify the texture systems anyway\n            if (didResize) return;\n        }\n\n        this.emit('update', this);\n    }\n\n    /** Destroys this texture source */\n    public destroy()\n    {\n        this.destroyed = true;\n        this.emit('destroy', this);\n\n        if (this._style)\n        {\n            this._style.destroy();\n            this._style = null;\n        }\n\n        this.uploadMethodId = null;\n        this.resource = null;\n        this.removeAllListeners();\n    }\n\n    /**\n     * This will unload the Texture source from the GPU. This will free up the GPU memory\n     * As soon as it is required fore rendering, it will be re-uploaded.\n     */\n    public unload()\n    {\n        this._resourceId = uid('resource');\n        this.emit('change', this);\n        this.emit('unload', this);\n    }\n\n    /** the width of the resource. This is the REAL pure number, not accounting resolution   */\n    public get resourceWidth(): number\n    {\n        const { resource } = this;\n\n        return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;\n    }\n\n    /** the height of the resource. This is the REAL pure number, not accounting resolution */\n    public get resourceHeight(): number\n    {\n        const { resource } = this;\n\n        return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;\n    }\n\n    /**\n     * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture\n     * but will the size of the texture when rendered.\n     *\n     * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel\n     * density will have increased)\n     */\n    get resolution(): number\n    {\n        return this._resolution;\n    }\n\n    set resolution(resolution: number)\n    {\n        if (this._resolution === resolution) return;\n\n        this._resolution = resolution;\n\n        this.width = this.pixelWidth / resolution;\n        this.height = this.pixelHeight / resolution;\n    }\n\n    /**\n     * Resize the texture, this is handy if you want to use the texture as a render texture\n     * @param width - the new width of the texture\n     * @param height - the new height of the texture\n     * @param resolution - the new resolution of the texture\n     * @returns - if the texture was resized\n     */\n    public resize(width?: number, height?: number, resolution?: number): boolean\n    {\n        resolution = resolution || this._resolution;\n        width = width || this.width;\n        height = height || this.height;\n\n        // make sure we work with rounded pixels\n        const newPixelWidth = Math.round(width * resolution);\n        const newPixelHeight = Math.round(height * resolution);\n\n        this.width = newPixelWidth / resolution;\n        this.height = newPixelHeight / resolution;\n\n        this._resolution = resolution;\n\n        if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight)\n        {\n            return false;\n        }\n\n        this._refreshPOT();\n\n        this.pixelWidth = newPixelWidth;\n        this.pixelHeight = newPixelHeight;\n\n        this.emit('resize', this);\n\n        this._resourceId = uid('resource');\n        this.emit('change', this);\n\n        return true;\n    }\n\n    /**\n     * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.\n     * This is only important for RenderTexture instances, as standard Texture instances will have their\n     * mipmaps generated on upload. You should call this method after you make any change to the texture\n     *\n     * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,\n     * We want you, the developer to specify when this action should happen.\n     *\n     * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,\n     */\n    public updateMipmaps()\n    {\n        if (this.autoGenerateMipmaps && this.mipLevelCount > 1)\n        {\n            this.emit('updateMipmaps', this);\n        }\n    }\n\n    set wrapMode(value: WRAP_MODE)\n    {\n        this._style.wrapMode = value;\n    }\n\n    get wrapMode(): WRAP_MODE\n    {\n        return this._style.wrapMode;\n    }\n\n    set scaleMode(value: SCALE_MODE)\n    {\n        this._style.scaleMode = value;\n    }\n\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n    get scaleMode(): SCALE_MODE\n    {\n        return this._style.scaleMode;\n    }\n\n    /**\n     * Refresh check for isPowerOfTwo texture based on size\n     * @private\n     */\n    protected _refreshPOT(): void\n    {\n        this.isPowerOfTwo = isPow2(this.pixelWidth) && isPow2(this.pixelHeight);\n    }\n\n    public static test(_resource: any): any\n    {\n        // this should be overridden by other sources..\n        throw new Error('Unimplemented');\n    }\n}\n","\"use strict\";\nfunction nextPow2(v) {\n  v += v === 0 ? 1 : 0;\n  --v;\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v + 1;\n}\nfunction isPow2(v) {\n  return !(v & v - 1) && !!v;\n}\nfunction log2(v) {\n  let r = (v > 65535 ? 1 : 0) << 4;\n  v >>>= r;\n  let shift = (v > 255 ? 1 : 0) << 3;\n  v >>>= shift;\n  r |= shift;\n  shift = (v > 15 ? 1 : 0) << 2;\n  v >>>= shift;\n  r |= shift;\n  shift = (v > 3 ? 1 : 0) << 1;\n  v >>>= shift;\n  r |= shift;\n  return r | v >> 1;\n}\n\nexport { isPow2, log2, nextPow2 };\n//# sourceMappingURL=pow2.mjs.map\n","// Taken from the bit-twiddle package\n\n/**\n * Rounds to next power of two.\n * @function nextPow2\n * @param {number} v - input value\n * @returns {number} - next rounded power of two\n * @memberof maths\n */\nexport function nextPow2(v: number): number\n{\n    v += v === 0 ? 1 : 0;\n    --v;\n    v |= v >>> 1;\n    v |= v >>> 2;\n    v |= v >>> 4;\n    v |= v >>> 8;\n    v |= v >>> 16;\n\n    return v + 1;\n}\n\n/**\n * Checks if a number is a power of two.\n * @function isPow2\n * @param {number} v - input value\n * @returns {boolean} `true` if value is power of two\n * @memberof maths\n */\nexport function isPow2(v: number): boolean\n{\n    return !(v & (v - 1)) && (!!v);\n}\n\n/**\n * Computes ceil of log base 2\n * @function log2\n * @param {number} v - input value\n * @returns {number} logarithm base 2\n * @memberof maths\n */\nexport function log2(v: number): number\n{\n    let r = (v > 0xFFFF ? 1 : 0) << 4;\n\n    v >>>= r;\n\n    let shift = (v > 0xFF ? 1 : 0) << 3;\n\n    v >>>= shift; r |= shift;\n    shift = (v > 0xF ? 1 : 0) << 2;\n    v >>>= shift; r |= shift;\n    shift = (v > 0x3 ? 1 : 0) << 1;\n    v >>>= shift; r |= shift;\n\n    return r | (v >> 1);\n}\n","\"use strict\";\nfunction definedProps(obj) {\n  const result = {};\n  for (const key in obj) {\n    if (obj[key] !== void 0) {\n      result[key] = obj[key];\n    }\n  }\n  return result;\n}\n\nexport { definedProps };\n//# sourceMappingURL=definedProps.mjs.map\n","/**\n * Returns a new object with all properties from the input object that have defined values.\n * @template T - The type of the input object.\n * @param {T} obj - The input object.\n * @returns {T} - A new object with only the defined properties from the input object.\n * @memberof utils\n * @ignore\n */\nexport function definedProps<T extends Record<string, any>>(obj: T): T\n{\n    const result: Partial<T> = {};\n\n    for (const key in obj)\n    {\n        if (obj[key] !== undefined)\n        {\n            result[key] = obj[key];\n        }\n    }\n\n    return result as T;\n}\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nconst idHash = /* @__PURE__ */ Object.create(null);\nfunction createResourceIdFromString(value) {\n  const id = idHash[value];\n  if (id === void 0) {\n    idHash[value] = uid(\"resource\");\n  }\n  return id;\n}\nconst _TextureStyle = class _TextureStyle extends EventEmitter {\n  /**\n   * @param options - options for the style\n   */\n  constructor(options = {}) {\n    super();\n    this._resourceType = \"textureSampler\";\n    this._touched = 0;\n    /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link GPUSamplerDescriptor#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     * @internal\n     * @ignore\n     */\n    this._maxAnisotropy = 1;\n    options = { ..._TextureStyle.defaultOptions, ...options };\n    this.addressMode = options.addressMode;\n    this.addressModeU = options.addressModeU ?? this.addressModeU;\n    this.addressModeV = options.addressModeV ?? this.addressModeV;\n    this.addressModeW = options.addressModeW ?? this.addressModeW;\n    this.scaleMode = options.scaleMode;\n    this.magFilter = options.magFilter ?? this.magFilter;\n    this.minFilter = options.minFilter ?? this.minFilter;\n    this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;\n    this.lodMinClamp = options.lodMinClamp;\n    this.lodMaxClamp = options.lodMaxClamp;\n    this.compare = options.compare;\n    this.maxAnisotropy = options.maxAnisotropy ?? 1;\n  }\n  set addressMode(value) {\n    this.addressModeU = value;\n    this.addressModeV = value;\n    this.addressModeW = value;\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get addressMode() {\n    return this.addressModeU;\n  }\n  set wrapMode(value) {\n    deprecation(v8_0_0, \"TextureStyle.wrapMode is now TextureStyle.addressMode\");\n    this.addressMode = value;\n  }\n  get wrapMode() {\n    return this.addressMode;\n  }\n  set scaleMode(value) {\n    this.magFilter = value;\n    this.minFilter = value;\n    this.mipmapFilter = value;\n  }\n  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n  get scaleMode() {\n    return this.magFilter;\n  }\n  /** Specifies the maximum anisotropy value clamp used by the sampler. */\n  set maxAnisotropy(value) {\n    this._maxAnisotropy = Math.min(value, 16);\n    if (this._maxAnisotropy > 1) {\n      this.scaleMode = \"linear\";\n    }\n  }\n  get maxAnisotropy() {\n    return this._maxAnisotropy;\n  }\n  // TODO - move this to WebGL?\n  get _resourceId() {\n    return this._sharedResourceId || this._generateResourceId();\n  }\n  update() {\n    this.emit(\"change\", this);\n    this._sharedResourceId = null;\n  }\n  _generateResourceId() {\n    const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;\n    this._sharedResourceId = createResourceIdFromString(bigKey);\n    return this._resourceId;\n  }\n  /** Destroys the style */\n  destroy() {\n    this.emit(\"destroy\", this);\n    this.removeAllListeners();\n  }\n};\n/** default options for the style */\n_TextureStyle.defaultOptions = {\n  addressMode: \"clamp-to-edge\",\n  scaleMode: \"linear\"\n};\nlet TextureStyle = _TextureStyle;\n\nexport { TextureStyle };\n//# sourceMappingURL=TextureStyle.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { COMPARE_FUNCTION, SCALE_MODE, WRAP_MODE } from './const';\n\nconst idHash: Record<string, number> = Object.create(null);\n\n/**\n * This takes a shader string and maps it to a resource id.\n * This is a little different than regular resource ids as these ids\n * are not unique to the resource. But must not overlap with other (non sampler) resources Ids.\n * @param value - the string to turn into a resource id\n * @returns a unique resource id\n */\nfunction createResourceIdFromString(value: string): number\n{\n    const id = idHash[value];\n\n    if (id === undefined)\n    {\n        idHash[value] = uid('resource');\n    }\n\n    return id;\n}\n\nexport interface TextureStyleOptions extends Partial<TextureStyle>\n{\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n    addressMode?: WRAP_MODE;\n    /** specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    addressModeU?: WRAP_MODE;\n    /** specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    addressModeV?: WRAP_MODE;\n    /** Specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    addressModeW?: WRAP_MODE;\n\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n    scaleMode?: SCALE_MODE;\n\n    /** specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n    magFilter?: SCALE_MODE;\n    /** specifies the sampling behavior when the sample footprint is larger than one texel. */\n    minFilter?: SCALE_MODE;\n    /** specifies behavior for sampling between mipmap levels. */\n    mipmapFilter?: SCALE_MODE;\n\n    /** specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    lodMinClamp?: number;\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    lodMaxClamp?: number;\n    /**\n     * When provided the sampler will be a comparison sampler with the specified\n     * {@link GPUCompareFunction}.\n     * Note: Comparison samplers may use filtering, but the sampling results will be\n     * implementation-dependent and may differ from the normal filtering rules.\n     */\n    compare?: COMPARE_FUNCTION;\n    /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link GPUSamplerDescriptor#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     *\n     * setting this to anything higher than 1 will set scale modes to 'linear'\n     */\n    maxAnisotropy?: number;\n}\n\n/**\n * A texture style describes how a texture should be sampled by a shader.\n * @memberof rendering\n */\nexport class TextureStyle extends EventEmitter<{\n    change: TextureStyle,\n    destroy: TextureStyle,\n}> implements BindResource\n{\n    public _resourceType = 'textureSampler';\n    public _touched = 0;\n    private _sharedResourceId: number;\n\n    /** default options for the style */\n    public static readonly defaultOptions: TextureStyleOptions = {\n        addressMode: 'clamp-to-edge',\n        scaleMode: 'linear'\n    };\n\n    /** */\n    public addressModeU?: WRAP_MODE;\n    /** */\n    public addressModeV?: WRAP_MODE;\n    /** Specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    public addressModeW?: WRAP_MODE;\n    /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n    public magFilter?: SCALE_MODE;\n    /** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n    public minFilter?: SCALE_MODE;\n    /** Specifies behavior for sampling between mipmap levels. */\n    public mipmapFilter?: SCALE_MODE;\n    /** */\n    public lodMinClamp?: number;\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    public lodMaxClamp?: number;\n    /**\n     * When provided the sampler will be a comparison sampler with the specified\n     * {@link GPUCompareFunction}.\n     * Note: Comparison samplers may use filtering, but the sampling results will be\n     * implementation-dependent and may differ from the normal filtering rules.\n     */\n    public compare?: COMPARE_FUNCTION;\n    /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link GPUSamplerDescriptor#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     * @internal\n     * @ignore\n     */\n    public _maxAnisotropy?: number = 1;\n\n    /**\n     * @param options - options for the style\n     */\n    constructor(options: TextureStyleOptions = {})\n    {\n        super();\n\n        options = { ...TextureStyle.defaultOptions, ...options };\n\n        this.addressMode = options.addressMode;\n\n        this.addressModeU = options.addressModeU ?? this.addressModeU;\n        this.addressModeV = options.addressModeV ?? this.addressModeV;\n        this.addressModeW = options.addressModeW ?? this.addressModeW;\n\n        this.scaleMode = options.scaleMode;\n\n        this.magFilter = options.magFilter ?? this.magFilter;\n        this.minFilter = options.minFilter ?? this.minFilter;\n        this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;\n\n        this.lodMinClamp = options.lodMinClamp;\n        this.lodMaxClamp = options.lodMaxClamp;\n\n        this.compare = options.compare;\n\n        this.maxAnisotropy = options.maxAnisotropy ?? 1;\n    }\n\n    set addressMode(value: WRAP_MODE)\n    {\n        this.addressModeU = value;\n        this.addressModeV = value;\n        this.addressModeW = value;\n    }\n\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n    get addressMode(): WRAP_MODE\n    {\n        return this.addressModeU;\n    }\n\n    set wrapMode(value: WRAP_MODE)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'TextureStyle.wrapMode is now TextureStyle.addressMode');\n        // #endif\n\n        this.addressMode = value;\n    }\n\n    get wrapMode(): WRAP_MODE\n    {\n        return this.addressMode;\n    }\n\n    set scaleMode(value: SCALE_MODE)\n    {\n        this.magFilter = value;\n        this.minFilter = value;\n        this.mipmapFilter = value;\n    }\n\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n    get scaleMode(): SCALE_MODE\n    {\n        return this.magFilter;\n    }\n\n    /** Specifies the maximum anisotropy value clamp used by the sampler. */\n    set maxAnisotropy(value: number)\n    {\n        this._maxAnisotropy = Math.min(value, 16);\n\n        if (this._maxAnisotropy > 1)\n        {\n            this.scaleMode = 'linear';\n        }\n    }\n\n    get maxAnisotropy(): number\n    {\n        return this._maxAnisotropy;\n    }\n\n    // TODO - move this to WebGL?\n    get _resourceId(): number\n    {\n        return this._sharedResourceId || this._generateResourceId();\n    }\n\n    public update()\n    {\n        // manage the resource..\n        this.emit('change', this);\n        this._sharedResourceId = null;\n    }\n\n    private _generateResourceId(): number\n    {\n        // eslint-disable-next-line max-len\n        const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;\n\n        this._sharedResourceId = createResourceIdFromString(bigKey);\n\n        return this._resourceId;\n    }\n\n    /** Destroys the style */\n    public destroy()\n    {\n        this.emit('destroy', this);\n\n        this.removeAllListeners();\n    }\n}\n","import { Matrix } from '../../../../maths/matrix/Matrix.mjs';\n\n\"use strict\";\nconst tempMat = new Matrix();\nclass TextureMatrix {\n  /**\n   * @param texture - observed texture\n   * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n   */\n  constructor(texture, clampMargin) {\n    this.mapCoord = new Matrix();\n    this.uClampFrame = new Float32Array(4);\n    this.uClampOffset = new Float32Array(2);\n    this._textureID = -1;\n    this._updateID = 0;\n    this.clampOffset = 0;\n    if (typeof clampMargin === \"undefined\") {\n      this.clampMargin = texture.width < 10 ? 0 : 0.5;\n    } else {\n      this.clampMargin = clampMargin;\n    }\n    this.isSimple = false;\n    this.texture = texture;\n  }\n  /** Texture property. */\n  get texture() {\n    return this._texture;\n  }\n  set texture(value) {\n    if (this.texture === value)\n      return;\n    this._texture?.removeListener(\"update\", this.update, this);\n    this._texture = value;\n    this._texture.addListener(\"update\", this.update, this);\n    this.update();\n  }\n  /**\n   * Multiplies uvs array to transform\n   * @param uvs - mesh uvs\n   * @param [out=uvs] - output\n   * @returns - output\n   */\n  multiplyUvs(uvs, out) {\n    if (out === void 0) {\n      out = uvs;\n    }\n    const mat = this.mapCoord;\n    for (let i = 0; i < uvs.length; i += 2) {\n      const x = uvs[i];\n      const y = uvs[i + 1];\n      out[i] = x * mat.a + y * mat.c + mat.tx;\n      out[i + 1] = x * mat.b + y * mat.d + mat.ty;\n    }\n    return out;\n  }\n  /**\n   * Updates matrices if texture was changed\n   * @returns - whether or not it was updated\n   */\n  update() {\n    const tex = this._texture;\n    this._updateID++;\n    const uvs = tex.uvs;\n    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n    const orig = tex.orig;\n    const trim = tex.trim;\n    if (trim) {\n      tempMat.set(\n        orig.width / trim.width,\n        0,\n        0,\n        orig.height / trim.height,\n        -trim.x / trim.width,\n        -trim.y / trim.height\n      );\n      this.mapCoord.append(tempMat);\n    }\n    const texBase = tex.source;\n    const frame = this.uClampFrame;\n    const margin = this.clampMargin / texBase._resolution;\n    const offset = this.clampOffset;\n    frame[0] = (tex.frame.x + margin + offset) / texBase.width;\n    frame[1] = (tex.frame.y + margin + offset) / texBase.height;\n    frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;\n    frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;\n    this.uClampOffset[0] = offset / texBase.pixelWidth;\n    this.uClampOffset[1] = offset / texBase.pixelHeight;\n    this.isSimple = tex.frame.width === texBase.width && tex.frame.height === texBase.height && tex.rotate === 0;\n    return true;\n  }\n}\n\nexport { TextureMatrix };\n//# sourceMappingURL=TextureMatrix.mjs.map\n","import { Matrix } from '../../../../maths/matrix/Matrix';\n\nimport type { Texture } from './Texture';\n\nconst tempMat = new Matrix();\n\n/**\n * Class controls uv mapping from Texture normal space to BaseTexture normal space.\n *\n * Takes `trim` and `rotate` into account. May contain clamp settings for Meshes and TilingSprite.\n *\n * Can be used in Texture `uvMatrix` field, or separately, you can use different clamp settings on the same texture.\n * If you want to add support for texture region of certain feature or filter, that's what you're looking for.\n *\n * Takes track of Texture changes through `_lastTextureID` private field.\n * Use `update()` method call to track it from outside.\n * @see Texture\n * @see Mesh\n * @see TilingSprite\n * @memberof rendering\n */\nexport class TextureMatrix\n{\n    /**\n     * Matrix operation that converts texture region coords to texture coords\n     * @readonly\n     */\n    public mapCoord: Matrix;\n\n    /**\n     * Changes frame clamping\n     * Works with TilingSprite and Mesh\n     * Change to 1.5 if you texture has repeated right and bottom lines, that leads to smoother borders\n     * @default 0\n     */\n    public clampOffset: number;\n\n    /**\n     * Changes frame clamping\n     * Works with TilingSprite and Mesh\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     * @default 0.5\n     */\n    public clampMargin: number;\n\n    /**\n     * Clamp region for normalized coords, left-top pixel center in xy , bottom-right in zw.\n     * Calculated based on clampOffset.\n     */\n    public readonly uClampFrame: Float32Array;\n\n    /** Normalized clamp offset. Calculated based on clampOffset. */\n    public readonly uClampOffset: Float32Array;\n\n    /**\n     * Tracks Texture frame changes.\n     * @ignore\n     */\n    public _updateID: number;\n\n    /**\n     * Tracks Texture frame changes.\n     * @protected\n     */\n    protected _textureID: number;\n\n    protected _texture: Texture;\n\n    /**\n     * If texture size is the same as baseTexture.\n     * @default false\n     * @readonly\n     */\n    public isSimple: boolean;\n\n    /**\n     * @param texture - observed texture\n     * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n     */\n    constructor(texture: Texture, clampMargin?: number)\n    {\n        this.mapCoord = new Matrix();\n        this.uClampFrame = new Float32Array(4);\n        this.uClampOffset = new Float32Array(2);\n        this._textureID = -1;\n        this._updateID = 0;\n\n        this.clampOffset = 0;\n\n        if ((typeof clampMargin === 'undefined'))\n        {\n            this.clampMargin = (texture.width < 10) ? 0 : 0.5;\n        }\n        else\n        {\n            this.clampMargin = clampMargin;\n        }\n\n        this.isSimple = false;\n\n        this.texture = texture;\n    }\n\n    /** Texture property. */\n    get texture(): Texture\n    {\n        return this._texture;\n    }\n\n    set texture(value: Texture)\n    {\n        if (this.texture === value) return;\n\n        this._texture?.removeListener('update', this.update, this);\n        this._texture = value;\n        this._texture.addListener('update', this.update, this);\n\n        this.update();\n    }\n\n    /**\n     * Multiplies uvs array to transform\n     * @param uvs - mesh uvs\n     * @param [out=uvs] - output\n     * @returns - output\n     */\n    public multiplyUvs(uvs: Float32Array, out?: Float32Array): Float32Array\n    {\n        if (out === undefined)\n        {\n            out = uvs;\n        }\n\n        const mat = this.mapCoord;\n\n        for (let i = 0; i < uvs.length; i += 2)\n        {\n            const x = uvs[i];\n            const y = uvs[i + 1];\n\n            out[i] = (x * mat.a) + (y * mat.c) + mat.tx;\n            out[i + 1] = (x * mat.b) + (y * mat.d) + mat.ty;\n        }\n\n        return out;\n    }\n\n    /**\n     * Updates matrices if texture was changed\n     * @returns - whether or not it was updated\n     */\n    public update(): boolean\n    {\n        const tex = this._texture;\n\n        this._updateID++;\n\n        const uvs = tex.uvs;\n\n        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n\n        const orig = tex.orig;\n        const trim = tex.trim;\n\n        if (trim)\n        {\n            tempMat.set(\n                orig.width / trim.width,\n                0, 0, orig.height / trim.height,\n                -trim.x / trim.width,\n                -trim.y / trim.height\n            );\n\n            this.mapCoord.append(tempMat);\n        }\n\n        const texBase = tex.source;\n        const frame = this.uClampFrame;\n        const margin = this.clampMargin / texBase._resolution;\n        const offset = this.clampOffset;\n\n        frame[0] = (tex.frame.x + margin + offset) / texBase.width;\n        frame[1] = (tex.frame.y + margin + offset) / texBase.height;\n        frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;\n        frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;\n\n        this.uClampOffset[0] = offset / texBase.pixelWidth;\n        this.uClampOffset[1] = offset / texBase.pixelHeight;\n\n        this.isSimple = tex.frame.width === texBase.width\n            && tex.frame.height === texBase.height\n            && tex.rotate === 0;\n\n        return true;\n    }\n}\n","import { ObservablePoint } from '../../maths/point/ObservablePoint.mjs';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { updateQuadBounds } from '../../utils/data/updateQuadBounds.mjs';\nimport { Container } from '../container/Container.mjs';\n\n\"use strict\";\nclass Sprite extends Container {\n  /**\n   * @param options - The options for creating the sprite.\n   */\n  constructor(options = Texture.EMPTY) {\n    if (options instanceof Texture) {\n      options = { texture: options };\n    }\n    const { texture, anchor, roundPixels, width, height, ...rest } = options;\n    super({\n      label: \"Sprite\",\n      ...rest\n    });\n    this.renderPipeId = \"sprite\";\n    this.batched = true;\n    this._didSpriteUpdate = false;\n    this._bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    this._sourceBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    this._boundsDirty = true;\n    this._sourceBoundsDirty = true;\n    this._roundPixels = 0;\n    this._anchor = new ObservablePoint(\n      {\n        _onUpdate: () => {\n          this.onViewUpdate();\n        }\n      }\n    );\n    if (anchor)\n      this.anchor = anchor;\n    this.texture = texture;\n    this.allowChildren = false;\n    this.roundPixels = roundPixels ?? false;\n    if (width)\n      this.width = width;\n    if (height)\n      this.height = height;\n  }\n  /**\n   * Helper function that creates a new sprite based on the source you provide.\n   * The source can be - frame id, image, video, canvas element, video element, texture\n   * @param source - Source to create texture from\n   * @param [skipCache] - Whether to skip the cache or not\n   * @returns The newly created sprite\n   */\n  static from(source, skipCache = false) {\n    if (source instanceof Texture) {\n      return new Sprite(source);\n    }\n    return new Sprite(Texture.from(source, skipCache));\n  }\n  set texture(value) {\n    value || (value = Texture.EMPTY);\n    const currentTexture = this._texture;\n    if (currentTexture === value)\n      return;\n    if (currentTexture && currentTexture.dynamic)\n      currentTexture.off(\"update\", this.onViewUpdate, this);\n    if (value.dynamic)\n      value.on(\"update\", this.onViewUpdate, this);\n    this._texture = value;\n    this.onViewUpdate();\n  }\n  /** The texture that the sprite is using. */\n  get texture() {\n    return this._texture;\n  }\n  /**\n   * The local bounds of the sprite.\n   * @type {rendering.Bounds}\n   */\n  get bounds() {\n    if (this._boundsDirty) {\n      this._updateBounds();\n      this._boundsDirty = false;\n    }\n    return this._bounds;\n  }\n  /**\n   * The bounds of the sprite, taking the texture's trim into account.\n   * @type {rendering.Bounds}\n   */\n  get sourceBounds() {\n    if (this._sourceBoundsDirty) {\n      this._updateSourceBounds();\n      this._sourceBoundsDirty = false;\n    }\n    return this._sourceBounds;\n  }\n  /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    const bounds = this.sourceBounds;\n    if (point.x >= bounds.maxX && point.x <= bounds.minX) {\n      if (point.y >= bounds.maxY && point.y <= bounds.minY) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Adds the bounds of this object to the bounds object.\n   * @param bounds - The output bounds object.\n   */\n  addBounds(bounds) {\n    const _bounds = this._texture.trim ? this.sourceBounds : this.bounds;\n    bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);\n  }\n  onViewUpdate() {\n    this._didChangeId += 1 << 12;\n    this._didSpriteUpdate = true;\n    this._sourceBoundsDirty = this._boundsDirty = true;\n    if (this.didViewUpdate)\n      return;\n    this.didViewUpdate = true;\n    if (this.renderGroup) {\n      this.renderGroup.onChildViewUpdate(this);\n    }\n  }\n  _updateBounds() {\n    updateQuadBounds(this._bounds, this._anchor, this._texture, 0);\n  }\n  _updateSourceBounds() {\n    const anchor = this._anchor;\n    const texture = this._texture;\n    const sourceBounds = this._sourceBounds;\n    const { width, height } = texture.orig;\n    sourceBounds.maxX = -anchor._x * width;\n    sourceBounds.minX = sourceBounds.maxX + width;\n    sourceBounds.maxY = -anchor._y * height;\n    sourceBounds.minY = sourceBounds.maxY + height;\n  }\n  /**\n   * Destroys this sprite renderable and optionally its texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n   */\n  destroy(options = false) {\n    super.destroy(options);\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      this._texture.destroy(destroyTextureSource);\n    }\n    this._texture = null;\n    this._bounds = null;\n    this._sourceBounds = null;\n    this._anchor = null;\n  }\n  /**\n   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n   * and passed to the constructor.\n   *\n   * The default is `(0,0)`, this means the sprite's origin is the top left.\n   *\n   * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n   *\n   * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * import { Sprite } from 'pixi.js';\n   *\n   * const sprite = new Sprite({texture: Texture.WHITE});\n   * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n   */\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    typeof value === \"number\" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n  }\n  /**\n   *  Whether or not to round the x/y position of the sprite.\n   * @type {boolean}\n   */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  set roundPixels(value) {\n    this._roundPixels = value ? 1 : 0;\n  }\n  /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get width() {\n    return Math.abs(this.scale.x) * this._texture.orig.width;\n  }\n  set width(value) {\n    this._setWidth(value, this._texture.orig.width);\n  }\n  /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get height() {\n    return Math.abs(this.scale.y) * this._texture.orig.height;\n  }\n  set height(value) {\n    this._setHeight(value, this._texture.orig.height);\n  }\n  /**\n   * Retrieves the size of the Sprite as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the Sprite.\n   */\n  getSize(out) {\n    if (!out) {\n      out = {};\n    }\n    out.width = Math.abs(this.scale.x) * this._texture.orig.width;\n    out.height = Math.abs(this.scale.y) * this._texture.orig.height;\n    return out;\n  }\n  /**\n   * Sets the size of the Sprite to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   */\n  setSize(value, height) {\n    let convertedWidth;\n    let convertedHeight;\n    if (typeof value !== \"object\") {\n      convertedWidth = value;\n      convertedHeight = height ?? value;\n    } else {\n      convertedWidth = value.width;\n      convertedHeight = value.height ?? value.width;\n    }\n    if (convertedWidth !== void 0) {\n      this._setWidth(convertedWidth, this._texture.orig.width);\n    }\n    if (convertedHeight !== void 0) {\n      this._setHeight(convertedHeight, this._texture.orig.height);\n    }\n  }\n}\n\nexport { Sprite };\n//# sourceMappingURL=Sprite.mjs.map\n","import { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { updateQuadBounds } from '../../utils/data/updateQuadBounds';\nimport { Container } from '../container/Container';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { TextureSourceLike } from '../../rendering/renderers/shared/texture/Texture';\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { Bounds, BoundsData } from '../container/bounds/Bounds';\nimport type { ContainerOptions } from '../container/Container';\nimport type { Optional } from '../container/container-mixins/measureMixin';\nimport type { DestroyOptions } from '../container/destroyTypes';\n\n/**\n * Options for the {@link scene.Sprite} constructor.\n * @memberof scene\n */\nexport interface SpriteOptions extends ContainerOptions\n{\n    /** The texture to use for the sprite. */\n    texture?: Texture;\n    /** The anchor point of the sprite. */\n    anchor?: PointData | number;\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n\n/**\n * The Sprite object is one of the most important objects in PixiJS. It is a\n * drawing item that can be added to a scene and rendered to the screen.\n *\n * A sprite can be created directly from an image like this:\n *\n * ```js\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('assets/image.png');\n * ```\n *\n * The more efficient way to create sprites is using a {@link assets.Spritesheet},\n * as swapping base textures when rendering to the screen is inefficient.\n *\n * ```js\n * import { Assets, Sprite } from 'pixi.js';\n *\n * const sheet = await Assets.load('assets/spritesheet.json');\n * const sprite = new Sprite(sheet.textures['image.png']);\n * ```\n * @memberof scene\n * @extends scene.Container\n */\nexport class Sprite extends Container implements View\n{\n    /**\n     * Helper function that creates a new sprite based on the source you provide.\n     * The source can be - frame id, image, video, canvas element, video element, texture\n     * @param source - Source to create texture from\n     * @param [skipCache] - Whether to skip the cache or not\n     * @returns The newly created sprite\n     */\n    public static from(source: Texture | TextureSourceLike, skipCache = false): Sprite\n    {\n        if (source instanceof Texture)\n        {\n            return new Sprite(source);\n        }\n\n        return new Sprite(Texture.from(source, skipCache));\n    }\n\n    public readonly renderPipeId = 'sprite';\n\n    public batched = true;\n    public readonly _anchor: ObservablePoint;\n\n    // sprite specific..\n    public _texture: Texture;\n    public _didSpriteUpdate = false;\n\n    private readonly _bounds: BoundsData = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    private readonly _sourceBounds: BoundsData = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    private _boundsDirty = true;\n    private _sourceBoundsDirty = true;\n\n    public _roundPixels: 0 | 1 = 0;\n\n    /**\n     * @param options - The options for creating the sprite.\n     */\n    constructor(options: SpriteOptions | Texture = Texture.EMPTY)\n    {\n        if (options instanceof Texture)\n        {\n            options = { texture: options };\n        }\n\n        // split out\n        const { texture, anchor, roundPixels, width, height, ...rest } = options;\n\n        super({\n            label: 'Sprite',\n            ...rest\n        });\n\n        this._anchor = new ObservablePoint(\n            {\n                _onUpdate: () =>\n                {\n                    this.onViewUpdate();\n                }\n            },\n        );\n\n        if (anchor) this.anchor = anchor;\n        this.texture = texture;\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n\n        // needs to be set after the container has initiated\n        if (width) this.width = width;\n        if (height) this.height = height;\n    }\n\n    set texture(value: Texture)\n    {\n        value ||= Texture.EMPTY;\n\n        const currentTexture = this._texture;\n\n        if (currentTexture === value) return;\n\n        if (currentTexture && currentTexture.dynamic) currentTexture.off('update', this.onViewUpdate, this);\n        if (value.dynamic) value.on('update', this.onViewUpdate, this);\n\n        this._texture = value;\n\n        this.onViewUpdate();\n    }\n\n    /** The texture that the sprite is using. */\n    get texture()\n    {\n        return this._texture;\n    }\n\n    /**\n     * The local bounds of the sprite.\n     * @type {rendering.Bounds}\n     */\n    get bounds()\n    {\n        if (this._boundsDirty)\n        {\n            this._updateBounds();\n            this._boundsDirty = false;\n        }\n\n        return this._bounds;\n    }\n\n    /**\n     * The bounds of the sprite, taking the texture's trim into account.\n     * @type {rendering.Bounds}\n     */\n    get sourceBounds()\n    {\n        if (this._sourceBoundsDirty)\n        {\n            this._updateSourceBounds();\n            this._sourceBoundsDirty = false;\n        }\n\n        return this._sourceBounds;\n    }\n\n    /**\n     * Checks if the object contains the given point.\n     * @param point - The point to check\n     */\n    public containsPoint(point: PointData)\n    {\n        const bounds = this.sourceBounds;\n\n        if (point.x >= bounds.maxX && point.x <= bounds.minX)\n        {\n            if (point.y >= bounds.maxY && point.y <= bounds.minY)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Adds the bounds of this object to the bounds object.\n     * @param bounds - The output bounds object.\n     */\n    public addBounds(bounds: Bounds)\n    {\n        const _bounds = this._texture.trim ? this.sourceBounds : this.bounds;\n\n        bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);\n    }\n\n    public onViewUpdate()\n    {\n        // increment from the 12th bit!\n        this._didChangeId += 1 << 12;\n        this._didSpriteUpdate = true;\n        this._sourceBoundsDirty = this._boundsDirty = true;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        if (this.renderGroup)\n        {\n            this.renderGroup.onChildViewUpdate(this);\n        }\n    }\n\n    private _updateBounds()\n    {\n        updateQuadBounds(this._bounds, this._anchor, this._texture, 0);\n    }\n\n    private _updateSourceBounds()\n    {\n        const anchor = this._anchor;\n        const texture = this._texture;\n\n        const sourceBounds = this._sourceBounds;\n\n        const { width, height } = texture.orig;\n\n        sourceBounds.maxX = -anchor._x * width;\n        sourceBounds.minX = sourceBounds.maxX + width;\n\n        sourceBounds.maxY = -anchor._y * height;\n        sourceBounds.minY = sourceBounds.maxY + height;\n    }\n\n    /**\n     * Destroys this sprite renderable and optionally its texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n     */\n    public destroy(options: DestroyOptions = false)\n    {\n        super.destroy(options);\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            this._texture.destroy(destroyTextureSource);\n        }\n\n        this._texture = null;\n        (this._bounds as null) = null;\n        (this._sourceBounds as null) = null;\n        (this._anchor as null) = null;\n    }\n\n    /**\n     * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n     * and passed to the constructor.\n     *\n     * The default is `(0,0)`, this means the sprite's origin is the top left.\n     *\n     * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n     *\n     * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n     *\n     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n     * @example\n     * import { Sprite } from 'pixi.js';\n     *\n     * const sprite = new Sprite({texture: Texture.WHITE});\n     * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n     */\n    get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    set anchor(value: PointData | number)\n    {\n        typeof value === 'number' ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n\n    /**\n     *  Whether or not to round the x/y position of the sprite.\n     * @type {boolean}\n     */\n    get roundPixels()\n    {\n        return !!this._roundPixels;\n    }\n\n    set roundPixels(value: boolean)\n    {\n        this._roundPixels = value ? 1 : 0;\n    }\n\n    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n    override get width(): number\n    {\n        return Math.abs(this.scale.x) * this._texture.orig.width;\n    }\n\n    override set width(value: number)\n    {\n        this._setWidth(value, this._texture.orig.width);\n    }\n\n    /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n    override get height(): number\n    {\n        return Math.abs(this.scale.y) * this._texture.orig.height;\n    }\n\n    override set height(value: number)\n    {\n        this._setHeight(value, this._texture.orig.height);\n    }\n\n    /**\n     * Retrieves the size of the Sprite as a [Size]{@link Size} object.\n     * This is faster than get the width and height separately.\n     * @param out - Optional object to store the size in.\n     * @returns - The size of the Sprite.\n     */\n    public override getSize(out?: Size): Size\n    {\n        if (!out)\n        {\n            out = {} as Size;\n        }\n\n        out.width = Math.abs(this.scale.x) * this._texture.orig.width;\n        out.height = Math.abs(this.scale.y) * this._texture.orig.height;\n\n        return out;\n    }\n\n    /**\n     * Sets the size of the Sprite to the specified width and height.\n     * This is faster than setting the width and height separately.\n     * @param value - This can be either a number or a [Size]{@link Size} object.\n     * @param height - The height to set. Defaults to the value of `width` if not provided.\n     */\n    public override setSize(value: number | Optional<Size, 'height'>, height?: number)\n    {\n        let convertedWidth: number;\n        let convertedHeight: number;\n\n        if (typeof value !== 'object')\n        {\n            convertedWidth = value;\n            convertedHeight = height ?? value;\n        }\n        else\n        {\n            convertedWidth = value.width;\n            convertedHeight = value.height ?? value.width;\n        }\n\n        if (convertedWidth !== undefined)\n        {\n            this._setWidth(convertedWidth, this._texture.orig.width);\n        }\n\n        if (convertedHeight !== undefined)\n        {\n            this._setHeight(convertedHeight, this._texture.orig.height);\n        }\n    }\n}\n","\"use strict\";\nfunction updateQuadBounds(bounds, anchor, texture, padding) {\n  const { width, height } = texture.orig;\n  const trim = texture.trim;\n  if (trim) {\n    const sourceWidth = trim.width;\n    const sourceHeight = trim.height;\n    bounds.minX = trim.x - anchor._x * width - padding;\n    bounds.maxX = bounds.minX + sourceWidth;\n    bounds.minY = trim.y - anchor._y * height - padding;\n    bounds.maxY = bounds.minY + sourceHeight;\n  } else {\n    bounds.minX = -anchor._x * width - padding;\n    bounds.maxX = bounds.minX + width;\n    bounds.minY = -anchor._y * height - padding;\n    bounds.maxY = bounds.minY + height;\n  }\n  return;\n}\n\nexport { updateQuadBounds };\n//# sourceMappingURL=updateQuadBounds.mjs.map\n","import type { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../../scene/container/bounds/Bounds';\n\nexport function updateQuadBounds(\n    bounds: BoundsData,\n    anchor: ObservablePoint,\n    texture: Texture,\n    padding: number\n)\n{\n    const { width, height } = texture.orig;\n    const trim = texture.trim;\n\n    if (trim)\n    {\n        const sourceWidth = trim.width;\n        const sourceHeight = trim.height;\n\n        bounds.minX = (trim.x) - (anchor._x * width) - padding;\n        bounds.maxX = bounds.minX + sourceWidth;\n\n        bounds.minY = (trim.y) - (anchor._y * height) - padding;\n        bounds.maxY = bounds.minY + sourceHeight;\n    }\n\n    else\n    {\n        bounds.minX = (-anchor._x * width) - padding;\n        bounds.maxX = bounds.minX + width;\n\n        bounds.minY = (-anchor._y * height) - padding;\n        bounds.maxY = bounds.minY + height;\n    }\n\n    return;\n}\n","import { DOMAdapter } from '../../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../../extensions/Extensions.mjs';\nimport { TextureSource } from './TextureSource.mjs';\n\n\"use strict\";\nclass CanvasSource extends TextureSource {\n  constructor(options) {\n    if (!options.resource) {\n      options.resource = DOMAdapter.get().createCanvas();\n    }\n    if (!options.width) {\n      options.width = options.resource.width;\n      if (!options.autoDensity) {\n        options.width /= options.resolution;\n      }\n    }\n    if (!options.height) {\n      options.height = options.resource.height;\n      if (!options.autoDensity) {\n        options.height /= options.resolution;\n      }\n    }\n    super(options);\n    this.uploadMethodId = \"image\";\n    this.autoDensity = options.autoDensity;\n    const canvas = options.resource;\n    if (this.pixelWidth !== canvas.width || this.pixelWidth !== canvas.height) {\n      this.resizeCanvas();\n    }\n    this.transparent = !!options.transparent;\n  }\n  resizeCanvas() {\n    if (this.autoDensity) {\n      this.resource.style.width = `${this.width}px`;\n      this.resource.style.height = `${this.height}px`;\n    }\n    if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) {\n      this.resource.width = this.pixelWidth;\n      this.resource.height = this.pixelHeight;\n    }\n  }\n  resize(width = this.width, height = this.height, resolution = this._resolution) {\n    const didResize = super.resize(width, height, resolution);\n    if (didResize) {\n      this.resizeCanvas();\n    }\n    return didResize;\n  }\n  static test(resource) {\n    return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas;\n  }\n}\nCanvasSource.extension = ExtensionType.TextureSource;\n\nexport { CanvasSource };\n//# sourceMappingURL=CanvasSource.mjs.map\n","import { DOMAdapter } from '../../../../../environment/adapter';\nimport { ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from './TextureSource';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { TextureSourceOptions } from './TextureSource';\n\nexport interface CanvasSourceOptions extends TextureSourceOptions<ICanvas>\n{\n    /** should the canvas be resized to preserve its screen width and height regardless of the resolution of the renderer */\n    autoDensity?: boolean;\n    /** if true, this canvas will be set up to be transparent where possible */\n    transparent?: boolean;\n}\n\nexport class CanvasSource extends TextureSource<ICanvas>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n\n    public uploadMethodId = 'image';\n    public autoDensity: boolean;\n    public transparent: boolean;\n\n    constructor(options: CanvasSourceOptions)\n    {\n        if (!options.resource)\n        {\n            options.resource = DOMAdapter.get().createCanvas();\n        }\n\n        if (!options.width)\n        {\n            options.width = options.resource.width;\n\n            if (!options.autoDensity)\n            {\n                options.width /= options.resolution;\n            }\n        }\n\n        if (!options.height)\n        {\n            options.height = options.resource.height;\n\n            if (!options.autoDensity)\n            {\n                options.height /= options.resolution;\n            }\n        }\n\n        super(options);\n\n        this.autoDensity = options.autoDensity;\n\n        const canvas = options.resource;\n\n        if (this.pixelWidth !== canvas.width || this.pixelWidth !== canvas.height)\n        {\n            this.resizeCanvas();\n        }\n\n        this.transparent = !!options.transparent;\n    }\n\n    public resizeCanvas()\n    {\n        if (this.autoDensity)\n        {\n            this.resource.style.width = `${this.width}px`;\n            this.resource.style.height = `${this.height}px`;\n        }\n\n        // only resize if wee need to, as this clears the canvas (even if values are set to the same)\n        if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight)\n        {\n            this.resource.width = this.pixelWidth;\n            this.resource.height = this.pixelHeight;\n        }\n    }\n\n    public resize(width = this.width, height = this.height, resolution = this._resolution): boolean\n    {\n        const didResize = super.resize(width, height, resolution);\n\n        if (didResize)\n        {\n            this.resizeCanvas();\n        }\n\n        return didResize;\n    }\n\n    public static test(resource: any): resource is ICanvas\n    {\n        return (globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement)\n        || (globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas);\n    }\n}\n","import { Buffer } from '../../renderers/shared/buffer/Buffer.mjs';\nimport { BufferUsage } from '../../renderers/shared/buffer/const.mjs';\nimport { Geometry } from '../../renderers/shared/geometry/Geometry.mjs';\n\n\"use strict\";\nconst placeHolderBufferData = new Float32Array(1);\nconst placeHolderIndexData = new Uint32Array(1);\nclass BatchGeometry extends Geometry {\n  constructor() {\n    const vertexSize = 6;\n    const attributeBuffer = new Buffer({\n      data: placeHolderBufferData,\n      label: \"attribute-batch-buffer\",\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n      shrinkToFit: false\n    });\n    const indexBuffer = new Buffer({\n      data: placeHolderIndexData,\n      label: \"index-batch-buffer\",\n      usage: BufferUsage.INDEX | BufferUsage.COPY_DST,\n      // | BufferUsage.STATIC,\n      shrinkToFit: false\n    });\n    const stride = vertexSize * 4;\n    super({\n      attributes: {\n        aPosition: {\n          buffer: attributeBuffer,\n          format: \"float32x2\",\n          stride,\n          offset: 0,\n          location: 1\n        },\n        aUV: {\n          buffer: attributeBuffer,\n          format: \"float32x2\",\n          stride,\n          offset: 2 * 4,\n          location: 3\n        },\n        aColor: {\n          buffer: attributeBuffer,\n          format: \"unorm8x4\",\n          stride,\n          offset: 4 * 4,\n          location: 0\n        },\n        aTextureIdAndRound: {\n          buffer: attributeBuffer,\n          format: \"uint16x2\",\n          stride,\n          offset: 5 * 4,\n          location: 2\n        }\n      },\n      indexBuffer\n    });\n  }\n}\n\nexport { BatchGeometry };\n//# sourceMappingURL=BatchGeometry.mjs.map\n","import { Buffer } from '../../renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../renderers/shared/buffer/const';\nimport { Geometry } from '../../renderers/shared/geometry/Geometry';\n\nconst placeHolderBufferData = new Float32Array(1);\nconst placeHolderIndexData = new Uint32Array(1);\n\nexport class BatchGeometry extends Geometry\n{\n    constructor()\n    {\n        const vertexSize = 6;\n\n        const attributeBuffer = new Buffer({\n            data: placeHolderBufferData,\n            label: 'attribute-batch-buffer',\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n            shrinkToFit: false,\n        });\n\n        const indexBuffer = new Buffer({\n            data: placeHolderIndexData,\n            label: 'index-batch-buffer',\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST, // | BufferUsage.STATIC,\n            shrinkToFit: false,\n        });\n\n        const stride = vertexSize * 4;\n\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: attributeBuffer,\n                    format: 'float32x2',\n                    stride,\n                    offset: 0,\n                    location: 1,\n                },\n                aUV: {\n                    buffer: attributeBuffer,\n                    format: 'float32x2',\n                    stride,\n                    offset: 2 * 4,\n                    location: 3,\n                },\n                aColor: {\n                    buffer: attributeBuffer,\n                    format: 'unorm8x4',\n                    stride,\n                    offset: 4 * 4,\n                    location: 0,\n                },\n                aTextureIdAndRound: {\n                    buffer: attributeBuffer,\n                    format: 'uint16x2',\n                    stride,\n                    offset: 5 * 4,\n                    location: 2,\n                },\n            },\n            indexBuffer\n        });\n    }\n}\n\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { BufferUsage } from './const.mjs';\n\n\"use strict\";\nclass Buffer extends EventEmitter {\n  /**\n   * Creates a new Buffer with the given options\n   * @param options - the options for the buffer\n   */\n  constructor(options) {\n    let { data, size } = options;\n    const { usage, label, shrinkToFit } = options;\n    super();\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n    /**\n     * emits when the underlying buffer data has been updated. letting the renderer know\n     * that it needs to update the buffer on the GPU\n     * @event update\n     */\n    /**\n     * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU\n     * @event destroy\n     */\n    /**\n     * a unique id for this uniform group used through the renderer\n     * @internal\n     * @ignore\n     */\n    this.uid = uid(\"buffer\");\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */\n    this._resourceType = \"buffer\";\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */\n    this._resourceId = uid(\"resource\");\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */\n    this._touched = 0;\n    /**\n     * @internal\n     * @ignore\n     */\n    this._updateID = 1;\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    this.shrinkToFit = true;\n    if (data instanceof Array) {\n      data = new Float32Array(data);\n    }\n    this._data = data;\n    size = size ?? data?.byteLength;\n    const mappedAtCreation = !!data;\n    this.descriptor = {\n      size,\n      usage,\n      mappedAtCreation,\n      label\n    };\n    this.shrinkToFit = shrinkToFit ?? true;\n  }\n  /** the data in the buffer */\n  get data() {\n    return this._data;\n  }\n  set data(value) {\n    this.setDataWithSize(value, value.length, true);\n  }\n  /** whether the buffer is static or not */\n  get static() {\n    return !!(this.descriptor.usage & BufferUsage.STATIC);\n  }\n  set static(value) {\n    if (value) {\n      this.descriptor.usage |= BufferUsage.STATIC;\n    } else {\n      this.descriptor.usage &= ~BufferUsage.STATIC;\n    }\n  }\n  /**\n   * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.\n   * If you only want to update a subset of the buffer, you can pass in the size of the data.\n   * @param value - the data to set\n   * @param size - the size of the data in bytes\n   * @param syncGPU - should the buffer be updated on the GPU immediately?\n   */\n  setDataWithSize(value, size, syncGPU) {\n    this._updateID++;\n    this._updateSize = size * value.BYTES_PER_ELEMENT;\n    if (this._data === value) {\n      if (syncGPU)\n        this.emit(\"update\", this);\n      return;\n    }\n    const oldData = this._data;\n    this._data = value;\n    if (oldData.length !== value.length) {\n      if (!this.shrinkToFit && value.byteLength < oldData.byteLength) {\n        if (syncGPU)\n          this.emit(\"update\", this);\n      } else {\n        this.descriptor.size = value.byteLength;\n        this._resourceId = uid(\"resource\");\n        this.emit(\"change\", this);\n      }\n      return;\n    }\n    if (syncGPU)\n      this.emit(\"update\", this);\n  }\n  /**\n   * updates the buffer on the GPU to reflect the data in the buffer.\n   * By default it will update the entire buffer. If you only want to update a subset of the buffer,\n   * you can pass in the size of the buffer to update.\n   * @param sizeInBytes - the new size of the buffer in bytes\n   */\n  update(sizeInBytes) {\n    this._updateSize = sizeInBytes ?? this._updateSize;\n    this._updateID++;\n    this.emit(\"update\", this);\n  }\n  /** Destroys the buffer */\n  destroy() {\n    this.emit(\"destroy\", this);\n    this._data = null;\n    this.descriptor = null;\n    this.removeAllListeners();\n  }\n}\n\nexport { Buffer };\n//# sourceMappingURL=Buffer.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\nimport { BufferUsage } from './const';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\n\n/** All the various typed arrays that exist in js */\n// eslint-disable-next-line max-len\nexport type TypedArray = Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array;\n\n/** Options for creating a buffer */\nexport interface BufferOptions\n{\n    /**\n     * the data to initialize the buffer with, this can be a typed array,\n     * or a regular number array. If it is a number array, it will be converted to a Float32Array\n     */\n    data?: TypedArray | number[];\n    /** the size of the buffer in bytes, if not supplied, it will be inferred from the data */\n    size?: number;\n    /** the usage of the buffer, see {@link rendering.BufferUsage} */\n    usage: number;\n    /** a label for the buffer, this is useful for debugging */\n    label?: string;\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    shrinkToFit?: boolean;\n}\n\nexport interface BufferDescriptor\n{\n    label?: string;\n    size: GPUSize64;\n    usage: BufferUsage;\n    mappedAtCreation?: boolean;\n}\n\n/**\n * A wrapper for a WebGPU/WebGL Buffer.\n * In PixiJS, the Buffer class is used to manage the data that is sent to the GPU rendering pipeline.\n * It abstracts away the underlying GPU buffer and provides an interface for uploading typed arrays or other data to the GPU,\n * They are used in the following places:\n * <br><br>\n * .1. {@link Geometry} as attribute data or index data for geometry\n * <br>\n * .2. {@link UniformGroup} as an underlying buffer for uniform data\n * <br>\n * .3. {@link BufferResource} as an underlying part of a buffer used directly by the GPU program\n * <br>\n *\n * It is important to note that you must provide a usage type when creating a buffer. This is because\n * the underlying GPU buffer needs to know how it will be used. For example, if you are creating a buffer\n * to hold vertex data, you would use `BufferUsage.VERTEX`. This will tell the GPU that this buffer will be\n * used as a vertex buffer. This is important because it will affect how you can use the buffer.\n *\n * Buffers are updated by calling the {@link Buffer.update} method. This immediately updates the buffer on the GPU.\n * Be mindful of calling this more often than you need to. It is recommended to update buffers only when needed.\n *\n * In WebGPU, a GPU buffer cannot resized. This limitation is abstracted away, but know that resizing a buffer means\n * creating a brand new one and destroying the old, so it is best to limit this if possible.\n * @example\n *\n * const buffer = new Buffer({\n *     data: new Float32Array([1, 2, 3, 4]),\n *     usage: BufferUsage.VERTEX,\n * });\n * @memberof rendering\n */\nexport class Buffer extends EventEmitter<{\n    change: BindResource,\n    update: Buffer,\n    destroy: Buffer,\n}> implements BindResource\n{\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n\n    /**\n     * emits when the underlying buffer data has been updated. letting the renderer know\n     * that it needs to update the buffer on the GPU\n     * @event update\n     */\n\n    /**\n     * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU\n     * @event destroy\n     */\n\n    /**\n     * a unique id for this uniform group used through the renderer\n     * @internal\n     * @ignore\n     */\n    public readonly uid = uid('buffer');\n\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */\n    public readonly _resourceType = 'buffer';\n\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */\n    public _resourceId = uid('resource');\n\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */\n    public _touched = 0;\n\n    /**\n     * a description of the buffer and how it should be set up on the GPU\n     * @internal\n     * @ignore\n     */\n    public readonly descriptor: BufferDescriptor;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _updateID = 1;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _updateSize: number;\n\n    private _data: TypedArray;\n\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    public shrinkToFit = true;\n\n    /**\n     * Creates a new Buffer with the given options\n     * @param options - the options for the buffer\n     */\n    constructor(options: BufferOptions)\n    {\n        let { data, size } = options;\n        const { usage, label, shrinkToFit } = options;\n\n        super();\n\n        if (data instanceof Array)\n        {\n            data = new Float32Array(data as number[]);\n        }\n\n        this._data = data as TypedArray;\n\n        size = size ?? (data as TypedArray)?.byteLength;\n\n        const mappedAtCreation = !!data;\n\n        this.descriptor = {\n            size,\n            usage,\n            mappedAtCreation,\n            label,\n        };\n\n        this.shrinkToFit = shrinkToFit ?? true;\n    }\n\n    /** the data in the buffer */\n    get data()\n    {\n        return this._data;\n    }\n\n    set data(value: TypedArray)\n    {\n        this.setDataWithSize(value, value.length, true);\n    }\n\n    /** whether the buffer is static or not */\n    get static()\n    {\n        return !!(this.descriptor.usage & BufferUsage.STATIC);\n    }\n\n    set static(value: boolean)\n    {\n        if (value)\n        {\n            this.descriptor.usage |= BufferUsage.STATIC;\n        }\n        else\n        {\n            this.descriptor.usage &= ~BufferUsage.STATIC;\n        }\n    }\n\n    /**\n     * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.\n     * If you only want to update a subset of the buffer, you can pass in the size of the data.\n     * @param value - the data to set\n     * @param size - the size of the data in bytes\n     * @param syncGPU - should the buffer be updated on the GPU immediately?\n     */\n    public setDataWithSize(value: TypedArray, size: number, syncGPU: boolean)\n    {\n        // Increment update ID\n        this._updateID++;\n\n        this._updateSize = (size * value.BYTES_PER_ELEMENT);\n\n        // If the data hasn't changed, early return after emitting 'update'\n        if (this._data === value)\n        {\n            if (syncGPU) this.emit('update', this);\n\n            return;\n        }\n\n        // Cache old data and update to new value\n        const oldData = this._data;\n\n        this._data = value;\n\n        // Event handling\n        if (oldData.length !== value.length)\n        {\n            if (!this.shrinkToFit && value.byteLength < oldData.byteLength)\n            {\n                if (syncGPU) this.emit('update', this);\n            }\n            else\n            {\n                this.descriptor.size = value.byteLength;\n                this._resourceId = uid('resource');\n                this.emit('change', this);\n            }\n\n            return;\n        }\n\n        if (syncGPU) this.emit('update', this);\n    }\n\n    /**\n     * updates the buffer on the GPU to reflect the data in the buffer.\n     * By default it will update the entire buffer. If you only want to update a subset of the buffer,\n     * you can pass in the size of the buffer to update.\n     * @param sizeInBytes - the new size of the buffer in bytes\n     */\n    public update(sizeInBytes?: number): void\n    {\n        this._updateSize = sizeInBytes ?? this._updateSize;\n\n        this._updateID++;\n\n        this.emit('update', this);\n    }\n\n    /** Destroys the buffer */\n    public destroy()\n    {\n        this.emit('destroy', this);\n\n        this._data = null;\n        (this.descriptor as null) = null;\n\n        this.removeAllListeners();\n    }\n}\n\n","\"use strict\";\nvar BufferUsage = /* @__PURE__ */ ((BufferUsage2) => {\n  BufferUsage2[BufferUsage2[\"MAP_READ\"] = 1] = \"MAP_READ\";\n  BufferUsage2[BufferUsage2[\"MAP_WRITE\"] = 2] = \"MAP_WRITE\";\n  BufferUsage2[BufferUsage2[\"COPY_SRC\"] = 4] = \"COPY_SRC\";\n  BufferUsage2[BufferUsage2[\"COPY_DST\"] = 8] = \"COPY_DST\";\n  BufferUsage2[BufferUsage2[\"INDEX\"] = 16] = \"INDEX\";\n  BufferUsage2[BufferUsage2[\"VERTEX\"] = 32] = \"VERTEX\";\n  BufferUsage2[BufferUsage2[\"UNIFORM\"] = 64] = \"UNIFORM\";\n  BufferUsage2[BufferUsage2[\"STORAGE\"] = 128] = \"STORAGE\";\n  BufferUsage2[BufferUsage2[\"INDIRECT\"] = 256] = \"INDIRECT\";\n  BufferUsage2[BufferUsage2[\"QUERY_RESOLVE\"] = 512] = \"QUERY_RESOLVE\";\n  BufferUsage2[BufferUsage2[\"STATIC\"] = 1024] = \"STATIC\";\n  return BufferUsage2;\n})(BufferUsage || {});\n\nexport { BufferUsage };\n//# sourceMappingURL=const.mjs.map\n","/**\n * Buffer usage flags. they can be combined using the bitwise OR operator\n * eg : BufferUsage.VERTEX | BufferUsage.INDEX\n * @memberof rendering\n */\nexport enum BufferUsage\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    /**\n     * The buffer can be mapped for reading. (Example: calling mapAsync() with GPUMapMode.READ)\n     * May only be combined with COPY_DST.\n     */\n    MAP_READ = 0x0001,\n    /**\n     * The buffer can be mapped for writing. (Example: calling mapAsync() with GPUMapMode.WRITE)\n     * May only be combined with COPY_SRC.\n     */\n    MAP_WRITE = 0x0002,\n    /**\n     * The buffer can be used as the source of a copy operation.\n     * (Examples: as the source argument of a copyBufferToBuffer() or copyBufferToTexture() call.)\n     */\n    COPY_SRC = 0x0004,\n    /**\n     * The buffer can be used as the destination of a copy or write operation.\n     * (Examples: as the destination argument of a copyBufferToBuffer() or\n     * copyTextureToBuffer() call, or as the target of a writeBuffer() call.)\n     */\n    COPY_DST = 0x0008,\n    /** The buffer can be used as an index buffer. (Example: passed to setIndexBuffer().) */\n    INDEX = 0x0010,\n    /** The buffer can be used as a vertex buffer. (Example: passed to setVertexBuffer().) */\n    VERTEX = 0x0020,\n    /**\n     * The buffer can be used as a uniform buffer.\n     * (Example: as a bind group entry for a GPUBufferBindingLayout with a buffer.type of \"uniform\".)\n     */\n    UNIFORM = 0x0040,\n    /**\n     * The buffer can be used as a storage buffer.\n     * (Example: as a bind group entry for a GPUBufferBindingLayout with a buffer.type of \"storage\" or \"read-only-storage\".)\n     */\n    STORAGE = 0x0080,\n    /**\n     * The buffer can be used as to store indirect command arguments.\n     * (Examples: as the indirectBuffer argument of a drawIndirect() or dispatchWorkgroupsIndirect() call.)\n     */\n    INDIRECT = 0x0100,\n    /**\n     * The buffer can be used to capture query results.\n     * (Example: as the destination argument of a resolveQuerySet() call.)\n     */\n    QUERY_RESOLVE = 0x0200,\n    /** the buffer will not be updated frequently */\n    STATIC = 0x0400\n}\n","import EventEmitter from 'eventemitter3';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { Buffer } from '../buffer/Buffer.mjs';\nimport { ensureIsBuffer } from './utils/ensureIsBuffer.mjs';\nimport { getGeometryBounds } from './utils/getGeometryBounds.mjs';\n\n\"use strict\";\nfunction ensureIsAttribute(attribute) {\n  if (attribute instanceof Buffer || Array.isArray(attribute) || attribute.BYTES_PER_ELEMENT) {\n    attribute = {\n      buffer: attribute\n    };\n  }\n  attribute.buffer = ensureIsBuffer(attribute.buffer, false);\n  return attribute;\n}\nclass Geometry extends EventEmitter {\n  /**\n   * Create a new instance of a geometry\n   * @param options - The options for the geometry.\n   */\n  constructor(options) {\n    const { attributes, indexBuffer, topology } = options;\n    super();\n    /** The unique id of the geometry. */\n    this.uid = uid(\"geometry\");\n    /**\n     * the layout key will be generated by WebGPU all geometries that have the same structure\n     * will have the same layout key. This is used to cache the pipeline layout\n     * @internal\n     * @ignore\n     */\n    this._layoutKey = 0;\n    /** the instance count of the geometry to draw */\n    this.instanceCount = 1;\n    this._bounds = new Bounds();\n    this._boundsDirty = true;\n    this.attributes = attributes;\n    this.buffers = [];\n    this.instanceCount = options.instanceCount || 1;\n    for (const i in attributes) {\n      const attribute = attributes[i] = ensureIsAttribute(attributes[i]);\n      const bufferIndex = this.buffers.indexOf(attribute.buffer);\n      if (bufferIndex === -1) {\n        this.buffers.push(attribute.buffer);\n        attribute.buffer.on(\"update\", this.onBufferUpdate, this);\n        attribute.buffer.on(\"change\", this.onBufferUpdate, this);\n      }\n    }\n    if (indexBuffer) {\n      this.indexBuffer = ensureIsBuffer(indexBuffer, true);\n      this.buffers.push(this.indexBuffer);\n    }\n    this.topology = topology || \"triangle-list\";\n  }\n  onBufferUpdate() {\n    this._boundsDirty = true;\n    this.emit(\"update\", this);\n  }\n  /**\n   * Returns the requested attribute.\n   * @param id - The name of the attribute required\n   * @returns - The attribute requested.\n   */\n  getAttribute(id) {\n    return this.attributes[id];\n  }\n  /**\n   * Returns the index buffer\n   * @returns - The index buffer.\n   */\n  getIndex() {\n    return this.indexBuffer;\n  }\n  /**\n   * Returns the requested buffer.\n   * @param id - The name of the buffer required.\n   * @returns - The buffer requested.\n   */\n  getBuffer(id) {\n    return this.getAttribute(id).buffer;\n  }\n  /**\n   * Used to figure out how many vertices there are in this geometry\n   * @returns the number of vertices in the geometry\n   */\n  getSize() {\n    for (const i in this.attributes) {\n      const attribute = this.attributes[i];\n      const buffer = attribute.buffer;\n      return buffer.data.length / (attribute.stride / 4 || attribute.size);\n    }\n    return 0;\n  }\n  /** Returns the bounds of the geometry. */\n  get bounds() {\n    if (!this._boundsDirty)\n      return this._bounds;\n    this._boundsDirty = false;\n    return getGeometryBounds(this, \"aPosition\", this._bounds);\n  }\n  /**\n   * destroys the geometry.\n   * @param destroyBuffers - destroy the buffers associated with this geometry\n   */\n  destroy(destroyBuffers = false) {\n    this.emit(\"destroy\", this);\n    this.removeAllListeners();\n    if (destroyBuffers) {\n      this.buffers.forEach((buffer) => buffer.destroy());\n    }\n    this.attributes = null;\n    this.buffers = null;\n    this.indexBuffer = null;\n    this._bounds = null;\n  }\n}\n\nexport { Geometry };\n//# sourceMappingURL=Geometry.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds';\nimport { uid } from '../../../../utils/data/uid';\nimport { Buffer } from '../buffer/Buffer';\nimport { ensureIsBuffer } from './utils/ensureIsBuffer';\nimport { getGeometryBounds } from './utils/getGeometryBounds';\n\nimport type { TypedArray } from '../buffer/Buffer';\nimport type { Topology, VertexFormat } from './const';\n\nexport type IndexBufferArray = Uint16Array | Uint32Array;\n\n/**\n * The attribute data for a geometries attributes\n * @memberof rendering\n */\nexport interface Attribute\n{\n    /** the buffer that this attributes data belongs to */\n    buffer: Buffer;\n    /** the format of the attribute */\n    format?: VertexFormat;\n    /** set where the shader location is for this attribute */\n    location?: number;\n    /** the stride of the data in the buffer*/\n    stride?: number;\n    /** the offset of the attribute from the buffer, defaults to 0 */\n    offset?: number;\n    /** is this an instanced buffer? (defaults to false) */\n    instance?: boolean;\n    /**  The number of elements to be rendered. If not specified, all vertices after the starting vertex will be drawn. */\n    size?: number;\n    /** the type of attribute  */\n    type?: number;\n    /**\n     * The starting vertex in the geometry to start drawing from. If not specified,\n     *  drawing will start from the first vertex.\n     */\n    start?: number;\n}\n\n/**\n * The attribute options used by the constructor for adding geometries attributes\n * extends {@link rendering.Attribute} but allows for the buffer to be a typed or number array\n * @memberof rendering\n */\ntype AttributesOption = Omit<Attribute, 'buffer'> & { buffer: Buffer | TypedArray | number[]}\n| Buffer | TypedArray | number[];\n\n/**\n * the interface that describes the structure of the geometry\n * @memberof rendering\n */\nexport interface GeometryDescriptor\n{\n    /** an optional label to easily identify the geometry */\n    label?: string;\n    /** the attributes that make up the geometry */\n    attributes: Record<string, AttributesOption>;\n    /** optional index buffer for this geometry */\n    indexBuffer?: Buffer | TypedArray | number[];\n    /** the topology of the geometry, defaults to 'triangle-list' */\n    topology?: Topology;\n\n    instanceCount?: number;\n}\nfunction ensureIsAttribute(attribute: AttributesOption): Attribute\n{\n    if (attribute instanceof Buffer || Array.isArray(attribute) || (attribute as TypedArray).BYTES_PER_ELEMENT)\n    {\n        attribute = {\n            buffer: attribute as Buffer | TypedArray | number[],\n        };\n    }\n\n    (attribute as Attribute).buffer = ensureIsBuffer(attribute.buffer as Buffer | TypedArray | number[], false);\n\n    return attribute as Attribute;\n}\n\n/**\n * A Geometry is a low-level object that represents the structure of 2D shapes in terms of vertices and attributes.\n * It's a crucial component for rendering as it describes the shape and format of the data that will go through the shaders.\n * Essentially, a Geometry object holds the data you'd send to a GPU buffer.\n *\n * A geometry is basically made of two components:\n * <br>\n * <b>Attributes</b>: These are essentially arrays that define properties of the vertices like position, color,\n * texture coordinates, etc. They map directly to attributes in your vertex shaders.\n * <br>\n * <b>Indices</b>: An optional array that describes how the vertices are connected.\n * If not provided, vertices will be interpreted in the sequence they're given.\n * @example\n *\n * const geometry = new Geometry({\n *   attributes: {\n *     aPosition: [ // add some positions\n *       0, 0,\n *       0, 100,\n *       100, 100,\n *       100,   0,\n *     ],\n *     aUv: [ // add some uvs\n *       0, 0,\n *       0, 1,\n *       1, 1,\n *       1, 0,\n *     ]\n *   }\n * });\n * @memberof rendering\n * @class\n */\nexport class Geometry extends EventEmitter<{\n    update: Geometry,\n    destroy: Geometry,\n}>\n{\n    /** The topology of the geometry. */\n    public topology: Topology;\n    /** The unique id of the geometry. */\n    public readonly uid: number = uid('geometry');\n    /** A record of the attributes of the geometry. */\n    public readonly attributes: Record<string, Attribute>;\n    /** The buffers that the attributes use */\n    public readonly buffers: Buffer[];\n    /** The index buffer of the geometry */\n    public readonly indexBuffer: Buffer;\n\n    /**\n     * the layout key will be generated by WebGPU all geometries that have the same structure\n     * will have the same layout key. This is used to cache the pipeline layout\n     * @internal\n     * @ignore\n     */\n    public _layoutKey = 0;\n\n    /** the instance count of the geometry to draw */\n    public instanceCount = 1;\n\n    private readonly _bounds: Bounds = new Bounds();\n    private _boundsDirty = true;\n\n    /**\n     * Create a new instance of a geometry\n     * @param options - The options for the geometry.\n     */\n    constructor(options: GeometryDescriptor)\n    {\n        const { attributes, indexBuffer, topology } = options;\n\n        super();\n\n        this.attributes = attributes as Record<string, Attribute>;\n        this.buffers = [];\n\n        this.instanceCount = options.instanceCount || 1;\n\n        for (const i in attributes)\n        {\n            const attribute = attributes[i] = ensureIsAttribute(attributes[i]);\n\n            const bufferIndex = this.buffers.indexOf(attribute.buffer);\n\n            if (bufferIndex === -1)\n            {\n                this.buffers.push(attribute.buffer);\n\n                // two events here - one for a resize (new buffer change)\n                // and one for an update (existing buffer change)\n                attribute.buffer.on('update', this.onBufferUpdate, this);\n                attribute.buffer.on('change', this.onBufferUpdate, this);\n            }\n        }\n\n        if (indexBuffer)\n        {\n            this.indexBuffer = ensureIsBuffer(indexBuffer, true);\n            this.buffers.push(this.indexBuffer);\n        }\n\n        this.topology = topology || 'triangle-list';\n    }\n\n    protected onBufferUpdate(): void\n    {\n        this._boundsDirty = true;\n        this.emit('update', this);\n    }\n\n    /**\n     * Returns the requested attribute.\n     * @param id - The name of the attribute required\n     * @returns - The attribute requested.\n     */\n    public getAttribute(id: string): Attribute\n    {\n        return this.attributes[id];\n    }\n\n    /**\n     * Returns the index buffer\n     * @returns - The index buffer.\n     */\n    public getIndex(): Buffer\n    {\n        return this.indexBuffer;\n    }\n\n    /**\n     * Returns the requested buffer.\n     * @param id - The name of the buffer required.\n     * @returns - The buffer requested.\n     */\n    public getBuffer(id: string): Buffer\n    {\n        return this.getAttribute(id).buffer;\n    }\n\n    /**\n     * Used to figure out how many vertices there are in this geometry\n     * @returns the number of vertices in the geometry\n     */\n    public getSize(): number\n    {\n        for (const i in this.attributes)\n        {\n            const attribute = this.attributes[i];\n            const buffer = attribute.buffer;\n\n            // TODO use SIZE again like v7..\n            return (buffer.data as any).length / ((attribute.stride / 4) || attribute.size);\n        }\n\n        return 0;\n    }\n\n    /** Returns the bounds of the geometry. */\n    get bounds(): Bounds\n    {\n        if (!this._boundsDirty) return this._bounds;\n\n        this._boundsDirty = false;\n\n        return getGeometryBounds(this, 'aPosition', this._bounds);\n    }\n\n    /**\n     * destroys the geometry.\n     * @param destroyBuffers - destroy the buffers associated with this geometry\n     */\n    public destroy(destroyBuffers = false): void\n    {\n        this.emit('destroy', this);\n\n        this.removeAllListeners();\n\n        if (destroyBuffers)\n        {\n            this.buffers.forEach((buffer) => buffer.destroy());\n        }\n\n        (this.attributes as null) = null;\n        (this.buffers as null) = null;\n        (this.indexBuffer as null) = null;\n        (this._bounds as null) = null;\n    }\n}\n\n","import { Buffer } from '../../buffer/Buffer.mjs';\nimport { BufferUsage } from '../../buffer/const.mjs';\n\n\"use strict\";\nfunction ensureIsBuffer(buffer, index) {\n  if (!(buffer instanceof Buffer)) {\n    let usage = index ? BufferUsage.INDEX : BufferUsage.VERTEX;\n    if (buffer instanceof Array) {\n      if (index) {\n        buffer = new Uint32Array(buffer);\n        usage = BufferUsage.INDEX | BufferUsage.COPY_DST;\n      } else {\n        buffer = new Float32Array(buffer);\n        usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;\n      }\n    }\n    buffer = new Buffer({\n      data: buffer,\n      label: index ? \"index-mesh-buffer\" : \"vertex-mesh-buffer\",\n      usage\n    });\n  }\n  return buffer;\n}\n\nexport { ensureIsBuffer };\n//# sourceMappingURL=ensureIsBuffer.mjs.map\n","import { Buffer } from '../../buffer/Buffer';\nimport { BufferUsage } from '../../buffer/const';\n\nimport type { TypedArray } from '../../buffer/Buffer';\n\n/**\n * Converts something into a buffer. If it is already a buffer it will pass it through\n * if it is a number array it will convert it to a float32 array before being passed into a buffer\n * the buffer will be created with the correct usage flags for geometry attributes\n * @param buffer - number array\n * @param index - is this an index buffer?\n * @returns a buffer\n * @memberof rendering\n */\nexport function ensureIsBuffer(buffer: Buffer | TypedArray | number[], index: boolean): Buffer\n{\n    if (!(buffer instanceof Buffer))\n    {\n        let usage: number = index ? BufferUsage.INDEX : BufferUsage.VERTEX;\n\n        // its an array!\n        if (buffer instanceof Array)\n        {\n            if (index)\n            {\n                buffer = new Uint32Array(buffer);\n                usage = BufferUsage.INDEX | BufferUsage.COPY_DST;\n            }\n\n            else\n            {\n                buffer = new Float32Array(buffer);\n                usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;\n            }\n        }\n\n        buffer = new Buffer({\n            data: buffer,\n            label: index ? 'index-mesh-buffer' : 'vertex-mesh-buffer',\n            usage\n        });\n    }\n\n    return buffer;\n}\n","\"use strict\";\nfunction getGeometryBounds(geometry, attributeId, bounds) {\n  const attribute = geometry.getAttribute(attributeId);\n  if (!attribute) {\n    bounds.minX = 0;\n    bounds.minY = 0;\n    bounds.maxX = 0;\n    bounds.maxY = 0;\n    return bounds;\n  }\n  const data = attribute.buffer.data;\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  const byteSize = data.BYTES_PER_ELEMENT;\n  const offset = (attribute.offset || 0) / byteSize;\n  const stride = (attribute.stride || 2 * 4) / byteSize;\n  for (let i = offset; i < data.length; i += stride) {\n    const x = data[i];\n    const y = data[i + 1];\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n  }\n  bounds.minX = minX;\n  bounds.minY = minY;\n  bounds.maxX = maxX;\n  bounds.maxY = maxY;\n  return bounds;\n}\n\nexport { getGeometryBounds };\n//# sourceMappingURL=getGeometryBounds.mjs.map\n","import type { Bounds } from '../../../../../scene/container/bounds/Bounds';\nimport type { Geometry } from '../Geometry';\n\n/**\n * Gets the 2D bounds of a geometry, based on a specific attribute.\n * @param geometry - Geometry to to measure\n * @param attributeId - AttributeId that contains the x,y data\n * @param bounds - Bounds to store the result in\n * @returns the bounds\n */\nexport function getGeometryBounds(geometry: Geometry, attributeId: string, bounds: Bounds): Bounds\n{\n    const attribute = geometry.getAttribute(attributeId);\n\n    if (!attribute)\n    {\n        bounds.minX = 0;\n        bounds.minY = 0;\n        bounds.maxX = 0;\n        bounds.maxY = 0;\n\n        return bounds;\n    }\n\n    const data = attribute.buffer.data as Float32Array;\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    const byteSize = data.BYTES_PER_ELEMENT;\n\n    // stride and offset MAY have not been calculated yet.. so go with assumed defaults\n    const offset = (attribute.offset || 0) / byteSize;\n    const stride = (attribute.stride || (2 * 4)) / byteSize;\n\n    for (let i = offset; i < data.length; i += stride)\n    {\n        const x = data[i];\n        const y = data[i + 1];\n\n        if (x > maxX)maxX = x;\n        if (y > maxY)maxY = y;\n        if (x < minX)minX = x;\n        if (y < minY)minY = y;\n    }\n\n    bounds.minX = minX;\n    bounds.minY = minY;\n    bounds.maxX = maxX;\n    bounds.maxY = maxY;\n\n    return bounds;\n}\n","\"use strict\";\nclass BindGroup {\n  /**\n   * Create a new instance eof the Bind Group.\n   * @param resources - The resources that are bound together for use by a shader.\n   */\n  constructor(resources) {\n    /** The resources that are bound together for use by a shader. */\n    this.resources = /* @__PURE__ */ Object.create(null);\n    this._dirty = true;\n    let index = 0;\n    for (const i in resources) {\n      const resource = resources[i];\n      this.setResource(resource, index++);\n    }\n    this._updateKey();\n  }\n  /**\n   * Updates the key if its flagged as dirty. This is used internally to\n   * match this bind group to a WebGPU BindGroup.\n   * @internal\n   * @ignore\n   */\n  _updateKey() {\n    if (!this._dirty)\n      return;\n    this._dirty = false;\n    const keyParts = [];\n    let index = 0;\n    for (const i in this.resources) {\n      keyParts[index++] = this.resources[i]._resourceId;\n    }\n    this._key = keyParts.join(\"|\");\n  }\n  /**\n   * Set a resource at a given index. this function will\n   * ensure that listeners will be removed from the current resource\n   * and added to the new resource.\n   * @param resource - The resource to set.\n   * @param index - The index to set the resource at.\n   */\n  setResource(resource, index) {\n    const currentResource = this.resources[index];\n    if (resource === currentResource)\n      return;\n    if (currentResource) {\n      resource.off?.(\"change\", this.onResourceChange, this);\n    }\n    resource.on?.(\"change\", this.onResourceChange, this);\n    this.resources[index] = resource;\n    this._dirty = true;\n  }\n  /**\n   * Returns the resource at the current specified index.\n   * @param index - The index of the resource to get.\n   * @returns - The resource at the specified index.\n   */\n  getResource(index) {\n    return this.resources[index];\n  }\n  /**\n   * Used internally to 'touch' each resource, to ensure that the GC\n   * knows that all resources in this bind group are still being used.\n   * @param tick - The current tick.\n   * @internal\n   * @ignore\n   */\n  _touch(tick) {\n    const resources = this.resources;\n    for (const i in resources) {\n      resources[i]._touched = tick;\n    }\n  }\n  /** Destroys this bind group and removes all listeners. */\n  destroy() {\n    const resources = this.resources;\n    for (const i in resources) {\n      const resource = resources[i];\n      resource.off?.(\"change\", this.onResourceChange, this);\n    }\n    this.resources = null;\n  }\n  onResourceChange() {\n    this._dirty = true;\n    this._updateKey();\n  }\n}\n\nexport { BindGroup };\n//# sourceMappingURL=BindGroup.mjs.map\n","import type { BindResource } from './BindResource';\n\n/**\n * A bind group is a collection of resources that are bound together for use by a shader.\n * They are essentially a wrapper for the WebGPU BindGroup class. But with the added bonus\n * that WebGL can also work with them.\n * @see https://gpuweb.github.io/gpuweb/#dictdef-gpubindgroupdescriptor\n * @example\n * // Create a bind group with a single texture and sampler\n * const bindGroup = new BindGroup({\n *    uTexture: texture.source,\n *    uTexture: texture.style,\n * });\n *\n * Bind groups resources must implement the {@link BindResource} interface.\n * The following resources are supported:\n * - {@link TextureSource}\n * - {@link TextureStyle}\n * - {@link Buffer}\n * - {@link BufferResource}\n * - {@link UniformGroup}\n *\n * The keys in the bind group must correspond to the names of the resources in the GPU program.\n *\n * This bind group class will also watch for changes in its resources ensuring that the changes\n * are reflected in the WebGPU BindGroup.\n * @memberof rendering\n */\nexport class BindGroup\n{\n    /** The resources that are bound together for use by a shader. */\n    public resources: Record<string, BindResource> = Object.create(null);\n    /**\n     * a key used internally to match it up to a WebGPU Bindgroup\n     * @internal\n     * @ignore\n     */\n    public _key: string;\n    private _dirty = true;\n\n    /**\n     * Create a new instance eof the Bind Group.\n     * @param resources - The resources that are bound together for use by a shader.\n     */\n    constructor(resources?: Record<string, BindResource>)\n    {\n        let index = 0;\n\n        for (const i in resources)\n        {\n            const resource: BindResource = resources[i];\n\n            this.setResource(resource, index++);\n        }\n\n        this._updateKey();\n    }\n\n    /**\n     * Updates the key if its flagged as dirty. This is used internally to\n     * match this bind group to a WebGPU BindGroup.\n     * @internal\n     * @ignore\n     */\n    public _updateKey(): void\n    {\n        if (!this._dirty) return;\n\n        this._dirty = false;\n\n        const keyParts = [];\n        let index = 0;\n\n        // TODO - lets use big ints instead of strings...\n        for (const i in this.resources)\n        {\n            // TODO make this consistent...\n            keyParts[index++] = this.resources[i]._resourceId;\n        }\n\n        this._key = keyParts.join('|');\n    }\n\n    /**\n     * Set a resource at a given index. this function will\n     * ensure that listeners will be removed from the current resource\n     * and added to the new resource.\n     * @param resource - The resource to set.\n     * @param index - The index to set the resource at.\n     */\n    public setResource(resource: BindResource, index: number): void\n    {\n        const currentResource = this.resources[index];\n\n        if (resource === currentResource) return;\n\n        if (currentResource)\n        {\n            resource.off?.('change', this.onResourceChange, this);\n        }\n\n        resource.on?.('change', this.onResourceChange, this);\n\n        this.resources[index] = resource;\n        this._dirty = true;\n    }\n\n    /**\n     * Returns the resource at the current specified index.\n     * @param index - The index of the resource to get.\n     * @returns - The resource at the specified index.\n     */\n    public getResource(index: number): BindResource\n    {\n        return this.resources[index];\n    }\n\n    /**\n     * Used internally to 'touch' each resource, to ensure that the GC\n     * knows that all resources in this bind group are still being used.\n     * @param tick - The current tick.\n     * @internal\n     * @ignore\n     */\n    public _touch(tick: number)\n    {\n        const resources = this.resources;\n\n        for (const i in resources)\n        {\n            resources[i]._touched = tick;\n        }\n    }\n\n    /** Destroys this bind group and removes all listeners. */\n    public destroy()\n    {\n        const resources = this.resources;\n\n        for (const i in resources)\n        {\n            const resource = resources[i];\n\n            resource.off?.('change', this.onResourceChange, this);\n        }\n\n        this.resources = null;\n    }\n\n    protected onResourceChange()\n    {\n        this._dirty = true;\n        this._updateKey();\n    }\n}\n","\"use strict\";\nconst MAX_TEXTURES = 16;\n\nexport { MAX_TEXTURES };\n//# sourceMappingURL=const.mjs.map\n","export const MAX_TEXTURES = 16;\n","import { uid } from '../../../utils/data/uid.mjs';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer.mjs';\nimport { fastCopy } from '../../renderers/shared/buffer/utils/fastCopy.mjs';\nimport { getAdjustedBlendModeBlend } from '../../renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nimport { BatchTextureArray } from './BatchTextureArray.mjs';\nimport { MAX_TEXTURES } from './const.mjs';\n\n\"use strict\";\nclass Batch {\n  constructor() {\n    this.renderPipeId = \"batch\";\n    this.action = \"startBatch\";\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n    // for drawing..\n    this.start = 0;\n    this.size = 0;\n    this.blendMode = \"normal\";\n    this.canBundle = true;\n  }\n  destroy() {\n    this.textures = null;\n    this.gpuBindGroup = null;\n    this.bindGroup = null;\n    this.batcher = null;\n  }\n}\nlet BATCH_TICK = 0;\nconst _Batcher = class _Batcher {\n  constructor(options = {}) {\n    this.uid = uid(\"batcher\");\n    this.dirty = true;\n    this.batchIndex = 0;\n    this.batches = [];\n    // specifics.\n    this._vertexSize = 6;\n    this._elements = [];\n    this._batchPool = [];\n    this._batchPoolIndex = 0;\n    this._textureBatchPool = [];\n    this._textureBatchPoolIndex = 0;\n    options = { ..._Batcher.defaultOptions, ...options };\n    const { vertexSize, indexSize } = options;\n    this.attributeBuffer = new ViewableBuffer(vertexSize * this._vertexSize * 4);\n    this.indexBuffer = new Uint16Array(indexSize);\n  }\n  begin() {\n    this.batchIndex = 0;\n    this.elementSize = 0;\n    this.elementStart = 0;\n    this.indexSize = 0;\n    this.attributeSize = 0;\n    this._batchPoolIndex = 0;\n    this._textureBatchPoolIndex = 0;\n    this._batchIndexStart = 0;\n    this._batchIndexSize = 0;\n    this.dirty = true;\n  }\n  add(batchableObject) {\n    this._elements[this.elementSize++] = batchableObject;\n    batchableObject.indexStart = this.indexSize;\n    batchableObject.location = this.attributeSize;\n    batchableObject.batcher = this;\n    this.indexSize += batchableObject.indexSize;\n    this.attributeSize += batchableObject.vertexSize * this._vertexSize;\n  }\n  checkAndUpdateTexture(batchableObject, texture) {\n    const textureId = batchableObject.batch.textures.ids[texture._source.uid];\n    if (!textureId && textureId !== 0)\n      return false;\n    batchableObject.textureId = textureId;\n    batchableObject.texture = texture;\n    return true;\n  }\n  updateElement(batchableObject) {\n    this.dirty = true;\n    batchableObject.packAttributes(\n      this.attributeBuffer.float32View,\n      this.attributeBuffer.uint32View,\n      batchableObject.location,\n      batchableObject.textureId\n    );\n  }\n  /**\n   * breaks the batcher. This happens when a batch gets too big,\n   * or we need to switch to a different type of rendering (a filter for example)\n   * @param instructionSet\n   */\n  break(instructionSet) {\n    const elements = this._elements;\n    let textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();\n    textureBatch.clear();\n    if (!elements[this.elementStart])\n      return;\n    const firstElement = elements[this.elementStart];\n    let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);\n    if (this.attributeSize * 4 > this.attributeBuffer.size) {\n      this._resizeAttributeBuffer(this.attributeSize * 4);\n    }\n    if (this.indexSize > this.indexBuffer.length) {\n      this._resizeIndexBuffer(this.indexSize);\n    }\n    const f32 = this.attributeBuffer.float32View;\n    const u32 = this.attributeBuffer.uint32View;\n    const iBuffer = this.indexBuffer;\n    let size = this._batchIndexSize;\n    let start = this._batchIndexStart;\n    let action = \"startBatch\";\n    let batch = this._batchPool[this._batchPoolIndex++] || new Batch();\n    for (let i = this.elementStart; i < this.elementSize; ++i) {\n      const element = elements[i];\n      elements[i] = null;\n      const texture = element.texture;\n      const source = texture._source;\n      const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source);\n      const blendModeChange = blendMode !== adjustedBlendMode;\n      if (source._batchTick === BATCH_TICK && !blendModeChange) {\n        element.textureId = source._textureBindLocation;\n        size += element.indexSize;\n        element.packAttributes(f32, u32, element.location, element.textureId);\n        element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n        element.batch = batch;\n        continue;\n      }\n      source._batchTick = BATCH_TICK;\n      if (textureBatch.count >= MAX_TEXTURES || blendModeChange) {\n        this._finishBatch(\n          batch,\n          start,\n          size - start,\n          textureBatch,\n          blendMode,\n          instructionSet,\n          action\n        );\n        action = \"renderBatch\";\n        start = size;\n        blendMode = adjustedBlendMode;\n        textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();\n        textureBatch.clear();\n        batch = this._batchPool[this._batchPoolIndex++] || new Batch();\n        ++BATCH_TICK;\n      }\n      element.textureId = source._textureBindLocation = textureBatch.count;\n      textureBatch.ids[source.uid] = textureBatch.count;\n      textureBatch.textures[textureBatch.count++] = source;\n      element.batch = batch;\n      size += element.indexSize;\n      element.packAttributes(f32, u32, element.location, element.textureId);\n      element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n    }\n    if (textureBatch.count > 0) {\n      this._finishBatch(\n        batch,\n        start,\n        size - start,\n        textureBatch,\n        blendMode,\n        instructionSet,\n        action\n      );\n      start = size;\n      ++BATCH_TICK;\n    }\n    this.elementStart = this.elementSize;\n    this._batchIndexStart = start;\n    this._batchIndexSize = size;\n  }\n  _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, instructionSet, action) {\n    batch.gpuBindGroup = null;\n    batch.action = action;\n    batch.batcher = this;\n    batch.textures = textureBatch;\n    batch.blendMode = blendMode;\n    batch.start = indexStart;\n    batch.size = indexSize;\n    ++BATCH_TICK;\n    instructionSet.add(batch);\n  }\n  finish(instructionSet) {\n    this.break(instructionSet);\n  }\n  /**\n   * Resizes the attribute buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureAttributeBuffer(size) {\n    if (size * 4 <= this.attributeBuffer.size)\n      return;\n    this._resizeAttributeBuffer(size * 4);\n  }\n  /**\n   * Resizes the index buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureIndexBuffer(size) {\n    if (size <= this.indexBuffer.length)\n      return;\n    this._resizeIndexBuffer(size);\n  }\n  _resizeAttributeBuffer(size) {\n    const newSize = Math.max(size, this.attributeBuffer.size * 2);\n    const newArrayBuffer = new ViewableBuffer(newSize);\n    fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n    this.attributeBuffer = newArrayBuffer;\n  }\n  _resizeIndexBuffer(size) {\n    const indexBuffer = this.indexBuffer;\n    let newSize = Math.max(size, indexBuffer.length * 1.5);\n    newSize += newSize % 2;\n    const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);\n    if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {\n      for (let i = 0; i < indexBuffer.length; i++) {\n        newIndexBuffer[i] = indexBuffer[i];\n      }\n    } else {\n      fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);\n    }\n    this.indexBuffer = newIndexBuffer;\n  }\n  destroy() {\n    for (let i = 0; i < this.batches.length; i++) {\n      this.batches[i].destroy();\n    }\n    this.batches = null;\n    for (let i = 0; i < this._elements.length; i++) {\n      this._elements[i].batch = null;\n    }\n    this._elements = null;\n    this.indexBuffer = null;\n    this.attributeBuffer.destroy();\n    this.attributeBuffer = null;\n  }\n};\n_Batcher.defaultOptions = {\n  vertexSize: 4,\n  indexSize: 6\n};\nlet Batcher = _Batcher;\n\nexport { Batch, Batcher };\n//# sourceMappingURL=Batcher.mjs.map\n","import { uid } from '../../../utils/data/uid';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer';\nimport { fastCopy } from '../../renderers/shared/buffer/utils/fastCopy';\nimport { type BLEND_MODES } from '../../renderers/shared/state/const';\nimport { getAdjustedBlendModeBlend } from '../../renderers/shared/state/getAdjustedBlendModeBlend';\nimport { BatchTextureArray } from './BatchTextureArray';\nimport { MAX_TEXTURES } from './const';\n\nimport type { BindGroup } from '../../renderers/gpu/shader/BindGroup';\nimport type { IndexBufferArray } from '../../renderers/shared/geometry/Geometry';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { Texture } from '../../renderers/shared/texture/Texture';\n\nexport type BatchAction = 'startBatch' | 'renderBatch';\n\n/**\n * A batch pool is used to store batches when they are not currently in use.\n * @memberof rendering\n */\nexport class Batch implements Instruction\n{\n    public renderPipeId = 'batch';\n    public action: BatchAction = 'startBatch';\n\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n\n    // for drawing..\n    public start = 0;\n    public size = 0;\n    public textures: BatchTextureArray;\n\n    public blendMode: BLEND_MODES = 'normal';\n\n    public canBundle = true;\n\n    /**\n     * breaking rules slightly here in the name of performance..\n     * storing references to these bindgroups here is just faster for access!\n     * keeps a reference to the GPU bind group to set when rendering this batch for WebGPU. Will be null is using WebGL.\n     */\n    public gpuBindGroup: GPUBindGroup;\n    /**\n     * breaking rules slightly here in the name of performance..\n     * storing references to these bindgroups here is just faster for access!\n     * keeps a reference to the bind group to set when rendering this batch for WebGPU. Will be null if using WebGl.\n     */\n    public bindGroup: BindGroup;\n\n    public batcher: Batcher;\n\n    public destroy()\n    {\n        this.textures = null;\n        this.gpuBindGroup = null;\n        this.bindGroup = null;\n        this.batcher = null;\n    }\n}\n\nexport interface BatchableObject\n{\n    indexStart: number;\n\n    packAttributes: (\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number,\n    ) => void;\n    packIndex: (indexBuffer: IndexBufferArray, index: number, indicesOffset: number) => void;\n\n    texture: Texture;\n    blendMode: BLEND_MODES;\n    vertexSize: number;\n    indexSize: number;\n\n    // stored for efficient updating..\n    textureId: number;\n    location: number; // location in the buffer\n    batcher: Batcher;\n    batch: Batch;\n\n    roundPixels: 0 | 1;\n}\n\nlet BATCH_TICK = 0;\n\n/**\n * The options for the batcher.\n * @ignore\n */\nexport interface BatcherOptions\n{\n    /** The size of the vertex buffer. */\n    vertexSize?: number;\n    /** The size of the index buffer. */\n    indexSize?: number;\n}\n\n/**\n * A batcher is used to batch together objects with the same texture.\n * @ignore\n */\nexport class Batcher\n{\n    public static defaultOptions: BatcherOptions = {\n        vertexSize: 4,\n        indexSize: 6,\n    };\n\n    public uid = uid('batcher');\n    public attributeBuffer: ViewableBuffer;\n    public indexBuffer: IndexBufferArray;\n\n    public attributeSize: number;\n    public indexSize: number;\n    public elementSize: number;\n    public elementStart: number;\n\n    public dirty = true;\n\n    public batchIndex = 0;\n    public batches: Batch[] = [];\n\n    // specifics.\n    private readonly _vertexSize: number = 6;\n\n    private _elements: BatchableObject[] = [];\n\n    private readonly _batchPool: Batch[] = [];\n    private _batchPoolIndex = 0;\n    private readonly _textureBatchPool: BatchTextureArray[] = [];\n    private _textureBatchPoolIndex = 0;\n    private _batchIndexStart: number;\n    private _batchIndexSize: number;\n\n    constructor(options: BatcherOptions = {})\n    {\n        options = { ...Batcher.defaultOptions, ...options };\n\n        const { vertexSize, indexSize } = options;\n\n        this.attributeBuffer = new ViewableBuffer(vertexSize * this._vertexSize * 4);\n\n        this.indexBuffer = new Uint16Array(indexSize);\n    }\n\n    public begin()\n    {\n        this.batchIndex = 0;\n        this.elementSize = 0;\n        this.elementStart = 0;\n        this.indexSize = 0;\n        this.attributeSize = 0;\n        this._batchPoolIndex = 0;\n        this._textureBatchPoolIndex = 0;\n        this._batchIndexStart = 0;\n        this._batchIndexSize = 0;\n\n        this.dirty = true;\n    }\n\n    public add(batchableObject: BatchableObject)\n    {\n        this._elements[this.elementSize++] = batchableObject;\n\n        batchableObject.indexStart = this.indexSize;\n        batchableObject.location = this.attributeSize;\n        batchableObject.batcher = this;\n\n        this.indexSize += batchableObject.indexSize;\n        this.attributeSize += ((batchableObject.vertexSize) * this._vertexSize);\n    }\n\n    public checkAndUpdateTexture(batchableObject: BatchableObject, texture: Texture): boolean\n    {\n        const textureId = batchableObject.batch.textures.ids[texture._source.uid];\n\n        // TODO could try to be a bit smarter if there are spare textures..\n        // but need to figure out how to alter the bind groups too..\n        if (!textureId && textureId !== 0) return false;\n\n        batchableObject.textureId = textureId;\n        batchableObject.texture = texture;\n\n        return true;\n    }\n\n    public updateElement(batchableObject: BatchableObject)\n    {\n        this.dirty = true;\n\n        batchableObject.packAttributes(\n            this.attributeBuffer.float32View,\n            this.attributeBuffer.uint32View,\n            batchableObject.location, batchableObject.textureId);\n    }\n\n    /**\n     * breaks the batcher. This happens when a batch gets too big,\n     * or we need to switch to a different type of rendering (a filter for example)\n     * @param instructionSet\n     */\n    public break(instructionSet: InstructionSet)\n    {\n        // ++BATCH_TICK;\n        const elements = this._elements;\n\n        let textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();\n\n        textureBatch.clear();\n\n        // length 0??!! (we broke without ading anything)\n        if (!elements[this.elementStart]) return;\n\n        const firstElement = elements[this.elementStart];\n        let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);\n\n        if (this.attributeSize * 4 > this.attributeBuffer.size)\n        {\n            this._resizeAttributeBuffer(this.attributeSize * 4);\n        }\n\n        if (this.indexSize > this.indexBuffer.length)\n        {\n            this._resizeIndexBuffer(this.indexSize);\n        }\n\n        const f32 = this.attributeBuffer.float32View;\n        const u32 = this.attributeBuffer.uint32View;\n        const iBuffer = this.indexBuffer;\n\n        let size = this._batchIndexSize;\n        let start = this._batchIndexStart;\n\n        let action: BatchAction = 'startBatch';\n        let batch = this._batchPool[this._batchPoolIndex++] || new Batch();\n\n        for (let i = this.elementStart; i < this.elementSize; ++i)\n        {\n            const element = elements[i];\n\n            elements[i] = null;\n\n            const texture = element.texture;\n            const source = texture._source;\n\n            const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source);\n\n            const blendModeChange = blendMode !== adjustedBlendMode;\n\n            if (source._batchTick === BATCH_TICK && !blendModeChange)\n            {\n                element.textureId = source._textureBindLocation;\n\n                size += element.indexSize;\n                element.packAttributes(f32, u32, element.location, element.textureId);\n                element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n\n                element.batch = batch;\n\n                continue;\n            }\n\n            source._batchTick = BATCH_TICK;\n\n            if (textureBatch.count >= MAX_TEXTURES || blendModeChange)\n            {\n                this._finishBatch(\n                    batch,\n                    start,\n                    size - start,\n                    textureBatch,\n                    blendMode,\n                    instructionSet,\n                    action\n                );\n\n                action = 'renderBatch';\n                start = size;\n                // create a batch...\n                blendMode = adjustedBlendMode;\n\n                textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();\n                textureBatch.clear();\n\n                batch = this._batchPool[this._batchPoolIndex++] || new Batch();\n                ++BATCH_TICK;\n            }\n\n            element.textureId = source._textureBindLocation = textureBatch.count;\n            textureBatch.ids[source.uid] = textureBatch.count;\n            textureBatch.textures[textureBatch.count++] = source;\n            element.batch = batch;\n\n            size += element.indexSize;\n            element.packAttributes(f32, u32, element.location, element.textureId);\n            element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n        }\n\n        if (textureBatch.count > 0)\n        {\n            this._finishBatch(\n                batch,\n                start,\n                size - start,\n                textureBatch,\n                blendMode,\n                instructionSet,\n                action\n            );\n\n            start = size;\n            ++BATCH_TICK;\n        }\n\n        this.elementStart = this.elementSize;\n        this._batchIndexStart = start;\n        this._batchIndexSize = size;\n    }\n\n    private _finishBatch(\n        batch: Batch,\n        indexStart: number,\n        indexSize: number,\n        textureBatch: BatchTextureArray,\n        blendMode: BLEND_MODES,\n        instructionSet: InstructionSet,\n        action: BatchAction\n    )\n    {\n        batch.gpuBindGroup = null;\n        batch.action = action;\n\n        batch.batcher = this;\n        batch.textures = textureBatch;\n        batch.blendMode = blendMode;\n\n        batch.start = indexStart;\n        batch.size = indexSize;\n\n        ++BATCH_TICK;\n\n        instructionSet.add(batch);\n    }\n\n    public finish(instructionSet: InstructionSet)\n    {\n        this.break(instructionSet);\n    }\n\n    /**\n     * Resizes the attribute buffer to the given size (1 = 1 float32)\n     * @param size - the size in vertices to ensure (not bytes!)\n     */\n    public ensureAttributeBuffer(size: number)\n    {\n        if (size * 4 <= this.attributeBuffer.size) return;\n\n        this._resizeAttributeBuffer(size * 4);\n    }\n\n    /**\n     * Resizes the index buffer to the given size (1 = 1 float32)\n     * @param size - the size in vertices to ensure (not bytes!)\n     */\n    public ensureIndexBuffer(size: number)\n    {\n        if (size <= this.indexBuffer.length) return;\n\n        this._resizeIndexBuffer(size);\n    }\n\n    private _resizeAttributeBuffer(size: number)\n    {\n        const newSize = Math.max(size, this.attributeBuffer.size * 2);\n\n        const newArrayBuffer = new ViewableBuffer(newSize);\n\n        fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n\n        this.attributeBuffer = newArrayBuffer;\n    }\n\n    private _resizeIndexBuffer(size: number)\n    {\n        const indexBuffer = this.indexBuffer;\n\n        let newSize = Math.max(size, indexBuffer.length * 1.5);\n\n        newSize += newSize % 2;\n\n        // this, is technically not 100% accurate, as really we should\n        // be checking the maximum value in the buffer. This approximation\n        // does the trick though...\n\n        // make sure buffer is always an even number..\n        const newIndexBuffer = (newSize > 65535) ? new Uint32Array(newSize) : new Uint16Array(newSize);\n\n        if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT)\n        {\n            for (let i = 0; i < indexBuffer.length; i++)\n            {\n                newIndexBuffer[i] = indexBuffer[i];\n            }\n        }\n        else\n        {\n            fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);\n        }\n\n        this.indexBuffer = newIndexBuffer;\n    }\n\n    public destroy()\n    {\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            this.batches[i].destroy();\n        }\n\n        this.batches = null;\n\n        for (let i = 0; i < this._elements.length; i++)\n        {\n            this._elements[i].batch = null;\n        }\n\n        this._elements = null;\n\n        this.indexBuffer = null;\n\n        this.attributeBuffer.destroy();\n        this.attributeBuffer = null;\n    }\n}\n\n","\"use strict\";\nclass ViewableBuffer {\n  constructor(sizeOrBuffer) {\n    if (typeof sizeOrBuffer === \"number\") {\n      this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);\n    } else if (sizeOrBuffer instanceof Uint8Array) {\n      this.rawBinaryData = sizeOrBuffer.buffer;\n    } else {\n      this.rawBinaryData = sizeOrBuffer;\n    }\n    this.uint32View = new Uint32Array(this.rawBinaryData);\n    this.float32View = new Float32Array(this.rawBinaryData);\n    this.size = this.rawBinaryData.byteLength;\n  }\n  /** View on the raw binary data as a `Int8Array`. */\n  get int8View() {\n    if (!this._int8View) {\n      this._int8View = new Int8Array(this.rawBinaryData);\n    }\n    return this._int8View;\n  }\n  /** View on the raw binary data as a `Uint8Array`. */\n  get uint8View() {\n    if (!this._uint8View) {\n      this._uint8View = new Uint8Array(this.rawBinaryData);\n    }\n    return this._uint8View;\n  }\n  /**  View on the raw binary data as a `Int16Array`. */\n  get int16View() {\n    if (!this._int16View) {\n      this._int16View = new Int16Array(this.rawBinaryData);\n    }\n    return this._int16View;\n  }\n  /** View on the raw binary data as a `Int32Array`. */\n  get int32View() {\n    if (!this._int32View) {\n      this._int32View = new Int32Array(this.rawBinaryData);\n    }\n    return this._int32View;\n  }\n  /** View on the raw binary data as a `Float64Array`. */\n  get float64View() {\n    if (!this._float64Array) {\n      this._float64Array = new Float64Array(this.rawBinaryData);\n    }\n    return this._float64Array;\n  }\n  /** View on the raw binary data as a `BigUint64Array`. */\n  get bigUint64View() {\n    if (!this._bigUint64Array) {\n      this._bigUint64Array = new BigUint64Array(this.rawBinaryData);\n    }\n    return this._bigUint64Array;\n  }\n  /**\n   * Returns the view of the given type.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *    `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - typed array of given type\n   */\n  view(type) {\n    return this[`${type}View`];\n  }\n  /** Destroys all buffer references. Do not use after calling this. */\n  destroy() {\n    this.rawBinaryData = null;\n    this._int8View = null;\n    this._uint8View = null;\n    this._int16View = null;\n    this.uint16View = null;\n    this._int32View = null;\n    this.uint32View = null;\n    this.float32View = null;\n  }\n  /**\n   * Returns the size of the given type in bytes.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *   `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - size of the type in bytes\n   */\n  static sizeOf(type) {\n    switch (type) {\n      case \"int8\":\n      case \"uint8\":\n        return 1;\n      case \"int16\":\n      case \"uint16\":\n        return 2;\n      case \"int32\":\n      case \"uint32\":\n      case \"float32\":\n        return 4;\n      default:\n        throw new Error(`${type} isn't a valid view type`);\n    }\n  }\n}\n\nexport { ViewableBuffer };\n//# sourceMappingURL=ViewableBuffer.mjs.map\n","type TypedArray = Float32Array | Uint32Array | Int32Array | Uint8Array;\n\n/**\n * Flexible wrapper around `ArrayBuffer` that also provides typed array views on demand.\n * @memberof utils\n */\nexport class ViewableBuffer\n{\n    /** The size of the buffer in bytes. */\n    public size: number;\n\n    /** Underlying `ArrayBuffer` that holds all the data and is of capacity `this.size`. */\n    public rawBinaryData: ArrayBuffer;\n\n    /** View on the raw binary data as a `Uint32Array`. */\n    public uint32View: Uint32Array;\n\n    /** View on the raw binary data as a `Float32Array`. */\n    public float32View: Float32Array;\n    public uint16View: Uint16Array;\n\n    private _int8View: Int8Array;\n    private _uint8View: Uint8Array;\n    private _int16View: Int16Array;\n    private _int32View: Int32Array;\n    private _float64Array: Float64Array;\n    private _bigUint64Array: BigUint64Array;\n\n    /**\n     * @param length - The size of the buffer in bytes.\n     */\n    constructor(length: number);\n\n    /**\n     * @param arrayBuffer - The source array buffer.\n     */\n    constructor(arrayBuffer: ArrayBuffer);\n\n    constructor(sizeOrBuffer: number | ArrayBuffer | Uint8Array)\n    {\n        if (typeof sizeOrBuffer === 'number')\n        {\n            this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);\n        }\n        else if (sizeOrBuffer instanceof Uint8Array)\n        {\n            this.rawBinaryData = sizeOrBuffer.buffer;\n        }\n        else\n        {\n            this.rawBinaryData = sizeOrBuffer;\n        }\n\n        this.uint32View = new Uint32Array(this.rawBinaryData);\n        this.float32View = new Float32Array(this.rawBinaryData);\n\n        this.size = this.rawBinaryData.byteLength;\n    }\n\n    /** View on the raw binary data as a `Int8Array`. */\n    get int8View(): Int8Array\n    {\n        if (!this._int8View)\n        {\n            this._int8View = new Int8Array(this.rawBinaryData);\n        }\n\n        return this._int8View;\n    }\n\n    /** View on the raw binary data as a `Uint8Array`. */\n    get uint8View(): Uint8Array\n    {\n        if (!this._uint8View)\n        {\n            this._uint8View = new Uint8Array(this.rawBinaryData);\n        }\n\n        return this._uint8View;\n    }\n\n    /**  View on the raw binary data as a `Int16Array`. */\n    get int16View(): Int16Array\n    {\n        if (!this._int16View)\n        {\n            this._int16View = new Int16Array(this.rawBinaryData);\n        }\n\n        return this._int16View;\n    }\n\n    /** View on the raw binary data as a `Int32Array`. */\n    get int32View(): Int32Array\n    {\n        if (!this._int32View)\n        {\n            this._int32View = new Int32Array(this.rawBinaryData);\n        }\n\n        return this._int32View;\n    }\n\n    /** View on the raw binary data as a `Float64Array`. */\n    get float64View(): Float64Array\n    {\n        if (!this._float64Array)\n        {\n            this._float64Array = new Float64Array(this.rawBinaryData);\n        }\n\n        return this._float64Array;\n    }\n\n    /** View on the raw binary data as a `BigUint64Array`. */\n    get bigUint64View(): BigUint64Array\n    {\n        if (!this._bigUint64Array)\n        {\n            this._bigUint64Array = new BigUint64Array(this.rawBinaryData);\n        }\n\n        return this._bigUint64Array;\n    }\n\n    /**\n     * Returns the view of the given type.\n     * @param type - One of `int8`, `uint8`, `int16`,\n     *    `uint16`, `int32`, `uint32`, and `float32`.\n     * @returns - typed array of given type\n     */\n    public view(type: string): TypedArray\n    {\n        return (this as any)[`${type}View`];\n    }\n\n    /** Destroys all buffer references. Do not use after calling this. */\n    public destroy(): void\n    {\n        this.rawBinaryData = null;\n        this._int8View = null;\n        this._uint8View = null;\n        this._int16View = null;\n        this.uint16View = null;\n        this._int32View = null;\n        this.uint32View = null;\n        this.float32View = null;\n    }\n\n    /**\n     * Returns the size of the given type in bytes.\n     * @param type - One of `int8`, `uint8`, `int16`,\n     *   `uint16`, `int32`, `uint32`, and `float32`.\n     * @returns - size of the type in bytes\n     */\n    public static sizeOf(type: string): number\n    {\n        switch (type)\n        {\n            case 'int8':\n            case 'uint8':\n                return 1;\n            case 'int16':\n            case 'uint16':\n                return 2;\n            case 'int32':\n            case 'uint32':\n            case 'float32':\n                return 4;\n            default:\n                throw new Error(`${type} isn't a valid view type`);\n        }\n    }\n}\n","\"use strict\";\nfunction fastCopy(sourceBuffer, destinationBuffer) {\n  const lengthDouble = sourceBuffer.byteLength / 8 | 0;\n  const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);\n  const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);\n  destinationFloat64View.set(sourceFloat64View);\n  const remainingBytes = sourceBuffer.byteLength - lengthDouble * 8;\n  if (remainingBytes > 0) {\n    const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);\n    const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);\n    destinationUint8View.set(sourceUint8View);\n  }\n}\n\nexport { fastCopy };\n//# sourceMappingURL=fastCopy.mjs.map\n","/**\n * Copies from one buffer to another.\n * This is an optimised function that will use `Float64Array` window.\n * This means it can copy twice as fast!\n * @param sourceBuffer - the array buffer to copy from\n * @param destinationBuffer - the array buffer to copy to\n * @private\n */\nexport function fastCopy(sourceBuffer: ArrayBuffer, destinationBuffer: ArrayBuffer): void\n{\n    const lengthDouble = (sourceBuffer.byteLength / 8) | 0;\n\n    const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);\n    const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);\n\n    // Use set for faster copying\n    destinationFloat64View.set(sourceFloat64View);\n\n    // copying over the remaining bytes\n    const remainingBytes = sourceBuffer.byteLength - (lengthDouble * 8);\n\n    if (remainingBytes > 0)\n    {\n        const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);\n        const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);\n\n        // Direct copy for remaining bytes\n        destinationUint8View.set(sourceUint8View);\n    }\n}\n","import { BLEND_TO_NPM } from './const.mjs';\n\n\"use strict\";\nfunction getAdjustedBlendModeBlend(blendMode, textureSource) {\n  if (textureSource.alphaMode === \"no-premultiply-alpha\") {\n    return BLEND_TO_NPM[blendMode] || blendMode;\n  }\n  return blendMode;\n}\n\nexport { getAdjustedBlendModeBlend };\n//# sourceMappingURL=getAdjustedBlendModeBlend.mjs.map\n","import { type BLEND_MODES, BLEND_TO_NPM } from './const';\n\nimport type { TextureSource } from '../texture/sources/TextureSource';\n\n/**\n * Adjusts a blend mode for the current alpha mode. Returns the blend mode that works with that format.\n * eg 'normal' blend mode will return 'normal-npm' when rendering with premultiplied alpha.\n * and 'normal' if the texture is already premultiplied (the default)\n * @param blendMode - The blend mode to get the adjusted blend mode for.\n * @param textureSource - The texture to test the format of.\n * @returns - the blend mode that should be used to render this texture correctly based on its alphaMode\n */\nexport function getAdjustedBlendModeBlend(blendMode: BLEND_MODES, textureSource: TextureSource): BLEND_MODES\n{\n    if (textureSource.alphaMode === 'no-premultiply-alpha')\n    {\n        return (BLEND_TO_NPM[blendMode as keyof typeof BLEND_TO_NPM] || blendMode) as BLEND_MODES;\n    }\n\n    return blendMode;\n}\n","\"use strict\";\nconst BLEND_TO_NPM = {\n  normal: \"normal-npm\",\n  add: \"add-npm\",\n  screen: \"screen-npm\"\n};\nvar STENCIL_MODES = /* @__PURE__ */ ((STENCIL_MODES2) => {\n  STENCIL_MODES2[STENCIL_MODES2[\"DISABLED\"] = 0] = \"DISABLED\";\n  STENCIL_MODES2[STENCIL_MODES2[\"RENDERING_MASK_ADD\"] = 1] = \"RENDERING_MASK_ADD\";\n  STENCIL_MODES2[STENCIL_MODES2[\"MASK_ACTIVE\"] = 2] = \"MASK_ACTIVE\";\n  STENCIL_MODES2[STENCIL_MODES2[\"RENDERING_MASK_REMOVE\"] = 3] = \"RENDERING_MASK_REMOVE\";\n  STENCIL_MODES2[STENCIL_MODES2[\"NONE\"] = 4] = \"NONE\";\n  return STENCIL_MODES2;\n})(STENCIL_MODES || {});\n\nexport { BLEND_TO_NPM, STENCIL_MODES };\n//# sourceMappingURL=const.mjs.map\n","/* eslint-disable @typescript-eslint/indent */\n/**\n * Various blend modes supported by Pixi\n * @memberof filters\n */\nexport type BLEND_MODES = 'inherit'\n| 'normal'\n| 'add'\n| 'multiply'\n| 'screen'\n| 'darken'\n| 'lighten'\n| 'erase'\n| 'color-dodge'\n| 'color-burn'\n| 'linear-burn'\n| 'linear-dodge'\n| 'linear-light'\n| 'hard-light'\n| 'soft-light'\n| 'pin-light'\n| 'difference'\n| 'exclusion'\n| 'overlay'\n// | 'hue'\n| 'saturation'\n| 'color'\n| 'luminosity'\n| 'normal-npm'\n| 'add-npm'\n| 'screen-npm'\n| 'none'\n| 'subtract'\n| 'divide'\n| 'vivid-light'\n| 'hard-mix'\n| 'negation';\n\n/**\n * The map of blend modes supported by Pixi\n * @memberof rendering\n */\nexport const BLEND_TO_NPM = {\n    normal: 'normal-npm',\n    add: 'add-npm',\n    screen: 'screen-npm',\n};\n\n/**\n * The stencil operation to perform when using the stencil buffer\n * @memberof rendering\n */\nexport enum STENCIL_MODES\n{\n    DISABLED = 0,\n    RENDERING_MASK_ADD = 1,\n    MASK_ACTIVE = 2,\n    RENDERING_MASK_REMOVE = 3,\n    NONE = 4,\n}\n\n/**\n * The culling mode to use. It can be either `none`, `front` or `back`.\n * @memberof rendering\n */\nexport type CULL_MODES = 'none' | 'back' | 'front';\n\n","\"use strict\";\nclass BatchTextureArray {\n  constructor() {\n    /** Respective locations for textures. */\n    this.ids = /* @__PURE__ */ Object.create(null);\n    this.textures = [];\n    this.count = 0;\n  }\n  /** Clear the textures and their locations. */\n  clear() {\n    for (let i = 0; i < this.count; i++) {\n      const t = this.textures[i];\n      this.textures[i] = null;\n      this.ids[t.uid] = null;\n    }\n    this.count = 0;\n  }\n}\n\nexport { BatchTextureArray };\n//# sourceMappingURL=BatchTextureArray.mjs.map\n","import type { TextureSource } from '../../renderers/shared/texture/sources/TextureSource';\n\n/**\n * Used by the batcher to build texture batches. Holds list of textures and their respective locations.\n * @memberof rendering\n */\nexport class BatchTextureArray\n{\n    /** Inside textures array. */\n    public textures: TextureSource[];\n\n    /** Respective locations for textures. */\n    public ids: Record<number, number> = Object.create(null);\n\n    /** Number of filled elements. */\n    public count: number;\n\n    constructor()\n    {\n        this.textures = [];\n        this.count = 0;\n    }\n\n    /** Clear the textures and their locations. */\n    public clear(): void\n    {\n        for (let i = 0; i < this.count; i++)\n        {\n            const t = this.textures[i];\n\n            this.textures[i] = null;\n            this.ids[t.uid] = null;\n        }\n\n        this.count = 0;\n    }\n}\n","import { mixHexColors } from './mixHexColors.mjs';\n\n\"use strict\";\nconst WHITE_BGR = 16777215;\nfunction mixColors(localBGRColor, parentBGRColor) {\n  if (localBGRColor === WHITE_BGR || parentBGRColor === WHITE_BGR) {\n    return localBGRColor + parentBGRColor - WHITE_BGR;\n  }\n  return mixHexColors(localBGRColor, parentBGRColor, 0.5);\n}\nfunction mixStandardAnd32BitColors(localColorRGB, localAlpha, parentColor) {\n  const parentAlpha = (parentColor >> 24 & 255) / 255;\n  const globalAlpha = localAlpha * parentAlpha * 255;\n  const localBGRColor = ((localColorRGB & 255) << 16) + (localColorRGB & 65280) + (localColorRGB >> 16 & 255);\n  const parentBGRColor = parentColor & 16777215;\n  let sharedBGRColor;\n  if (localBGRColor === WHITE_BGR || parentBGRColor === WHITE_BGR) {\n    sharedBGRColor = localBGRColor + parentBGRColor - WHITE_BGR;\n  } else {\n    sharedBGRColor = mixHexColors(localBGRColor, parentBGRColor, 0.5);\n  }\n  return sharedBGRColor + (globalAlpha << 24);\n}\n\nexport { mixColors, mixStandardAnd32BitColors };\n//# sourceMappingURL=mixColors.mjs.map\n","import { mixHexColors } from './mixHexColors';\n\nconst WHITE_BGR = 0xFFFFFF;\n\nexport function mixColors(localBGRColor: number, parentBGRColor: number)\n{\n    if (localBGRColor === WHITE_BGR || parentBGRColor === WHITE_BGR)\n    {\n        return localBGRColor + parentBGRColor - WHITE_BGR;\n    }\n\n    return mixHexColors(localBGRColor, parentBGRColor, 0.5);\n}\n\nexport function mixStandardAnd32BitColors(localColorRGB: number, localAlpha: number, parentColor: number)\n{\n    const parentAlpha = ((parentColor >> 24) & 0xFF) / 255;\n\n    const globalAlpha = ((localAlpha * parentAlpha) * 255);\n\n    // flip rgb to bgr\n    const localBGRColor = ((localColorRGB & 0xFF) << 16) + (localColorRGB & 0xFF00) + ((localColorRGB >> 16) & 0xFF);\n\n    const parentBGRColor = parentColor & 0x00FFFFFF;\n\n    let sharedBGRColor: number;\n\n    if (localBGRColor === WHITE_BGR || parentBGRColor === WHITE_BGR)\n    {\n        sharedBGRColor = localBGRColor + parentBGRColor - WHITE_BGR;\n    }\n    else\n    {\n        sharedBGRColor = mixHexColors(localBGRColor, parentBGRColor, 0.5);\n    }\n\n    return sharedBGRColor + (globalAlpha << 24);\n}\n\n","\"use strict\";\nfunction mixHexColors(color1, color2, ratio) {\n  const r1 = color1 >> 16 & 255;\n  const g1 = color1 >> 8 & 255;\n  const b1 = color1 & 255;\n  const r2 = color2 >> 16 & 255;\n  const g2 = color2 >> 8 & 255;\n  const b2 = color2 & 255;\n  const r = r1 + (r2 - r1) * ratio;\n  const g = g1 + (g2 - g1) * ratio;\n  const b = b1 + (b2 - b1) * ratio;\n  return (r << 16) + (g << 8) + b;\n}\n\nexport { mixHexColors };\n//# sourceMappingURL=mixHexColors.mjs.map\n","export function mixHexColors(color1: number, color2: number, ratio: number): number\n{\n    const r1 = (color1 >> 16) & 0xFF;\n    const g1 = (color1 >> 8) & 0xFF;\n    const b1 = color1 & 0xFF;\n\n    const r2 = (color2 >> 16) & 0xFF;\n    const g2 = (color2 >> 8) & 0xFF;\n    const b2 = color2 & 0xFF;\n\n    const r = r1 + ((r2 - r1) * ratio);\n    const g = g1 + ((g2 - g1) * ratio);\n    const b = b1 + ((b2 - b1) * ratio);\n\n    return (r << 16) + (g << 8) + b;\n}\n\n","\"use strict\";\nconst blendModeIds = {\n  normal: 0,\n  add: 1,\n  multiply: 2,\n  screen: 3,\n  overlay: 4,\n  erase: 5,\n  \"normal-npm\": 6,\n  \"add-npm\": 7,\n  \"screen-npm\": 8\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\nconst _State = class _State {\n  constructor() {\n    this.data = 0;\n    this.blendMode = \"normal\";\n    this.polygonOffset = 0;\n    this.blend = true;\n    this.depthMask = true;\n  }\n  /**\n   * Activates blending of the computed fragment color values.\n   * @default true\n   */\n  get blend() {\n    return !!(this.data & 1 << BLEND);\n  }\n  set blend(value) {\n    if (!!(this.data & 1 << BLEND) !== value) {\n      this.data ^= 1 << BLEND;\n    }\n  }\n  /**\n   * Activates adding an offset to depth values of polygon's fragments\n   * @default false\n   */\n  get offsets() {\n    return !!(this.data & 1 << OFFSET);\n  }\n  set offsets(value) {\n    if (!!(this.data & 1 << OFFSET) !== value) {\n      this.data ^= 1 << OFFSET;\n    }\n  }\n  /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n  set cullMode(value) {\n    if (value === \"none\") {\n      this.culling = false;\n      return;\n    }\n    this.culling = true;\n    this.clockwiseFrontFace = value === \"front\";\n  }\n  get cullMode() {\n    if (!this.culling) {\n      return \"none\";\n    }\n    return this.clockwiseFrontFace ? \"front\" : \"back\";\n  }\n  /**\n   * Activates culling of polygons.\n   * @default false\n   */\n  get culling() {\n    return !!(this.data & 1 << CULLING);\n  }\n  set culling(value) {\n    if (!!(this.data & 1 << CULLING) !== value) {\n      this.data ^= 1 << CULLING;\n    }\n  }\n  /**\n   * Activates depth comparisons and updates to the depth buffer.\n   * @default false\n   */\n  get depthTest() {\n    return !!(this.data & 1 << DEPTH_TEST);\n  }\n  set depthTest(value) {\n    if (!!(this.data & 1 << DEPTH_TEST) !== value) {\n      this.data ^= 1 << DEPTH_TEST;\n    }\n  }\n  /**\n   * Enables or disables writing to the depth buffer.\n   * @default true\n   */\n  get depthMask() {\n    return !!(this.data & 1 << DEPTH_MASK);\n  }\n  set depthMask(value) {\n    if (!!(this.data & 1 << DEPTH_MASK) !== value) {\n      this.data ^= 1 << DEPTH_MASK;\n    }\n  }\n  /**\n   * Specifies whether or not front or back-facing polygons can be culled.\n   * @default false\n   */\n  get clockwiseFrontFace() {\n    return !!(this.data & 1 << WINDING);\n  }\n  set clockwiseFrontFace(value) {\n    if (!!(this.data & 1 << WINDING) !== value) {\n      this.data ^= 1 << WINDING;\n    }\n  }\n  /**\n   * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n   * @default 'normal'\n   */\n  get blendMode() {\n    return this._blendMode;\n  }\n  set blendMode(value) {\n    this.blend = value !== \"none\";\n    this._blendMode = value;\n    this._blendModeId = blendModeIds[value] || 0;\n  }\n  /**\n   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n   * @default 0\n   */\n  get polygonOffset() {\n    return this._polygonOffset;\n  }\n  set polygonOffset(value) {\n    this.offsets = !!value;\n    this._polygonOffset = value;\n  }\n  toString() {\n    return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;\n  }\n  /**\n   * A quickly getting an instance of a State that is configured for 2d rendering.\n   * @returns a new State with values set for 2d rendering\n   */\n  static for2d() {\n    const state = new _State();\n    state.depthTest = false;\n    state.blend = true;\n    return state;\n  }\n};\n_State.default2d = _State.for2d();\nlet State = _State;\n\nexport { State };\n//# sourceMappingURL=State.mjs.map\n","/* eslint-disable max-len */\nimport type { BLEND_MODES, CULL_MODES } from './const';\n\nconst blendModeIds = {\n    normal: 0,\n    add: 1,\n    multiply: 2,\n    screen: 3,\n    overlay: 4,\n    erase: 5,\n    'normal-npm': 6,\n    'add-npm': 7,\n    'screen-npm': 8,\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\n\n/**\n * This is a WebGL state, and is is passed to {@link StateSystem}.\n *\n * Each mesh rendered may require WebGL to be in a different state.\n * For example you may want different blend mode or to enable polygon offsets\n * @memberof rendering\n */\nexport class State\n{\n    /**\n     * The data is a unique number based on the states settings.\n     * This lets us quickly compare states with a single number rather than looking\n     * at all the individual settings.\n     */\n    public data: number;\n    public _blendModeId: number;\n    private _blendMode: BLEND_MODES;\n    private _polygonOffset: number;\n\n    constructor()\n    {\n        this.data = 0;\n\n        this.blendMode = 'normal';\n        this.polygonOffset = 0;\n\n        this.blend = true;\n        this.depthMask = true;\n    }\n\n    /**\n     * Activates blending of the computed fragment color values.\n     * @default true\n     */\n    get blend(): boolean\n    {\n        return !!(this.data & (1 << BLEND));\n    }\n\n    set blend(value: boolean)\n    {\n        if (!!(this.data & (1 << BLEND)) !== value)\n        {\n            this.data ^= (1 << BLEND);\n        }\n    }\n\n    /**\n     * Activates adding an offset to depth values of polygon's fragments\n     * @default false\n     */\n    get offsets(): boolean\n    {\n        return !!(this.data & (1 << OFFSET));\n    }\n\n    set offsets(value: boolean)\n    {\n        if (!!(this.data & (1 << OFFSET)) !== value)\n        {\n            this.data ^= (1 << OFFSET);\n        }\n    }\n\n    /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n    set cullMode(value: CULL_MODES)\n    {\n        if (value === 'none')\n        {\n            this.culling = false;\n\n            return;\n        }\n\n        this.culling = true;\n        this.clockwiseFrontFace = value === 'front';\n    }\n\n    get cullMode(): CULL_MODES\n    {\n        if (!this.culling)\n        {\n            return 'none';\n        }\n\n        return this.clockwiseFrontFace ? 'front' : 'back';\n    }\n\n    /**\n     * Activates culling of polygons.\n     * @default false\n     */\n    get culling(): boolean\n    {\n        return !!(this.data & (1 << CULLING));\n    }\n\n    set culling(value: boolean)\n    {\n        if (!!(this.data & (1 << CULLING)) !== value)\n        {\n            this.data ^= (1 << CULLING);\n        }\n    }\n\n    /**\n     * Activates depth comparisons and updates to the depth buffer.\n     * @default false\n     */\n    get depthTest(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_TEST));\n    }\n\n    set depthTest(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_TEST)) !== value)\n        {\n            this.data ^= (1 << DEPTH_TEST);\n        }\n    }\n\n    /**\n     * Enables or disables writing to the depth buffer.\n     * @default true\n     */\n    get depthMask(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_MASK));\n    }\n\n    set depthMask(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_MASK)) !== value)\n        {\n            this.data ^= (1 << DEPTH_MASK);\n        }\n    }\n\n    /**\n     * Specifies whether or not front or back-facing polygons can be culled.\n     * @default false\n     */\n    get clockwiseFrontFace(): boolean\n    {\n        return !!(this.data & (1 << WINDING));\n    }\n\n    set clockwiseFrontFace(value: boolean)\n    {\n        if (!!(this.data & (1 << WINDING)) !== value)\n        {\n            this.data ^= (1 << WINDING);\n        }\n    }\n\n    /**\n     * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n     * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n     * @default 'normal'\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._blendMode;\n    }\n\n    set blendMode(value: BLEND_MODES)\n    {\n        this.blend = (value !== 'none');\n        this._blendMode = value;\n        this._blendModeId = blendModeIds[value as keyof typeof blendModeIds] || 0;\n    }\n\n    /**\n     * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n     * @default 0\n     */\n    get polygonOffset(): number\n    {\n        return this._polygonOffset;\n    }\n\n    set polygonOffset(value: number)\n    {\n        this.offsets = !!value;\n        this._polygonOffset = value;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/core:State `\n            + `blendMode=${this.blendMode} `\n            + `clockwiseFrontFace=${this.clockwiseFrontFace} `\n            + `culling=${this.culling} `\n            + `depthMask=${this.depthMask} `\n            + `polygonOffset=${this.polygonOffset}`\n            + `]`;\n    }\n    // #endif\n\n    /**\n     * A quickly getting an instance of a State that is configured for 2d rendering.\n     * @returns a new State with values set for 2d rendering\n     */\n    public static for2d(): State\n    {\n        const state = new State();\n\n        state.depthTest = false;\n        state.blend = true;\n\n        return state;\n    }\n\n    public static default2d = State.for2d();\n}\n\n","\"use strict\";\nfunction colorToUniform(rgb, alpha, out, offset) {\n  out[offset++] = (rgb >> 16 & 255) / 255;\n  out[offset++] = (rgb >> 8 & 255) / 255;\n  out[offset++] = (rgb & 255) / 255;\n  out[offset++] = alpha;\n}\nfunction color32BitToUniform(abgr, out, offset) {\n  const alpha = (abgr >> 24 & 255) / 255;\n  out[offset++] = (abgr & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 8 & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 16 & 255) / 255 * alpha;\n  out[offset++] = alpha;\n}\n\nexport { color32BitToUniform, colorToUniform };\n//# sourceMappingURL=colorToUniform.mjs.map\n","export function colorToUniform(rgb: number, alpha: number, out: Float32Array, offset: number)\n{\n    // TODO replace with Color..\n    out[offset++] = ((rgb >> 16) & 0xFF) / 255;\n    out[offset++] = ((rgb >> 8) & 0xFF) / 255;\n    out[offset++] = (rgb & 0xFF) / 255;\n    out[offset++] = alpha;\n}\n\nexport function color32BitToUniform(abgr: number, out: Float32Array, offset: number)\n{\n    const alpha = ((abgr >> 24) & 0xFF) / 255;\n\n    out[offset++] = ((abgr & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 8) & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 16) & 0xFF) / 255) * alpha;\n    out[offset++] = alpha;\n}\n","import { uid } from '../../../../utils/data/uid.mjs';\nimport { createIdFromString } from '../utils/createIdFromString.mjs';\nimport { getDefaultUniformValue } from './utils/getDefaultUniformValue.mjs';\n\n\"use strict\";\nconst _UniformGroup = class _UniformGroup {\n  /**\n   * Create a new Uniform group\n   * @param uniformStructures - The structures of the uniform group\n   * @param options - The optional parameters of this uniform group\n   */\n  constructor(uniformStructures, options) {\n    /** used internally to know if a uniform group was used in the last render pass */\n    this._touched = 0;\n    /** a unique id for this uniform group used through the renderer */\n    this.uid = uid(\"uniform\");\n    /** a resource type, used to identify how to handle it when its in a bind group / shader resource */\n    this._resourceType = \"uniformGroup\";\n    /** the resource id used internally by the renderer to build bind group keys */\n    this._resourceId = uid(\"resource\");\n    /** used ito identify if this is a uniform group */\n    this.isUniformGroup = true;\n    /**\n     * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU\n     * @internal\n     * @ignore\n     */\n    this._dirtyId = 0;\n    options = { ..._UniformGroup.defaultOptions, ...options };\n    this.uniformStructures = uniformStructures;\n    const uniforms = {};\n    for (const i in uniformStructures) {\n      const uniformData = uniformStructures[i];\n      uniformData.name = i;\n      uniformData.size = uniformData.size ?? 1;\n      uniformData.value ?? (uniformData.value = getDefaultUniformValue(uniformData.type, uniformData.size));\n      uniforms[i] = uniformData.value;\n    }\n    this.uniforms = uniforms;\n    this._dirtyId = 1;\n    this.ubo = options.ubo;\n    this.isStatic = options.isStatic;\n    this._signature = createIdFromString(Object.keys(uniforms).map(\n      (i) => `${i}-${uniformStructures[i].type}`\n    ).join(\"-\"), \"uniform-group\");\n  }\n  /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */\n  update() {\n    this._dirtyId++;\n  }\n};\n/** The default options used by the uniform group. */\n_UniformGroup.defaultOptions = {\n  /** if true the UniformGroup is handled as an Uniform buffer object. */\n  ubo: false,\n  /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n  isStatic: false\n};\nlet UniformGroup = _UniformGroup;\n\nexport { UniformGroup };\n//# sourceMappingURL=UniformGroup.mjs.map\n","import { uid } from '../../../../utils/data/uid';\nimport { createIdFromString } from '../utils/createIdFromString';\nimport { getDefaultUniformValue } from './utils/getDefaultUniformValue';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { Buffer } from '../buffer/Buffer';\nimport type { UniformData } from './types';\n\ntype FLOPS<T = UniformData> = T extends { value: infer V } ? V : never;\n\n// TODO replace..T['value']\ntype ExtractUniformObject<T = Record<string, UniformData>> = {\n    [K in keyof T]: FLOPS<T[K]>;\n};\n\n/**\n * Uniform group options\n * @memberof rendering\n */\nexport type UniformGroupOptions = {\n    /**\n     * if true the UniformGroup is handled as an Uniform buffer object.\n     * This is the only way WebGPU can work with uniforms. WebGL2 can also use this.\n     * So don't set to true if you want to use WebGPU :D\n     */\n    ubo?: boolean;\n    /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n    isStatic?: boolean;\n};\n\n/**\n * Uniform group holds uniform map and some ID's for work\n *\n * `UniformGroup` has two modes:\n *\n * 1: Normal mode\n * Normal mode will upload the uniforms with individual function calls as required. This is the default mode\n * for WebGL rendering.\n *\n * 2: Uniform buffer mode\n * This mode will treat the uniforms as a uniform buffer. You can pass in either a buffer that you manually handle, or\n * or a generic object that PixiJS will automatically map to a buffer for you.\n * For maximum benefits, make Ubo UniformGroups static, and only update them each frame.\n * This is the only way uniforms can be used with WebGPU.\n *\n * Rules of UBOs:\n * - UBOs only work with WebGL2, so make sure you have a fallback!\n * - Only floats are supported (including vec[2,3,4], mat[2,3,4])\n * - Samplers cannot be used in ubo's (a GPU limitation)\n * - You must ensure that the object you pass in exactly matches in the shader ubo structure.\n * Otherwise, weirdness will ensue!\n * - The name of the ubo object added to the group must match exactly the name of the ubo in the shader.\n *\n * When declaring your uniform options, you ust parse in the value and the type of the uniform.\n * The types correspond to the WebGPU types {@link UNIFORM_TYPES}\n *\n Uniforms can be modified via the classes 'uniforms' property. It will contain all the uniforms declared in the constructor.\n *\n * ```glsl\n * // UBO in shader:\n * uniform myCoolData { // Declaring a UBO...\n *     mat4 uCoolMatrix;\n *     float uFloatyMcFloatFace;\n * };\n * ```\n *\n * ```js\n * // A new Uniform Buffer Object...\n * const myCoolData = new UniformGroup({\n *     uCoolMatrix: {value:new Matrix(), type: 'mat4<f32>'},\n *     uFloatyMcFloatFace: {value:23, type: 'f32'},\n * }}\n *\n * // modify the data\n * myCoolData.uniforms.uFloatyMcFloatFace = 42;\n * // Build a shader...\n * const shader = Shader.from(srcVert, srcFrag, {\n *     myCoolData // Name matches the UBO name in the shader. Will be processed accordingly.\n * })\n *\n *\n *  ```\n * @memberof rendering\n */\nexport class UniformGroup<UNIFORMS extends { [key: string]: UniformData } = any> implements BindResource\n{\n    /** The default options used by the uniform group. */\n    public static defaultOptions: UniformGroupOptions = {\n        /** if true the UniformGroup is handled as an Uniform buffer object. */\n        ubo: false,\n        /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n        isStatic: false,\n    };\n\n    /** used internally to know if a uniform group was used in the last render pass */\n    public _touched = 0;\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid = uid('uniform');\n    /** a resource type, used to identify how to handle it when its in a bind group / shader resource */\n    public _resourceType = 'uniformGroup';\n    /** the resource id used internally by the renderer to build bind group keys */\n    public _resourceId = uid('resource');\n    /** the structures of the uniform group */\n    public uniformStructures: UNIFORMS;\n    /** the uniforms as an easily accessible map of properties */\n    public uniforms: ExtractUniformObject<UNIFORMS>;\n    /** true if it should be used as a uniform buffer object */\n    public ubo: boolean;\n    /** an underlying buffer that will be uploaded to the GPU when using this UniformGroup */\n    public buffer?: Buffer;\n    /**\n     * if true, then you are responsible for when the data is uploaded to the GPU.\n     * otherwise, the data is reuploaded each frame.\n     */\n    public isStatic: boolean;\n    /** used ito identify if this is a uniform group */\n    public readonly isUniformGroup = true;\n    /**\n     * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU\n     * @internal\n     * @ignore\n     */\n    public _dirtyId = 0;\n    /**\n     * a signature string generated for internal use\n     * @internal\n     * @ignore\n     */\n    public readonly _signature: number;\n\n    /**\n     * Create a new Uniform group\n     * @param uniformStructures - The structures of the uniform group\n     * @param options - The optional parameters of this uniform group\n     */\n    constructor(uniformStructures: UNIFORMS, options?: UniformGroupOptions)\n    {\n        options = { ...UniformGroup.defaultOptions, ...options };\n\n        this.uniformStructures = uniformStructures;\n\n        const uniforms = {} as ExtractUniformObject<UNIFORMS>;\n\n        for (const i in uniformStructures)\n        {\n            const uniformData = uniformStructures[i] as UniformData;\n\n            uniformData.name = i;\n            uniformData.size = uniformData.size ?? 1;\n            uniformData.value ??= getDefaultUniformValue(uniformData.type, uniformData.size);\n\n            uniforms[i] = uniformData.value as ExtractUniformObject<UNIFORMS>[keyof UNIFORMS];\n        }\n\n        this.uniforms = uniforms;\n\n        this._dirtyId = 1;\n        this.ubo = options.ubo;\n        this.isStatic = options.isStatic;\n\n        this._signature = createIdFromString(Object.keys(uniforms).map(\n            (i) => `${i}-${(uniformStructures[i as keyof typeof uniformStructures] as UniformData).type}`\n        ).join('-'), 'uniform-group');\n    }\n\n    /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */\n    public update(): void\n    {\n        this._dirtyId++;\n        // dispatch...\n    }\n}\n","\"use strict\";\nconst idCounts = /* @__PURE__ */ Object.create(null);\nconst idHash = /* @__PURE__ */ Object.create(null);\nfunction createIdFromString(value, groupId) {\n  let id = idHash[value];\n  if (id === void 0) {\n    if (idCounts[groupId] === void 0) {\n      idCounts[groupId] = 1;\n    }\n    idHash[value] = id = idCounts[groupId]++;\n  }\n  return id;\n}\n\nexport { createIdFromString };\n//# sourceMappingURL=createIdFromString.mjs.map\n","const idCounts: Record<string, number> = Object.create(null);\nconst idHash: Record<string, number> = Object.create(null);\n\nexport function createIdFromString(value: string, groupId: string): number\n{\n    let id = idHash[value];\n\n    if (id === undefined)\n    {\n        if (idCounts[groupId] === undefined)\n        {\n            idCounts[groupId] = 1;\n        }\n\n        idHash[value] = id = idCounts[groupId]++;\n    }\n\n    return id;\n}\n","\"use strict\";\nfunction getDefaultUniformValue(type, size) {\n  switch (type) {\n    case \"f32\":\n      return 0;\n    case \"vec2<f32>\":\n      return new Float32Array(2 * size);\n    case \"vec3<f32>\":\n      return new Float32Array(3 * size);\n    case \"vec4<f32>\":\n      return new Float32Array(4 * size);\n    case \"mat2x2<f32>\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        1\n      ]);\n    case \"mat3x3<f32>\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ]);\n    case \"mat4x4<f32>\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      ]);\n  }\n  return null;\n}\n\nexport { getDefaultUniformValue };\n//# sourceMappingURL=getDefaultUniformValue.mjs.map\n","/**\n * @method defaultValue\n * @param {string} type - Type of value\n * @param {number} size\n * @private\n */\nexport function getDefaultUniformValue(\n    type: string,\n    size: number\n): number | Float32Array | Int32Array | Uint32Array | boolean | boolean[]\n{\n    switch (type)\n    {\n        case 'f32':\n            return 0;\n\n        case 'vec2<f32>':\n            return new Float32Array(2 * size);\n\n        case 'vec3<f32>':\n            return new Float32Array(3 * size);\n\n        case 'vec4<f32>':\n            return new Float32Array(4 * size);\n        case 'mat2x2<f32>':\n            return new Float32Array([1, 0,\n                0, 1]);\n\n        case 'mat3x3<f32>':\n            return new Float32Array([1, 0, 0,\n                0, 1, 0,\n                0, 0, 1]);\n\n        case 'mat4x4<f32>':\n            return new Float32Array([1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1]);\n    }\n\n    return null;\n}\n","\"use strict\";\nclass BatchableSprite {\n  constructor() {\n    // batch specific..\n    this.vertexSize = 4;\n    this.indexSize = 6;\n    this.location = 0;\n    // location in the buffer\n    this.batcher = null;\n    this.batch = null;\n    this.roundPixels = 0;\n  }\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n  packAttributes(float32View, uint32View, index, textureId) {\n    const sprite = this.renderable;\n    const texture = this.texture;\n    const wt = sprite.groupTransform;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const bounds = this.bounds;\n    const w0 = bounds.maxX;\n    const w1 = bounds.minX;\n    const h0 = bounds.maxY;\n    const h1 = bounds.minY;\n    const uvs = texture.uvs;\n    const argb = sprite.groupColorAlpha;\n    const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;\n    float32View[index + 0] = a * w1 + c * h1 + tx;\n    float32View[index + 1] = d * h1 + b * w1 + ty;\n    float32View[index + 2] = uvs.x0;\n    float32View[index + 3] = uvs.y0;\n    uint32View[index + 4] = argb;\n    uint32View[index + 5] = textureIdAndRound;\n    float32View[index + 6] = a * w0 + c * h1 + tx;\n    float32View[index + 7] = d * h1 + b * w0 + ty;\n    float32View[index + 8] = uvs.x1;\n    float32View[index + 9] = uvs.y1;\n    uint32View[index + 10] = argb;\n    uint32View[index + 11] = textureIdAndRound;\n    float32View[index + 12] = a * w0 + c * h0 + tx;\n    float32View[index + 13] = d * h0 + b * w0 + ty;\n    float32View[index + 14] = uvs.x2;\n    float32View[index + 15] = uvs.y2;\n    uint32View[index + 16] = argb;\n    uint32View[index + 17] = textureIdAndRound;\n    float32View[index + 18] = a * w1 + c * h0 + tx;\n    float32View[index + 19] = d * h0 + b * w1 + ty;\n    float32View[index + 20] = uvs.x3;\n    float32View[index + 21] = uvs.y3;\n    uint32View[index + 22] = argb;\n    uint32View[index + 23] = textureIdAndRound;\n  }\n  packIndex(indexBuffer, index, indicesOffset) {\n    indexBuffer[index] = indicesOffset + 0;\n    indexBuffer[index + 1] = indicesOffset + 1;\n    indexBuffer[index + 2] = indicesOffset + 2;\n    indexBuffer[index + 3] = indicesOffset + 0;\n    indexBuffer[index + 4] = indicesOffset + 2;\n    indexBuffer[index + 5] = indicesOffset + 3;\n  }\n  reset() {\n    this.renderable = null;\n    this.texture = null;\n    this.batcher = null;\n    this.batch = null;\n    this.bounds = null;\n  }\n}\n\nexport { BatchableSprite };\n//# sourceMappingURL=BatchableSprite.mjs.map\n","import type { Batch, BatchableObject, Batcher } from '../../rendering/batcher/shared/Batcher';\nimport type { IndexBufferArray } from '../../rendering/renderers/shared/geometry/Geometry';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { Container } from '../container/Container';\n\n/**\n * A batchable sprite object.\n * @ignore\n */\nexport class BatchableSprite implements BatchableObject\n{\n    public indexStart: number;\n    public renderable: Container;\n\n    // batch specific..\n    public vertexSize = 4;\n    public indexSize = 6;\n    public texture: Texture;\n\n    public textureId: number;\n    public location = 0; // location in the buffer\n    public batcher: Batcher = null;\n    public batch: Batch = null;\n    public bounds: BoundsData;\n    public roundPixels: 0 | 1 = 0;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n\n    public packAttributes(\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number,\n    )\n    {\n        const sprite = this.renderable;\n        const texture = this.texture;\n\n        const wt = sprite.groupTransform;\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const bounds = this.bounds;\n\n        const w0 = bounds.maxX;\n        const w1 = bounds.minX;\n        const h0 = bounds.maxY;\n        const h1 = bounds.minY;\n\n        const uvs = texture.uvs;\n\n        // _ _ _ _\n        // a b g r\n        const argb = sprite.groupColorAlpha;\n\n        const textureIdAndRound = (textureId << 16) | (this.roundPixels & 0xFFFF);\n\n        float32View[index + 0] = (a * w1) + (c * h1) + tx;\n        float32View[index + 1] = (d * h1) + (b * w1) + ty;\n\n        float32View[index + 2] = uvs.x0;\n        float32View[index + 3] = uvs.y0;\n\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureIdAndRound;\n\n        // xy\n        float32View[index + 6] = (a * w0) + (c * h1) + tx;\n        float32View[index + 7] = (d * h1) + (b * w0) + ty;\n\n        float32View[index + 8] = uvs.x1;\n        float32View[index + 9] = uvs.y1;\n\n        uint32View[index + 10] = argb;\n        uint32View[index + 11] = textureIdAndRound;\n\n        // xy\n        float32View[index + 12] = (a * w0) + (c * h0) + tx;\n        float32View[index + 13] = (d * h0) + (b * w0) + ty;\n\n        float32View[index + 14] = uvs.x2;\n        float32View[index + 15] = uvs.y2;\n\n        uint32View[index + 16] = argb;\n        uint32View[index + 17] = textureIdAndRound;\n\n        // xy\n        float32View[index + 18] = (a * w1) + (c * h0) + tx;\n        float32View[index + 19] = (d * h0) + (b * w1) + ty;\n\n        float32View[index + 20] = uvs.x3;\n        float32View[index + 21] = uvs.y3;\n\n        uint32View[index + 22] = argb;\n        uint32View[index + 23] = textureIdAndRound;\n    }\n\n    public packIndex(indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        indexBuffer[index] = indicesOffset + 0;\n        indexBuffer[index + 1] = indicesOffset + 1;\n        indexBuffer[index + 2] = indicesOffset + 2;\n\n        indexBuffer[index + 3] = indicesOffset + 0;\n        indexBuffer[index + 4] = indicesOffset + 2;\n        indexBuffer[index + 5] = indicesOffset + 3;\n    }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this.batcher = null;\n        this.batch = null;\n        this.bounds = null;\n    }\n}\n","import { nextPow2 } from '../../../../maths/misc/pow2.mjs';\nimport { TextureSource } from './sources/TextureSource.mjs';\nimport { Texture } from './Texture.mjs';\n\n\"use strict\";\nlet count = 0;\nclass TexturePoolClass {\n  /**\n   * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n   * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.\n   */\n  constructor(textureOptions) {\n    this._poolKeyHash = /* @__PURE__ */ Object.create(null);\n    this._texturePool = {};\n    this.textureOptions = textureOptions || {};\n    this.enableFullScreen = false;\n  }\n  /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param pixelWidth - Width of texture in pixels.\n   * @param pixelHeight - Height of texture in pixels.\n   * @param antialias\n   */\n  createTexture(pixelWidth, pixelHeight, antialias) {\n    const textureSource = new TextureSource({\n      ...this.textureOptions,\n      width: pixelWidth,\n      height: pixelHeight,\n      resolution: 1,\n      antialias,\n      autoGarbageCollect: true\n    });\n    return new Texture({\n      source: textureSource,\n      label: `texturePool_${count++}`\n    });\n  }\n  /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param frameWidth - The minimum width of the render texture.\n   * @param frameHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @param antialias\n   * @returns The new render texture.\n   */\n  getOptimalTexture(frameWidth, frameHeight, resolution = 1, antialias) {\n    let po2Width = Math.ceil(frameWidth * resolution - 1e-6);\n    let po2Height = Math.ceil(frameHeight * resolution - 1e-6);\n    po2Width = nextPow2(po2Width);\n    po2Height = nextPow2(po2Height);\n    const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);\n    if (!this._texturePool[key]) {\n      this._texturePool[key] = [];\n    }\n    let texture = this._texturePool[key].pop();\n    if (!texture) {\n      texture = this.createTexture(po2Width, po2Height, antialias);\n    }\n    texture.source._resolution = resolution;\n    texture.source.width = po2Width / resolution;\n    texture.source.height = po2Height / resolution;\n    texture.source.pixelWidth = po2Width;\n    texture.source.pixelHeight = po2Height;\n    texture.frame.x = 0;\n    texture.frame.y = 0;\n    texture.frame.width = frameWidth;\n    texture.frame.height = frameHeight;\n    texture.updateUvs();\n    this._poolKeyHash[texture.uid] = key;\n    return texture;\n  }\n  /**\n   * Gets extra texture of the same size as input renderTexture\n   * @param texture - The texture to check what size it is.\n   * @param antialias - Whether to use antialias.\n   * @returns A texture that is a power of two\n   */\n  getSameSizeTexture(texture, antialias = false) {\n    const source = texture.source;\n    return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);\n  }\n  /**\n   * Place a render texture back into the pool.\n   * @param renderTexture - The renderTexture to free\n   */\n  returnTexture(renderTexture) {\n    const key = this._poolKeyHash[renderTexture.uid];\n    this._texturePool[key].push(renderTexture);\n  }\n  /**\n   * Clears the pool.\n   * @param destroyTextures - Destroy all stored textures.\n   */\n  clear(destroyTextures) {\n    destroyTextures = destroyTextures !== false;\n    if (destroyTextures) {\n      for (const i in this._texturePool) {\n        const textures = this._texturePool[i];\n        if (textures) {\n          for (let j = 0; j < textures.length; j++) {\n            textures[j].destroy(true);\n          }\n        }\n      }\n    }\n    this._texturePool = {};\n  }\n}\nconst TexturePool = new TexturePoolClass();\n\nexport { TexturePool, TexturePoolClass };\n//# sourceMappingURL=TexturePool.mjs.map\n","import { nextPow2 } from '../../../../maths/misc/pow2';\nimport { TextureSource } from './sources/TextureSource';\nimport { Texture } from './Texture';\n\nimport type { TextureSourceOptions } from './sources/TextureSource';\n\nlet count = 0;\n\n/**\n * Texture pool, used by FilterSystem and plugins.\n *\n * Stores collection of temporary pow2 or screen-sized renderTextures\n *\n * If you use custom RenderTexturePool for your filters, you can use methods\n * `getFilterTexture` and `returnFilterTexture` same as in default pool\n * @memberof rendering\n * @name TexturePool\n */\nexport class TexturePoolClass\n{\n    /** The default options for texture pool */\n    public textureOptions: TextureSourceOptions;\n\n    /**\n     * Allow renderTextures of the same size as screen, not just pow2\n     *\n     * Automatically sets to true after `setScreenSize`\n     * @default false\n     */\n    public enableFullScreen: boolean;\n\n    private _texturePool: {[x in string | number]: Texture[]};\n    private _poolKeyHash: Record<number, number> = Object.create(null);\n\n    /**\n     * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n     * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.\n     */\n    constructor(textureOptions?: TextureSourceOptions)\n    {\n        this._texturePool = {};\n        this.textureOptions = textureOptions || {};\n        this.enableFullScreen = false;\n    }\n\n    /**\n     * Creates texture with params that were specified in pool constructor.\n     * @param pixelWidth - Width of texture in pixels.\n     * @param pixelHeight - Height of texture in pixels.\n     * @param antialias\n     */\n    public createTexture(pixelWidth: number, pixelHeight: number, antialias: boolean): Texture\n    {\n        const textureSource = new TextureSource({\n            ...this.textureOptions,\n\n            width: pixelWidth,\n            height: pixelHeight,\n            resolution: 1,\n            antialias,\n            autoGarbageCollect: true,\n        });\n\n        return new Texture({\n            source: textureSource,\n            label: `texturePool_${count++}`,\n        });\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param frameWidth - The minimum width of the render texture.\n     * @param frameHeight - The minimum height of the render texture.\n     * @param resolution - The resolution of the render texture.\n     * @param antialias\n     * @returns The new render texture.\n     */\n    public getOptimalTexture(frameWidth: number, frameHeight: number, resolution = 1, antialias: boolean): Texture\n    {\n        let po2Width = Math.ceil((frameWidth * resolution) - 1e-6);\n        let po2Height = Math.ceil((frameHeight * resolution) - 1e-6);\n\n        po2Width = nextPow2(po2Width);\n        po2Height = nextPow2(po2Height);\n\n        const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);\n\n        if (!this._texturePool[key])\n        {\n            this._texturePool[key] = [];\n        }\n\n        let texture = this._texturePool[key].pop();\n\n        if (!texture)\n        {\n            texture = this.createTexture(po2Width, po2Height, antialias);\n        }\n\n        texture.source._resolution = resolution;\n        texture.source.width = po2Width / resolution;\n        texture.source.height = po2Height / resolution;\n        texture.source.pixelWidth = po2Width;\n        texture.source.pixelHeight = po2Height;\n\n        // fit the layout to the requested original size\n        texture.frame.x = 0;\n        texture.frame.y = 0;\n        texture.frame.width = frameWidth;\n        texture.frame.height = frameHeight;\n\n        texture.updateUvs();\n\n        this._poolKeyHash[texture.uid] = key;\n\n        return texture;\n    }\n\n    /**\n     * Gets extra texture of the same size as input renderTexture\n     * @param texture - The texture to check what size it is.\n     * @param antialias - Whether to use antialias.\n     * @returns A texture that is a power of two\n     */\n    public getSameSizeTexture(texture: Texture, antialias = false)\n    {\n        const source = texture.source;\n\n        return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);\n    }\n\n    /**\n     * Place a render texture back into the pool.\n     * @param renderTexture - The renderTexture to free\n     */\n    public returnTexture(renderTexture: Texture): void\n    {\n        const key = this._poolKeyHash[renderTexture.uid];\n\n        this._texturePool[key].push(renderTexture);\n    }\n\n    /**\n     * Clears the pool.\n     * @param destroyTextures - Destroy all stored textures.\n     */\n    public clear(destroyTextures?: boolean): void\n    {\n        destroyTextures = destroyTextures !== false;\n        if (destroyTextures)\n        {\n            for (const i in this._texturePool)\n            {\n                const textures = this._texturePool[i];\n\n                if (textures)\n                {\n                    for (let j = 0; j < textures.length; j++)\n                    {\n                        textures[j].destroy(true);\n                    }\n                }\n            }\n        }\n\n        this._texturePool = {};\n    }\n}\n\nexport const TexturePool = new TexturePoolClass();\n","import { GlProgram } from '../renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../renderers/gpu/shader/GpuProgram.mjs';\nimport { compileHighShader, compileHighShaderGl } from './compiler/compileHighShader.mjs';\nimport { fragmentGPUTemplate, vertexGPUTemplate, vertexGlTemplate, fragmentGlTemplate } from './defaultProgramTemplate.mjs';\nimport { globalUniformsBit, globalUniformsBitGl } from './shader-bits/globalUniformsBit.mjs';\n\n\"use strict\";\nfunction compileHighShaderGpuProgram({ bits, name }) {\n  const source = compileHighShader({\n    template: {\n      fragment: fragmentGPUTemplate,\n      vertex: vertexGPUTemplate\n    },\n    bits: [\n      globalUniformsBit,\n      ...bits\n    ]\n  });\n  return GpuProgram.from({\n    name,\n    vertex: {\n      source: source.vertex,\n      entryPoint: \"main\"\n    },\n    fragment: {\n      source: source.fragment,\n      entryPoint: \"main\"\n    }\n  });\n}\nfunction compileHighShaderGlProgram({ bits, name }) {\n  return new GlProgram({\n    name,\n    ...compileHighShaderGl({\n      template: {\n        vertex: vertexGlTemplate,\n        fragment: fragmentGlTemplate\n      },\n      bits: [\n        globalUniformsBitGl,\n        ...bits\n      ]\n    })\n  });\n}\n\nexport { compileHighShaderGlProgram, compileHighShaderGpuProgram };\n//# sourceMappingURL=compileHighShaderToProgram.mjs.map\n","import { GlProgram } from '../renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../renderers/gpu/shader/GpuProgram';\nimport { compileHighShader, compileHighShaderGl } from './compiler/compileHighShader';\nimport { fragmentGlTemplate, fragmentGPUTemplate, vertexGlTemplate, vertexGPUTemplate } from './defaultProgramTemplate';\nimport { globalUniformsBit, globalUniformsBitGl } from './shader-bits/globalUniformsBit';\n\nimport type { HighShaderBit } from './compiler/types';\n\nexport function compileHighShaderGpuProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GpuProgram\n{\n    const source = compileHighShader({\n        template: {\n            fragment: fragmentGPUTemplate,\n            vertex: vertexGPUTemplate,\n        },\n        bits: [\n            globalUniformsBit,\n            ...bits,\n        ]\n    });\n\n    return GpuProgram.from({\n        name,\n        vertex: {\n            source: source.vertex,\n            entryPoint: 'main',\n        },\n        fragment: {\n            source: source.fragment,\n            entryPoint: 'main',\n        },\n    });\n}\n\nexport function compileHighShaderGlProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GlProgram\n{\n    return new GlProgram({\n        name,\n        ...compileHighShaderGl({\n            template: {\n                vertex: vertexGlTemplate,\n                fragment: fragmentGlTemplate,\n            },\n            bits: [\n                globalUniformsBitGl,\n                ...bits,\n            ]\n        })\n    });\n}\n","import { createIdFromString } from '../../shared/utils/createIdFromString.mjs';\nimport { getMaxFragmentPrecision } from './program/getMaxFragmentPrecision.mjs';\nimport { addProgramDefines } from './program/preprocessors/addProgramDefines.mjs';\nimport { ensurePrecision } from './program/preprocessors/ensurePrecision.mjs';\nimport { insertVersion } from './program/preprocessors/insertVersion.mjs';\nimport { setProgramName } from './program/preprocessors/setProgramName.mjs';\nimport { stripVersion } from './program/preprocessors/stripVersion.mjs';\n\n\"use strict\";\nconst processes = {\n  // strips any version headers..\n  stripVersion,\n  // adds precision string if not already present\n  ensurePrecision,\n  // add some defines if WebGL1 to make it more compatible with WebGL2 shaders\n  addProgramDefines,\n  // add the program name to the shader\n  setProgramName,\n  // add the version string to the shader header\n  insertVersion\n};\nconst programCache = /* @__PURE__ */ Object.create(null);\nconst _GlProgram = class _GlProgram {\n  /**\n   * Creates a shiny new GlProgram. Used by WebGL renderer.\n   * @param options - The options for the program.\n   */\n  constructor(options) {\n    options = { ..._GlProgram.defaultOptions, ...options };\n    const isES300 = options.fragment.indexOf(\"#version 300 es\") !== -1;\n    const preprocessorOptions = {\n      stripVersion: isES300,\n      ensurePrecision: {\n        requestedFragmentPrecision: options.preferredFragmentPrecision,\n        requestedVertexPrecision: options.preferredVertexPrecision,\n        maxSupportedVertexPrecision: \"highp\",\n        maxSupportedFragmentPrecision: getMaxFragmentPrecision()\n      },\n      setProgramName: {\n        name: options.name\n      },\n      addProgramDefines: isES300,\n      insertVersion: isES300\n    };\n    let fragment = options.fragment;\n    let vertex = options.vertex;\n    Object.keys(processes).forEach((processKey) => {\n      const processOptions = preprocessorOptions[processKey];\n      fragment = processes[processKey](fragment, processOptions, true);\n      vertex = processes[processKey](vertex, processOptions, false);\n    });\n    this.fragment = fragment;\n    this.vertex = vertex;\n    this._key = createIdFromString(`${this.vertex}:${this.fragment}`, \"gl-program\");\n  }\n  /** destroys the program */\n  destroy() {\n    this.fragment = null;\n    this.vertex = null;\n    this._attributeData = null;\n    this._uniformData = null;\n    this._uniformBlockData = null;\n    this.transformFeedbackVaryings = null;\n  }\n  /**\n   * Helper function that creates a program for a given source.\n   * It will check the program cache if the program has already been created.\n   * If it has that one will be returned, if not a new one will be created and cached.\n   * @param options - The options for the program.\n   * @returns A program using the same source\n   */\n  static from(options) {\n    const key = `${options.vertex}:${options.fragment}`;\n    if (!programCache[key]) {\n      programCache[key] = new _GlProgram(options);\n    }\n    return programCache[key];\n  }\n};\n/** The default options used by the program. */\n_GlProgram.defaultOptions = {\n  preferredVertexPrecision: \"highp\",\n  preferredFragmentPrecision: \"mediump\"\n};\nlet GlProgram = _GlProgram;\n\nexport { GlProgram };\n//# sourceMappingURL=GlProgram.mjs.map\n","import { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { getMaxFragmentPrecision } from './program/getMaxFragmentPrecision';\nimport { addProgramDefines } from './program/preprocessors/addProgramDefines';\nimport { ensurePrecision } from './program/preprocessors/ensurePrecision';\nimport { insertVersion } from './program/preprocessors/insertVersion';\nimport { setProgramName } from './program/preprocessors/setProgramName';\nimport { stripVersion } from './program/preprocessors/stripVersion';\n\nimport type { TypedArray } from '../../shared/buffer/Buffer';\nimport type { ExtractedAttributeData } from './program/extractAttributesFromGlProgram';\n\nexport interface GlAttributeData\n{\n    type: string;\n    size: number;\n    location: number;\n    name: string;\n}\n\nexport interface GlUniformData\n{\n    name: string;\n    index: number;\n    type: string;\n    size: number;\n    isArray: boolean;\n    value: any;\n}\n\nexport interface GlUniformBlockData\n{\n    index: number;\n    name: string;\n    size: number;\n    value?: TypedArray;\n}\n\n/**\n * The options for the gl program\n * @memberof rendering\n */\nexport interface GlProgramOptions\n{\n    /** The fragment glsl shader source. */\n    fragment: string;\n    /** The vertex glsl shader source. */\n    vertex: string;\n    /** the name of the program, defaults to 'pixi-program' */\n    name?: string;\n    /** the preferred vertex precision for the shader, this may not be used if the device does not support it  */\n    preferredVertexPrecision?: string;\n    /** the preferred fragment precision for the shader, this may not be used if the device does not support it  */\n    preferredFragmentPrecision?: string;\n}\n\nconst processes: Record<string, ((source: string, options: any, isFragment?: boolean) => string)> = {\n    // strips any version headers..\n    stripVersion,\n    // adds precision string if not already present\n    ensurePrecision,\n    // add some defines if WebGL1 to make it more compatible with WebGL2 shaders\n    addProgramDefines,\n    // add the program name to the shader\n    setProgramName,\n    // add the version string to the shader header\n    insertVersion,\n};\n\nconst programCache: Record<string, GlProgram> = Object.create(null);\n\n/**\n * A wrapper for a WebGL Program. You can create one and then pass it to a shader.\n * This will manage the WebGL program that is compiled and uploaded to the GPU.\n *\n * To get the most out of this class, you should be familiar with glsl shaders and how they work.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLProgram\n * @example\n *\n * // Create a new program\n * const program = new GlProgram({\n *   vertex: '...',\n *   fragment: '...',\n * });\n *\n *\n * There are a few key things that pixi shader will do for you automatically:\n * <br>\n * - If no precision is provided in the shader, it will be injected into the program source for you.\n * This precision will be taken form the options provided, if none is provided,\n * then the program will default to the defaultOptions.\n * <br>\n * - It will inject the program name into the shader source if none is provided.\n * <br>\n *  - It will set the program version to 300 es.\n *\n * For optimal usage and best performance, its best to reuse programs as much as possible.\n * You should use the {@link GlProgram.from} helper function to create programs.\n * @class\n * @memberof rendering\n */\nexport class GlProgram\n{\n    /** The default options used by the program. */\n    public static defaultOptions: Partial<GlProgramOptions> = {\n        preferredVertexPrecision: 'highp',\n        preferredFragmentPrecision: 'mediump',\n    };\n\n    /** the fragment glsl shader source. */\n    public readonly fragment?: string;\n    /** the vertex glsl shader source */\n    public readonly vertex?: string;\n    /**\n     * attribute data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _attributeData: Record<string, ExtractedAttributeData>;\n    /**\n     * uniform data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _uniformData: Record<string, GlUniformData>;\n    /**\n     * uniform data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _uniformBlockData: Record<string, GlUniformBlockData>;\n    /** details on how to use this program with transform feedback */\n    public transformFeedbackVaryings?: {names: string[], bufferMode: 'separate' | 'interleaved'};\n    /**\n     * the key that identifies the program via its source vertex + fragment\n     * @internal\n     * @ignore\n     */\n    public readonly _key: number;\n\n    /**\n     * Creates a shiny new GlProgram. Used by WebGL renderer.\n     * @param options - The options for the program.\n     */\n    constructor(options: GlProgramOptions)\n    {\n        options = { ...GlProgram.defaultOptions, ...options };\n\n        // only need to check one as they both need to be the same or\n        // errors ensue!\n        const isES300 = options.fragment.indexOf('#version 300 es') !== -1;\n\n        const preprocessorOptions = {\n            stripVersion: isES300,\n            ensurePrecision: {\n                requestedFragmentPrecision: options.preferredFragmentPrecision,\n                requestedVertexPrecision: options.preferredVertexPrecision,\n                maxSupportedVertexPrecision: 'highp',\n                maxSupportedFragmentPrecision: getMaxFragmentPrecision(),\n            },\n            setProgramName: {\n                name: options.name,\n            },\n            addProgramDefines: isES300,\n            insertVersion: isES300\n        };\n\n        let fragment = options.fragment;\n        let vertex = options.vertex;\n\n        Object.keys(processes).forEach((processKey) =>\n        {\n            const processOptions = preprocessorOptions[processKey as keyof typeof preprocessorOptions];\n\n            fragment = processes[processKey](fragment, processOptions, true);\n            vertex = processes[processKey](vertex, processOptions, false);\n        });\n\n        this.fragment = fragment;\n        this.vertex = vertex;\n\n        this._key = createIdFromString(`${this.vertex}:${this.fragment}`, 'gl-program');\n    }\n\n    /** destroys the program */\n    public destroy(): void\n    {\n        (this.fragment as null) = null;\n        (this.vertex as null) = null;\n\n        this._attributeData = null;\n        this._uniformData = null;\n        this._uniformBlockData = null;\n\n        this.transformFeedbackVaryings = null;\n    }\n\n    /**\n     * Helper function that creates a program for a given source.\n     * It will check the program cache if the program has already been created.\n     * If it has that one will be returned, if not a new one will be created and cached.\n     * @param options - The options for the program.\n     * @returns A program using the same source\n     */\n    public static from(options: GlProgramOptions): GlProgram\n    {\n        const key = `${options.vertex}:${options.fragment}`;\n\n        if (!programCache[key])\n        {\n            programCache[key] = new GlProgram(options);\n        }\n\n        return programCache[key];\n    }\n}\n","import { getTestContext } from './getTestContext.mjs';\n\n\"use strict\";\nlet maxFragmentPrecision;\nfunction getMaxFragmentPrecision() {\n  if (!maxFragmentPrecision) {\n    maxFragmentPrecision = \"mediump\";\n    const gl = getTestContext();\n    if (gl) {\n      if (gl.getShaderPrecisionFormat) {\n        const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n        maxFragmentPrecision = shaderFragment.precision ? \"highp\" : \"mediump\";\n      }\n    }\n  }\n  return maxFragmentPrecision;\n}\n\nexport { getMaxFragmentPrecision };\n//# sourceMappingURL=getMaxFragmentPrecision.mjs.map\n","import { getTestContext } from './getTestContext';\n\nimport type { PRECISION } from '../const';\n\nlet maxFragmentPrecision: PRECISION;\n\nexport function getMaxFragmentPrecision(): PRECISION\n{\n    if (!maxFragmentPrecision)\n    {\n        maxFragmentPrecision = 'mediump';\n        const gl = getTestContext();\n\n        if (gl)\n        {\n            if (gl.getShaderPrecisionFormat)\n            {\n                const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n\n                maxFragmentPrecision = shaderFragment.precision ? 'highp' : 'mediump';\n            }\n        }\n    }\n\n    return maxFragmentPrecision;\n}\n","import { DOMAdapter } from '../../../../../environment/adapter.mjs';\n\n\"use strict\";\nlet context;\nfunction getTestContext() {\n  if (!context || context?.isContextLost()) {\n    const canvas = DOMAdapter.get().createCanvas();\n    context = canvas.getContext(\"webgl\", {});\n  }\n  return context;\n}\n\nexport { getTestContext };\n//# sourceMappingURL=getTestContext.mjs.map\n","import { DOMAdapter } from '../../../../../environment/adapter';\n\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\n\nlet context: GlRenderingContext;\n\n/**\n * returns a little WebGL context to use for program inspection.\n * @static\n * @private\n * @returns {WebGLRenderingContext} a gl context to test with\n */\nexport function getTestContext(): GlRenderingContext\n{\n    if (!context || context?.isContextLost())\n    {\n        const canvas = DOMAdapter.get().createCanvas();\n\n        context = canvas.getContext('webgl', {}) as GlRenderingContext;\n    }\n\n    return context;\n}\n","\"use strict\";\nfunction addProgramDefines(src, isES300, isFragment) {\n  if (isES300)\n    return src;\n  if (isFragment) {\n    src = src.replace(\"out vec4 finalColor;\", \"\");\n    return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${src}\n        `;\n  }\n  return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${src}\n        `;\n}\n\nexport { addProgramDefines };\n//# sourceMappingURL=addProgramDefines.mjs.map\n","export function addProgramDefines(src: string, isES300: boolean, isFragment?: boolean)\n{\n    if (isES300) return src;\n\n    if (isFragment)\n    {\n        src = src.replace('out vec4 finalColor;', '');\n\n        return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${src}\n        `;\n    }\n\n    return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${src}\n        `;\n}\n","\"use strict\";\nfunction ensurePrecision(src, options, isFragment) {\n  const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;\n  if (src.substring(0, 9) !== \"precision\") {\n    let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;\n    if (precision === \"highp\" && maxSupportedPrecision !== \"highp\") {\n      precision = \"mediump\";\n    }\n    return `precision ${precision} float;\n${src}`;\n  } else if (maxSupportedPrecision !== \"highp\" && src.substring(0, 15) === \"precision highp\") {\n    return src.replace(\"precision highp\", \"precision mediump\");\n  }\n  return src;\n}\n\nexport { ensurePrecision };\n//# sourceMappingURL=ensurePrecision.mjs.map\n","import type { PRECISION } from '../../const';\n\ninterface EnsurePrecisionOptions\n{\n    requestedVertexPrecision: PRECISION;\n    requestedFragmentPrecision: PRECISION;\n    maxSupportedVertexPrecision: PRECISION;\n    maxSupportedFragmentPrecision: PRECISION;\n}\n\n/**\n * Sets the float precision on the shader, ensuring the device supports the request precision.\n * If the precision is already present, it just ensures that the device is able to handle it.\n * @param src\n * @param options\n * @param options.requestedVertexPrecision\n * @param options.requestedFragmentPrecision\n * @param options.maxSupportedVertexPrecision\n * @param options.maxSupportedFragmentPrecision\n * @param isFragment\n * @private\n */\nexport function ensurePrecision(\n    src: string,\n    options: EnsurePrecisionOptions,\n    isFragment: boolean,\n): string\n{\n    const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;\n\n    if (src.substring(0, 9) !== 'precision')\n    {\n        // no precision supplied, so PixiJS will add the requested level.\n        let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;\n\n        // If highp is requested but not supported, downgrade precision to a level all devices support.\n        if (precision === 'highp' && maxSupportedPrecision !== 'highp')\n        {\n            precision = 'mediump';\n        }\n\n        return `precision ${precision} float;\\n${src}`;\n    }\n    else if (maxSupportedPrecision !== 'highp' && src.substring(0, 15) === 'precision highp')\n    {\n        // precision was supplied, but at a level this device does not support, so downgrading to mediump.\n        return src.replace('precision highp', 'precision mediump');\n    }\n\n    return src;\n}\n","\"use strict\";\nfunction insertVersion(src, isES300) {\n  if (!isES300)\n    return src;\n  return `#version 300 es\n${src}`;\n}\n\nexport { insertVersion };\n//# sourceMappingURL=insertVersion.mjs.map\n","export function insertVersion(src: string, isES300: boolean): string\n{\n    if (!isES300) return src;\n\n    return `#version 300 es\\n${src}`;\n}\n","\"use strict\";\nconst fragmentNameCache = {};\nconst VertexNameCache = {};\nfunction setProgramName(src, { name = `pixi-program` }, isFragment = true) {\n  name = name.replace(/\\s+/g, \"-\");\n  name += isFragment ? \"-fragment\" : \"-vertex\";\n  const nameCache = isFragment ? fragmentNameCache : VertexNameCache;\n  if (nameCache[name]) {\n    nameCache[name]++;\n    name += `-${nameCache[name]}`;\n  } else {\n    nameCache[name] = 1;\n  }\n  if (src.indexOf(\"#define SHADER_NAME\") !== -1)\n    return src;\n  const shaderName = `#define SHADER_NAME ${name}`;\n  return `${shaderName}\n${src}`;\n}\n\nexport { setProgramName };\n//# sourceMappingURL=setProgramName.mjs.map\n","const fragmentNameCache: { [key: string]: number } = {};\nconst VertexNameCache: { [key: string]: number } = {};\n\nexport function setProgramName(src: string, { name = `pixi-program` }: { name: string; }, isFragment = true)\n{\n    name = name.replace(/\\s+/g, '-');\n\n    name += isFragment ? '-fragment' : '-vertex';\n\n    const nameCache = isFragment ? fragmentNameCache : VertexNameCache;\n\n    if (nameCache[name])\n    {\n        nameCache[name]++;\n        name += `-${nameCache[name]}`;\n    }\n    else\n    {\n        nameCache[name] = 1;\n    }\n\n    // if it already contains the define return\n    if (src.indexOf('#define SHADER_NAME') !== -1) return src;\n\n    const shaderName = `#define SHADER_NAME ${name}`;\n\n    return `${shaderName}\\n${src}`;\n}\n","\"use strict\";\nfunction stripVersion(src, isES300) {\n  if (!isES300)\n    return src;\n  return src.replace(\"#version 300 es\", \"\");\n}\n\nexport { stripVersion };\n//# sourceMappingURL=stripVersion.mjs.map\n","export function stripVersion(src: string, isES300: boolean): string\n{\n    if (!isES300) return src;\n\n    return src.replace('#version 300 es', '');\n}\n","import { createIdFromString } from '../../shared/utils/createIdFromString.mjs';\nimport { extractAttributesFromGpuProgram } from './utils/extractAttributesFromGpuProgram.mjs';\nimport { extractStructAndGroups } from './utils/extractStructAndGroups.mjs';\nimport { generateGpuLayoutGroups } from './utils/generateGpuLayoutGroups.mjs';\nimport { generateLayoutHash } from './utils/generateLayoutHash.mjs';\nimport { removeStructAndGroupDuplicates } from './utils/removeStructAndGroupDuplicates.mjs';\n\n\"use strict\";\nconst programCache = /* @__PURE__ */ Object.create(null);\nclass GpuProgram {\n  /**\n   * Create a new GpuProgram\n   * @param options - The options for the gpu program\n   */\n  constructor(options) {\n    /**\n     * @internal\n     * @ignore\n     */\n    this._layoutKey = 0;\n    const { fragment, vertex, layout, gpuLayout, name } = options;\n    this.name = name;\n    this.fragment = fragment;\n    this.vertex = vertex;\n    if (fragment.source === vertex.source) {\n      const structsAndGroups = extractStructAndGroups(fragment.source);\n      this.structsAndGroups = structsAndGroups;\n    } else {\n      const vertexStructsAndGroups = extractStructAndGroups(vertex.source);\n      const fragmentStructsAndGroups = extractStructAndGroups(fragment.source);\n      this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);\n    }\n    this.layout = layout ?? generateLayoutHash(this.structsAndGroups);\n    this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);\n    this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== void 0);\n    this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== void 0);\n    this._generateProgramKey();\n  }\n  // TODO maker this pure\n  _generateProgramKey() {\n    const { vertex, fragment } = this;\n    const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;\n    this._layoutKey = createIdFromString(bigKey, \"program\");\n  }\n  get attributeData() {\n    this._attributeData ?? (this._attributeData = extractAttributesFromGpuProgram(this.vertex));\n    return this._attributeData;\n  }\n  /** destroys the program */\n  destroy() {\n    this.gpuLayout = null;\n    this.layout = null;\n    this.structsAndGroups = null;\n    this.fragment = null;\n    this.vertex = null;\n  }\n  /**\n   * Helper function that creates a program for a given source.\n   * It will check the program cache if the program has already been created.\n   * If it has that one will be returned, if not a new one will be created and cached.\n   * @param options - The options for the program.\n   * @returns A program using the same source\n   */\n  static from(options) {\n    const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;\n    if (!programCache[key]) {\n      programCache[key] = new GpuProgram(options);\n    }\n    return programCache[key];\n  }\n}\n\nexport { GpuProgram };\n//# sourceMappingURL=GpuProgram.mjs.map\n","import { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { extractAttributesFromGpuProgram } from './utils/extractAttributesFromGpuProgram';\nimport { extractStructAndGroups } from './utils/extractStructAndGroups';\nimport { generateGpuLayoutGroups } from './utils/generateGpuLayoutGroups';\nimport { generateLayoutHash } from './utils/generateLayoutHash';\nimport { removeStructAndGroupDuplicates } from './utils/removeStructAndGroupDuplicates';\n\nimport type { ExtractedAttributeData } from '../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { StructsAndGroups } from './utils/extractStructAndGroups';\n\n/**\n * a WebGPU descriptions of how the program is layed out\n * @see https://gpuweb.github.io/gpuweb/#gpupipelinelayout\n * @memberof rendering\n */\nexport type ProgramPipelineLayoutDescription = GPUBindGroupLayoutEntry[][];\n/**\n * a map the maps names of uniforms to group indexes\n * @memberof rendering\n */\nexport type ProgramLayout = Record<string, number>[];\n\n/**\n * the program source\n * @memberof rendering\n */\nexport interface ProgramSource\n{\n    /** The wgsl source code of the shader. */\n    source: string;\n    /** The main function to run in this shader */\n    entryPoint?: string;\n}\n\n/**\n * The options for the gpu program\n * @memberof rendering\n */\nexport interface GpuProgramOptions\n{\n    /**\n     * the name of the program, this is added to the label of the GPU Program created\n     * under the hood. Makes it much easier to debug!\n     */\n    name?: string;\n    /** The fragment glsl shader source. */\n    fragment?: ProgramSource;\n    /** The vertex glsl shader source. */\n    vertex?: ProgramSource;\n    /** The layout of the program. If not provided, it will be generated from the shader sources. */\n    layout?: ProgramLayout;\n    /** The gpu layout of the program. If not provided, it will be generated from the shader sources. */\n    gpuLayout?: ProgramPipelineLayoutDescription;\n}\n\nconst programCache: Record<string, GpuProgram> = Object.create(null);\n\n/**\n * A wrapper for a WebGPU Program, specifically designed for the WebGPU renderer.\n * This class facilitates the creation and management of shader code that integrates with the WebGPU pipeline.\n *\n * To leverage the full capabilities of this class, familiarity with WGSL shaders is recommended.\n * @see https://gpuweb.github.io/gpuweb/#index\n * @example\n *\n * // Create a new program\n * const program = new GpuProgram({\n *   vertex: {\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n *   fragment:{\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n * });\n *\n *\n * Note: Both fragment and vertex shader sources can coexist within a single WGSL source file\n * this can make things a bit simpler.\n *\n * For optimal usage and best performance, it help to reuse programs whenever possible.\n * The {@link GpuProgram.from} helper function is designed for this purpose, utilizing an\n * internal cache to efficiently manage and retrieve program instances.\n * By leveraging this function, you can significantly reduce overhead and enhance the performance of your rendering pipeline.\n *\n * An important distinction between WebGL and WebGPU regarding program data retrieval:\n * While WebGL allows extraction of program information directly from its compiled state,\n * WebGPU does not offer such a capability. Therefore, in the context of WebGPU, we're required\n * to manually extract the program layout information from the source code itself.\n * @memberof rendering\n */\nexport class GpuProgram\n{\n    /** The fragment glsl shader source. */\n    public readonly fragment?: ProgramSource;\n    /** The vertex glsl shader source */\n    public readonly vertex?: ProgramSource;\n\n    /**\n     * Mapping of uniform names to group indexes for organizing shader program uniforms.\n     * Automatically generated from shader sources if not provided.\n     * @example\n     * // Assuming a shader with two uniforms, `u_time` and `u_resolution`, grouped respectively:\n     * [\n     *   { \"u_time\": 0 },\n     *   { \"u_resolution\": 1 }\n     * ]\n     */\n    public readonly layout: ProgramLayout;\n\n    /**\n     * Configuration for the WebGPU bind group layouts, detailing resource organization for the shader.\n     * Generated from shader sources if not explicitly provided.\n     * @example\n     * // Assuming a shader program that requires two bind groups:\n     * [\n     *   // First bind group layout entries\n     *   [{ binding: 0, visibility: GPUShaderStage.VERTEX, type: \"uniform-buffer\" }],\n     *   // Second bind group layout entries\n     *   [{ binding: 1, visibility: GPUShaderStage.FRAGMENT, type: \"sampler\" },\n     *    { binding: 2, visibility: GPUShaderStage.FRAGMENT, type: \"sampled-texture\" }]\n     * ]\n     */\n    public readonly gpuLayout: ProgramPipelineLayoutDescription;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _layoutKey = 0;\n\n    /** the structs and groups extracted from the shader sources */\n    public readonly structsAndGroups: StructsAndGroups;\n    /**\n     * the name of the program, this is added to the label of the GPU Program created under the hood.\n     * Makes it much easier to debug!\n     */\n    public readonly name: string;\n    private _attributeData: Record<string, ExtractedAttributeData>;\n\n    /** if true, the program will automatically assign global uniforms to group[0] */\n    public autoAssignGlobalUniforms: boolean;\n    /** if true, the program will automatically assign local uniforms to group[1] */\n    public autoAssignLocalUniforms: boolean;\n\n    /**\n     * Create a new GpuProgram\n     * @param options - The options for the gpu program\n     */\n    constructor(options: GpuProgramOptions)\n    {\n        const { fragment, vertex, layout, gpuLayout, name } = options;\n\n        this.name = name;\n\n        this.fragment = fragment;\n        this.vertex = vertex;\n\n        // TODO this should be cached - or dealt with at a system level.\n        if (fragment.source === vertex.source)\n        {\n            const structsAndGroups = extractStructAndGroups(fragment.source);\n\n            this.structsAndGroups = structsAndGroups;\n        }\n        else\n        {\n            const vertexStructsAndGroups = extractStructAndGroups(vertex.source);\n            const fragmentStructsAndGroups = extractStructAndGroups(fragment.source);\n\n            this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);\n        }\n\n        // todo layout\n        this.layout = layout ?? generateLayoutHash(this.structsAndGroups);\n\n        // struct properties!\n\n        this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);\n\n        this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== undefined);\n        this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== undefined);\n\n        this._generateProgramKey();\n    }\n\n    // TODO maker this pure\n    private _generateProgramKey()\n    {\n        const { vertex, fragment } = this;\n\n        const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;\n\n        this._layoutKey = createIdFromString(bigKey, 'program');\n    }\n\n    get attributeData()\n    {\n        this._attributeData ??= extractAttributesFromGpuProgram(this.vertex);\n\n        return this._attributeData;\n    }\n    /** destroys the program */\n    public destroy(): void\n    {\n        (this.gpuLayout as null) = null;\n        (this.layout as null) = null;\n        (this.structsAndGroups as null) = null;\n        (this.fragment as null) = null;\n        (this.vertex as null) = null;\n    }\n\n    /**\n     * Helper function that creates a program for a given source.\n     * It will check the program cache if the program has already been created.\n     * If it has that one will be returned, if not a new one will be created and cached.\n     * @param options - The options for the program.\n     * @returns A program using the same source\n     */\n    public static from(options: GpuProgramOptions): GpuProgram\n    {\n        // eslint-disable-next-line max-len\n        const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;\n\n        if (!programCache[key])\n        {\n            programCache[key] = new GpuProgram(options);\n        }\n\n        return programCache[key];\n    }\n}\n\n","import { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat.mjs';\n\n\"use strict\";\nconst WGSL_TO_VERTEX_TYPES = {\n  f32: \"float32\",\n  \"vec2<f32>\": \"float32x2\",\n  \"vec3<f32>\": \"float32x3\",\n  \"vec4<f32>\": \"float32x4\",\n  vec2f: \"float32x2\",\n  vec3f: \"float32x3\",\n  vec4f: \"float32x4\",\n  i32: \"sint32\",\n  \"vec2<i32>\": \"sint32x2\",\n  \"vec3<i32>\": \"sint32x3\",\n  \"vec4<i32>\": \"sint32x4\",\n  u32: \"uint32\",\n  \"vec2<u32>\": \"uint32x2\",\n  \"vec3<u32>\": \"uint32x3\",\n  \"vec4<u32>\": \"uint32x4\",\n  bool: \"uint32\",\n  \"vec2<bool>\": \"uint32x2\",\n  \"vec3<bool>\": \"uint32x3\",\n  \"vec4<bool>\": \"uint32x4\"\n};\nfunction extractAttributesFromGpuProgram({ source, entryPoint }) {\n  const results = {};\n  const mainVertStart = source.indexOf(`fn ${entryPoint}`);\n  if (mainVertStart !== -1) {\n    const arrowFunctionStart = source.indexOf(\"->\", mainVertStart);\n    if (arrowFunctionStart !== -1) {\n      const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);\n      const inputsRegex = /@location\\((\\d+)\\)\\s+([a-zA-Z0-9_]+)\\s*:\\s*([a-zA-Z0-9_<>]+)(?:,|\\s|$)/g;\n      let match;\n      while ((match = inputsRegex.exec(functionArgsSubstring)) !== null) {\n        const format = WGSL_TO_VERTEX_TYPES[match[3]] ?? \"float32\";\n        results[match[2]] = {\n          location: parseInt(match[1], 10),\n          format,\n          stride: getAttributeInfoFromFormat(format).stride,\n          offset: 0,\n          instance: false,\n          start: 0\n        };\n      }\n    }\n  }\n  return results;\n}\n\nexport { extractAttributesFromGpuProgram };\n//# sourceMappingURL=extractAttributesFromGpuProgram.mjs.map\n","import { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { ExtractedAttributeData } from '../../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { VertexFormat } from '../../../shared/geometry/const';\nimport type { ProgramSource } from '../GpuProgram';\n\nconst WGSL_TO_VERTEX_TYPES: Record<string, VertexFormat> = {\n\n    f32:  'float32',\n    'vec2<f32>': 'float32x2',\n    'vec3<f32>': 'float32x3',\n    'vec4<f32>': 'float32x4',\n    vec2f: 'float32x2',\n    vec3f: 'float32x3',\n    vec4f: 'float32x4',\n\n    i32: 'sint32',\n    'vec2<i32>': 'sint32x2',\n    'vec3<i32>': 'sint32x3',\n    'vec4<i32>': 'sint32x4',\n\n    u32: 'uint32',\n    'vec2<u32>': 'uint32x2',\n    'vec3<u32>': 'uint32x3',\n    'vec4<u32>': 'uint32x4',\n\n    bool: 'uint32',\n    'vec2<bool>': 'uint32x2',\n    'vec3<bool>': 'uint32x3',\n    'vec4<bool>': 'uint32x4',\n};\n\nexport function extractAttributesFromGpuProgram(\n    { source, entryPoint }: ProgramSource\n): Record<string, ExtractedAttributeData>\n{\n    const results: Record<string, ExtractedAttributeData> = {};\n\n    // Step 1: Find the start of the mainVert function using string methods\n    const mainVertStart = source.indexOf(`fn ${entryPoint}`);\n\n    if (mainVertStart !== -1)\n    {\n        // Step 2: Find the index of the next '->' after the start of the mainVert function\n        const arrowFunctionStart = source.indexOf('->', mainVertStart);\n\n        if (arrowFunctionStart !== -1)\n        {\n            const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);\n\n            // Apply the inputs regex directly to the trimmed string\n            const inputsRegex = /@location\\((\\d+)\\)\\s+([a-zA-Z0-9_]+)\\s*:\\s*([a-zA-Z0-9_<>]+)(?:,|\\s|$)/g;\n            let match;\n\n            while ((match = inputsRegex.exec(functionArgsSubstring)) !== null)\n            {\n                const format = WGSL_TO_VERTEX_TYPES[match[3] as VertexFormat] ?? 'float32';\n\n                results[match[2]] = {\n                    location: parseInt(match[1], 10),\n                    format,\n                    stride: getAttributeInfoFromFormat(format).stride,\n                    offset: 0,\n                    instance: false,\n                    start: 0,\n                };\n            }\n        }\n    }\n\n    return results;\n}\n","\"use strict\";\nconst attributeFormatData = {\n  uint8x2: { size: 2, stride: 2, normalised: false },\n  uint8x4: { size: 4, stride: 4, normalised: false },\n  sint8x2: { size: 2, stride: 2, normalised: false },\n  sint8x4: { size: 4, stride: 4, normalised: false },\n  unorm8x2: { size: 2, stride: 2, normalised: true },\n  unorm8x4: { size: 4, stride: 4, normalised: true },\n  snorm8x2: { size: 2, stride: 2, normalised: true },\n  snorm8x4: { size: 4, stride: 4, normalised: true },\n  uint16x2: { size: 2, stride: 4, normalised: false },\n  uint16x4: { size: 4, stride: 8, normalised: false },\n  sint16x2: { size: 2, stride: 4, normalised: false },\n  sint16x4: { size: 4, stride: 8, normalised: false },\n  unorm16x2: { size: 2, stride: 4, normalised: true },\n  unorm16x4: { size: 4, stride: 8, normalised: true },\n  snorm16x2: { size: 2, stride: 4, normalised: true },\n  snorm16x4: { size: 4, stride: 8, normalised: true },\n  float16x2: { size: 2, stride: 4, normalised: false },\n  float16x4: { size: 4, stride: 8, normalised: false },\n  float32: { size: 1, stride: 4, normalised: false },\n  float32x2: { size: 2, stride: 8, normalised: false },\n  float32x3: { size: 3, stride: 12, normalised: false },\n  float32x4: { size: 4, stride: 16, normalised: false },\n  uint32: { size: 1, stride: 4, normalised: false },\n  uint32x2: { size: 2, stride: 8, normalised: false },\n  uint32x3: { size: 3, stride: 12, normalised: false },\n  uint32x4: { size: 4, stride: 16, normalised: false },\n  sint32: { size: 1, stride: 4, normalised: false },\n  sint32x2: { size: 2, stride: 8, normalised: false },\n  sint32x3: { size: 3, stride: 12, normalised: false },\n  sint32x4: { size: 4, stride: 16, normalised: false }\n};\nfunction getAttributeInfoFromFormat(format) {\n  return attributeFormatData[format] ?? attributeFormatData.float32;\n}\n\nexport { getAttributeInfoFromFormat };\n//# sourceMappingURL=getAttributeInfoFromFormat.mjs.map\n","import type { VertexFormat } from '../const';\n\nconst attributeFormatData = {\n    uint8x2: { size: 2, stride: 2, normalised: false },\n    uint8x4: { size: 4, stride: 4, normalised: false },\n    sint8x2: { size: 2, stride: 2, normalised: false },\n    sint8x4: { size: 4, stride: 4, normalised: false },\n    unorm8x2: { size: 2, stride: 2, normalised: true },\n    unorm8x4: { size: 4, stride: 4, normalised: true },\n    snorm8x2: { size: 2, stride: 2, normalised: true },\n    snorm8x4: { size: 4, stride: 4, normalised: true },\n    uint16x2: { size: 2, stride: 4, normalised: false },\n    uint16x4: { size: 4, stride: 8, normalised: false },\n    sint16x2: { size: 2, stride: 4, normalised: false },\n    sint16x4: { size: 4, stride: 8, normalised: false },\n    unorm16x2: { size: 2, stride: 4, normalised: true },\n    unorm16x4: { size: 4, stride: 8, normalised: true },\n    snorm16x2: { size: 2, stride: 4, normalised: true },\n    snorm16x4: { size: 4, stride: 8, normalised: true },\n    float16x2: { size: 2, stride: 4, normalised: false },\n    float16x4: { size: 4, stride: 8, normalised: false },\n    float32: { size: 1, stride: 4, normalised: false },\n    float32x2: { size: 2, stride: 8, normalised: false },\n    float32x3: { size: 3, stride: 12, normalised: false },\n    float32x4: { size: 4, stride: 16, normalised: false },\n    uint32: { size: 1, stride: 4, normalised: false },\n    uint32x2: { size: 2, stride: 8, normalised: false },\n    uint32x3: { size: 3, stride: 12, normalised: false },\n    uint32x4: { size: 4, stride: 16, normalised: false },\n    sint32: { size: 1, stride: 4, normalised: false },\n    sint32x2: { size: 2, stride: 8, normalised: false },\n    sint32x3: { size: 3, stride: 12, normalised: false },\n    sint32x4: { size: 4, stride: 16, normalised: false },\n};\n\nexport function getAttributeInfoFromFormat(format: VertexFormat): { size: number; stride: number; normalised: boolean }\n{\n    return attributeFormatData[format] ?? attributeFormatData.float32;\n}\n","\"use strict\";\nfunction extractStructAndGroups(wgsl) {\n  const linePattern = /(^|[^/])@(group|binding)\\(\\d+\\)[^;]+;/g;\n  const groupPattern = /@group\\((\\d+)\\)/;\n  const bindingPattern = /@binding\\((\\d+)\\)/;\n  const namePattern = /var(<[^>]+>)? (\\w+)/;\n  const typePattern = /:\\s*(\\w+)/;\n  const structPattern = /struct\\s+(\\w+)\\s*{([^}]+)}/g;\n  const structMemberPattern = /(\\w+)\\s*:\\s*([\\w\\<\\>]+)/g;\n  const structName = /struct\\s+(\\w+)/;\n  const groups = wgsl.match(linePattern)?.map((item) => ({\n    group: parseInt(item.match(groupPattern)[1], 10),\n    binding: parseInt(item.match(bindingPattern)[1], 10),\n    name: item.match(namePattern)[2],\n    isUniform: item.match(namePattern)[1] === \"<uniform>\",\n    type: item.match(typePattern)[1]\n  }));\n  if (!groups) {\n    return {\n      groups: [],\n      structs: []\n    };\n  }\n  const structs = wgsl.match(structPattern)?.map((struct) => {\n    const name = struct.match(structName)[1];\n    const members = struct.match(structMemberPattern).reduce((acc, member) => {\n      const [name2, type] = member.split(\":\");\n      acc[name2.trim()] = type.trim();\n      return acc;\n    }, {});\n    if (!members) {\n      return null;\n    }\n    return { name, members };\n  }).filter(({ name }) => groups.some((group) => group.type === name)) ?? [];\n  return {\n    groups,\n    structs\n  };\n}\n\nexport { extractStructAndGroups };\n//# sourceMappingURL=extractStructAndGroups.mjs.map\n","export interface StructsAndGroups\n{\n    groups: {\n        group: number;\n        binding: number;\n        name: string;\n        isUniform: boolean;\n        type: string;\n    }[];\n    structs: {\n        name: string;\n        members: Record<string, string>;\n    }[];\n}\n\nexport function extractStructAndGroups(wgsl: string): StructsAndGroups\n{\n    // Patterns for parsing the WGSL file\n    const linePattern = /(^|[^/])@(group|binding)\\(\\d+\\)[^;]+;/g;\n    const groupPattern = /@group\\((\\d+)\\)/;\n    const bindingPattern = /@binding\\((\\d+)\\)/;\n    const namePattern = /var(<[^>]+>)? (\\w+)/;\n    const typePattern = /:\\s*(\\w+)/;\n    const structPattern = /struct\\s+(\\w+)\\s*{([^}]+)}/g;\n    const structMemberPattern = /(\\w+)\\s*:\\s*([\\w\\<\\>]+)/g;\n    const structName = /struct\\s+(\\w+)/;\n\n    // Find the @group and @binding annotations\n    const groups = wgsl.match(linePattern)?.map((item) => ({\n        group: parseInt(item.match(groupPattern)[1], 10),\n        binding: parseInt(item.match(bindingPattern)[1], 10),\n        name: item.match(namePattern)[2],\n        isUniform: item.match(namePattern)[1] === '<uniform>',\n        type: item.match(typePattern)[1],\n    }));\n\n    if (!groups)\n    {\n        return {\n            groups: [],\n            structs: [],\n        };\n    }\n\n    // Find the structs\n    const structs = wgsl\n        .match(structPattern)\n        ?.map((struct) =>\n        {\n            const name = struct.match(structName)[1];\n            const members = struct.match(structMemberPattern).reduce((acc: Record<string, string>, member) =>\n            {\n                const [name, type] = member.split(':');\n\n                acc[name.trim()] = type.trim();\n\n                return acc;\n            }, {});\n\n            if (!members)\n            {\n                return null;\n            }\n\n            return { name, members };\n            // Only include the structs mentioned in the @group/@binding annotations\n        })\n        .filter(({ name }) => groups.some((group) => group.type === name)) ?? [];\n\n    return {\n        groups,\n        structs,\n    };\n}\n","import { ShaderStage } from '../../../shared/shader/const.mjs';\n\n\"use strict\";\nfunction generateGpuLayoutGroups({ groups }) {\n  const layout = [];\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    if (!layout[group.group]) {\n      layout[group.group] = [];\n    }\n    if (group.isUniform) {\n      layout[group.group].push({\n        binding: group.binding,\n        visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,\n        buffer: {\n          type: \"uniform\"\n        }\n      });\n    } else if (group.type === \"sampler\") {\n      layout[group.group].push({\n        binding: group.binding,\n        visibility: ShaderStage.FRAGMENT,\n        sampler: {\n          type: \"filtering\"\n        }\n      });\n    } else if (group.type === \"texture_2d\") {\n      layout[group.group].push({\n        binding: group.binding,\n        visibility: ShaderStage.FRAGMENT,\n        texture: {\n          sampleType: \"float\",\n          viewDimension: \"2d\",\n          multisampled: false\n        }\n      });\n    }\n  }\n  return layout;\n}\n\nexport { generateGpuLayoutGroups };\n//# sourceMappingURL=generateGpuLayoutGroups.mjs.map\n","import { ShaderStage } from '../../../shared/shader/const';\n\nimport type { ProgramPipelineLayoutDescription } from '../GpuProgram';\nimport type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function generateGpuLayoutGroups({ groups }: StructsAndGroups): ProgramPipelineLayoutDescription\n{\n    const layout: ProgramPipelineLayoutDescription = [];\n\n    for (let i = 0; i < groups.length; i++)\n    {\n        const group = groups[i];\n\n        if (!layout[group.group])\n        {\n            layout[group.group] = [];\n        }\n\n        if (group.isUniform)\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,\n                buffer: {\n                    type: 'uniform'\n                }\n            });\n        }\n        else if (group.type === 'sampler')\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.FRAGMENT,\n                sampler: {\n                    type: 'filtering'\n                }\n            });\n        }\n        else if (group.type === 'texture_2d')\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.FRAGMENT,\n                texture: {\n                    sampleType: 'float',\n                    viewDimension: '2d',\n                    multisampled: false,\n                }\n            });\n        }\n    }\n\n    return layout;\n}\n","\"use strict\";\nvar ShaderStage = /* @__PURE__ */ ((ShaderStage2) => {\n  ShaderStage2[ShaderStage2[\"VERTEX\"] = 1] = \"VERTEX\";\n  ShaderStage2[ShaderStage2[\"FRAGMENT\"] = 2] = \"FRAGMENT\";\n  ShaderStage2[ShaderStage2[\"COMPUTE\"] = 4] = \"COMPUTE\";\n  return ShaderStage2;\n})(ShaderStage || {});\n\nexport { ShaderStage };\n//# sourceMappingURL=const.mjs.map\n","export enum ShaderStage\n    {\n    VERTEX = 1,\n    FRAGMENT = 2,\n    COMPUTE = 4\n}\n","\"use strict\";\nfunction generateLayoutHash({ groups }) {\n  const layout = [];\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    if (!layout[group.group]) {\n      layout[group.group] = {};\n    }\n    layout[group.group][group.name] = group.binding;\n  }\n  return layout;\n}\n\nexport { generateLayoutHash };\n//# sourceMappingURL=generateLayoutHash.mjs.map\n","import type { ProgramLayout } from '../GpuProgram';\nimport type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function generateLayoutHash({ groups }: StructsAndGroups): ProgramLayout\n{\n    const layout: ProgramLayout = [];\n\n    for (let i = 0; i < groups.length; i++)\n    {\n        const group = groups[i];\n\n        if (!layout[group.group])\n        {\n            layout[group.group] = {};\n        }\n\n        layout[group.group][group.name] = group.binding;\n    }\n\n    return layout;\n}\n","\"use strict\";\nfunction removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups) {\n  const structNameSet = /* @__PURE__ */ new Set();\n  const dupeGroupKeySet = /* @__PURE__ */ new Set();\n  const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs].filter((struct) => {\n    if (structNameSet.has(struct.name)) {\n      return false;\n    }\n    structNameSet.add(struct.name);\n    return true;\n  });\n  const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups].filter((group) => {\n    const key = `${group.name}-${group.binding}`;\n    if (dupeGroupKeySet.has(key)) {\n      return false;\n    }\n    dupeGroupKeySet.add(key);\n    return true;\n  });\n  return { structs, groups };\n}\n\nexport { removeStructAndGroupDuplicates };\n//# sourceMappingURL=removeStructAndGroupDuplicates.mjs.map\n","import type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function removeStructAndGroupDuplicates(\n    vertexStructsAndGroups: StructsAndGroups,\n    fragmentStructsAndGroups: StructsAndGroups\n)\n{\n    const structNameSet = new Set();\n    const dupeGroupKeySet = new Set();\n\n    const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs]\n        .filter((struct) =>\n        {\n            if (structNameSet.has(struct.name))\n            {\n                return false;\n            }\n            structNameSet.add(struct.name);\n\n            return true;\n        });\n\n    const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups]\n        .filter((group) =>\n        {\n            const key = `${group.name}-${group.binding}`;\n\n            if (dupeGroupKeySet.has(key))\n            {\n                return false;\n            }\n            dupeGroupKeySet.add(key);\n\n            return true;\n        });\n\n    return { structs, groups };\n}\n","import { addBits } from './utils/addBits.mjs';\nimport { compileHooks } from './utils/compileHooks.mjs';\nimport { compileInputs } from './utils/compileInputs.mjs';\nimport { compileOutputs } from './utils/compileOutputs.mjs';\nimport { injectBits } from './utils/injectBits.mjs';\n\n\"use strict\";\nconst cacheMap = /* @__PURE__ */ Object.create(null);\nconst bitCacheMap = /* @__PURE__ */ new Map();\nlet CACHE_UID = 0;\nfunction compileHighShader({\n  template,\n  bits\n}) {\n  const cacheId = generateCacheId(template, bits);\n  if (cacheMap[cacheId])\n    return cacheMap[cacheId];\n  const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n  cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n  return cacheMap[cacheId];\n}\nfunction compileHighShaderGl({\n  template,\n  bits\n}) {\n  const cacheId = generateCacheId(template, bits);\n  if (cacheMap[cacheId])\n    return cacheMap[cacheId];\n  cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n  return cacheMap[cacheId];\n}\nfunction compileInputsAndOutputs(template, bits) {\n  const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n  const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n  let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n  compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n  const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n  return {\n    vertex: compiledVertex,\n    fragment: compiledFragment\n  };\n}\nfunction generateCacheId(template, bits) {\n  return bits.map((highFragment) => {\n    if (!bitCacheMap.has(highFragment)) {\n      bitCacheMap.set(highFragment, CACHE_UID++);\n    }\n    return bitCacheMap.get(highFragment);\n  }).sort((a, b) => a - b).join(\"-\") + template.vertex + template.fragment;\n}\nfunction compileBits(vertex, fragment, bits) {\n  const vertexParts = compileHooks(vertex);\n  const fragmentParts = compileHooks(fragment);\n  bits.forEach((shaderBit) => {\n    addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n    addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n  });\n  return {\n    vertex: injectBits(vertex, vertexParts),\n    fragment: injectBits(fragment, fragmentParts)\n  };\n}\n\nexport { compileHighShader, compileHighShaderGl };\n//# sourceMappingURL=compileHighShader.mjs.map\n","import { addBits } from './utils/addBits';\nimport { compileHooks } from './utils/compileHooks';\nimport { compileInputs } from './utils/compileInputs';\nimport { compileOutputs } from './utils/compileOutputs';\nimport { injectBits } from './utils/injectBits';\n\nimport type { HighShaderBit, HighShaderSource } from './types';\n\n/** A high template consists of vertex and fragment source */\nexport interface HighShaderTemplate\n{\n    name?: string;\n    fragment: string;\n    vertex: string;\n}\n\nexport interface CompileHighShaderOptions\n{\n    template: HighShaderTemplate;\n    bits: HighShaderBit[];\n}\n\nconst cacheMap: {[key: string]: HighShaderSource} = Object.create(null);\nconst bitCacheMap: Map<HighShaderBit, number> = new Map();\n\nlet CACHE_UID = 0;\n\n/**\n * This function will take a HighShader template, some High fragments and then merge them in to a shader source.\n * @param options\n * @param options.template\n * @param options.bits\n */\nexport function compileHighShader({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n\n    cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nexport function compileHighShaderGl({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nfunction compileInputsAndOutputs(template: HighShaderTemplate, bits: HighShaderBit[])\n{\n    const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n    const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n\n    // WebGPU compile inputs and outputs..\n    let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n\n    compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n\n    const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n\n    return {\n        vertex: compiledVertex,\n        fragment: compiledFragment,\n    };\n}\n\nfunction generateCacheId(template: HighShaderTemplate, bits: HighShaderBit[]): string\n{\n    return bits\n        .map((highFragment) =>\n        {\n            if (!bitCacheMap.has(highFragment))\n            {\n                bitCacheMap.set(highFragment, CACHE_UID++);\n            }\n\n            return bitCacheMap.get(highFragment);\n        })\n        .sort((a, b) => a - b)\n        .join('-') + template.vertex + template.fragment;\n}\n\nfunction compileBits(vertex: string, fragment: string, bits: HighShaderBit[])\n{\n    const vertexParts = compileHooks(vertex);\n    const fragmentParts = compileHooks(fragment);\n\n    bits.forEach((shaderBit) =>\n    {\n        addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n        addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n    });\n\n    return {\n        vertex: injectBits(vertex, vertexParts),\n        fragment: injectBits(fragment, fragmentParts),\n    };\n}\n","import { warn } from '../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nfunction addBits(srcParts, parts, name) {\n  if (srcParts) {\n    for (const i in srcParts) {\n      const id = i.toLocaleLowerCase();\n      const part = parts[id];\n      if (part) {\n        let sanitisedPart = srcParts[i];\n        if (i === \"header\") {\n          sanitisedPart = sanitisedPart.replace(/@in\\s+[^;]+;\\s*/g, \"\").replace(/@out\\s+[^;]+;\\s*/g, \"\");\n        }\n        if (name) {\n          part.push(`//----${name}----//`);\n        }\n        part.push(sanitisedPart);\n      } else {\n        warn(`${i} placement hook does not exist in shader`);\n      }\n    }\n  }\n}\n\nexport { addBits };\n//# sourceMappingURL=addBits.mjs.map\n","import { warn } from '../../../../utils/logging/warn';\n\n/**\n * takes the HighFragment source parts and adds them to the hook hash\n * @param srcParts - the hash of hook arrays\n * @param parts - the code to inject into the hooks\n * @param name - optional the name of the part to add\n */\nexport function addBits(srcParts: Record<string, string>, parts: Record<string, string[]>, name?: string)\n{\n    if (srcParts)\n    {\n        for (const i in srcParts)\n        {\n            const id = i.toLocaleLowerCase();\n\n            const part = parts[id];\n\n            if (part)\n            {\n                let sanitisedPart = srcParts[i];\n\n                if (i === 'header')\n                {\n                    sanitisedPart = sanitisedPart\n                        .replace(/@in\\s+[^;]+;\\s*/g, '')\n                        .replace(/@out\\s+[^;]+;\\s*/g, '');\n                }\n\n                if (name)\n                {\n                    part.push(`//----${name}----//`);\n                }\n                part.push(sanitisedPart);\n            }\n\n            else\n            {\n                // #if _DEBUG\n                warn(`${i} placement hook does not exist in shader`);\n                // #endif\n            }\n        }\n    }\n}\n","\"use strict\";\nconst findHooksRx = /\\{\\{(.*?)\\}\\}/g;\nfunction compileHooks(programSrc) {\n  const parts = {};\n  const partMatches = programSrc.match(findHooksRx)?.map((hook) => hook.replace(/[{()}]/g, \"\")) ?? [];\n  partMatches.forEach((hook) => {\n    parts[hook] = [];\n  });\n  return parts;\n}\n\nexport { compileHooks, findHooksRx };\n//# sourceMappingURL=compileHooks.mjs.map\n","export const findHooksRx = /\\{\\{(.*?)\\}\\}/g;\n\n/**\n * takes a program string and returns an hash mapping the hooks to empty arrays\n * @param programSrc - the program containing hooks\n */\nexport function compileHooks(programSrc: string): Record<string, string[]>\n{\n    const parts: Record<string, string[]> = {};\n\n    const partMatches = programSrc\n        .match(findHooksRx)\n        ?.map((hook) => hook.replace(/[{()}]/g, '')) ?? [];\n\n    partMatches.forEach((hook) =>\n    {\n        parts[hook] = [];\n    });\n\n    return parts;\n}\n","\"use strict\";\nfunction extractInputs(fragmentSource, out) {\n  let match;\n  const regex = /@in\\s+([^;]+);/g;\n  while ((match = regex.exec(fragmentSource)) !== null) {\n    out.push(match[1]);\n  }\n}\nfunction compileInputs(fragments, template, sort = false) {\n  const results = [];\n  extractInputs(template, results);\n  fragments.forEach((fragment) => {\n    if (fragment.header) {\n      extractInputs(fragment.header, results);\n    }\n  });\n  const mainInput = results;\n  if (sort) {\n    mainInput.sort();\n  }\n  const finalString = mainInput.map((inValue, i) => `       @location(${i}) ${inValue},`).join(\"\\n\");\n  let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, \"\");\n  cleanedString = cleanedString.replace(\"{{in}}\", `\n${finalString}\n`);\n  return cleanedString;\n}\n\nexport { compileInputs };\n//# sourceMappingURL=compileInputs.mjs.map\n","function extractInputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@in\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\nexport function compileInputs(fragments: any[], template: string, sort = false)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractInputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractInputs(fragment.header, results);\n        }\n    });\n\n    // build the input:\n    const mainInput = results;\n\n    if (sort)\n    {\n        mainInput.sort();\n    }\n\n    const finalString = mainInput\n        .map((inValue, i) => `       @location(${i}) ${inValue},`)\n        .join('\\n');\n\n    // Remove lines from original string\n    let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, '');\n\n    cleanedString = cleanedString.replace('{{in}}', `\\n${finalString}\\n`);\n\n    return cleanedString;\n}\n","\"use strict\";\nfunction extractOutputs(fragmentSource, out) {\n  let match;\n  const regex = /@out\\s+([^;]+);/g;\n  while ((match = regex.exec(fragmentSource)) !== null) {\n    out.push(match[1]);\n  }\n}\nfunction extractVariableName(value) {\n  const regex = /\\b(\\w+)\\s*:/g;\n  const match = regex.exec(value);\n  return match ? match[1] : \"\";\n}\nfunction stripVariable(value) {\n  const regex = /@.*?\\s+/g;\n  return value.replace(regex, \"\");\n}\nfunction compileOutputs(fragments, template) {\n  const results = [];\n  extractOutputs(template, results);\n  fragments.forEach((fragment) => {\n    if (fragment.header) {\n      extractOutputs(fragment.header, results);\n    }\n  });\n  let index = 0;\n  const mainStruct = results.sort().map((inValue) => {\n    if (inValue.indexOf(\"builtin\") > -1) {\n      return inValue;\n    }\n    return `@location(${index++}) ${inValue}`;\n  }).join(\",\\n\");\n  const mainStart = results.sort().map((inValue) => `       var ${stripVariable(inValue)};`).join(\"\\n\");\n  const mainEnd = `return VSOutput(\n                ${results.sort().map((inValue) => ` ${extractVariableName(inValue)}`).join(\",\\n\")});`;\n  let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, \"\");\n  compiledCode = compiledCode.replace(\"{{struct}}\", `\n${mainStruct}\n`);\n  compiledCode = compiledCode.replace(\"{{start}}\", `\n${mainStart}\n`);\n  compiledCode = compiledCode.replace(\"{{return}}\", `\n${mainEnd}\n`);\n  return compiledCode;\n}\n\nexport { compileOutputs };\n//# sourceMappingURL=compileOutputs.mjs.map\n","function extractOutputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@out\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\nfunction extractVariableName(value: string)\n{\n    const regex = /\\b(\\w+)\\s*:/g;\n\n    const match = regex.exec(value);\n\n    return match ? match[1] : '';\n}\n\nfunction stripVariable(value: string)\n{\n    const regex = /@.*?\\s+/g;\n\n    return value.replace(regex, '');\n}\n\nexport function compileOutputs(fragments: any[], template: string)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractOutputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractOutputs(fragment.header, results);\n        }\n    });\n\n    let index = 0;\n\n    // generate the output struct\n    const mainStruct = results\n        .sort()\n        .map((inValue) =>\n        {\n            if (inValue.indexOf('builtin') > -1)\n            {\n                return inValue;\n            }\n\n            return `@location(${index++}) ${inValue}`;\n        })\n        .join(',\\n');\n\n    // generate the variables we will set:\n    const mainStart = results\n        .sort()\n        .map((inValue) => `       var ${stripVariable(inValue)};`)\n        .join('\\n');\n\n    // generate the return object\n    const mainEnd = `return VSOutput(\n                ${results\n        .sort()\n        .map((inValue) => ` ${extractVariableName(inValue)}`)\n        .join(',\\n')});`;\n\n    // Remove lines from original string\n    let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, '');\n\n    compiledCode = compiledCode.replace('{{struct}}', `\\n${mainStruct}\\n`);\n    compiledCode = compiledCode.replace('{{start}}', `\\n${mainStart}\\n`);\n    compiledCode = compiledCode.replace('{{return}}', `\\n${mainEnd}\\n`);\n\n    return compiledCode;\n}\n","\"use strict\";\nfunction injectBits(templateSrc, fragmentParts) {\n  let out = templateSrc;\n  for (const i in fragmentParts) {\n    const parts = fragmentParts[i];\n    const toInject = parts.join(\"\\n\");\n    if (toInject.length) {\n      out = out.replace(`{{${i}}}`, `//-----${i} START-----//\n${parts.join(\"\\n\")}\n//----${i} FINISH----//`);\n    } else {\n      out = out.replace(`{{${i}}}`, \"\");\n    }\n  }\n  return out;\n}\n\nexport { injectBits };\n//# sourceMappingURL=injectBits.mjs.map\n","/**\n * takes a shader src and replaces any hooks with the HighFragment code.\n * @param templateSrc - the program src template\n * @param fragmentParts - the fragments to inject\n */\nexport function injectBits(templateSrc: string, fragmentParts: Record<string, string[]>): string\n{\n    let out = templateSrc;\n\n    for (const i in fragmentParts)\n    {\n        const parts = fragmentParts[i];\n\n        const toInject = parts.join('\\n');\n\n        if (toInject.length)\n        {\n            out = out.replace(`{{${i}}}`, `//-----${i} START-----//\\n${parts.join('\\n')}\\n//----${i} FINISH----//`);\n        }\n\n        else\n        {\n            out = out.replace(`{{${i}}}`, '');\n        }\n    }\n\n    return out;\n}\n","\"use strict\";\nconst vertexGPUTemplate = (\n  /* wgsl */\n  `\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`\n);\nconst fragmentGPUTemplate = (\n  /* wgsl */\n  `\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        return outColor * vColor;\n      };\n`\n);\nconst vertexGlTemplate = (\n  /* glsl */\n  `\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`\n);\nconst fragmentGlTemplate = (\n  /* glsl */\n  `\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n    }\n`\n);\n\nexport { fragmentGPUTemplate, fragmentGlTemplate, vertexGPUTemplate, vertexGlTemplate };\n//# sourceMappingURL=defaultProgramTemplate.mjs.map\n","const vertexGPUTemplate = /* wgsl */`\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`;\n\nconst fragmentGPUTemplate = /* wgsl */`\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        return outColor * vColor;\n      };\n`;\n\nconst vertexGlTemplate = /* glsl */`\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`;\n\nconst fragmentGlTemplate = /* glsl */`\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n    }\n`;\n\nexport {\n    fragmentGlTemplate,\n    fragmentGPUTemplate,\n    vertexGlTemplate,\n    vertexGPUTemplate\n};\n","\"use strict\";\nconst globalUniformsBit = {\n  name: \"global-uniforms-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    )\n  }\n};\nconst globalUniformsUBOBitGl = {\n  name: \"global-uniforms-ubo-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    )\n  }\n};\nconst globalUniformsBitGl = {\n  name: \"global-uniforms-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    )\n  }\n};\n\nexport { globalUniformsBit, globalUniformsBitGl, globalUniformsUBOBitGl };\n//# sourceMappingURL=globalUniformsBit.mjs.map\n","export const globalUniformsBit = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* wgsl */`\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    }\n};\n\nexport const globalUniformsUBOBitGl = {\n    name: 'global-uniforms-ubo-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    }\n};\n\nexport const globalUniformsBitGl = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    }\n\n};\n","\"use strict\";\nconst colorBit = {\n  name: \"color-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            @in aColor: vec4<f32>;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    )\n  }\n};\nconst colorBitGl = {\n  name: \"color-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            in vec4 aColor;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    )\n  }\n};\n\nexport { colorBit, colorBitGl };\n//# sourceMappingURL=colorBit.mjs.map\n","export const colorBit = {\n    name: 'color-bit',\n    vertex: {\n        header: /* wgsl */`\n            @in aColor: vec4<f32>;\n        `,\n        main: /* wgsl */`\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n\nexport const colorBitGl = {\n    name: 'color-bit',\n    vertex: {\n        header: /* glsl */`\n            in vec4 aColor;\n        `,\n        main: /* glsl */`\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n","\"use strict\";\nconst textureBatchBitGpuCache = {};\nfunction generateBindingSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"@group(1) @binding(0) var textureSource1: texture_2d<f32>;\");\n    src.push(\"@group(1) @binding(1) var textureSampler1: sampler;\");\n  } else {\n    let bindingIndex = 0;\n    for (let i = 0; i < maxTextures; i++) {\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n    }\n  }\n  return src.join(\"\\n\");\n}\nfunction generateSampleSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);\");\n  } else {\n    src.push(\"switch vTextureId {\");\n    for (let i = 0; i < maxTextures; i++) {\n      if (i === maxTextures - 1) {\n        src.push(`  default:{`);\n      } else {\n        src.push(`  case ${i}:{`);\n      }\n      src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n      src.push(`      break;}`);\n    }\n    src.push(`}`);\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBit(maxTextures) {\n  if (!textureBatchBitGpuCache[maxTextures]) {\n    textureBatchBitGpuCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                @in @interpolate(flat) vTextureId: u32;\n    \n                ${generateBindingSrc(16)}\n            `,\n        main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n    \n                ${generateSampleSrc(16)}\n            `\n      }\n    };\n  }\n  return textureBatchBitGpuCache[maxTextures];\n}\nconst textureBatchBitGlCache = {};\nfunction generateSampleGlSrc(maxTextures) {\n  const src = [];\n  for (let i = 0; i < maxTextures; i++) {\n    if (i > 0) {\n      src.push(\"else\");\n    }\n    if (i < maxTextures - 1) {\n      src.push(`if(vTextureId < ${i}.5)`);\n    }\n    src.push(\"{\");\n    src.push(`\toutColor = texture(uTextures[${i}], vUV);`);\n    src.push(\"}\");\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBitGl(maxTextures) {\n  if (!textureBatchBitGlCache[maxTextures]) {\n    textureBatchBitGlCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n              \n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                in float vTextureId;\n    \n                uniform sampler2D uTextures[${maxTextures}];\n              \n            `,\n        main: `\n    \n                ${generateSampleGlSrc(16)}\n            `\n      }\n    };\n  }\n  return textureBatchBitGlCache[maxTextures];\n}\n\nexport { generateTextureBatchBit, generateTextureBatchBitGl };\n//# sourceMappingURL=generateTextureBatchBit.mjs.map\n","import type { HighShaderBit } from '../compiler/types';\n\nconst textureBatchBitGpuCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateBindingSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('@group(1) @binding(0) var textureSource1: texture_2d<f32>;');\n        src.push('@group(1) @binding(1) var textureSampler1: sampler;');\n    }\n    else\n    {\n        let bindingIndex = 0;\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n        }\n    }\n\n    return src.join('\\n');\n}\n\nfunction generateSampleSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);');\n    }\n    else\n    {\n        src.push('switch vTextureId {');\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            if (i === maxTextures - 1)\n            {\n                src.push(`  default:{`);\n            }\n            else\n            {\n                src.push(`  case ${i}:{`);\n            }\n            src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n            src.push(`      break;}`);\n        }\n\n        src.push(`}`);\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBit(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGpuCache[maxTextures])\n    {\n        textureBatchBitGpuCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                @in @interpolate(flat) vTextureId: u32;\n    \n                ${generateBindingSrc(16)}\n            `,\n                main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n    \n                ${generateSampleSrc(16)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGpuCache[maxTextures];\n}\n\nconst textureBatchBitGlCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateSampleGlSrc(maxTextures: number): string\n{\n    const src = [];\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        if (i > 0)\n        {\n            src.push('else');\n        }\n\n        if (i < maxTextures - 1)\n        {\n            src.push(`if(vTextureId < ${i}.5)`);\n        }\n\n        src.push('{');\n        src.push(`\\toutColor = texture(uTextures[${i}], vUV);`);\n        src.push('}');\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBitGl(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGlCache[maxTextures])\n    {\n        textureBatchBitGlCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n              \n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                in float vTextureId;\n    \n                uniform sampler2D uTextures[${maxTextures}];\n              \n            `,\n                main: `\n    \n                ${generateSampleGlSrc(16)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGlCache[maxTextures];\n}\n","\"use strict\";\nconst roundPixelsBit = {\n  name: \"round-pixels-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor((position * 0.5 + 0.5) * targetSize) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    )\n  }\n};\nconst roundPixelsBitGl = {\n  name: \"round-pixels-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor((position * 0.5 + 0.5) * targetSize) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    )\n  }\n};\n\nexport { roundPixelsBit, roundPixelsBitGl };\n//# sourceMappingURL=roundPixelsBit.mjs.map\n","export const roundPixelsBit = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* wgsl */`\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor((position * 0.5 + 0.5) * targetSize) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\nexport const roundPixelsBitGl = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* glsl */`   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor((position * 0.5 + 0.5) * targetSize) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\n","import EventEmitter from 'eventemitter3';\nimport { GlProgram } from '../../gl/shader/GlProgram.mjs';\nimport { BindGroup } from '../../gpu/shader/BindGroup.mjs';\nimport { GpuProgram } from '../../gpu/shader/GpuProgram.mjs';\nimport { RendererType } from '../../types.mjs';\nimport { UniformGroup } from './UniformGroup.mjs';\n\n\"use strict\";\nclass Shader extends EventEmitter {\n  constructor(options) {\n    super();\n    /**\n     * A record of the uniform groups and resources used by the shader.\n     * This is used by WebGL renderer to sync uniform data.\n     * @internal\n     * @ignore\n     */\n    this._uniformBindMap = /* @__PURE__ */ Object.create(null);\n    this._ownedBindGroups = [];\n    let {\n      gpuProgram,\n      glProgram,\n      groups,\n      resources,\n      compatibleRenderers,\n      groupMap\n    } = options;\n    this.gpuProgram = gpuProgram;\n    this.glProgram = glProgram;\n    if (compatibleRenderers === void 0) {\n      compatibleRenderers = 0;\n      if (gpuProgram)\n        compatibleRenderers |= RendererType.WEBGPU;\n      if (glProgram)\n        compatibleRenderers |= RendererType.WEBGL;\n    }\n    this.compatibleRenderers = compatibleRenderers;\n    const nameHash = {};\n    if (!resources && !groups) {\n      resources = {};\n    }\n    if (resources && groups) {\n      throw new Error(\"[Shader] Cannot have both resources and groups\");\n    } else if (!gpuProgram && groups && !groupMap) {\n      throw new Error(\"[Shader] No group map or WebGPU shader provided - consider using resources instead.\");\n    } else if (!gpuProgram && groups && groupMap) {\n      for (const i in groupMap) {\n        for (const j in groupMap[i]) {\n          const uniformName = groupMap[i][j];\n          nameHash[uniformName] = {\n            group: i,\n            binding: j,\n            name: uniformName\n          };\n        }\n      }\n    } else if (gpuProgram && groups && !groupMap) {\n      const groupData = gpuProgram.structsAndGroups.groups;\n      groupMap = {};\n      groupData.forEach((data) => {\n        groupMap[data.group] = groupMap[data.group] || {};\n        groupMap[data.group][data.binding] = data.name;\n        nameHash[data.name] = data;\n      });\n    } else if (resources) {\n      if (!gpuProgram) {\n        groupMap = {};\n        groups = {\n          99: new BindGroup()\n        };\n        this._ownedBindGroups.push(groups[99]);\n        let bindTick = 0;\n        for (const i in resources) {\n          nameHash[i] = { group: 99, binding: bindTick, name: i };\n          groupMap[99] = groupMap[99] || {};\n          groupMap[99][bindTick] = i;\n          bindTick++;\n        }\n      } else {\n        const groupData = gpuProgram.structsAndGroups.groups;\n        groupMap = {};\n        groupData.forEach((data) => {\n          groupMap[data.group] = groupMap[data.group] || {};\n          groupMap[data.group][data.binding] = data.name;\n          nameHash[data.name] = data;\n        });\n      }\n      groups = {};\n      for (const i in resources) {\n        const name = i;\n        let value = resources[i];\n        if (!value.source && !value._resourceType) {\n          value = new UniformGroup(value);\n        }\n        const data = nameHash[name];\n        if (data) {\n          if (!groups[data.group]) {\n            groups[data.group] = new BindGroup();\n            this._ownedBindGroups.push(groups[data.group]);\n          }\n          groups[data.group].setResource(value, data.binding);\n        }\n      }\n    }\n    this.groups = groups;\n    this._uniformBindMap = groupMap;\n    this.resources = this._buildResourceAccessor(groups, nameHash);\n  }\n  /**\n   * Sometimes a resource group will be provided later (for example global uniforms)\n   * In such cases, this method can be used to let the shader know about the group.\n   * @param name - the name of the resource group\n   * @param groupIndex - the index of the group (should match the webGPU shader group location)\n   * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)\n   */\n  addResource(name, groupIndex, bindIndex) {\n    var _a, _b;\n    (_a = this._uniformBindMap)[groupIndex] || (_a[groupIndex] = {});\n    (_b = this._uniformBindMap[groupIndex])[bindIndex] || (_b[bindIndex] = name);\n    if (!this.groups[groupIndex]) {\n      this.groups[groupIndex] = new BindGroup();\n      this._ownedBindGroups.push(this.groups[groupIndex]);\n    }\n  }\n  _buildResourceAccessor(groups, nameHash) {\n    const uniformsOut = {};\n    for (const i in nameHash) {\n      const data = nameHash[i];\n      Object.defineProperty(uniformsOut, data.name, {\n        get() {\n          return groups[data.group].getResource(data.binding);\n        },\n        set(value) {\n          groups[data.group].setResource(value, data.binding);\n        }\n      });\n    }\n    return uniformsOut;\n  }\n  /**\n   * Use to destroy the shader when its not longer needed.\n   * It will destroy the resources and remove listeners.\n   * @param destroyPrograms - if the programs should be destroyed as well.\n   * Make sure its not being used by other shaders!\n   */\n  destroy(destroyPrograms = false) {\n    this.emit(\"destroy\", this);\n    if (destroyPrograms) {\n      this.gpuProgram?.destroy();\n      this.glProgram?.destroy();\n    }\n    this.gpuProgram = null;\n    this.glProgram = null;\n    this.removeAllListeners();\n    this._uniformBindMap = null;\n    this._ownedBindGroups.forEach((bindGroup) => {\n      bindGroup.destroy();\n    });\n    this._ownedBindGroups = null;\n    this.resources = null;\n    this.groups = null;\n  }\n  static from(options) {\n    const { gpu, gl, ...rest } = options;\n    let gpuProgram;\n    let glProgram;\n    if (gpu) {\n      gpuProgram = GpuProgram.from(gpu);\n    }\n    if (gl) {\n      glProgram = GlProgram.from(gl);\n    }\n    return new Shader({\n      gpuProgram,\n      glProgram,\n      ...rest\n    });\n  }\n}\n\nexport { Shader };\n//# sourceMappingURL=Shader.mjs.map\n","/* eslint-disable no-new */\nimport EventEmitter from 'eventemitter3';\nimport { GlProgram } from '../../gl/shader/GlProgram';\nimport { BindGroup } from '../../gpu/shader/BindGroup';\nimport { GpuProgram } from '../../gpu/shader/GpuProgram';\nimport { RendererType } from '../../types';\nimport { UniformGroup } from './UniformGroup';\n\nimport type { GlProgramOptions } from '../../gl/shader/GlProgram';\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { GpuProgramOptions } from '../../gpu/shader/GpuProgram';\n\n/**\n * A record of {@link BindGroup}'s used by the shader.\n *\n * `Record<number, BindGroup>`\n * @memberof rendering\n */\nexport type ShaderGroups = Record<number, BindGroup>;\n\ninterface ShaderBase\n{\n    /** The WebGL program used by the WebGL renderer. */\n    glProgram?: GlProgram\n    /** The WebGPU program used by the WebGPU renderer. */\n    gpuProgram?: GpuProgram\n    /**\n     * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n     * 0b00 - not compatible with either\n     * 0b01 - compatible with WebGL\n     * 0b10 - compatible with WebGPU\n     * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n     */\n    compatibleRenderers?: number\n}\n\ninterface GlShaderWith extends ShaderBase\n{\n    /** The WebGL program used by the WebGL renderer. */\n    glProgram: GlProgram\n}\n\ninterface GpuShaderWith extends ShaderBase\n{\n    /** The WebGPU program used by the WebGPU renderer. */\n    gpuProgram: GpuProgram\n}\n\ninterface ShaderWithGroupsDescriptor\n{\n    /** A record of {@link BindGroup}'s used by the shader. */\n    groups: ShaderGroups;\n    /** an optional map of how to bind the groups. This is automatically generated by reading the WebGPU program */\n    groupMap?: Record<string, Record<string, any>>;\n}\n\ninterface ShaderWithResourcesDescriptor\n{\n    /**\n     * A key value of uniform resources used by the shader.\n     * Under the hood pixi will look at the provided shaders and figure out where\n     * the resources are mapped. Its up to you to make sure the resource key\n     * matches the uniform name in the webGPU program. WebGL is a little more forgiving!\n     */\n    resources?: Record<string, any>;\n}\n\ninterface GroupsData\n{\n    group: number\n    binding: number\n    name: string\n}\n\n/**\n * A descriptor for a shader\n * @memberof rendering\n */\nexport type ShaderWith = GlShaderWith | GpuShaderWith;\n\n/**\n * A descriptor for a shader with groups.\n * @memberof rendering\n */\nexport type ShaderWithGroups = ShaderWithGroupsDescriptor & ShaderWith;\nexport interface IShaderWithGroups extends ShaderWithGroupsDescriptor, ShaderBase {}\n\n/**\n * A descriptor for a shader with resources. This is an easier way to work with uniforms.\n * especially when you are not working with bind groups\n * @memberof rendering\n */\nexport type ShaderWithResources = ShaderWithResourcesDescriptor & ShaderWith;\nexport interface IShaderWithResources extends ShaderWithResourcesDescriptor, ShaderBase {}\n\nexport type ShaderDescriptor = ShaderWithGroups & ShaderWithResources;\n\ntype GlShaderFromWith = {\n    gpu?: GpuProgramOptions,\n    gl: GlProgramOptions\n};\ntype GpuShaderFromWith = {\n    gpu: GpuProgramOptions,\n    gl?: GlProgramOptions\n};\nexport type ShaderFromGroups = (GlShaderFromWith | GpuShaderFromWith) & Omit<ShaderWithGroups, 'glProgram' | 'gpuProgram'>;\nexport type ShaderFromResources = (GlShaderFromWith | GpuShaderFromWith)\n& Omit<ShaderWithResources, 'glProgram' | 'gpuProgram'>;\n\n/**\n * The Shader class is an integral part of the PixiJS graphics pipeline.\n * Central to rendering in PixiJS are two key elements: A [shader] and a [geometry].\n * The shader incorporates a {@link GlProgram} for WebGL or a {@link GpuProgram} for WebGPU,\n * instructing the respective technology on how to render the geometry.\n *\n * The primary goal of the Shader class is to offer a unified interface compatible with both WebGL and WebGPU.\n * When constructing a shader, you need to provide both a WebGL program and a WebGPU program due to the distinctions\n * between the two rendering engines. If only one is provided, the shader won't function with the omitted renderer.\n *\n * Both WebGL and WebGPU utilize the same resource object when passed into the shader.\n * Post-creation, the shader's interface remains consistent across both WebGL and WebGPU.\n * The sole distinction lies in whether a glProgram or a gpuProgram is employed.\n *\n * Modifying shader uniforms, which can encompass:\n *  - TextureSampler {@link TextureStyle}\n *  - TextureSource {@link TextureSource}\n *  - UniformsGroups {@link UniformGroup}\n * @example\n *\n * const shader = new Shader({\n *     glProgram: glProgram,\n *     gpuProgram: gpuProgram,\n *     resources: {\n *         uTexture: texture.source,\n *         uSampler: texture.sampler,\n *         uColor: [1, 0, 0, 1],\n *     },\n * });\n *\n * // update the uniforms\n * shader.resources.uColor[1] = 1;\n * shader.resources.uTexture = texture2.source;\n * @class\n * @memberof rendering\n */\nexport class Shader extends EventEmitter<{'destroy': Shader}>\n{\n    /** An instance of the GPU program used by the WebGPU renderer */\n    public gpuProgram: GpuProgram;\n    /** An instance of the GL program used by the WebGL renderer */\n    public glProgram: GlProgram;\n    /**\n     * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n     * 0b00 - not compatible with either\n     * 0b01 - compatible with WebGL\n     * 0b10 - compatible with WebGPU\n     * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n     */\n    public readonly compatibleRenderers: number;\n    /** */\n    public groups: Record<number, BindGroup>;\n    /** A record of the resources used by the shader. */\n    public resources: Record<string, any>;\n    /**\n     * A record of the uniform groups and resources used by the shader.\n     * This is used by WebGL renderer to sync uniform data.\n     * @internal\n     * @ignore\n     */\n    public _uniformBindMap: Record<number, Record<number, string>> = Object.create(null);\n    private readonly _ownedBindGroups: BindGroup[] = [];\n\n    /**\n     * Fired after rendering finishes.\n     * @event rendering.Shader#destroy\n     */\n\n    /**\n     * There are two ways to create a shader.\n     * one is to pass in resources which is a record of uniform groups and resources.\n     * another is to pass in groups which is a record of {@link BindGroup}s.\n     * this second method is really to make use of shared {@link BindGroup}s.\n     * For most cases you will want to use resources as they are easier to work with.\n     * USe Groups if you want to share {@link BindGroup}s between shaders.\n     * you cannot mix and match - either use resources or groups.\n     * @param {ShaderWithResourcesDescriptor} options - The options for the shader using ShaderWithResourcesDescriptor.\n     */\n    constructor(options: ShaderWithResources);\n    constructor(options: ShaderWithGroups);\n    constructor(options: ShaderDescriptor)\n    {\n        super();\n\n        /* eslint-disable prefer-const */\n        let {\n            gpuProgram,\n            glProgram,\n            groups,\n            resources,\n            compatibleRenderers,\n            groupMap\n        } = options;\n        /* eslint-enable prefer-const */\n\n        this.gpuProgram = gpuProgram;\n        this.glProgram = glProgram;\n\n        if (compatibleRenderers === undefined)\n        {\n            compatibleRenderers = 0;\n\n            if (gpuProgram)compatibleRenderers |= RendererType.WEBGPU;\n            if (glProgram)compatibleRenderers |= RendererType.WEBGL;\n        }\n\n        this.compatibleRenderers = compatibleRenderers;\n\n        const nameHash: Record<string, GroupsData> = {};\n\n        if (!resources && !groups)\n        {\n            resources = {};\n        }\n\n        if (resources && groups)\n        {\n            throw new Error('[Shader] Cannot have both resources and groups');\n        }\n        else if (!gpuProgram && groups && !groupMap)\n        {\n            throw new Error('[Shader] No group map or WebGPU shader provided - consider using resources instead.');\n        }\n        else if (!gpuProgram && groups && groupMap)\n        {\n            for (const i in groupMap)\n            {\n                for (const j in groupMap[i])\n                {\n                    const uniformName = groupMap[i][j];\n\n                    nameHash[uniformName] = {\n                        group: i as unknown as number,\n                        binding: j as unknown as number,\n                        name: uniformName\n                    };\n                }\n            }\n        }\n        else if (gpuProgram && groups && !groupMap)\n        {\n            const groupData = gpuProgram.structsAndGroups.groups;\n\n            groupMap = {};\n\n            groupData.forEach((data) =>\n            {\n                groupMap[data.group] = groupMap[data.group] || {};\n                groupMap[data.group][data.binding] = data.name;\n\n                nameHash[data.name] = data;\n            });\n        }\n        else if (resources)\n        {\n            if (!gpuProgram)\n            {\n                // build out a dummy bind group..\n                groupMap = {};\n                groups = {\n                    99: new BindGroup(),\n                };\n\n                this._ownedBindGroups.push(groups[99]);\n\n                let bindTick = 0;\n\n                for (const i in resources)\n                {\n                    // Yes i know this is a little strange, but wil line up the shaders neatly\n                    // basically we want to be driven by how webGPU does things.\n                    // so making a fake group will work and not affect gpu as it means no gpu shader was provided..\n                    nameHash[i] = { group: 99, binding: bindTick, name: i };\n\n                    groupMap[99] = groupMap[99] || {};\n                    groupMap[99][bindTick] = i;\n\n                    bindTick++;\n                }\n            }\n            else\n            {\n                const groupData = gpuProgram.structsAndGroups.groups;\n\n                groupMap = {};\n\n                groupData.forEach((data) =>\n                {\n                    groupMap[data.group] = groupMap[data.group] || {};\n                    groupMap[data.group][data.binding] = data.name;\n\n                    nameHash[data.name] = data;\n                });\n            }\n\n            groups = {};\n\n            for (const i in resources)\n            {\n                const name = i;\n                let value = resources[i];\n\n                if (!(value.source) && !(value as BindResource)._resourceType)\n                {\n                    value = new UniformGroup(value);\n                }\n\n                const data = nameHash[name];\n\n                if (data)\n                {\n                    if (!groups[data.group])\n                    {\n                        groups[data.group] = new BindGroup();\n\n                        this._ownedBindGroups.push(groups[data.group]);\n                    }\n\n                    groups[data.group].setResource(value, data.binding);\n                }\n            }\n        }\n\n        this.groups = groups;\n        this._uniformBindMap = groupMap;\n\n        this.resources = this._buildResourceAccessor(groups, nameHash);\n    }\n\n    /**\n     * Sometimes a resource group will be provided later (for example global uniforms)\n     * In such cases, this method can be used to let the shader know about the group.\n     * @param name - the name of the resource group\n     * @param groupIndex - the index of the group (should match the webGPU shader group location)\n     * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)\n     */\n    public addResource(name: string, groupIndex: number, bindIndex: number): void\n    {\n        this._uniformBindMap[groupIndex] ||= {};\n\n        this._uniformBindMap[groupIndex][bindIndex] ||= name;\n\n        if (!this.groups[groupIndex])\n        {\n            this.groups[groupIndex] = new BindGroup();\n            this._ownedBindGroups.push(this.groups[groupIndex]);\n        }\n    }\n\n    private _buildResourceAccessor(groups: ShaderGroups, nameHash: Record<string, GroupsData>)\n    {\n        const uniformsOut = {};\n\n        for (const i in nameHash)\n        {\n            const data = nameHash[i];\n\n            // add getter setter for uniforms\n            Object.defineProperty(uniformsOut, data.name, {\n                get()\n                {\n                    return groups[data.group].getResource(data.binding);\n                },\n                set(value)\n                {\n                    groups[data.group].setResource(value, data.binding);\n                }\n            });\n        }\n\n        return uniformsOut;\n    }\n\n    /**\n     * Use to destroy the shader when its not longer needed.\n     * It will destroy the resources and remove listeners.\n     * @param destroyPrograms - if the programs should be destroyed as well.\n     * Make sure its not being used by other shaders!\n     */\n    public destroy(destroyPrograms = false): void\n    {\n        this.emit('destroy', this);\n\n        if (destroyPrograms)\n        {\n            this.gpuProgram?.destroy();\n            this.glProgram?.destroy();\n        }\n\n        this.gpuProgram = null;\n        this.glProgram = null;\n\n        this.removeAllListeners();\n\n        this._uniformBindMap = null;\n\n        this._ownedBindGroups.forEach((bindGroup) =>\n        {\n            bindGroup.destroy();\n        });\n\n        (this._ownedBindGroups as null) = null;\n\n        this.resources = null;\n        this.groups = null;\n    }\n\n    /**\n     * A short hand function to create a shader based of a vertex and fragment shader.\n     * @param options\n     * @returns A shiny new PixiJS shader!\n     */\n    public static from(options: ShaderFromGroups): Shader;\n    public static from(options: ShaderFromResources): Shader;\n    public static from(options: ShaderFromGroups & ShaderFromResources): Shader\n    {\n        const { gpu, gl, ...rest } = options;\n\n        let gpuProgram: GpuProgram;\n        let glProgram: GlProgram;\n\n        if (gpu)\n        {\n            gpuProgram = GpuProgram.from(gpu);\n        }\n\n        if (gl)\n        {\n            glProgram = GlProgram.from(gl);\n        }\n\n        return new Shader({\n            gpuProgram,\n            glProgram,\n            ...rest\n        });\n    }\n}\n","\"use strict\";\nvar RendererType = /* @__PURE__ */ ((RendererType2) => {\n  RendererType2[RendererType2[\"WEBGL\"] = 1] = \"WEBGL\";\n  RendererType2[RendererType2[\"WEBGPU\"] = 2] = \"WEBGPU\";\n  RendererType2[RendererType2[\"BOTH\"] = 3] = \"BOTH\";\n  return RendererType2;\n})(RendererType || {});\n\nexport { RendererType };\n//# sourceMappingURL=types.mjs.map\n","import type { ICanvas } from '../../environment/canvas/ICanvas';\nimport type { WebGLOptions, WebGLPipes, WebGLRenderer } from './gl/WebGLRenderer';\nimport type { WebGPUOptions, WebGPUPipes, WebGPURenderer } from './gpu/WebGPURenderer';\n\n/** A generic renderer. */\nexport type Renderer<T extends ICanvas = HTMLCanvasElement> = WebGLRenderer<T> | WebGPURenderer<T>;\nexport type RenderPipes = WebGLPipes | WebGPUPipes;\nexport interface RendererOptions extends WebGLOptions, WebGPUOptions {}\n\n/* eslint-disable @typescript-eslint/indent */\n/**\n * Ids for the different render types.\n * The idea is that you can use bitwise operations to filter weather or not you want to do somthing in a certain render type.\n * Filters for example can be compatible for both webGL or WebGPU but not compatible with canvas.\n * So internally if it works with both we set filter.compatibleRenderers = RendererType.WEBGL | RendererType.WEBGPU\n * if it only works with webgl we set filter.compatibleRenderers = RendererType.WEBGL\n *\n */\nexport enum RendererType\n{\n    WEBGL = 0b01,\n    WEBGPU = 0b10,\n    BOTH = 0b11\n}\n\nexport type GpuPowerPreference = 'low-power' | 'high-performance';\n","\"use strict\";\nconst localUniformBit = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  }\n};\nconst localUniformBitGroup2 = {\n  ...localUniformBit,\n  vertex: {\n    ...localUniformBit.vertex,\n    // replace the group!\n    header: localUniformBit.vertex.header.replace(\"group(1)\", \"group(2)\")\n  }\n};\nconst localUniformBitGl = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  }\n};\n\nexport { localUniformBit, localUniformBitGl, localUniformBitGroup2 };\n//# sourceMappingURL=localUniformBit.mjs.map\n","export const localUniformBit = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* wgsl */`\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n};\n\n// TODO this works, but i think down the road it will be better to manage groups automatically if there are clashes\nexport const localUniformBitGroup2 = {\n    ...localUniformBit,\n    vertex: {\n        ...localUniformBit.vertex,\n        // replace the group!\n        header: localUniformBit.vertex.header.replace('group(1)', 'group(2)'),\n    }\n};\n\nexport const localUniformBitGl = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* glsl */`\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n};\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$interopDefault","a","__esModule","default","parcelRequire","$parcel$global","globalThis","parcelRegister","register","module","exports","$9c78bed6a0e6cb35$export$4f037c6ec2da4eeb","$9c78bed6a0e6cb35$export$cc3e2d3244e01b7f","ExtensionType2","$9c78bed6a0e6cb35$var$normalizeExtension","ext","extension","Error","type","ref","$9c78bed6a0e6cb35$export$ba4241979983e013","defaultPriority","priority","_addHandlers","_removeHandlers","_queue","remove","extensions2","map","forEach","add","handlers","queue","push","handle","onAdd","onRemove","addHandlers","removeHandlers","handleByMap","name","handleByNamedList","findIndex","item","value","sort","b","index","splice","handleByList","list","includes","indexOf","$fbe6892413159d67$export$f8ede8d8bf091ab5","$fbe6892413159d67$export$e4801e7edc7582f","$fbe6892413159d67$export$83db162b74637ea","$fbe6892413159d67$export$42a852a2b6b56249","$gpXaq","$AHTcQ","$jorMT","$dNaJE","$gIu8o","$ep73P","$l80qL","$eX50w","$1AFlc","$4u67k","$6UPd0","$eHtGW","$bMTFJ","$8Eetq","$5gOfB","$hmS23","$e84qN","$fbe6892413159d67$var$defaultSkew","ObservablePoint","$fbe6892413159d67$var$defaultPivot","$fbe6892413159d67$var$defaultScale","constructor","options","uid","_updateFlags","isRenderGroupRoot","renderGroup","didChange","didViewUpdate","relativeRenderGroupDepth","children","parent","includeInBuild","measurable","isSimple","updateTick","localTransform","Matrix","relativeGroupTransform","groupTransform","destroyed","_position","_scale","_pivot","_skew","_cx","_sx","_cy","_sy","_rotation","localColor","localAlpha","groupAlpha","groupColor","groupColorAlpha","localBlendMode","groupBlendMode","localDisplayStatus","globalDisplayStatus","_didChangeId","_didLocalTransformChangeId","assignWithIgnore","effects","child","addChild","mixin","source","defineProperties","prototype","getOwnPropertyDescriptors","allowChildren","deprecation","v8_0_0","length","i","structureDidChange","removeChild","sortableChildren","sortDirty","emit","_zIndex","depthOfChildModified","_onUpdate","point","_updateSkew","renderGroupParent","onChildUpdate","isRenderGroup","enableRenderGroup","root","parentRenderGroup","RenderGroup","renderGroupChildren","childRenderGroup","addRenderGroupChild","_updateIsSimple","IDENTITY","worldTransform","_worldTransform","copyFrom","appendFrom","x","y","position","rotation","angle","RAD_TO_DEG","DEG_TO_RAD","pivot","skew","scale","width","Math","abs","getLocalBounds","localWidth","_setWidth","height","localHeight","_setHeight","getSize","out","bounds","setSize","convertedWidth","convertedHeight","size","cos","_y","sin","_x","updateTransform","opts","scaleX","scaleY","skewX","skewY","pivotX","pivotY","setFromMatrix","matrix","decompose","updateLocalTransform","lt","sx","sy","px","py","c","d","tx","ty","alpha","tint","bgr","tempColor","Color","shared","setValue","toBgrNumber","blendMode","visible","culled","renderable","isRenderable","destroy","removeFromParent","_mask","_filters","removeAllListeners","destroyChildren","oldChildren","removeChildren","childrenHelperMixin","toLocalGlobalMixin","onRenderMixin","measureMixin","effectsMixin","findMixin","sortMixin","cullingMixin","$bf3ce0801cd2364b$var$has","hasOwnProperty","$bf3ce0801cd2364b$var$prefix","$bf3ce0801cd2364b$var$Events","$bf3ce0801cd2364b$var$EE","fn","context","once","$bf3ce0801cd2364b$var$addListener","emitter","event","TypeError","listener","evt","_events","_eventsCount","$bf3ce0801cd2364b$var$clearEvent","$bf3ce0801cd2364b$var$EventEmitter","create","__proto__","eventNames","events","names","call","slice","getOwnPropertySymbols","concat","listeners","l","ee","Array","listenerCount","a1","a2","a3","a4","a5","args","len","arguments","removeListener","undefined","apply","j","on","off","addListener","prefixed","EventEmitter","$fe924fd83efb3dcd$export$892596cec99bc70e","$jyvmC","$flk9m","extend","$fe924fd83efb3dcd$var$_Color","_Color","_value","_components","Float32Array","fill","_int","red","green","blue","_cloneSource","_isSourceEqual","_normalize","Number","isArray","ArrayBuffer","isView","value1","value2","type1","every","keys1","keys","keys2","key","toRgba","r","g","toRgb","toRgbaString","toUint8RgbArray","_arrayRgb","round","toArray","_arrayRgba","toRgbArray","toNumber","toLittleEndianNumber","multiply","_temp","_refreshInt","premultiply","applyToRGB","toPremultiplied","toHex","hexString","toString","substring","toHexa","alphaString","alphaValue","setAlpha","_clamp","int","Uint8Array","Uint8ClampedArray","match","HEX_PATTERN","exec","color","colord","isValid","rgba","min","max","isColorLike","h","$34b99b961acc9a90$export$c8efe09109f9cb9e","$34b99b961acc9a90$export$8b58be045bf06082","$34b99b961acc9a90$var$r","grad","turn","rad","PI","$34b99b961acc9a90$var$t","$34b99b961acc9a90$var$n","t","pow","$34b99b961acc9a90$var$e","$34b99b961acc9a90$var$u","isFinite","$34b99b961acc9a90$var$a","$34b99b961acc9a90$var$o","$34b99b961acc9a90$var$i","$34b99b961acc9a90$var$s","$34b99b961acc9a90$var$h","u","o","$34b99b961acc9a90$var$b","floor","$34b99b961acc9a90$var$g","$34b99b961acc9a90$var$d","$34b99b961acc9a90$var$f","$34b99b961acc9a90$var$c","$34b99b961acc9a90$var$l","$34b99b961acc9a90$var$p","$34b99b961acc9a90$var$v","$34b99b961acc9a90$var$m","$34b99b961acc9a90$var$y","string","parseInt","substr","object","$34b99b961acc9a90$var$N","$34b99b961acc9a90$var$M","$34b99b961acc9a90$var$H","$34b99b961acc9a90$var$$","$34b99b961acc9a90$export$4d30ed660ff08d0","parsed","$34b99b961acc9a90$var$x","trim","brightness","isDark","isLight","toRgbString","toHsl","toHslString","toHsv","invert","saturate","desaturate","grayscale","lighten","darken","rotate","hue","isEqual","$34b99b961acc9a90$var$S","$6d738a730be80407$export$2e2bcd8739ae039","f","white","bisque","cadetblue","chartreuse","chocolate","coral","antiquewhite","aqua","azure","whitesmoke","papayawhip","plum","blanchedalmond","black","gold","goldenrod","gainsboro","cornsilk","cornflowerblue","burlywood","aquamarine","beige","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkkhaki","darkgray","darkgreen","darkgrey","peachpuff","darkmagenta","darkred","darkorchid","darkorange","darkslateblue","gray","darkslategray","darkslategrey","deeppink","deepskyblue","wheat","firebrick","floralwhite","ghostwhite","darkviolet","magenta","dodgerblue","grey","honeydew","hotpink","blueviolet","forestgreen","lawngreen","indianred","indigo","fuchsia","brown","maroon","mediumblue","lightcoral","darkturquoise","lightcyan","ivory","lightyellow","lightsalmon","lightseagreen","linen","mediumaquamarine","lemonchiffon","lime","khaki","mediumseagreen","limegreen","mediumspringgreen","lightskyblue","lightblue","midnightblue","lightpink","mistyrose","moccasin","mintcream","lightslategray","lightslategrey","navajowhite","navy","mediumvioletred","powderblue","palegoldenrod","oldlace","paleturquoise","mediumturquoise","mediumorchid","rebeccapurple","lightsteelblue","mediumslateblue","thistle","tan","orchid","mediumpurple","purple","pink","skyblue","springgreen","palegreen","yellow","slateblue","lavenderblush","peru","palevioletred","violet","teal","slategray","slategrey","aliceblue","darkseagreen","darkolivegreen","greenyellow","seagreen","seashell","tomato","silver","sienna","lavender","lightgreen","orange","orangered","steelblue","royalblue","turquoise","yellowgreen","salmon","saddlebrown","sandybrown","rosybrown","darksalmon","lightgoldenrodyellow","snow","lightgrey","lightgray","dimgray","dimgrey","olivedrab","olive","toName","closest","toLowerCase","$77279937bd81d006$export$dce76d4f0fd249ed","cullArea","cullable","cullableChildren","$c9bf2754f493888f$export$5b12bf1653c0dd85","$2NXni","array","fromArray","transpose","pos","newPos","Point","applyInverse","id","translate","c1","tx1","append","b1","d1","b2","c2","d2","setTransform","prepend","transform","atan2","delta","PI_2","sqrt","isIdentity","identity","clone","copyTo","equals","$c9bf2754f493888f$var$identityMatrix","$c9bf2754f493888f$var$tempMatrix","$9854bd3320d54841$export$59ed0a0a5de1084b","$9854bd3320d54841$export$3f91627dc85c5d57","$9854bd3320d54841$export$870617f62e3187f1","$33ead300f2416b90$export$baf26146a414f24a","p","$33ead300f2416b90$var$tempPoint","$1471e7ddf9463356$export$3755aaad3fd42e52","observer","_observer","$311c7125449cac6e$export$e2a22331486dcca0","$311c7125449cac6e$var$uidCache","$b14a3262a951e740$export$dc79da96439604f0","$b14a3262a951e740$export$afd31d834b512e89","$b14a3262a951e740$var$warnings","version","message","ignoreDepth","stack","console","warn","split","join","groupCollapsed","groupEnd","$72886fd1ec148d9f$export$64cca9f0c2df174a","$hpsHk","beginIndex","endIndex","end","range","removed","removeItems","RangeError","removeChildAt","getChildAt","setChildIndex","getChildIndex","addChildAt","currentIndex","swapChildren","child2","index1","index2","$77be0eb29c39195c$export$8d47c0e1ce445404","arr","startIdx","removeCount","$2eb61ab66b3b5ffb$export$eec5e288a9d02a7c","$fq91v","$fGBJF","$e98Fy","addEffect","effect","removeEffect","mask","MaskEffectManager","returnMaskEffect","getMaskEffect","filters","filterArea","hasFilters","freeze","BigPool","FilterEffect","return","$82803e0d8d097f5f$export$d66c06ffe23037ab","pipe","$fa986065911c7cb3$export$1eb319167fe02d04","$eVz1R","_effectClasses","_tests","_initialized","init","test","maskClass","extensions","ExtensionType","MaskEffect","$6be6cb2942b74e3a$export$8249372279066210","$iYfXR","_poolsByClass","Map","prepopulate","Class","total","classPool","getPool","data","pool","ClassType","has","Pool","stats","_classType","ID","free","totalFree","used","totalUsed","totalSize","$66bdaf1ccfbf3948$export$14963ee5c8637e11","initialSize","_pool","_count","_index","reset","$eeec6fee48380987$export$468b0762e1bfbd64","label","getChildByName","deep","getChildByLabel","RegExp","found","getChildrenByLabel","$635dbf0ee9aabfac$export$285e6e72e8e62f0","$ggeMF","$dXx4G","$5pskN","$96kAF","$635dbf0ee9aabfac$var$tempMatrix","_localBoundsCacheId","_localBoundsCacheData","sign","localBounds","Bounds","localBoundsCacheData","checkChildrenDidChange","getBounds","skipUpdate","getGlobalBounds","$a12d5e59ca4737b5$export$c4e9d269599ab4b4","$soqVu","$a12d5e59ca4737b5$var$defaultMatrix","minX","Infinity","minY","maxX","maxY","isEmpty","rectangle","_rectangle","Rectangle","copyFromBounds","clear","x0","y0","x1","y1","addFrame","addRect","rect","addBounds","addBoundsMask","applyMatrix","fit","left","right","top","bottom","fitBounds","pad","paddingX","paddingY","ceil","isPositive","addVertexData","vertexData","beginOffset","endOffset","localX","localY","containsPoint","$4ba4a3bc6c979a96$export$4617fb02663045ef","$4ba4a3bc6c979a96$var$tempPoints","EMPTY","contains","strokeContains","strokeWidth","intersects","other","x02","x12","y02","y12","lb","rt","rb","nx","ny","n00","n10","n01","n11","mx","my","m00","m10","m01","m11","x2","y2","resolution","eps","enlarge","$8e3ae21db977fba1$export$f4412a6981d97baa","$8e3ae21db977fba1$export$2022bc48a49dd6d2","$96ND8","target","skipUpdateTransform","parentTransform","pooledMatrix","matrixPool","$8e3ae21db977fba1$export$ca70956e64971628","parentBounds","preserveBounds","boundsPool","boundsArea","$826d79d1525243fc$export$3849005ba4dacf72","$826d79d1525243fc$export$9194656040c1dc42","$e441be710d94e6fb$export$ffaf4f504c4c5c9c","relativeMatrix","$e441be710d94e6fb$var$_getLocalBounds","rootContainer","isRoot","relativeTransform","renderPipeId","addLocalBounds","$babafddae46386dc$export$c106dd0671a0fc2d","$babafddae46386dc$var$warnCount","$3c4e83a868f7ed9d$export$fd5aadbd3827bcf1","container","previousData","changeId","$4b17ef0f98b62c7c$export$2a5246d1114cb81d","_onRender","onRender","func","removeOnRender","addOnRender","$b2f06f436f1ee35c$export$eb4acdd9f4781aed","zIndex","sortChildren","$b2f06f436f1ee35c$var$sortChildren","$f817b482336ecb12$export$38fa7a987602e8dd","getGlobalPosition","toGlobal","globalMatrix","updateTransformBackwards","toLocal","from","$8ebef99a9f866ab0$export$94d273f8d74f2a5","$vdXhX","canBundle","_children","worldColorAlpha","worldColor","worldAlpha","childrenToUpdate","childrenRenderablesToUpdate","instructionSet","InstructionSet","_onRenderContainers","renderGroupChild","_removeRenderGroupChild","_removeChildFromUpdate","updateRenderable","renderPipes","onChildViewUpdate","runOnRender","$d18e82f308ef3932$export$2946bd01f10dd922","instructions","instructionSize","instruction","log","table","$5070b2a9c014252d$export$59d0441a278e5935","ignore","$c2653834eabf3044$export$d988306fa84f7b44","$c2653834eabf3044$var$currentAdapter","$1pH92","BrowserAdapter","adapter","$ef74a33612e9f67a$export$e467cc3399500025","createCanvas","canvas","document","createElement","getCanvasRenderingContext2D","CanvasRenderingContext2D","getWebGLRenderingContext","WebGLRenderingContext","getWebGL2RenderingContext","WebGL2RenderingContext","getNavigator","navigator","getBaseUrl","baseURI","window","location","href","getFontFaceSet","fonts","fetch","url","parseXML","xml","parser","DOMParser","parseFromString","$bc4f7b0a8cd1dc50$export$5431306cf43de24a","$dhBBn","$EqaNP","$i8D1k","$9Ur0D","$iKeK4","frame","orig","defaultAnchor","defaultBorders","dynamic","uvs","x3","y3","noFrame","isTexture","TextureSource","_source","updateUvs","update","textureMatrix","_textureMatrix","TextureMatrix","nX","nY","nW","nH","w2","h2","cX","cY","groupD8","NW","uX","uY","destroySource","baseTexture","NOOP","WHITE","BufferImageSource","resource","alphaMode","$bd40f80fb18d9e32$export$b7bb6a2a8d203102","$bd40f80fb18d9e32$var$ux","$bd40f80fb18d9e32$var$uy","$bd40f80fb18d9e32$var$vx","$bd40f80fb18d9e32$var$vy","$bd40f80fb18d9e32$var$rotationCayley","$bd40f80fb18d9e32$var$rotationMatrices","$bd40f80fb18d9e32$var$signum","$bd40f80fb18d9e32$var$init","row","_ux","_uy","_vx","_vy","k","mat","E","SE","S","SW","W","N","NE","MIRROR_VERTICAL","MAIN_DIAGONAL","MIRROR_HORIZONTAL","REVERSE_DIAGONAL","ind","vX","vY","inv","rotationSecond","rotationFirst","sub","rotate180","isVertical","byDirection","dx","dy","matrixAppendRotationInv","$34de18656af55afd$export$5702a91a6f42969f","$afe0f8a97373316e$export$1872462350fcb7cd","buffer","format","Int32Array","Uint32Array","Int16Array","Uint16Array","Int8Array","uploadMethodId","$e85e2e39710bed0b$export$8498e6a2e655d3d8","$domwE","$5d1vV","$2mVLe","$e85e2e39710bed0b$var$_TextureSource","_TextureSource","_resourceType","_resourceId","_resolution","pixelWidth","pixelHeight","sampleCount","mipLevelCount","autoGenerateMipmaps","dimension","antialias","_touched","_batchTick","_textureBindLocation","defaultOptions","autoGarbageCollect","resourceWidth","resourceHeight","dimensions","style","TextureStyle","definedProps","_refreshPOT","_style","_onStyleChange","addressMode","repeatMode","magFilter","minFilter","mipmapFilter","lodMinClamp","lodMaxClamp","resize","unload","naturalWidth","videoWidth","displayWidth","naturalHeight","videoHeight","displayHeight","newPixelWidth","newPixelHeight","updateMipmaps","wrapMode","scaleMode","isPowerOfTwo","isPow2","_resource","$c53d88fff3c2b5cd$export$f0d90cf68bd426eb","$c53d88fff3c2b5cd$export$eb50b9c078eb6ae7","$a2e0819df772f5e5$export$801feaffb936a09d","obj","result","$d157fdece7dbd785$export$1ce1d0c10d3de5d5","$d157fdece7dbd785$var$idHash","$d157fdece7dbd785$var$_TextureStyle","_TextureStyle","_maxAnisotropy","addressModeU","addressModeV","addressModeW","compare","maxAnisotropy","_sharedResourceId","_generateResourceId","bigKey","$d157fdece7dbd785$var$createResourceIdFromString","$ab4f62e2624c4c4f$export$dbea3135e9da48cb","$ab4f62e2624c4c4f$var$tempMat","texture","clampMargin","mapCoord","uClampFrame","uClampOffset","_textureID","_updateID","clampOffset","_texture","multiplyUvs","tex","texBase","margin","offset","$f036b574519dd81d$export$3075603db8e6204c","$5h88T","$1ZKfN","$lR3Ev","Container","Texture","anchor","roundPixels","rest","batched","_didSpriteUpdate","_bounds","_sourceBounds","_boundsDirty","_sourceBoundsDirty","_roundPixels","_anchor","onViewUpdate","skipCache","currentTexture","_updateBounds","sourceBounds","_updateSourceBounds","updateQuadBounds","destroyTextureSource","textureSource","$16e40cd364463874$export$558ce66aa5723f1d","padding","sourceWidth","sourceHeight","$7d034785613a03fe$export$ca65ccf5708c6a0c","$5m2Qn","DOMAdapter","autoDensity","resizeCanvas","transparent","didResize","HTMLCanvasElement","OffscreenCanvas","$6387a2f1cd429ccd$export$449e8d355fd68e43","$2qhsM","$cnPar","$kFbJv","$6387a2f1cd429ccd$var$placeHolderBufferData","$6387a2f1cd429ccd$var$placeHolderIndexData","Geometry","attributeBuffer","Buffer","usage","BufferUsage","VERTEX","COPY_DST","shrinkToFit","attributes","aPosition","stride","vertexSize","aUV","aColor","aTextureIdAndRound","indexBuffer","INDEX","$b7e882ef59b860cf$export$a143d493d941bafc","_data","byteLength","mappedAtCreation","descriptor","setDataWithSize","static","STATIC","syncGPU","_updateSize","BYTES_PER_ELEMENT","oldData","sizeInBytes","$f342a3bbf89638f5$export$f8deb2be8632fd10","BufferUsage2","$2e3c8c2d71c2725b$export$2db6c17465f94a2","$h4RvW","$6RtYG","topology","_layoutKey","instanceCount","buffers","attribute","ensureIsBuffer","onBufferUpdate","getAttribute","getIndex","getBuffer","getGeometryBounds","destroyBuffers","$0e45541d190bc801$export$e02adcb3cf335e03","$a66388f56b469ccf$export$ca8be28ec6402f29","geometry","attributeId","byteSize","$a67f34b5a8404015$export$6f452ee382def63c","resources","_dirty","setResource","_updateKey","keyParts","_key","currentResource","onResourceChange","getResource","_touch","tick","$47da8e5c51bb3312$export$e09e7788b3f0275e","$3a37d26fd5247abe$export$704b12ddc1dacdd2","$1bOZ3","$yT1Ie","$gNQm7","$68TF0","$fIcRj","$3a37d26fd5247abe$export$33b107562567fc47","action","start","textures","gpuBindGroup","bindGroup","batcher","$3a37d26fd5247abe$var$BATCH_TICK","$3a37d26fd5247abe$var$_Batcher","_Batcher","dirty","batchIndex","batches","_vertexSize","_elements","_batchPool","_batchPoolIndex","_textureBatchPool","_textureBatchPoolIndex","indexSize","ViewableBuffer","begin","elementSize","elementStart","attributeSize","_batchIndexStart","_batchIndexSize","batchableObject","indexStart","checkAndUpdateTexture","textureId","batch","ids","updateElement","packAttributes","float32View","uint32View","break","elements","textureBatch","BatchTextureArray","firstElement","getAdjustedBlendModeBlend","_resizeAttributeBuffer","_resizeIndexBuffer","f32","u32","iBuffer","element","adjustedBlendMode","blendModeChange","packIndex","count","MAX_TEXTURES","_finishBatch","finish","ensureAttributeBuffer","ensureIndexBuffer","newSize","newArrayBuffer","fastCopy","rawBinaryData","newIndexBuffer","$091eabba1be7ffdf$export$4fdbf0662aa3047a","sizeOrBuffer","int8View","_int8View","uint8View","_uint8View","int16View","_int16View","int32View","_int32View","float64View","_float64Array","Float64Array","bigUint64View","_bigUint64Array","BigUint64Array","view","uint16View","sizeOf","$dc9e07f111dd75c7$export$c691b0c42debe682","sourceBuffer","destinationBuffer","lengthDouble","sourceFloat64View","destinationFloat64View","remainingBytes","sourceUint8View","destinationUint8View","$4c271e6d234c7a46$export$ab2fc5cf3fe899fe","$8Jr8b","BLEND_TO_NPM","$2fd2df46cfd69161$export$8c0bd2ccaa4a8d5e","$2fd2df46cfd69161$export$c250b85d73a91bdf","normal","screen","STENCIL_MODES2","$b1ecee865cb8c960$export$aa760e0febf1a758","$32363f0670dd5e82$export$72a85c3a80ccc403","$knTXf","localBGRColor","parentBGRColor","mixHexColors","$be486dafd58220da$export$ff72adc46f6bc63c","color1","color2","ratio","r1","g1","r2","g2","$9f149295c176ee7a$export$7254cc27399e90bd","$9f149295c176ee7a$var$blendModeIds","overlay","erase","$9f149295c176ee7a$var$_State","_State","polygonOffset","blend","depthMask","offsets","cullMode","culling","clockwiseFrontFace","depthTest","_blendMode","_blendModeId","_polygonOffset","for2d","state","default2d","$9e041d6e84ac0a03$export$2c68e848c5b81f5","abgr","$3672bd6e6c923f1d$export$6601a7a2dcf79bf5","$2aTkI","$kJ1OQ","$3672bd6e6c923f1d$var$_UniformGroup","_UniformGroup","uniformStructures","isUniformGroup","_dirtyId","uniforms","uniformData","getDefaultUniformValue","ubo","isStatic","_signature","createIdFromString","$20f496f4898984f0$export$1e452c36dfe36a93","$20f496f4898984f0$var$idCounts","$20f496f4898984f0$var$idHash","groupId","$8cd1a200cd417966$export$7febdb6905805c3d","$36f92037bd2a44c6$export$fe4bdc7069ee0b9c","sprite","wt","w0","w1","h0","h1","argb","textureIdAndRound","indicesOffset","$24b29c011bc4c5b6$export$686d8ddcd5ee6cd2","$24b29c011bc4c5b6$var$count","textureOptions","_poolKeyHash","_texturePool","enableFullScreen","createTexture","getOptimalTexture","frameWidth","frameHeight","po2Width","po2Height","nextPow2","pop","getSameSizeTexture","returnTexture","renderTexture","destroyTextures","$9be65aec2342e1ab$export$af9d352c01aa9018","$9be65aec2342e1ab$export$477b8252c7ecdf2","$2AaNu","$9IRF4","$2umnT","$9tj2y","$bgSqr","bits","compileHighShader","template","fragment","fragmentGPUTemplate","vertex","vertexGPUTemplate","globalUniformsBit","GpuProgram","entryPoint","GlProgram","compileHighShaderGl","vertexGlTemplate","fragmentGlTemplate","globalUniformsBitGl","$3e4928f628b169ba$export$64881d9ea0a969d7","$76Gha","$6chrV","$9uh5G","$5ThHq","$2smQn","$3e4928f628b169ba$var$processes","stripVersion","$cuCqf","ensurePrecision","addProgramDefines","setProgramName","insertVersion","$3e4928f628b169ba$var$programCache","$3e4928f628b169ba$var$_GlProgram","_GlProgram","isES300","preprocessorOptions","requestedFragmentPrecision","preferredFragmentPrecision","requestedVertexPrecision","preferredVertexPrecision","maxSupportedVertexPrecision","maxSupportedFragmentPrecision","getMaxFragmentPrecision","processKey","processOptions","_attributeData","_uniformData","_uniformBlockData","transformFeedbackVaryings","$3314ddd978d8f610$var$maxFragmentPrecision","$3314ddd978d8f610$export$428c38e64838140","$towXg","gl","getTestContext","getShaderPrecisionFormat","shaderFragment","FRAGMENT_SHADER","HIGH_FLOAT","precision","$706e2ddb38efa68c$var$context","$706e2ddb38efa68c$export$f034b2d55f8df08b","isContextLost","getContext","$b1b65f75cf795082$export$fba00ea8bc676dd1","src","isFragment","replace","$62185500478be9a1$export$899bdffb1b617f8b","maxSupportedPrecision","$a383d746f12b3c11$export$df5409633d2e06a0","$b4c893c1192ca086$export$fcd35f5a80d5e29b","$b4c893c1192ca086$var$fragmentNameCache","$b4c893c1192ca086$var$VertexNameCache","nameCache","shaderName","$f751430174b741b8$export$f71406e7a553e9e5","$7eafa2827bb311cd$export$b7a31a3cdd61870","$2liBL","$fPdyx","$9BwwY","$iHjNs","$4ZXFu","$7eafa2827bb311cd$var$programCache","layout","gpuLayout","structsAndGroups","extractStructAndGroups","vertexStructsAndGroups","fragmentStructsAndGroups","removeStructAndGroupDuplicates","generateLayoutHash","generateGpuLayoutGroups","autoAssignGlobalUniforms","globalUniforms","autoAssignLocalUniforms","localUniforms","_generateProgramKey","attributeData","extractAttributesFromGpuProgram","$1347c7101bdc3d4b$export$b0efe5f01c53f69f","$97JA6","$1347c7101bdc3d4b$var$WGSL_TO_VERTEX_TYPES","vec2f","vec3f","vec4f","i32","bool","results","mainVertStart","arrowFunctionStart","functionArgsSubstring","inputsRegex","getAttributeInfoFromFormat","instance","$323edfeef0d2ad2f$export$4da509c30cc6be33","$323edfeef0d2ad2f$var$attributeFormatData","uint8x2","normalised","uint8x4","sint8x2","sint8x4","unorm8x2","unorm8x4","snorm8x2","snorm8x4","uint16x2","uint16x4","sint16x2","sint16x4","unorm16x2","unorm16x4","snorm16x2","snorm16x4","float16x2","float16x4","float32","float32x2","float32x3","float32x4","uint32","uint32x2","uint32x3","uint32x4","sint32","sint32x2","sint32x3","sint32x4","$a773d036452fda49$export$368e99a200562975","wgsl","groupPattern","bindingPattern","namePattern","typePattern","structMemberPattern","structName","groups","group","binding","isUniform","structs","struct","members","reduce","acc","member","name2","filter","some","$cd3b18489a63a192$export$950011c0dc347495","$6ONS2","visibility","ShaderStage","FRAGMENT","sampler","sampleType","viewDimension","multisampled","$f39c1ac9ce80191b$export$34a0cafc5a97ef31","ShaderStage2","$7c0fb19c18bf77fd$export$6a0f9650f9d4f875","$abd17b3222aab333$export$5f344e20ddfaa2d6","structNameSet","Set","dupeGroupKeySet","$f0d2795437b8c8e6$export$86219fd7a1c584d2","$f0d2795437b8c8e6$export$ff7039b165d48f97","$hcREI","$gFFZS","$ltnz8","$3smY9","$3mQzs","$f0d2795437b8c8e6$var$cacheMap","$f0d2795437b8c8e6$var$bitCacheMap","$f0d2795437b8c8e6$var$CACHE_UID","cacheId","$f0d2795437b8c8e6$var$generateCacheId","$f0d2795437b8c8e6$var$compileInputsAndOutputs","vertexFragments","shaderBit","fragmentFragments","compiledVertex","compileInputs","compileOutputs","$f0d2795437b8c8e6$var$compileBits","highFragment","vertexParts","compileHooks","fragmentParts","addBits","injectBits","$783d512ed9109c4e$export$38c21fb192fe3d9","$8CF4q","srcParts","parts","part","toLocaleLowerCase","sanitisedPart","$7b8dc76672cc3e6f$export$17705ba43ca63936","$7b8dc76672cc3e6f$export$a564a4c9984eee7d","programSrc","partMatches","hook","$9de63faf17acebfa$var$extractInputs","fragmentSource","regex","$9de63faf17acebfa$export$aa47df9391ef0455","fragments","header","mainInput","finalString","inValue","cleanedString","$21523912be22cf2a$var$extractOutputs","$21523912be22cf2a$export$ae19cc473c7ab18","mainStruct","mainStart","mainEnd","$21523912be22cf2a$var$extractVariableName","compiledCode","$9220e691b142b050$export$83c47c7340456c75","templateSrc","toInject","$7b7a87a63a893098$export$61ecfa8d2718163a","$7b7a87a63a893098$export$922d1073ee2ef930","$7b7a87a63a893098$export$99b0f79e15be8ede","$7b7a87a63a893098$export$3f7784dd6a13ff5a","$65883fe23256fd04$export$435d64b3a14c5a51","$65883fe23256fd04$export$38608853d4735d51","$2daf77c5269b0d26$export$a62becfe5fe4ad2","$2daf77c5269b0d26$export$93189e9821cf4459","main","$bef51538f7a1ee9b$export$aff2d36945cda647","$bef51538f7a1ee9b$export$204e46d9a7a4f835","$bef51538f7a1ee9b$var$textureBatchBitGpuCache","maxTextures","$bef51538f7a1ee9b$var$generateBindingSrc","bindingIndex","$bef51538f7a1ee9b$var$generateSampleSrc","$bef51538f7a1ee9b$var$textureBatchBitGlCache","$bef51538f7a1ee9b$var$generateSampleGlSrc","$924b6a6b1952fa30$export$22150169726f7b1","$924b6a6b1952fa30$export$222909710f39cc5","$c2c6fdb6cde61fa5$export$462bb059fed9d9e5","$86NKO","$dgEnR","$lJEsO","_uniformBindMap","_ownedBindGroups","gpuProgram","glProgram","compatibleRenderers","groupMap","RendererType","WEBGPU","WEBGL","nameHash","uniformName","groupData","BindGroup","bindTick","UniformGroup","_buildResourceAccessor","addResource","groupIndex","bindIndex","_a","_b","uniformsOut","destroyPrograms","gpu","$ab7aed2a9e5fdd71$export$2ca8315eebe81c3d","RendererType2","$d2a24386d8923024$export$1723ac05bd5e9336","$d2a24386d8923024$export$adb0f80794f644d9","$d2a24386d8923024$export$36099520d0a716a","STENCIL_MODES"],"version":3,"file":"browserAll.929a84d1.js.map"}